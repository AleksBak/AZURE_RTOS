
sample_usbx_host_mass_storage.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000db38  080001d0  080001d0  000101d0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000001c8  0800dd08  0800dd08  0001dd08  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800ded0  0800ded0  00020168  2**0
                  CONTENTS
  4 .ARM          00000008  0800ded0  0800ded0  0001ded0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0800ded8  0800ded8  00020168  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800ded8  0800ded8  0001ded8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800dedc  0800dedc  0001dedc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000168  20000000  0800dee0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000138c  20000168  20000168  00020168  2**3
                  ALLOC
 10 ._user_heap_stack 00000604  200014f4  200014f4  00020168  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00020168  2**0
                  CONTENTS, READONLY
 12 .debug_info   00207380  00000000  00000000  00020198  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00022132  00000000  00000000  00227518  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00002bc8  00000000  00000000  00249650  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00002c90  00000000  00000000  0024c218  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  000559ce  00000000  00000000  0024eea8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   00070c5b  00000000  00000000  002a4876  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00145cf6  00000000  00000000  003154d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      000000fa  00000000  00000000  0045b1c7  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000596c  00000000  00000000  0045b2c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_loc    000214e9  00000000  00000000  00460c30  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001d0 <__do_global_dtors_aux>:
 80001d0:	b510      	push	{r4, lr}
 80001d2:	4c05      	ldr	r4, [pc, #20]	; (80001e8 <__do_global_dtors_aux+0x18>)
 80001d4:	7823      	ldrb	r3, [r4, #0]
 80001d6:	b933      	cbnz	r3, 80001e6 <__do_global_dtors_aux+0x16>
 80001d8:	4b04      	ldr	r3, [pc, #16]	; (80001ec <__do_global_dtors_aux+0x1c>)
 80001da:	b113      	cbz	r3, 80001e2 <__do_global_dtors_aux+0x12>
 80001dc:	4804      	ldr	r0, [pc, #16]	; (80001f0 <__do_global_dtors_aux+0x20>)
 80001de:	f3af 8000 	nop.w
 80001e2:	2301      	movs	r3, #1
 80001e4:	7023      	strb	r3, [r4, #0]
 80001e6:	bd10      	pop	{r4, pc}
 80001e8:	20000168 	.word	0x20000168
 80001ec:	00000000 	.word	0x00000000
 80001f0:	0800dcf0 	.word	0x0800dcf0

080001f4 <frame_dummy>:
 80001f4:	b508      	push	{r3, lr}
 80001f6:	4b03      	ldr	r3, [pc, #12]	; (8000204 <frame_dummy+0x10>)
 80001f8:	b11b      	cbz	r3, 8000202 <frame_dummy+0xe>
 80001fa:	4903      	ldr	r1, [pc, #12]	; (8000208 <frame_dummy+0x14>)
 80001fc:	4803      	ldr	r0, [pc, #12]	; (800020c <frame_dummy+0x18>)
 80001fe:	f3af 8000 	nop.w
 8000202:	bd08      	pop	{r3, pc}
 8000204:	00000000 	.word	0x00000000
 8000208:	2000016c 	.word	0x2000016c
 800020c:	0800dcf0 	.word	0x0800dcf0

08000210 <OTG_HS_IRQHandler>:
.thumb_func
OTG_HS_IRQHandler:
@ VOID UsbInterruptHandler (VOID)
@ {
@
        PUSH    {lr}
 8000210:	b500      	push	{lr}
        BL      _ux_hcd_stm32_interrupt_handler
 8000212:	f001 f98b 	bl	800152c <_ux_hcd_stm32_interrupt_handler>
        POP     {lr}
 8000216:	f85d eb04 	ldr.w	lr, [sp], #4
        BX      LR
 800021a:	4770      	bx	lr

0800021c <OTG_FS_IRQHandler>:
.thumb_func
OTG_FS_IRQHandler:
@ VOID UsbInterruptHandler (VOID)
@ {
@
        PUSH    {lr}
 800021c:	b500      	push	{lr}
        BL      _tx_thread_context_save
 800021e:	f000 f857 	bl	80002d0 <_tx_thread_context_save>
        POP     {lr}
 8000222:	f85d eb04 	ldr.w	lr, [sp], #4
        BX      LR
 8000226:	4770      	bx	lr
	...

08000230 <_tx_initialize_low_level>:
    .thumb_func
_tx_initialize_low_level:
@
@    /* Disable interrupts during ThreadX initialization.  */
@
    CPSID   i
 8000230:	b672      	cpsid	i
@
@    /* Set base of available memory to end of non-initialised RAM area.  */
@     
    LDR     r0, =_tx_initialize_unused_memory       @ Build address of unused memory pointer
 8000232:	481d      	ldr	r0, [pc, #116]	; (80002a8 <__tx_DBGHandler+0x6>)
    LDR     r1, =__RAM_segment_used_end__           @ Build first free address   
 8000234:	491d      	ldr	r1, [pc, #116]	; (80002ac <__tx_DBGHandler+0xa>)
    ADD     r1, r1, #4                              @ 
 8000236:	f101 0104 	add.w	r1, r1, #4
    STR     r1, [r0]                                @ Setup first unused memory pointer
 800023a:	6001      	str	r1, [r0, #0]
@
@    /* Setup Vector Table Offset Register.  */
@    
    MOV     r0, #0xE000E000                         @ Build address of NVIC registers
 800023c:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =_vectors                           @ Pickup address of vector table  
 8000240:	491b      	ldr	r1, [pc, #108]	; (80002b0 <__tx_DBGHandler+0xe>)
    STR     r1, [r0, #0xD08]                        @ Set vector table address   
 8000242:	f8c0 1d08 	str.w	r1, [r0, #3336]	; 0xd08
@
@    /* Set system stack pointer from vector value.  */
@
    LDR     r0, =_tx_thread_system_stack_ptr        @ Build address of system stack pointer
 8000246:	481b      	ldr	r0, [pc, #108]	; (80002b4 <__tx_DBGHandler+0x12>)
    LDR     r1, =_vectors                           @ Pickup address of vector table
 8000248:	4919      	ldr	r1, [pc, #100]	; (80002b0 <__tx_DBGHandler+0xe>)
    LDR     r1, [r1]                                @ Pickup reset stack pointer
 800024a:	6809      	ldr	r1, [r1, #0]
    STR     r1, [r0]                                @ Save system stack pointer
 800024c:	6001      	str	r1, [r0, #0]
@
@    /* Enable the cycle count register.  */
@
    LDR     r0, =0xE0001000                         @ Build address of DWT register
 800024e:	481a      	ldr	r0, [pc, #104]	; (80002b8 <__tx_DBGHandler+0x16>)
    LDR     r1, [r0]                                @ Pickup the current value
 8000250:	6801      	ldr	r1, [r0, #0]
    ORR     r1, r1, #1                              @ Set the CYCCNTENA bit
 8000252:	f041 0101 	orr.w	r1, r1, #1
    STR     r1, [r0]                                @ Enable the cycle count register 
 8000256:	6001      	str	r1, [r0, #0]
@
@    /* Configure SysTick for 100Hz clock, or 16384 cycles if no reference.  */
@
    MOV     r0, #0xE000E000                         @ Build address of NVIC registers
 8000258:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
    LDR     r1, =SYSTICK_CYCLES
 800025c:	4917      	ldr	r1, [pc, #92]	; (80002bc <__tx_DBGHandler+0x1a>)
    STR     r1, [r0, #0x14]                         @ Setup SysTick Reload Value
 800025e:	6141      	str	r1, [r0, #20]
    MOV     r1, #0x7                                @ Build SysTick Control Enable Value
 8000260:	f04f 0107 	mov.w	r1, #7
    STR     r1, [r0, #0x10]                         @ Setup SysTick Control
 8000264:	6101      	str	r1, [r0, #16]
@
@    /* Configure handler priorities.  */
@
    LDR     r1, =0x00000000                         @ Rsrv, UsgF, BusF, MemM
 8000266:	f04f 0100 	mov.w	r1, #0
    STR     r1, [r0, #0xD18]                        @ Setup System Handlers 4-7 Priority Registers
 800026a:	f8c0 1d18 	str.w	r1, [r0, #3352]	; 0xd18

    LDR     r1, =0xFF000000                         @ SVCl, Rsrv, Rsrv, Rsrv
 800026e:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
    STR     r1, [r0, #0xD1C]                        @ Setup System Handlers 8-11 Priority Registers
 8000272:	f8c0 1d1c 	str.w	r1, [r0, #3356]	; 0xd1c
                                                    @ Note: SVC must be lowest priority, which is 0xFF

    LDR     r1, =0x40FF0000                         @ SysT, PnSV, Rsrv, DbgM
 8000276:	4912      	ldr	r1, [pc, #72]	; (80002c0 <__tx_DBGHandler+0x1e>)
    STR     r1, [r0, #0xD20]                        @ Setup System Handlers 12-15 Priority Registers
 8000278:	f8c0 1d20 	str.w	r1, [r0, #3360]	; 0xd20
                                                    @ Note: PnSV must be lowest priority, which is 0xFF
        
@
@    /* Return to caller.  */
@    
    BX      lr 
 800027c:	4770      	bx	lr

0800027e <__tx_BadHandler>:
@/* Define shells for each of the unused vectors.  */
@
    .global  __tx_BadHandler
    .thumb_func
__tx_BadHandler:
    B       __tx_BadHandler
 800027e:	f7ff bffe 	b.w	800027e <__tx_BadHandler>

08000282 <__tx_HardfaultHandler>:
@ /* added to catch the hardfault */

    .global  __tx_HardfaultHandler
    .thumb_func
__tx_HardfaultHandler:
    B       __tx_HardfaultHandler
 8000282:	f7ff bffe 	b.w	8000282 <__tx_HardfaultHandler>

08000286 <__tx_SVCallHandler>:
@ /* added to catch the SVC */

    .global  __tx_SVCallHandler
    .thumb_func
__tx_SVCallHandler:
    B       __tx_SVCallHandler
 8000286:	f7ff bffe 	b.w	8000286 <__tx_SVCallHandler>

0800028a <__tx_IntHandler>:
    .global  __tx_IntHandler
    .thumb_func
__tx_IntHandler:
@ VOID InterruptHandler (VOID)
@ {
    PUSH    {r0, lr}
 800028a:	b501      	push	{r0, lr}
@    /* BL <your C Function>.... */

#ifdef TX_ENABLE_EXECUTION_CHANGE_NOTIFY
    BL      _tx_execution_isr_exit              ; Call the ISR exit function
#endif
    POP     {r0, lr}
 800028c:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      LR
 8000290:	4770      	bx	lr

08000292 <SysTick_Handler>:
    .thumb_func
SysTick_Handler:
@ VOID TimerInterruptHandler (VOID)
@ {
@
    PUSH    {r0, lr}
 8000292:	b501      	push	{r0, lr}
#ifdef TX_ENABLE_EXECUTION_CHANGE_NOTIFY
    BL      _tx_execution_isr_enter             ; Call the ISR enter function
#endif
    BL      _tx_timer_interrupt
 8000294:	f000 f87c 	bl	8000390 <_tx_timer_interrupt>
#ifdef TX_ENABLE_EXECUTION_CHANGE_NOTIFY
    BL      _tx_execution_isr_exit              ; Call the ISR exit function
#endif
    POP     {r0, lr}
 8000298:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
    BX      LR
 800029c:	4770      	bx	lr

0800029e <__tx_NMIHandler>:

@ /* NMI, DBG handlers */
    .global  __tx_NMIHandler 
    .thumb_func
__tx_NMIHandler:
    B       __tx_NMIHandler
 800029e:	f7ff bffe 	b.w	800029e <__tx_NMIHandler>

080002a2 <__tx_DBGHandler>:

    .global  __tx_DBGHandler
    .thumb_func
__tx_DBGHandler:
    B       __tx_DBGHandler
 80002a2:	f7ff bffe 	b.w	80002a2 <__tx_DBGHandler>
 80002a6:	0000      	.short	0x0000
    LDR     r0, =_tx_initialize_unused_memory       @ Build address of unused memory pointer
 80002a8:	200014d8 	.word	0x200014d8
    LDR     r1, =__RAM_segment_used_end__           @ Build first free address   
 80002ac:	20001af8 	.word	0x20001af8
    LDR     r1, =_vectors                           @ Pickup address of vector table  
 80002b0:	08000000 	.word	0x08000000
    LDR     r0, =_tx_thread_system_stack_ptr        @ Build address of system stack pointer
 80002b4:	20000f24 	.word	0x20000f24
    LDR     r0, =0xE0001000                         @ Build address of DWT register
 80002b8:	e0001000 	.word	0xe0001000
    LDR     r1, =SYSTICK_CYCLES
 80002bc:	0020f57f 	.word	0x0020f57f
    LDR     r1, =0x40FF0000                         @ SysT, PnSV, Rsrv, DbgM
 80002c0:	40ff0000 	.word	0x40ff0000
	...

080002d0 <_tx_thread_context_save>:
    .global  _tx_thread_context_save
    .thumb_func
_tx_thread_context_save:
@
@ /* Not needed for this port - just return!  */
    BX      lr
 80002d0:	4770      	bx	lr
 80002d2:	bf00      	nop
	...

080002e0 <_tx_thread_interrupt_control>:
    .thumb_func
_tx_thread_interrupt_control:

@/* Pickup current interrupt lockout posture.  */

    MRS     r1, PRIMASK                             @ Pickup current interrupt lockout
 80002e0:	f3ef 8110 	mrs	r1, PRIMASK

@/* Apply the new interrupt posture.  */

    MSR     PRIMASK, r0                             @ Apply the new interrupt lockout
 80002e4:	f380 8810 	msr	PRIMASK, r0
    MOV     r0, r1                                  @ Transfer old to return register
 80002e8:	4608      	mov	r0, r1
    BX      lr                                      @ Return to caller
 80002ea:	4770      	bx	lr
 80002ec:	0000      	movs	r0, r0
	...

080002f0 <_tx_thread_schedule>:
@       from the first schedule request. Subsequent scheduling occurs
@       from the PendSV handling routines below. */
@
@    /* Clear the preempt-disable flag to enable rescheduling after initialization on Cortex-M targets.  */
@     
    MOV     r0, #0                                  @ Build value for TX_FALSE
 80002f0:	f04f 0000 	mov.w	r0, #0
    LDR     r2, =_tx_thread_preempt_disable         @ Build address of preempt disable flag
 80002f4:	4a22      	ldr	r2, [pc, #136]	; (8000380 <__tx_ts_ready+0x12>)
    STR     r0, [r2, #0]                            @ Clear preempt disable flag
 80002f6:	6010      	str	r0, [r2, #0]
    MSR     CONTROL, r0                             @ Setup new CONTROL register
#endif
@
@    /* Enable interrupts */
@
    CPSIE   i
 80002f8:	b662      	cpsie	i
@            
@    /* Enter the scheduler for the first time.  */
@
    MOV     r0, #0x10000000                         @ Load PENDSVSET bit
 80002fa:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
    MOV     r1, #0xE000E000                         @ Load NVIC base
 80002fe:	f04f 21e0 	mov.w	r1, #3758153728	; 0xe000e000
    STR     r0, [r1, #0xD04]                        @ Set PENDSVBIT in ICSR
 8000302:	f8c1 0d04 	str.w	r0, [r1, #3332]	; 0xd04
    DSB                                             @ Complete all memory accesses
 8000306:	f3bf 8f4f 	dsb	sy
    ISB                                             @ Flush pipeline
 800030a:	f3bf 8f6f 	isb	sy

0800030e <__tx_wait_here>:
@
@    /* Wait here for the PendSV to take place.  */
@     
__tx_wait_here:
    B       __tx_wait_here                          @ Wait for the PendSV to happen
 800030e:	e7fe      	b.n	800030e <__tx_wait_here>

08000310 <PendSV_Handler>:
    PUSH    {r0, lr}                                @ Save LR (and r0 just for alignment)
    BL      _tx_execution_thread_exit               @ Call the thread exit function
    POP     {r0, lr}                                @ Recover LR
    CPSIE   i                                       @ Enable interrupts
#endif
    LDR     r0, =_tx_thread_current_ptr             @ Build current thread pointer address
 8000310:	481c      	ldr	r0, [pc, #112]	; (8000384 <__tx_ts_ready+0x16>)
    LDR     r2, =_tx_thread_execute_ptr             @ Build execute thread pointer address
 8000312:	4a1d      	ldr	r2, [pc, #116]	; (8000388 <__tx_ts_ready+0x1a>)
    MOV     r3, #0                                  @ Build NULL value
 8000314:	f04f 0300 	mov.w	r3, #0
    LDR     r1, [r0]                                @ Pickup current thread pointer
 8000318:	6801      	ldr	r1, [r0, #0]
@
@    /* Determine if there is a current thread to finish preserving.  */
@       
    CBZ     r1, __tx_ts_new                         @ If NULL, skip preservation
 800031a:	b169      	cbz	r1, 8000338 <__tx_ts_new>
@
@    /* Recover PSP and preserve current thread context.  */
@
    STR     r3, [r0]                                @ Set _tx_thread_current_ptr to NULL
 800031c:	6003      	str	r3, [r0, #0]
    MRS     r12, PSP                                @ Pickup PSP pointer (thread's stack pointer)
 800031e:	f3ef 8c09 	mrs	ip, PSP
    STMDB   r12!, {r4-r11}                          @ Save its remaining registers
 8000322:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
    TST     LR, #0x10                               @ Determine if the VFP extended frame is present
    BNE     _skip_vfp_save
    VSTMDB  r12!,{s16-s31}                          @ Yes, save additional VFP registers
_skip_vfp_save:
#endif
    LDR     r4, =_tx_timer_time_slice               @ Build address of time-slice variable
 8000326:	4c19      	ldr	r4, [pc, #100]	; (800038c <__tx_ts_ready+0x1e>)
    STMDB   r12!, {LR}                              @ Save LR on the stack
 8000328:	f84c ed04 	str.w	lr, [ip, #-4]!
@
@    /* Determine if time-slice is active. If it isn't, skip time handling processing.  */
@
    LDR     r5, [r4]                                @ Pickup current time-slice
 800032c:	6825      	ldr	r5, [r4, #0]
    STR     r12, [r1, #8]                           @ Save the thread stack pointer
 800032e:	f8c1 c008 	str.w	ip, [r1, #8]
    CBZ     r5, __tx_ts_new                         @ If not active, skip processing
 8000332:	b10d      	cbz	r5, 8000338 <__tx_ts_new>
@
@    /* Time-slice is active, save the current thread's time-slice and clear the global time-slice variable.  */
@
    STR     r5, [r1, #24]                           @ Save current time-slice
 8000334:	618d      	str	r5, [r1, #24]
@
@    /* Clear the global time-slice.  */
@
    STR     r3, [r4]                                @ Clear time-slice
 8000336:	6023      	str	r3, [r4, #0]

08000338 <__tx_ts_new>:
@
__tx_ts_new:
@
@    /* Now we are looking for a new thread to execute!  */
@
    CPSID   i                                       @ Disable interrupts
 8000338:	b672      	cpsid	i
    LDR     r1, [r2]                                @ Is there another thread ready to execute?
 800033a:	6811      	ldr	r1, [r2, #0]
    CBZ     r1, __tx_ts_wait                        @ No, skip to the wait processing
 800033c:	b189      	cbz	r1, 8000362 <__tx_ts_wait>
@
@    /* Yes, another thread is ready for else, make the current thread the new thread.  */
@
    STR     r1, [r0]                                @ Setup the current thread pointer to the new thread
 800033e:	6001      	str	r1, [r0, #0]
    CPSIE   i                                       @ Enable interrupts
 8000340:	b662      	cpsie	i

08000342 <__tx_ts_restore>:
@
@    /* Increment the thread run count.  */
@
__tx_ts_restore:
    LDR     r7, [r1, #4]                            @ Pickup the current thread run count
 8000342:	684f      	ldr	r7, [r1, #4]
    LDR     r4, =_tx_timer_time_slice               @ Build address of time-slice variable
 8000344:	4c11      	ldr	r4, [pc, #68]	; (800038c <__tx_ts_ready+0x1e>)
    LDR     r5, [r1, #24]                           @ Pickup thread's current time-slice
 8000346:	698d      	ldr	r5, [r1, #24]
    ADD     r7, r7, #1                              @ Increment the thread run count
 8000348:	f107 0701 	add.w	r7, r7, #1
    STR     r7, [r1, #4]                            @ Store the new run count
 800034c:	604f      	str	r7, [r1, #4]
@
@    /* Setup global time-slice with thread's current time-slice.  */
@
    STR     r5, [r4]                                @ Setup global time-slice
 800034e:	6025      	str	r5, [r4, #0]
    POP     {r0, r1}                                @ Recover r3
#endif
@
@    /* Restore the thread context and PSP.  */
@
    LDR     r12, [r1, #8]                           @ Pickup thread's stack pointer
 8000350:	f8d1 c008 	ldr.w	ip, [r1, #8]
    LDMIA   r12!, {LR}                              @ Pickup LR
 8000354:	f85c eb04 	ldr.w	lr, [ip], #4
    TST     LR, #0x10                               @ Determine if the VFP extended frame is present
    BNE     _skip_vfp_restore                       @ If not, skip VFP restore 
    VLDMIA  r12!, {s16-s31}                         @ Yes, restore additional VFP registers
_skip_vfp_restore:
#endif
    LDMIA   r12!, {r4-r11}                          @ Recover thread's registers
 8000358:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
    MSR     PSP, r12                                @ Setup the thread's stack pointer
 800035c:	f38c 8809 	msr	PSP, ip
@
@    /* Return to thread.  */
@       
    BX      lr                                      @ Return to thread!
 8000360:	4770      	bx	lr

08000362 <__tx_ts_wait>:
@    /* The following is the idle wait processing... in this case, no threads are ready for execution and the
@       system will simply be idle until an interrupt occurs that makes a thread ready. Note that interrupts 
@       are disabled to allow use of WFI for waiting for a thread to arrive.  */
@
__tx_ts_wait:
    CPSID   i                                       @ Disable interrupts
 8000362:	b672      	cpsid	i
    LDR     r1, [r2]                                @ Pickup the next thread to execute pointer
 8000364:	6811      	ldr	r1, [r2, #0]
    STR     r1, [r0]                                @ Store it in the current pointer
 8000366:	6001      	str	r1, [r0, #0]
    CBNZ    r1, __tx_ts_ready                       @ If non-NULL, a new thread is ready!
 8000368:	b909      	cbnz	r1, 800036e <__tx_ts_ready>
#ifdef TX_ENABLE_WFI
    DSB                                             @ Ensure no outstanding memory transactions
    WFI                                             @ Wait for interrupt
    ISB                                             @ Ensure pipeline is flushed
#endif
    CPSIE   i                                       @ Enable interrupts
 800036a:	b662      	cpsie	i
    B       __tx_ts_wait                            @ Loop to continue waiting
 800036c:	e7f9      	b.n	8000362 <__tx_ts_wait>

0800036e <__tx_ts_ready>:
@
@    /* At this point, we have a new thread ready to go. Clear any newly pended PendSV - since we are 
@       already in the handler!  */
@
__tx_ts_ready:
    MOV     r7, #0x08000000                         @ Build clear PendSV value
 800036e:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
    MOV     r8, #0xE000E000                         @ Build base NVIC address
 8000372:	f04f 28e0 	mov.w	r8, #3758153728	; 0xe000e000
    STR     r7, [r8, #0xD04]                        @ Clear any PendSV 
 8000376:	f8c8 7d04 	str.w	r7, [r8, #3332]	; 0xd04
@
@    /* Re-enable interrupts and restore new thread.  */
@       
    CPSIE   i                                       @ Enable interrupts
 800037a:	b662      	cpsie	i
    B       __tx_ts_restore                         @ Restore the thread
 800037c:	e7e1      	b.n	8000342 <__tx_ts_restore>
 800037e:	0000      	.short	0x0000
    LDR     r2, =_tx_thread_preempt_disable         @ Build address of preempt disable flag
 8000380:	20000f28 	.word	0x20000f28
    LDR     r0, =_tx_thread_current_ptr             @ Build current thread pointer address
 8000384:	20000f2c 	.word	0x20000f2c
    LDR     r2, =_tx_thread_execute_ptr             @ Build execute thread pointer address
 8000388:	20000f30 	.word	0x20000f30
    LDR     r4, =_tx_timer_time_slice               @ Build address of time-slice variable
 800038c:	20000fc8 	.word	0x20000fc8

08000390 <_tx_timer_interrupt>:
@       for use.  */
@
@    /* Increment the system clock.  */
@    _tx_timer_system_clock++;
@
    LDR     r1, =_tx_timer_system_clock             @ Pickup address of system clock
 8000390:	4926      	ldr	r1, [pc, #152]	; (800042c <__tx_timer_nothing_expired+0x8>)
    LDR     r0, [r1, #0]                            @ Pickup system clock
 8000392:	6808      	ldr	r0, [r1, #0]
    ADD     r0, r0, #1                              @ Increment system clock
 8000394:	f100 0001 	add.w	r0, r0, #1
    STR     r0, [r1, #0]                            @ Store new system clock
 8000398:	6008      	str	r0, [r1, #0]
@
@    /* Test for time-slice expiration.  */
@    if (_tx_timer_time_slice)
@    {
@
    LDR     r3, =_tx_timer_time_slice               @ Pickup address of time-slice 
 800039a:	4b25      	ldr	r3, [pc, #148]	; (8000430 <__tx_timer_nothing_expired+0xc>)
    LDR     r2, [r3, #0]                            @ Pickup time-slice
 800039c:	681a      	ldr	r2, [r3, #0]
    CMP     r2, #0                                  @ Is it non-active?
 800039e:	2a00      	cmp	r2, #0
    BEQ     __tx_timer_no_time_slice                @ Yes, skip time-slice processing
 80003a0:	d008      	beq.n	80003b4 <__tx_timer_no_time_slice>
@
@       /* Decrement the time_slice.  */
@       _tx_timer_time_slice--;
@
    SUB     r2, r2, #1                              @ Decrement the time-slice
 80003a2:	f1a2 0201 	sub.w	r2, r2, #1
    STR     r2, [r3, #0]                            @ Store new time-slice value
 80003a6:	601a      	str	r2, [r3, #0]
@
@       /* Check for expiration.  */
@       if (__tx_timer_time_slice == 0)
@
    CMP     r2, #0                                  @ Has it expired?
 80003a8:	2a00      	cmp	r2, #0
    BNE     __tx_timer_no_time_slice                @ No, skip expiration processing
 80003aa:	d103      	bne.n	80003b4 <__tx_timer_no_time_slice>
@
@       /* Set the time-slice expired flag.  */
@       _tx_timer_expired_time_slice =  TX_TRUE;
@
    LDR     r3, =_tx_timer_expired_time_slice       @ Pickup address of expired flag
 80003ac:	4b21      	ldr	r3, [pc, #132]	; (8000434 <__tx_timer_nothing_expired+0x10>)
    MOV     r0, #1                                  @ Build expired value
 80003ae:	f04f 0001 	mov.w	r0, #1
    STR     r0, [r3, #0]                            @ Set time-slice expiration flag
 80003b2:	6018      	str	r0, [r3, #0]

080003b4 <__tx_timer_no_time_slice>:
@
@    /* Test for timer expiration.  */
@    if (*_tx_timer_current_ptr)
@    {
@
    LDR     r1, =_tx_timer_current_ptr              @ Pickup current timer pointer address
 80003b4:	4920      	ldr	r1, [pc, #128]	; (8000438 <__tx_timer_nothing_expired+0x14>)
    LDR     r0, [r1, #0]                            @ Pickup current timer
 80003b6:	6808      	ldr	r0, [r1, #0]
    LDR     r2, [r0, #0]                            @ Pickup timer list entry
 80003b8:	6802      	ldr	r2, [r0, #0]
    CMP     r2, #0                                  @ Is there anything in the list?
 80003ba:	2a00      	cmp	r2, #0
    BEQ     __tx_timer_no_timer                     @ No, just increment the timer
 80003bc:	d004      	beq.n	80003c8 <__tx_timer_no_timer>
@
@        /* Set expiration flag.  */
@        _tx_timer_expired =  TX_TRUE;
@
    LDR     r3, =_tx_timer_expired                  @ Pickup expiration flag address
 80003be:	4b1f      	ldr	r3, [pc, #124]	; (800043c <__tx_timer_nothing_expired+0x18>)
    MOV     r2, #1                                  @ Build expired value
 80003c0:	f04f 0201 	mov.w	r2, #1
    STR     r2, [r3, #0]                            @ Set expired flag
 80003c4:	601a      	str	r2, [r3, #0]
    B       __tx_timer_done                         @ Finished timer processing
 80003c6:	e008      	b.n	80003da <__tx_timer_done>

080003c8 <__tx_timer_no_timer>:
__tx_timer_no_timer:
@
@        /* No timer expired, increment the timer pointer.  */
@        _tx_timer_current_ptr++;
@
    ADD     r0, r0, #4                              @ Move to next timer
 80003c8:	f100 0004 	add.w	r0, r0, #4
@
@        /* Check for wrap-around.  */
@        if (_tx_timer_current_ptr == _tx_timer_list_end)
@
    LDR     r3, =_tx_timer_list_end                 @ Pickup addr of timer list end
 80003cc:	4b1c      	ldr	r3, [pc, #112]	; (8000440 <__tx_timer_nothing_expired+0x1c>)
    LDR     r2, [r3, #0]                            @ Pickup list end
 80003ce:	681a      	ldr	r2, [r3, #0]
    CMP     r0, r2                                  @ Are we at list end?
 80003d0:	4290      	cmp	r0, r2
    BNE     __tx_timer_skip_wrap                    @ No, skip wrap-around logic
 80003d2:	d101      	bne.n	80003d8 <__tx_timer_skip_wrap>
@
@            /* Wrap to beginning of list.  */
@            _tx_timer_current_ptr =  _tx_timer_list_start;
@
    LDR     r3, =_tx_timer_list_start               @ Pickup addr of timer list start
 80003d4:	4b1b      	ldr	r3, [pc, #108]	; (8000444 <__tx_timer_nothing_expired+0x20>)
    LDR     r0, [r3, #0]                            @ Set current pointer to list start
 80003d6:	6818      	ldr	r0, [r3, #0]

080003d8 <__tx_timer_skip_wrap>:
@
__tx_timer_skip_wrap:
@
    STR     r0, [r1, #0]                            @ Store new current timer pointer
 80003d8:	6008      	str	r0, [r1, #0]

080003da <__tx_timer_done>:
@
@    /* See if anything has expired.  */
@    if ((_tx_timer_expired_time_slice) || (_tx_timer_expired))
@    {
@
    LDR     r3, =_tx_timer_expired_time_slice       @ Pickup addr of expired flag
 80003da:	4b16      	ldr	r3, [pc, #88]	; (8000434 <__tx_timer_nothing_expired+0x10>)
    LDR     r2, [r3, #0]                            @ Pickup time-slice expired flag
 80003dc:	681a      	ldr	r2, [r3, #0]
    CMP     r2, #0                                  @ Did a time-slice expire?
 80003de:	2a00      	cmp	r2, #0
    BNE     __tx_something_expired                  @ If non-zero, time-slice expired
 80003e0:	d103      	bne.n	80003ea <__tx_something_expired>
    LDR     r1, =_tx_timer_expired                  @ Pickup addr of other expired flag
 80003e2:	4916      	ldr	r1, [pc, #88]	; (800043c <__tx_timer_nothing_expired+0x18>)
    LDR     r0, [r1, #0]                            @ Pickup timer expired flag
 80003e4:	6808      	ldr	r0, [r1, #0]
    CMP     r0, #0                                  @ Did a timer expire?
 80003e6:	2800      	cmp	r0, #0
    BEQ     __tx_timer_nothing_expired              @ No, nothing expired
 80003e8:	d01c      	beq.n	8000424 <__tx_timer_nothing_expired>

080003ea <__tx_something_expired>:
@
__tx_something_expired:
@
@
    STMDB   sp!, {r0, lr}                           @ Save the lr register on the stack
 80003ea:	e92d 4001 	stmdb	sp!, {r0, lr}
@
@    /* Did a timer expire?  */
@    if (_tx_timer_expired)
@    {
@
    LDR     r1, =_tx_timer_expired                  @ Pickup addr of expired flag
 80003ee:	4913      	ldr	r1, [pc, #76]	; (800043c <__tx_timer_nothing_expired+0x18>)
    LDR     r0, [r1, #0]                            @ Pickup timer expired flag
 80003f0:	6808      	ldr	r0, [r1, #0]
    CMP     r0, #0                                  @ Check for timer expiration
 80003f2:	2800      	cmp	r0, #0
    BEQ     __tx_timer_dont_activate                @ If not set, skip timer activation
 80003f4:	d001      	beq.n	80003fa <__tx_timer_dont_activate>
@
@        /* Process timer expiration.  */
@        _tx_timer_expiration_process();
@
    BL      _tx_timer_expiration_process            @ Call the timer expiration handling routine
 80003f6:	f00d fbf3 	bl	800dbe0 <_tx_timer_expiration_process>

080003fa <__tx_timer_dont_activate>:
@
@    /* Did time slice expire?  */
@    if (_tx_timer_expired_time_slice)
@    {
@
    LDR     r3, =_tx_timer_expired_time_slice       @ Pickup addr of time-slice expired 
 80003fa:	4b0e      	ldr	r3, [pc, #56]	; (8000434 <__tx_timer_nothing_expired+0x10>)
    LDR     r2, [r3, #0]                            @ Pickup the actual flag
 80003fc:	681a      	ldr	r2, [r3, #0]
    CMP     r2, #0                                  @ See if the flag is set
 80003fe:	2a00      	cmp	r2, #0
    BEQ     __tx_timer_not_ts_expiration            @ No, skip time-slice processing
 8000400:	d00e      	beq.n	8000420 <__tx_timer_not_ts_expiration>
@
@        /* Time slice interrupted thread.  */
@        _tx_thread_time_slice(); 
@
    BL      _tx_thread_time_slice                   @ Call time-slice processing
 8000402:	f00d fb93 	bl	800db2c <_tx_thread_time_slice>
    LDR     r0, =_tx_thread_preempt_disable         @ Build address of preempt disable flag
 8000406:	4810      	ldr	r0, [pc, #64]	; (8000448 <__tx_timer_nothing_expired+0x24>)
    LDR     r1, [r0]                                @ Is the preempt disable flag set?
 8000408:	6801      	ldr	r1, [r0, #0]
    CBNZ    r1, __tx_timer_skip_time_slice          @ Yes, skip the PendSV logic
 800040a:	b949      	cbnz	r1, 8000420 <__tx_timer_not_ts_expiration>
    LDR     r0, =_tx_thread_current_ptr             @ Build current thread pointer address
 800040c:	480f      	ldr	r0, [pc, #60]	; (800044c <__tx_timer_nothing_expired+0x28>)
    LDR     r1, [r0]                                @ Pickup the current thread pointer
 800040e:	6801      	ldr	r1, [r0, #0]
    LDR     r2, =_tx_thread_execute_ptr             @ Build execute thread pointer address
 8000410:	4a0f      	ldr	r2, [pc, #60]	; (8000450 <__tx_timer_nothing_expired+0x2c>)
    LDR     r3, [r2]                                @ Pickup the execute thread pointer
 8000412:	6813      	ldr	r3, [r2, #0]
    LDR     r0, =0xE000ED04                         @ Build address of control register
 8000414:	480f      	ldr	r0, [pc, #60]	; (8000454 <__tx_timer_nothing_expired+0x30>)
    LDR     r2, =0x10000000                         @ Build value for PendSV bit
 8000416:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    CMP     r1, r3                                  @ Are they the same?
 800041a:	4299      	cmp	r1, r3
    BEQ     __tx_timer_skip_time_slice              @ If the same, there was no time-slice performed
 800041c:	d000      	beq.n	8000420 <__tx_timer_not_ts_expiration>
    STR     r2, [r0]                                @ Not the same, issue the PendSV for preemption
 800041e:	6002      	str	r2, [r0, #0]

08000420 <__tx_timer_not_ts_expiration>:
@
@    }
@
__tx_timer_not_ts_expiration:
@
    LDMIA   sp!, {r0, lr}                           @ Recover lr register (r0 is just there for
 8000420:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

08000424 <__tx_timer_nothing_expired>:
@
@    }
@
__tx_timer_nothing_expired:

    DSB                                             @ Complete all memory access
 8000424:	f3bf 8f4f 	dsb	sy
    BX      lr                                      @ Return to caller
 8000428:	4770      	bx	lr
 800042a:	0000      	.short	0x0000
    LDR     r1, =_tx_timer_system_clock             @ Pickup address of system clock
 800042c:	200014bc 	.word	0x200014bc
    LDR     r3, =_tx_timer_time_slice               @ Pickup address of time-slice 
 8000430:	20000fc8 	.word	0x20000fc8
    LDR     r3, =_tx_timer_expired_time_slice       @ Pickup address of expired flag
 8000434:	200014b8 	.word	0x200014b8
    LDR     r1, =_tx_timer_current_ptr              @ Pickup current timer pointer address
 8000438:	20000f40 	.word	0x20000f40
    LDR     r3, =_tx_timer_expired                  @ Pickup expiration flag address
 800043c:	20000fc4 	.word	0x20000fc4
    LDR     r3, =_tx_timer_list_end                 @ Pickup addr of timer list end
 8000440:	20000fd0 	.word	0x20000fd0
    LDR     r3, =_tx_timer_list_start               @ Pickup addr of timer list start
 8000444:	200010a4 	.word	0x200010a4
    LDR     r0, =_tx_thread_preempt_disable         @ Build address of preempt disable flag
 8000448:	20000f28 	.word	0x20000f28
    LDR     r0, =_tx_thread_current_ptr             @ Build current thread pointer address
 800044c:	20000f2c 	.word	0x20000f2c
    LDR     r2, =_tx_thread_execute_ptr             @ Build execute thread pointer address
 8000450:	20000f30 	.word	0x20000f30
    LDR     r0, =0xE000ED04                         @ Build address of control register
 8000454:	e000ed04 	.word	0xe000ed04
	...

08000460 <_tx_thread_stack_build>:
@                       pc          Initial value for pc
@                       xPSR        Initial value for xPSR
@
@    Stack Bottom: (higher memory address)  */
@
    LDR     r2, [r0, #16]                           @ Pickup end of stack area
 8000460:	6902      	ldr	r2, [r0, #16]
    BIC     r2, r2, #0x7                            @ Align frame
 8000462:	f022 0207 	bic.w	r2, r2, #7
    SUB     r2, r2, #68                             @ Subtract frame size
 8000466:	f1a2 0244 	sub.w	r2, r2, #68	; 0x44
    LDR     r3, =0xFFFFFFFD                         @ Build initial LR value
 800046a:	f06f 0302 	mvn.w	r3, #2
    STR     r3, [r2, #0]                            @ Save on the stack
 800046e:	6013      	str	r3, [r2, #0]
@
@    /* Actually build the stack frame.  */
@
    MOV     r3, #0                                  @ Build initial register value
 8000470:	f04f 0300 	mov.w	r3, #0
    STR     r3, [r2, #4]                            @ Store initial r4
 8000474:	6053      	str	r3, [r2, #4]
    STR     r3, [r2, #8]                            @ Store initial r5
 8000476:	6093      	str	r3, [r2, #8]
    STR     r3, [r2, #12]                           @ Store initial r6
 8000478:	60d3      	str	r3, [r2, #12]
    STR     r3, [r2, #16]                           @ Store initial r7
 800047a:	6113      	str	r3, [r2, #16]
    STR     r3, [r2, #20]                           @ Store initial r8
 800047c:	6153      	str	r3, [r2, #20]
    STR     r3, [r2, #24]                           @ Store initial r9
 800047e:	6193      	str	r3, [r2, #24]
    LDR     r3, [r0, #12]                           @ Pickup stack starting address
 8000480:	68c3      	ldr	r3, [r0, #12]
    STR     r3, [r2, #28]                           @ Store initial r10 (sl)
 8000482:	61d3      	str	r3, [r2, #28]
    MOV     r3, #0                                  @ Build initial register value
 8000484:	f04f 0300 	mov.w	r3, #0
    STR     r3, [r2, #32]                           @ Store initial r11
 8000488:	6213      	str	r3, [r2, #32]
@
@    /* Hardware stack follows.  */
@
    STR     r3, [r2, #36]                           @ Store initial r0
 800048a:	6253      	str	r3, [r2, #36]	; 0x24
    STR     r3, [r2, #40]                           @ Store initial r1
 800048c:	6293      	str	r3, [r2, #40]	; 0x28
    STR     r3, [r2, #44]                           @ Store initial r2
 800048e:	62d3      	str	r3, [r2, #44]	; 0x2c
    STR     r3, [r2, #48]                           @ Store initial r3
 8000490:	6313      	str	r3, [r2, #48]	; 0x30
    STR     r3, [r2, #52]                           @ Store initial r12
 8000492:	6353      	str	r3, [r2, #52]	; 0x34
    MOV     r3, #0xFFFFFFFF                         @ Poison EXC_RETURN value
 8000494:	f04f 33ff 	mov.w	r3, #4294967295
    STR     r3, [r2, #56]                           @ Store initial lr
 8000498:	6393      	str	r3, [r2, #56]	; 0x38
    STR     r1, [r2, #60]                           @ Store initial pc
 800049a:	63d1      	str	r1, [r2, #60]	; 0x3c
    MOV     r3, #0x01000000                         @ Only T-bit need be set
 800049c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    STR     r3, [r2, #64]                           @ Store initial xPSR
 80004a0:	6413      	str	r3, [r2, #64]	; 0x40
@
@    /* Setup stack pointer.  */
@    thread_ptr -> tx_thread_stack_ptr =  r2;
@
    STR     r2, [r0, #8]                            @ Save stack pointer in thread's
 80004a2:	6082      	str	r2, [r0, #8]
                                                    @   control block
    BX      lr                                      @ Return to caller
 80004a4:	4770      	bx	lr
 80004a6:	bf00      	nop

080004a8 <__aeabi_uldivmod>:
 80004a8:	b953      	cbnz	r3, 80004c0 <__aeabi_uldivmod+0x18>
 80004aa:	b94a      	cbnz	r2, 80004c0 <__aeabi_uldivmod+0x18>
 80004ac:	2900      	cmp	r1, #0
 80004ae:	bf08      	it	eq
 80004b0:	2800      	cmpeq	r0, #0
 80004b2:	bf1c      	itt	ne
 80004b4:	f04f 31ff 	movne.w	r1, #4294967295
 80004b8:	f04f 30ff 	movne.w	r0, #4294967295
 80004bc:	f000 b972 	b.w	80007a4 <__aeabi_idiv0>
 80004c0:	f1ad 0c08 	sub.w	ip, sp, #8
 80004c4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80004c8:	f000 f806 	bl	80004d8 <__udivmoddi4>
 80004cc:	f8dd e004 	ldr.w	lr, [sp, #4]
 80004d0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80004d4:	b004      	add	sp, #16
 80004d6:	4770      	bx	lr

080004d8 <__udivmoddi4>:
 80004d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80004dc:	9e08      	ldr	r6, [sp, #32]
 80004de:	4604      	mov	r4, r0
 80004e0:	4688      	mov	r8, r1
 80004e2:	2b00      	cmp	r3, #0
 80004e4:	d14b      	bne.n	800057e <__udivmoddi4+0xa6>
 80004e6:	428a      	cmp	r2, r1
 80004e8:	4615      	mov	r5, r2
 80004ea:	d967      	bls.n	80005bc <__udivmoddi4+0xe4>
 80004ec:	fab2 f282 	clz	r2, r2
 80004f0:	b14a      	cbz	r2, 8000506 <__udivmoddi4+0x2e>
 80004f2:	f1c2 0720 	rsb	r7, r2, #32
 80004f6:	fa01 f302 	lsl.w	r3, r1, r2
 80004fa:	fa20 f707 	lsr.w	r7, r0, r7
 80004fe:	4095      	lsls	r5, r2
 8000500:	ea47 0803 	orr.w	r8, r7, r3
 8000504:	4094      	lsls	r4, r2
 8000506:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800050a:	0c23      	lsrs	r3, r4, #16
 800050c:	fbb8 f7fe 	udiv	r7, r8, lr
 8000510:	fa1f fc85 	uxth.w	ip, r5
 8000514:	fb0e 8817 	mls	r8, lr, r7, r8
 8000518:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800051c:	fb07 f10c 	mul.w	r1, r7, ip
 8000520:	4299      	cmp	r1, r3
 8000522:	d909      	bls.n	8000538 <__udivmoddi4+0x60>
 8000524:	18eb      	adds	r3, r5, r3
 8000526:	f107 30ff 	add.w	r0, r7, #4294967295
 800052a:	f080 811b 	bcs.w	8000764 <__udivmoddi4+0x28c>
 800052e:	4299      	cmp	r1, r3
 8000530:	f240 8118 	bls.w	8000764 <__udivmoddi4+0x28c>
 8000534:	3f02      	subs	r7, #2
 8000536:	442b      	add	r3, r5
 8000538:	1a5b      	subs	r3, r3, r1
 800053a:	b2a4      	uxth	r4, r4
 800053c:	fbb3 f0fe 	udiv	r0, r3, lr
 8000540:	fb0e 3310 	mls	r3, lr, r0, r3
 8000544:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000548:	fb00 fc0c 	mul.w	ip, r0, ip
 800054c:	45a4      	cmp	ip, r4
 800054e:	d909      	bls.n	8000564 <__udivmoddi4+0x8c>
 8000550:	192c      	adds	r4, r5, r4
 8000552:	f100 33ff 	add.w	r3, r0, #4294967295
 8000556:	f080 8107 	bcs.w	8000768 <__udivmoddi4+0x290>
 800055a:	45a4      	cmp	ip, r4
 800055c:	f240 8104 	bls.w	8000768 <__udivmoddi4+0x290>
 8000560:	3802      	subs	r0, #2
 8000562:	442c      	add	r4, r5
 8000564:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8000568:	eba4 040c 	sub.w	r4, r4, ip
 800056c:	2700      	movs	r7, #0
 800056e:	b11e      	cbz	r6, 8000578 <__udivmoddi4+0xa0>
 8000570:	40d4      	lsrs	r4, r2
 8000572:	2300      	movs	r3, #0
 8000574:	e9c6 4300 	strd	r4, r3, [r6]
 8000578:	4639      	mov	r1, r7
 800057a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800057e:	428b      	cmp	r3, r1
 8000580:	d909      	bls.n	8000596 <__udivmoddi4+0xbe>
 8000582:	2e00      	cmp	r6, #0
 8000584:	f000 80eb 	beq.w	800075e <__udivmoddi4+0x286>
 8000588:	2700      	movs	r7, #0
 800058a:	e9c6 0100 	strd	r0, r1, [r6]
 800058e:	4638      	mov	r0, r7
 8000590:	4639      	mov	r1, r7
 8000592:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000596:	fab3 f783 	clz	r7, r3
 800059a:	2f00      	cmp	r7, #0
 800059c:	d147      	bne.n	800062e <__udivmoddi4+0x156>
 800059e:	428b      	cmp	r3, r1
 80005a0:	d302      	bcc.n	80005a8 <__udivmoddi4+0xd0>
 80005a2:	4282      	cmp	r2, r0
 80005a4:	f200 80fa 	bhi.w	800079c <__udivmoddi4+0x2c4>
 80005a8:	1a84      	subs	r4, r0, r2
 80005aa:	eb61 0303 	sbc.w	r3, r1, r3
 80005ae:	2001      	movs	r0, #1
 80005b0:	4698      	mov	r8, r3
 80005b2:	2e00      	cmp	r6, #0
 80005b4:	d0e0      	beq.n	8000578 <__udivmoddi4+0xa0>
 80005b6:	e9c6 4800 	strd	r4, r8, [r6]
 80005ba:	e7dd      	b.n	8000578 <__udivmoddi4+0xa0>
 80005bc:	b902      	cbnz	r2, 80005c0 <__udivmoddi4+0xe8>
 80005be:	deff      	udf	#255	; 0xff
 80005c0:	fab2 f282 	clz	r2, r2
 80005c4:	2a00      	cmp	r2, #0
 80005c6:	f040 808f 	bne.w	80006e8 <__udivmoddi4+0x210>
 80005ca:	1b49      	subs	r1, r1, r5
 80005cc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80005d0:	fa1f f885 	uxth.w	r8, r5
 80005d4:	2701      	movs	r7, #1
 80005d6:	fbb1 fcfe 	udiv	ip, r1, lr
 80005da:	0c23      	lsrs	r3, r4, #16
 80005dc:	fb0e 111c 	mls	r1, lr, ip, r1
 80005e0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80005e4:	fb08 f10c 	mul.w	r1, r8, ip
 80005e8:	4299      	cmp	r1, r3
 80005ea:	d907      	bls.n	80005fc <__udivmoddi4+0x124>
 80005ec:	18eb      	adds	r3, r5, r3
 80005ee:	f10c 30ff 	add.w	r0, ip, #4294967295
 80005f2:	d202      	bcs.n	80005fa <__udivmoddi4+0x122>
 80005f4:	4299      	cmp	r1, r3
 80005f6:	f200 80cd 	bhi.w	8000794 <__udivmoddi4+0x2bc>
 80005fa:	4684      	mov	ip, r0
 80005fc:	1a59      	subs	r1, r3, r1
 80005fe:	b2a3      	uxth	r3, r4
 8000600:	fbb1 f0fe 	udiv	r0, r1, lr
 8000604:	fb0e 1410 	mls	r4, lr, r0, r1
 8000608:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 800060c:	fb08 f800 	mul.w	r8, r8, r0
 8000610:	45a0      	cmp	r8, r4
 8000612:	d907      	bls.n	8000624 <__udivmoddi4+0x14c>
 8000614:	192c      	adds	r4, r5, r4
 8000616:	f100 33ff 	add.w	r3, r0, #4294967295
 800061a:	d202      	bcs.n	8000622 <__udivmoddi4+0x14a>
 800061c:	45a0      	cmp	r8, r4
 800061e:	f200 80b6 	bhi.w	800078e <__udivmoddi4+0x2b6>
 8000622:	4618      	mov	r0, r3
 8000624:	eba4 0408 	sub.w	r4, r4, r8
 8000628:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 800062c:	e79f      	b.n	800056e <__udivmoddi4+0x96>
 800062e:	f1c7 0c20 	rsb	ip, r7, #32
 8000632:	40bb      	lsls	r3, r7
 8000634:	fa22 fe0c 	lsr.w	lr, r2, ip
 8000638:	ea4e 0e03 	orr.w	lr, lr, r3
 800063c:	fa01 f407 	lsl.w	r4, r1, r7
 8000640:	fa20 f50c 	lsr.w	r5, r0, ip
 8000644:	fa21 f30c 	lsr.w	r3, r1, ip
 8000648:	ea4f 481e 	mov.w	r8, lr, lsr #16
 800064c:	4325      	orrs	r5, r4
 800064e:	fbb3 f9f8 	udiv	r9, r3, r8
 8000652:	0c2c      	lsrs	r4, r5, #16
 8000654:	fb08 3319 	mls	r3, r8, r9, r3
 8000658:	fa1f fa8e 	uxth.w	sl, lr
 800065c:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8000660:	fb09 f40a 	mul.w	r4, r9, sl
 8000664:	429c      	cmp	r4, r3
 8000666:	fa02 f207 	lsl.w	r2, r2, r7
 800066a:	fa00 f107 	lsl.w	r1, r0, r7
 800066e:	d90b      	bls.n	8000688 <__udivmoddi4+0x1b0>
 8000670:	eb1e 0303 	adds.w	r3, lr, r3
 8000674:	f109 30ff 	add.w	r0, r9, #4294967295
 8000678:	f080 8087 	bcs.w	800078a <__udivmoddi4+0x2b2>
 800067c:	429c      	cmp	r4, r3
 800067e:	f240 8084 	bls.w	800078a <__udivmoddi4+0x2b2>
 8000682:	f1a9 0902 	sub.w	r9, r9, #2
 8000686:	4473      	add	r3, lr
 8000688:	1b1b      	subs	r3, r3, r4
 800068a:	b2ad      	uxth	r5, r5
 800068c:	fbb3 f0f8 	udiv	r0, r3, r8
 8000690:	fb08 3310 	mls	r3, r8, r0, r3
 8000694:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8000698:	fb00 fa0a 	mul.w	sl, r0, sl
 800069c:	45a2      	cmp	sl, r4
 800069e:	d908      	bls.n	80006b2 <__udivmoddi4+0x1da>
 80006a0:	eb1e 0404 	adds.w	r4, lr, r4
 80006a4:	f100 33ff 	add.w	r3, r0, #4294967295
 80006a8:	d26b      	bcs.n	8000782 <__udivmoddi4+0x2aa>
 80006aa:	45a2      	cmp	sl, r4
 80006ac:	d969      	bls.n	8000782 <__udivmoddi4+0x2aa>
 80006ae:	3802      	subs	r0, #2
 80006b0:	4474      	add	r4, lr
 80006b2:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 80006b6:	fba0 8902 	umull	r8, r9, r0, r2
 80006ba:	eba4 040a 	sub.w	r4, r4, sl
 80006be:	454c      	cmp	r4, r9
 80006c0:	46c2      	mov	sl, r8
 80006c2:	464b      	mov	r3, r9
 80006c4:	d354      	bcc.n	8000770 <__udivmoddi4+0x298>
 80006c6:	d051      	beq.n	800076c <__udivmoddi4+0x294>
 80006c8:	2e00      	cmp	r6, #0
 80006ca:	d069      	beq.n	80007a0 <__udivmoddi4+0x2c8>
 80006cc:	ebb1 050a 	subs.w	r5, r1, sl
 80006d0:	eb64 0403 	sbc.w	r4, r4, r3
 80006d4:	fa04 fc0c 	lsl.w	ip, r4, ip
 80006d8:	40fd      	lsrs	r5, r7
 80006da:	40fc      	lsrs	r4, r7
 80006dc:	ea4c 0505 	orr.w	r5, ip, r5
 80006e0:	e9c6 5400 	strd	r5, r4, [r6]
 80006e4:	2700      	movs	r7, #0
 80006e6:	e747      	b.n	8000578 <__udivmoddi4+0xa0>
 80006e8:	f1c2 0320 	rsb	r3, r2, #32
 80006ec:	fa20 f703 	lsr.w	r7, r0, r3
 80006f0:	4095      	lsls	r5, r2
 80006f2:	fa01 f002 	lsl.w	r0, r1, r2
 80006f6:	fa21 f303 	lsr.w	r3, r1, r3
 80006fa:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80006fe:	4338      	orrs	r0, r7
 8000700:	0c01      	lsrs	r1, r0, #16
 8000702:	fbb3 f7fe 	udiv	r7, r3, lr
 8000706:	fa1f f885 	uxth.w	r8, r5
 800070a:	fb0e 3317 	mls	r3, lr, r7, r3
 800070e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000712:	fb07 f308 	mul.w	r3, r7, r8
 8000716:	428b      	cmp	r3, r1
 8000718:	fa04 f402 	lsl.w	r4, r4, r2
 800071c:	d907      	bls.n	800072e <__udivmoddi4+0x256>
 800071e:	1869      	adds	r1, r5, r1
 8000720:	f107 3cff 	add.w	ip, r7, #4294967295
 8000724:	d22f      	bcs.n	8000786 <__udivmoddi4+0x2ae>
 8000726:	428b      	cmp	r3, r1
 8000728:	d92d      	bls.n	8000786 <__udivmoddi4+0x2ae>
 800072a:	3f02      	subs	r7, #2
 800072c:	4429      	add	r1, r5
 800072e:	1acb      	subs	r3, r1, r3
 8000730:	b281      	uxth	r1, r0
 8000732:	fbb3 f0fe 	udiv	r0, r3, lr
 8000736:	fb0e 3310 	mls	r3, lr, r0, r3
 800073a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800073e:	fb00 f308 	mul.w	r3, r0, r8
 8000742:	428b      	cmp	r3, r1
 8000744:	d907      	bls.n	8000756 <__udivmoddi4+0x27e>
 8000746:	1869      	adds	r1, r5, r1
 8000748:	f100 3cff 	add.w	ip, r0, #4294967295
 800074c:	d217      	bcs.n	800077e <__udivmoddi4+0x2a6>
 800074e:	428b      	cmp	r3, r1
 8000750:	d915      	bls.n	800077e <__udivmoddi4+0x2a6>
 8000752:	3802      	subs	r0, #2
 8000754:	4429      	add	r1, r5
 8000756:	1ac9      	subs	r1, r1, r3
 8000758:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 800075c:	e73b      	b.n	80005d6 <__udivmoddi4+0xfe>
 800075e:	4637      	mov	r7, r6
 8000760:	4630      	mov	r0, r6
 8000762:	e709      	b.n	8000578 <__udivmoddi4+0xa0>
 8000764:	4607      	mov	r7, r0
 8000766:	e6e7      	b.n	8000538 <__udivmoddi4+0x60>
 8000768:	4618      	mov	r0, r3
 800076a:	e6fb      	b.n	8000564 <__udivmoddi4+0x8c>
 800076c:	4541      	cmp	r1, r8
 800076e:	d2ab      	bcs.n	80006c8 <__udivmoddi4+0x1f0>
 8000770:	ebb8 0a02 	subs.w	sl, r8, r2
 8000774:	eb69 020e 	sbc.w	r2, r9, lr
 8000778:	3801      	subs	r0, #1
 800077a:	4613      	mov	r3, r2
 800077c:	e7a4      	b.n	80006c8 <__udivmoddi4+0x1f0>
 800077e:	4660      	mov	r0, ip
 8000780:	e7e9      	b.n	8000756 <__udivmoddi4+0x27e>
 8000782:	4618      	mov	r0, r3
 8000784:	e795      	b.n	80006b2 <__udivmoddi4+0x1da>
 8000786:	4667      	mov	r7, ip
 8000788:	e7d1      	b.n	800072e <__udivmoddi4+0x256>
 800078a:	4681      	mov	r9, r0
 800078c:	e77c      	b.n	8000688 <__udivmoddi4+0x1b0>
 800078e:	3802      	subs	r0, #2
 8000790:	442c      	add	r4, r5
 8000792:	e747      	b.n	8000624 <__udivmoddi4+0x14c>
 8000794:	f1ac 0c02 	sub.w	ip, ip, #2
 8000798:	442b      	add	r3, r5
 800079a:	e72f      	b.n	80005fc <__udivmoddi4+0x124>
 800079c:	4638      	mov	r0, r7
 800079e:	e708      	b.n	80005b2 <__udivmoddi4+0xda>
 80007a0:	4637      	mov	r7, r6
 80007a2:	e6e9      	b.n	8000578 <__udivmoddi4+0xa0>

080007a4 <__aeabi_idiv0>:
 80007a4:	4770      	bx	lr
 80007a6:	bf00      	nop

080007a8 <SCB_EnableICache>:
/**
  \brief   Enable I-Cache
  \details Turns on I-Cache
  */
__STATIC_INLINE void SCB_EnableICache (void)
{
 80007a8:	b480      	push	{r7}
 80007aa:	af00      	add	r7, sp, #0
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80007ac:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80007b0:	f3bf 8f6f 	isb	sy
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80007b4:	4b0b      	ldr	r3, [pc, #44]	; (80007e4 <SCB_EnableICache+0x3c>)
 80007b6:	2200      	movs	r2, #0
 80007b8:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 80007bc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80007c0:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 80007c4:	4b07      	ldr	r3, [pc, #28]	; (80007e4 <SCB_EnableICache+0x3c>)
 80007c6:	695b      	ldr	r3, [r3, #20]
 80007c8:	4a06      	ldr	r2, [pc, #24]	; (80007e4 <SCB_EnableICache+0x3c>)
 80007ca:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80007ce:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 80007d0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80007d4:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  #endif
}
 80007d8:	bf00      	nop
 80007da:	46bd      	mov	sp, r7
 80007dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007e0:	4770      	bx	lr
 80007e2:	bf00      	nop
 80007e4:	e000ed00 	.word	0xe000ed00

080007e8 <SCB_EnableDCache>:
/**
  \brief   Enable D-Cache
  \details Turns on D-Cache
  */
__STATIC_INLINE void SCB_EnableDCache (void)
{
 80007e8:	b480      	push	{r7}
 80007ea:	b085      	sub	sp, #20
 80007ec:	af00      	add	r7, sp, #0
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 80007ee:	4b1d      	ldr	r3, [pc, #116]	; (8000864 <SCB_EnableDCache+0x7c>)
 80007f0:	2200      	movs	r2, #0
 80007f2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 80007f6:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 80007fa:	4b1a      	ldr	r3, [pc, #104]	; (8000864 <SCB_EnableDCache+0x7c>)
 80007fc:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8000800:	607b      	str	r3, [r7, #4]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000802:	687b      	ldr	r3, [r7, #4]
 8000804:	0b5b      	lsrs	r3, r3, #13
 8000806:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800080a:	60fb      	str	r3, [r7, #12]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 800080c:	687b      	ldr	r3, [r7, #4]
 800080e:	08db      	lsrs	r3, r3, #3
 8000810:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8000814:	60bb      	str	r3, [r7, #8]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000816:	68fb      	ldr	r3, [r7, #12]
 8000818:	015a      	lsls	r2, r3, #5
 800081a:	f643 73e0 	movw	r3, #16352	; 0x3fe0
 800081e:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 8000820:	68ba      	ldr	r2, [r7, #8]
 8000822:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000824:	490f      	ldr	r1, [pc, #60]	; (8000864 <SCB_EnableDCache+0x7c>)
 8000826:	4313      	orrs	r3, r2
 8000828:	f8c1 3260 	str.w	r3, [r1, #608]	; 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 800082c:	68bb      	ldr	r3, [r7, #8]
 800082e:	1e5a      	subs	r2, r3, #1
 8000830:	60ba      	str	r2, [r7, #8]
 8000832:	2b00      	cmp	r3, #0
 8000834:	d1ef      	bne.n	8000816 <SCB_EnableDCache+0x2e>
    } while(sets-- != 0U);
 8000836:	68fb      	ldr	r3, [r7, #12]
 8000838:	1e5a      	subs	r2, r3, #1
 800083a:	60fa      	str	r2, [r7, #12]
 800083c:	2b00      	cmp	r3, #0
 800083e:	d1e5      	bne.n	800080c <SCB_EnableDCache+0x24>
 8000840:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8000844:	4b07      	ldr	r3, [pc, #28]	; (8000864 <SCB_EnableDCache+0x7c>)
 8000846:	695b      	ldr	r3, [r3, #20]
 8000848:	4a06      	ldr	r2, [pc, #24]	; (8000864 <SCB_EnableDCache+0x7c>)
 800084a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800084e:	6153      	str	r3, [r2, #20]
 8000850:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000854:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
  #endif
}
 8000858:	bf00      	nop
 800085a:	3714      	adds	r7, #20
 800085c:	46bd      	mov	sp, r7
 800085e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000862:	4770      	bx	lr
 8000864:	e000ed00 	.word	0xe000ed00

08000868 <HAL_UART_MspInit>:
 * This function configures the hardware resources used in this example
 * @param huart: UART handle pointer
 * @retval None
 */
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8000868:	b580      	push	{r7, lr}
 800086a:	b08c      	sub	sp, #48	; 0x30
 800086c:	af00      	add	r7, sp, #0
 800086e:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef GPIO_InitStruct = { 0 };
 8000870:	f107 031c 	add.w	r3, r7, #28
 8000874:	2200      	movs	r2, #0
 8000876:	601a      	str	r2, [r3, #0]
 8000878:	605a      	str	r2, [r3, #4]
 800087a:	609a      	str	r2, [r3, #8]
 800087c:	60da      	str	r2, [r3, #12]
 800087e:	611a      	str	r2, [r3, #16]

	if (huart->Instance == USART1)
 8000880:	687b      	ldr	r3, [r7, #4]
 8000882:	681b      	ldr	r3, [r3, #0]
 8000884:	4a3c      	ldr	r2, [pc, #240]	; (8000978 <HAL_UART_MspInit+0x110>)
 8000886:	4293      	cmp	r3, r2
 8000888:	d145      	bne.n	8000916 <HAL_UART_MspInit+0xae>
	{
		/* Peripheral clock enable */
		__HAL_RCC_USART1_CLK_ENABLE();
 800088a:	4b3c      	ldr	r3, [pc, #240]	; (800097c <HAL_UART_MspInit+0x114>)
 800088c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800088e:	4a3b      	ldr	r2, [pc, #236]	; (800097c <HAL_UART_MspInit+0x114>)
 8000890:	f043 0310 	orr.w	r3, r3, #16
 8000894:	6453      	str	r3, [r2, #68]	; 0x44
 8000896:	4b39      	ldr	r3, [pc, #228]	; (800097c <HAL_UART_MspInit+0x114>)
 8000898:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800089a:	f003 0310 	and.w	r3, r3, #16
 800089e:	61bb      	str	r3, [r7, #24]
 80008a0:	69bb      	ldr	r3, [r7, #24]

		__HAL_RCC_GPIOB_CLK_ENABLE();
 80008a2:	4b36      	ldr	r3, [pc, #216]	; (800097c <HAL_UART_MspInit+0x114>)
 80008a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80008a6:	4a35      	ldr	r2, [pc, #212]	; (800097c <HAL_UART_MspInit+0x114>)
 80008a8:	f043 0302 	orr.w	r3, r3, #2
 80008ac:	6313      	str	r3, [r2, #48]	; 0x30
 80008ae:	4b33      	ldr	r3, [pc, #204]	; (800097c <HAL_UART_MspInit+0x114>)
 80008b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80008b2:	f003 0302 	and.w	r3, r3, #2
 80008b6:	617b      	str	r3, [r7, #20]
 80008b8:	697b      	ldr	r3, [r7, #20]
		__HAL_RCC_GPIOA_CLK_ENABLE();
 80008ba:	4b30      	ldr	r3, [pc, #192]	; (800097c <HAL_UART_MspInit+0x114>)
 80008bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80008be:	4a2f      	ldr	r2, [pc, #188]	; (800097c <HAL_UART_MspInit+0x114>)
 80008c0:	f043 0301 	orr.w	r3, r3, #1
 80008c4:	6313      	str	r3, [r2, #48]	; 0x30
 80008c6:	4b2d      	ldr	r3, [pc, #180]	; (800097c <HAL_UART_MspInit+0x114>)
 80008c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80008ca:	f003 0301 	and.w	r3, r3, #1
 80008ce:	613b      	str	r3, [r7, #16]
 80008d0:	693b      	ldr	r3, [r7, #16]

		/* USART1 GPIO Configuration
		 * PB7 ------> USART1_RX
		 * PA9 ------> USART1_TX
		 */
		GPIO_InitStruct.Pin = VCP_RX_Pin;
 80008d2:	2380      	movs	r3, #128	; 0x80
 80008d4:	61fb      	str	r3, [r7, #28]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80008d6:	2302      	movs	r3, #2
 80008d8:	623b      	str	r3, [r7, #32]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 80008da:	2300      	movs	r3, #0
 80008dc:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80008de:	2300      	movs	r3, #0
 80008e0:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 80008e2:	2307      	movs	r3, #7
 80008e4:	62fb      	str	r3, [r7, #44]	; 0x2c
		HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
 80008e6:	f107 031c 	add.w	r3, r7, #28
 80008ea:	4619      	mov	r1, r3
 80008ec:	4824      	ldr	r0, [pc, #144]	; (8000980 <HAL_UART_MspInit+0x118>)
 80008ee:	f00a fa61 	bl	800adb4 <HAL_GPIO_Init>

		GPIO_InitStruct.Pin = VCP_TX_Pin;
 80008f2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80008f6:	61fb      	str	r3, [r7, #28]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80008f8:	2302      	movs	r3, #2
 80008fa:	623b      	str	r3, [r7, #32]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 80008fc:	2300      	movs	r3, #0
 80008fe:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000900:	2300      	movs	r3, #0
 8000902:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8000904:	2307      	movs	r3, #7
 8000906:	62fb      	str	r3, [r7, #44]	; 0x2c
		HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);
 8000908:	f107 031c 	add.w	r3, r7, #28
 800090c:	4619      	mov	r1, r3
 800090e:	481d      	ldr	r0, [pc, #116]	; (8000984 <HAL_UART_MspInit+0x11c>)
 8000910:	f00a fa50 	bl	800adb4 <HAL_GPIO_Init>
		GPIO_InitStruct.Pull = GPIO_NOPULL;
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
		GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
		HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
	}
}
 8000914:	e02c      	b.n	8000970 <HAL_UART_MspInit+0x108>
	else if (huart->Instance == USART6)
 8000916:	687b      	ldr	r3, [r7, #4]
 8000918:	681b      	ldr	r3, [r3, #0]
 800091a:	4a1b      	ldr	r2, [pc, #108]	; (8000988 <HAL_UART_MspInit+0x120>)
 800091c:	4293      	cmp	r3, r2
 800091e:	d127      	bne.n	8000970 <HAL_UART_MspInit+0x108>
		__HAL_RCC_USART6_CLK_ENABLE();
 8000920:	4b16      	ldr	r3, [pc, #88]	; (800097c <HAL_UART_MspInit+0x114>)
 8000922:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000924:	4a15      	ldr	r2, [pc, #84]	; (800097c <HAL_UART_MspInit+0x114>)
 8000926:	f043 0320 	orr.w	r3, r3, #32
 800092a:	6453      	str	r3, [r2, #68]	; 0x44
 800092c:	4b13      	ldr	r3, [pc, #76]	; (800097c <HAL_UART_MspInit+0x114>)
 800092e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000930:	f003 0320 	and.w	r3, r3, #32
 8000934:	60fb      	str	r3, [r7, #12]
 8000936:	68fb      	ldr	r3, [r7, #12]
		__HAL_RCC_GPIOC_CLK_ENABLE();
 8000938:	4b10      	ldr	r3, [pc, #64]	; (800097c <HAL_UART_MspInit+0x114>)
 800093a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800093c:	4a0f      	ldr	r2, [pc, #60]	; (800097c <HAL_UART_MspInit+0x114>)
 800093e:	f043 0304 	orr.w	r3, r3, #4
 8000942:	6313      	str	r3, [r2, #48]	; 0x30
 8000944:	4b0d      	ldr	r3, [pc, #52]	; (800097c <HAL_UART_MspInit+0x114>)
 8000946:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000948:	f003 0304 	and.w	r3, r3, #4
 800094c:	60bb      	str	r3, [r7, #8]
 800094e:	68bb      	ldr	r3, [r7, #8]
		GPIO_InitStruct.Pin = ARDUINO_RX_D0_Pin | ARDUINO_TX_D1_Pin;
 8000950:	23c0      	movs	r3, #192	; 0xc0
 8000952:	61fb      	str	r3, [r7, #28]
		GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000954:	2302      	movs	r3, #2
 8000956:	623b      	str	r3, [r7, #32]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000958:	2300      	movs	r3, #0
 800095a:	627b      	str	r3, [r7, #36]	; 0x24
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800095c:	2303      	movs	r3, #3
 800095e:	62bb      	str	r3, [r7, #40]	; 0x28
		GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
 8000960:	2308      	movs	r3, #8
 8000962:	62fb      	str	r3, [r7, #44]	; 0x2c
		HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000964:	f107 031c 	add.w	r3, r7, #28
 8000968:	4619      	mov	r1, r3
 800096a:	4808      	ldr	r0, [pc, #32]	; (800098c <HAL_UART_MspInit+0x124>)
 800096c:	f00a fa22 	bl	800adb4 <HAL_GPIO_Init>
}
 8000970:	bf00      	nop
 8000972:	3730      	adds	r7, #48	; 0x30
 8000974:	46bd      	mov	sp, r7
 8000976:	bd80      	pop	{r7, pc}
 8000978:	40011000 	.word	0x40011000
 800097c:	40023800 	.word	0x40023800
 8000980:	40020400 	.word	0x40020400
 8000984:	40020000 	.word	0x40020000
 8000988:	40011400 	.word	0x40011400
 800098c:	40020800 	.word	0x40020800

08000990 <hardware_rand_initialize>:

void BSP_SDRAM_Init();
void USB_OTG_BSP_HS_Init(void);

void hardware_rand_initialize(void)
{
 8000990:	b480      	push	{r7}
 8000992:	af00      	add	r7, sp, #0
	/* Enable clock for the RNG.  */
	STM32F7_RCC_AHB2ENR |= STM32F7_RCC_AHB2ENR_RNGEN;
 8000994:	4b06      	ldr	r3, [pc, #24]	; (80009b0 <hardware_rand_initialize+0x20>)
 8000996:	681b      	ldr	r3, [r3, #0]
 8000998:	4a05      	ldr	r2, [pc, #20]	; (80009b0 <hardware_rand_initialize+0x20>)
 800099a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800099e:	6013      	str	r3, [r2, #0]

	/* Enable the random number generator.  */
	STM32_RNG_CR = STM32_RNG_CR_RNGEN;
 80009a0:	4b04      	ldr	r3, [pc, #16]	; (80009b4 <hardware_rand_initialize+0x24>)
 80009a2:	2204      	movs	r2, #4
 80009a4:	601a      	str	r2, [r3, #0]
}
 80009a6:	bf00      	nop
 80009a8:	46bd      	mov	sp, r7
 80009aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80009ae:	4770      	bx	lr
 80009b0:	40023834 	.word	0x40023834
 80009b4:	50060800 	.word	0x50060800

080009b8 <MX_USART1_UART_Init>:
 * @brief USART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_USART1_UART_Init(void)
{
 80009b8:	b580      	push	{r7, lr}
 80009ba:	af00      	add	r7, sp, #0
	huart1.Instance = USART1;
 80009bc:	4b13      	ldr	r3, [pc, #76]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009be:	4a14      	ldr	r2, [pc, #80]	; (8000a10 <MX_USART1_UART_Init+0x58>)
 80009c0:	601a      	str	r2, [r3, #0]
	huart1.Init.BaudRate = 115200;
 80009c2:	4b12      	ldr	r3, [pc, #72]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009c4:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 80009c8:	605a      	str	r2, [r3, #4]
	huart1.Init.WordLength = UART_WORDLENGTH_8B;
 80009ca:	4b10      	ldr	r3, [pc, #64]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009cc:	2200      	movs	r2, #0
 80009ce:	609a      	str	r2, [r3, #8]
	huart1.Init.StopBits = UART_STOPBITS_1;
 80009d0:	4b0e      	ldr	r3, [pc, #56]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009d2:	2200      	movs	r2, #0
 80009d4:	60da      	str	r2, [r3, #12]
	huart1.Init.Parity = UART_PARITY_NONE;
 80009d6:	4b0d      	ldr	r3, [pc, #52]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009d8:	2200      	movs	r2, #0
 80009da:	611a      	str	r2, [r3, #16]
	huart1.Init.Mode = UART_MODE_TX_RX;
 80009dc:	4b0b      	ldr	r3, [pc, #44]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009de:	220c      	movs	r2, #12
 80009e0:	615a      	str	r2, [r3, #20]
	huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80009e2:	4b0a      	ldr	r3, [pc, #40]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009e4:	2200      	movs	r2, #0
 80009e6:	619a      	str	r2, [r3, #24]
	huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 80009e8:	4b08      	ldr	r3, [pc, #32]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009ea:	2200      	movs	r2, #0
 80009ec:	61da      	str	r2, [r3, #28]
	huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 80009ee:	4b07      	ldr	r3, [pc, #28]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009f0:	2200      	movs	r2, #0
 80009f2:	621a      	str	r2, [r3, #32]
	huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80009f4:	4b05      	ldr	r3, [pc, #20]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009f6:	2200      	movs	r2, #0
 80009f8:	625a      	str	r2, [r3, #36]	; 0x24
	if (HAL_UART_Init(&huart1) != HAL_OK)
 80009fa:	4804      	ldr	r0, [pc, #16]	; (8000a0c <MX_USART1_UART_Init+0x54>)
 80009fc:	f00a ff4e 	bl	800b89c <HAL_UART_Init>
 8000a00:	4603      	mov	r3, r0
 8000a02:	2b00      	cmp	r3, #0
 8000a04:	d000      	beq.n	8000a08 <MX_USART1_UART_Init+0x50>
	{
		while (1);
 8000a06:	e7fe      	b.n	8000a06 <MX_USART1_UART_Init+0x4e>
	}
}
 8000a08:	bf00      	nop
 8000a0a:	bd80      	pop	{r7, pc}
 8000a0c:	20000210 	.word	0x20000210
 8000a10:	40011000 	.word	0x40011000

08000a14 <SystemClock_Config>:
 *            Flash Latency(WS)              = 7
 * @param  None
 * @retval None
 */
static void SystemClock_Config(void)
{
 8000a14:	b580      	push	{r7, lr}
 8000a16:	b092      	sub	sp, #72	; 0x48
 8000a18:	af00      	add	r7, sp, #0
	RCC_ClkInitTypeDef RCC_ClkInitStruct;
	RCC_OscInitTypeDef RCC_OscInitStruct;
	HAL_StatusTypeDef ret = HAL_OK;
 8000a1a:	2300      	movs	r3, #0
 8000a1c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

	/* Enable HSE Oscillator and activate PLL with HSE as source */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000a20:	2301      	movs	r3, #1
 8000a22:	603b      	str	r3, [r7, #0]
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000a24:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000a28:	607b      	str	r3, [r7, #4]
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000a2a:	2302      	movs	r3, #2
 8000a2c:	61bb      	str	r3, [r7, #24]
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000a2e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8000a32:	61fb      	str	r3, [r7, #28]
	RCC_OscInitStruct.PLL.PLLM = 25;
 8000a34:	2319      	movs	r3, #25
 8000a36:	623b      	str	r3, [r7, #32]
	RCC_OscInitStruct.PLL.PLLN = 432;
 8000a38:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
 8000a3c:	627b      	str	r3, [r7, #36]	; 0x24
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8000a3e:	2302      	movs	r3, #2
 8000a40:	62bb      	str	r3, [r7, #40]	; 0x28
	RCC_OscInitStruct.PLL.PLLQ = 9;
 8000a42:	2309      	movs	r3, #9
 8000a44:	62fb      	str	r3, [r7, #44]	; 0x2c

	ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8000a46:	463b      	mov	r3, r7
 8000a48:	4618      	mov	r0, r3
 8000a4a:	f00a faf5 	bl	800b038 <HAL_RCC_OscConfig>
 8000a4e:	4603      	mov	r3, r0
 8000a50:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (ret != HAL_OK)
 8000a54:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8000a58:	2b00      	cmp	r3, #0
 8000a5a:	d000      	beq.n	8000a5e <SystemClock_Config+0x4a>
	{
		while (1);
 8000a5c:	e7fe      	b.n	8000a5c <SystemClock_Config+0x48>
	}

	/* Activate the OverDrive to reach the 216 MHz Frequency */
	ret = HAL_PWREx_EnableOverDrive();
 8000a5e:	f00a faaf 	bl	800afc0 <HAL_PWREx_EnableOverDrive>
 8000a62:	4603      	mov	r3, r0
 8000a64:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (ret != HAL_OK)
 8000a68:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8000a6c:	2b00      	cmp	r3, #0
 8000a6e:	d000      	beq.n	8000a72 <SystemClock_Config+0x5e>
	{
		while (1);
 8000a70:	e7fe      	b.n	8000a70 <SystemClock_Config+0x5c>
	}

	/* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */
	RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1
 8000a72:	230f      	movs	r3, #15
 8000a74:	633b      	str	r3, [r7, #48]	; 0x30
			| RCC_CLOCKTYPE_PCLK2);
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000a76:	2302      	movs	r3, #2
 8000a78:	637b      	str	r3, [r7, #52]	; 0x34
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000a7a:	2300      	movs	r3, #0
 8000a7c:	63bb      	str	r3, [r7, #56]	; 0x38
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 8000a7e:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8000a82:	63fb      	str	r3, [r7, #60]	; 0x3c
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8000a84:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000a88:	643b      	str	r3, [r7, #64]	; 0x40

	ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
 8000a8a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8000a8e:	2107      	movs	r1, #7
 8000a90:	4618      	mov	r0, r3
 8000a92:	f00a fccb 	bl	800b42c <HAL_RCC_ClockConfig>
 8000a96:	4603      	mov	r3, r0
 8000a98:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (ret != HAL_OK)
 8000a9c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8000aa0:	2b00      	cmp	r3, #0
 8000aa2:	d000      	beq.n	8000aa6 <SystemClock_Config+0x92>
	{
		while (1);
 8000aa4:	e7fe      	b.n	8000aa4 <SystemClock_Config+0x90>
	}
}
 8000aa6:	bf00      	nop
 8000aa8:	3748      	adds	r7, #72	; 0x48
 8000aaa:	46bd      	mov	sp, r7
 8000aac:	bd80      	pop	{r7, pc}
	...

08000ab0 <MPU_Config>:
 *         The Region Size is 256KB, it is related to SRAM1 and SRAM2  memory size.
 * @param  None
 * @retval None
 */
static void MPU_Config(void)
{
 8000ab0:	b580      	push	{r7, lr}
 8000ab2:	b084      	sub	sp, #16
 8000ab4:	af00      	add	r7, sp, #0
	MPU_Region_InitTypeDef MPU_InitStruct;

	/* Disable the MPU */
	HAL_MPU_Disable();
 8000ab6:	f00a f855 	bl	800ab64 <HAL_MPU_Disable>

	/* Configure the MPU attributes as cacheable for SRAM */
	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8000aba:	2301      	movs	r3, #1
 8000abc:	703b      	strb	r3, [r7, #0]
	MPU_InitStruct.BaseAddress = 0x20010000;
 8000abe:	4b1d      	ldr	r3, [pc, #116]	; (8000b34 <MPU_Config+0x84>)
 8000ac0:	607b      	str	r3, [r7, #4]
	MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 8000ac2:	2311      	movs	r3, #17
 8000ac4:	723b      	strb	r3, [r7, #8]
	MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 8000ac6:	2303      	movs	r3, #3
 8000ac8:	72fb      	strb	r3, [r7, #11]
	MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 8000aca:	2301      	movs	r3, #1
 8000acc:	73fb      	strb	r3, [r7, #15]
	MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 8000ace:	2301      	movs	r3, #1
 8000ad0:	73bb      	strb	r3, [r7, #14]
	MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 8000ad2:	2300      	movs	r3, #0
 8000ad4:	737b      	strb	r3, [r7, #13]
	MPU_InitStruct.Number = MPU_REGION_NUMBER0;
 8000ad6:	2300      	movs	r3, #0
 8000ad8:	707b      	strb	r3, [r7, #1]
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 8000ada:	2300      	movs	r3, #0
 8000adc:	72bb      	strb	r3, [r7, #10]
	MPU_InitStruct.SubRegionDisable = 0x00;
 8000ade:	2300      	movs	r3, #0
 8000ae0:	727b      	strb	r3, [r7, #9]
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 8000ae2:	2300      	movs	r3, #0
 8000ae4:	733b      	strb	r3, [r7, #12]
	HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8000ae6:	463b      	mov	r3, r7
 8000ae8:	4618      	mov	r0, r3
 8000aea:	f00a f85d 	bl	800aba8 <HAL_MPU_ConfigRegion>
	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8000aee:	2301      	movs	r3, #1
 8000af0:	703b      	strb	r3, [r7, #0]
	MPU_InitStruct.BaseAddress = 0xC0000000;
 8000af2:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 8000af6:	607b      	str	r3, [r7, #4]
	MPU_InitStruct.Size = MPU_REGION_SIZE_8MB;
 8000af8:	2316      	movs	r3, #22
 8000afa:	723b      	strb	r3, [r7, #8]
	MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 8000afc:	2303      	movs	r3, #3
 8000afe:	72fb      	strb	r3, [r7, #11]
	MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
 8000b00:	2301      	movs	r3, #1
 8000b02:	73fb      	strb	r3, [r7, #15]
	MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
 8000b04:	2301      	movs	r3, #1
 8000b06:	73bb      	strb	r3, [r7, #14]
	MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
 8000b08:	2300      	movs	r3, #0
 8000b0a:	737b      	strb	r3, [r7, #13]
	MPU_InitStruct.Number = MPU_REGION_NUMBER1;
 8000b0c:	2301      	movs	r3, #1
 8000b0e:	707b      	strb	r3, [r7, #1]
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 8000b10:	2300      	movs	r3, #0
 8000b12:	72bb      	strb	r3, [r7, #10]
	MPU_InitStruct.SubRegionDisable = 0x00;
 8000b14:	2300      	movs	r3, #0
 8000b16:	727b      	strb	r3, [r7, #9]
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 8000b18:	2300      	movs	r3, #0
 8000b1a:	733b      	strb	r3, [r7, #12]
	HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8000b1c:	463b      	mov	r3, r7
 8000b1e:	4618      	mov	r0, r3
 8000b20:	f00a f842 	bl	800aba8 <HAL_MPU_ConfigRegion>

	/* Enable the MPU */
	HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 8000b24:	2004      	movs	r0, #4
 8000b26:	f00a f82d 	bl	800ab84 <HAL_MPU_Enable>
}
 8000b2a:	bf00      	nop
 8000b2c:	3710      	adds	r7, #16
 8000b2e:	46bd      	mov	sp, r7
 8000b30:	bd80      	pop	{r7, pc}
 8000b32:	bf00      	nop
 8000b34:	20010000 	.word	0x20010000

08000b38 <CPU_CACHE_Enable>:
 * @brief  CPU L1-Cache enable.
 * @param  None
 * @retval None
 */
static void CPU_CACHE_Enable(void)
{
 8000b38:	b580      	push	{r7, lr}
 8000b3a:	af00      	add	r7, sp, #0
	/* Enable I-Cache */
	SCB_EnableICache();
 8000b3c:	f7ff fe34 	bl	80007a8 <SCB_EnableICache>

	/* Enable D-Cache */
	SCB_EnableDCache();
 8000b40:	f7ff fe52 	bl	80007e8 <SCB_EnableDCache>
}
 8000b44:	bf00      	nop
 8000b46:	bd80      	pop	{r7, pc}

08000b48 <hardware_setup>:

/** Initialize: MPU, CACHE, HAL, Clock, SDRAM, USART1, RNG */
void hardware_setup(void)
{
 8000b48:	b580      	push	{r7, lr}
 8000b4a:	af00      	add	r7, sp, #0
	/* Configure the MPU attributes as Write Through */
	MPU_Config();
 8000b4c:	f7ff ffb0 	bl	8000ab0 <MPU_Config>

	/* Enable the CPU Cache */
	CPU_CACHE_Enable();
 8000b50:	f7ff fff2 	bl	8000b38 <CPU_CACHE_Enable>

	/* STM32F7xx HAL library initialization */
	HAL_Init();
 8000b54:	f009 ff78 	bl	800aa48 <HAL_Init>

	/* Configure the system clock to 216 MHz */
	SystemClock_Config();
 8000b58:	f7ff ff5c 	bl	8000a14 <SystemClock_Config>

	/* Configure the SDRAM.  */
	BSP_SDRAM_Init();
 8000b5c:	f009 feea 	bl	800a934 <BSP_SDRAM_Init>

	/* Initialize UART for printf.  */
	MX_USART1_UART_Init();
 8000b60:	f7ff ff2a 	bl	80009b8 <MX_USART1_UART_Init>

	/* Initialize the hardware random number generator.  */
	hardware_rand_initialize();
 8000b64:	f7ff ff14 	bl	8000990 <hardware_rand_initialize>
}
 8000b68:	bf00      	nop
 8000b6a:	bd80      	pop	{r7, pc}

08000b6c <main>:
UCHAR storage_buffer[DEMO_BUFFER_SIZE];

/*--------------------------------------------- main ---------------------------------------------*/

int main(int argc, char** argv)
{
 8000b6c:	b580      	push	{r7, lr}
 8000b6e:	b082      	sub	sp, #8
 8000b70:	af00      	add	r7, sp, #0
 8000b72:	6078      	str	r0, [r7, #4]
 8000b74:	6039      	str	r1, [r7, #0]
	/* Setup the hardware. */
	hardware_setup();
 8000b76:	f7ff ffe7 	bl	8000b48 <hardware_setup>

	/* Enter the ThreadX kernel.
	 * 1. _tx_initialize_low_level();
	 * 2. tx_application_define(_tx_initialize_unused_memory);
	 * 3. _tx_thread_schedule(); */
	tx_kernel_enter();
 8000b7a:	f00b fa9f 	bl	800c0bc <_tx_initialize_kernel_enter>
 8000b7e:	2300      	movs	r3, #0
}
 8000b80:	4618      	mov	r0, r3
 8000b82:	3708      	adds	r7, #8
 8000b84:	46bd      	mov	sp, r7
 8000b86:	bd80      	pop	{r7, pc}

08000b88 <tx_application_define>:

/*-------------------------- Define what the initial system looks like. --------------------------*/

void tx_application_define(void* first_unused_memory)
{
 8000b88:	b580      	push	{r7, lr}
 8000b8a:	b08c      	sub	sp, #48	; 0x30
 8000b8c:	af08      	add	r7, sp, #32
 8000b8e:	6078      	str	r0, [r7, #4]
//	CHAR* stack_pointer;
//	CHAR* memory_pointer;

	/* Initialize the bsp layer of the USB OTG HS Controller.  */
	USB_OTG_BSP_HS_Init();
 8000b90:	f000 f966 	bl	8000e60 <USB_OTG_BSP_HS_Init>

	/* Initialize the free memory pointer */
	CHAR* stack_pointer = (CHAR*)first_unused_memory;
 8000b94:	687b      	ldr	r3, [r7, #4]
 8000b96:	60fb      	str	r3, [r7, #12]
	CHAR* memory_pointer = stack_pointer + DEMO_STACK_SIZE;
 8000b98:	68fb      	ldr	r3, [r7, #12]
 8000b9a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8000b9e:	60bb      	str	r3, [r7, #8]

	/* Initialize FileX.  */
	fx_system_initialize();
 8000ba0:	f005 f8c2 	bl	8005d28 <_fx_system_initialize>

	/* Initialize USBX memory. */
	ux_system_initialize(memory_pointer, USBX_MEMORY_SIZE, UX_NULL, 0);
 8000ba4:	2300      	movs	r3, #0
 8000ba6:	2200      	movs	r2, #0
 8000ba8:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8000bac:	68b8      	ldr	r0, [r7, #8]
 8000bae:	f001 f837 	bl	8001c20 <_ux_system_initialize>

	/* Create the main demo thread.  */
	tx_thread_create(&tx_demo_thread, "tx demo", demo_thread_entry, 0, stack_pointer,
 8000bb2:	23c8      	movs	r3, #200	; 0xc8
 8000bb4:	9306      	str	r3, [sp, #24]
 8000bb6:	2301      	movs	r3, #1
 8000bb8:	9305      	str	r3, [sp, #20]
 8000bba:	2301      	movs	r3, #1
 8000bbc:	9304      	str	r3, [sp, #16]
 8000bbe:	231e      	movs	r3, #30
 8000bc0:	9303      	str	r3, [sp, #12]
 8000bc2:	231e      	movs	r3, #30
 8000bc4:	9302      	str	r3, [sp, #8]
 8000bc6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8000bca:	9301      	str	r3, [sp, #4]
 8000bcc:	68fb      	ldr	r3, [r7, #12]
 8000bce:	9300      	str	r3, [sp, #0]
 8000bd0:	2300      	movs	r3, #0
 8000bd2:	4a04      	ldr	r2, [pc, #16]	; (8000be4 <tx_application_define+0x5c>)
 8000bd4:	4904      	ldr	r1, [pc, #16]	; (8000be8 <tx_application_define+0x60>)
 8000bd6:	4805      	ldr	r0, [pc, #20]	; (8000bec <tx_application_define+0x64>)
 8000bd8:	f00c fa2e 	bl	800d038 <_txe_thread_create>
			DEMO_STACK_SIZE, 30, 30, 1, TX_AUTO_START);
}
 8000bdc:	bf00      	nop
 8000bde:	3710      	adds	r7, #16
 8000be0:	46bd      	mov	sp, r7
 8000be2:	bd80      	pop	{r7, pc}
 8000be4:	08000bf1 	.word	0x08000bf1
 8000be8:	0800dd08 	.word	0x0800dd08
 8000bec:	20000698 	.word	0x20000698

08000bf0 <demo_thread_entry>:

void demo_thread_entry(ULONG arg)
{
 8000bf0:	b580      	push	{r7, lr}
 8000bf2:	b082      	sub	sp, #8
 8000bf4:	af00      	add	r7, sp, #0
 8000bf6:	6078      	str	r0, [r7, #4]
	/* The code below is required for installing the host portion of USBX.  */
	status = ux_host_stack_initialize(UX_NULL);
 8000bf8:	2000      	movs	r0, #0
 8000bfa:	f000 ff25 	bl	8001a48 <_ux_host_stack_initialize>
 8000bfe:	4602      	mov	r2, r0
 8000c00:	4b29      	ldr	r3, [pc, #164]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c02:	601a      	str	r2, [r3, #0]
	if (status != UX_SUCCESS)
 8000c04:	4b28      	ldr	r3, [pc, #160]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c06:	681b      	ldr	r3, [r3, #0]
 8000c08:	2b00      	cmp	r3, #0
 8000c0a:	d142      	bne.n	8000c92 <demo_thread_entry+0xa2>
		return;

	/* Register the HUB class.  */
	status = ux_host_stack_class_register(_ux_system_host_class_hub_name, _ux_host_class_hub_entry);
 8000c0c:	4927      	ldr	r1, [pc, #156]	; (8000cac <demo_thread_entry+0xbc>)
 8000c0e:	4828      	ldr	r0, [pc, #160]	; (8000cb0 <demo_thread_entry+0xc0>)
 8000c10:	f000 fe9c 	bl	800194c <_ux_host_stack_class_register>
 8000c14:	4602      	mov	r2, r0
 8000c16:	4b24      	ldr	r3, [pc, #144]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c18:	601a      	str	r2, [r3, #0]
	if (status != UX_SUCCESS)
 8000c1a:	4b23      	ldr	r3, [pc, #140]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c1c:	681b      	ldr	r3, [r3, #0]
 8000c1e:	2b00      	cmp	r3, #0
 8000c20:	d139      	bne.n	8000c96 <demo_thread_entry+0xa6>
		return;

	/* Register storage class.  */
	status = ux_host_stack_class_register(_ux_system_host_class_storage_name,
 8000c22:	4924      	ldr	r1, [pc, #144]	; (8000cb4 <demo_thread_entry+0xc4>)
 8000c24:	4824      	ldr	r0, [pc, #144]	; (8000cb8 <demo_thread_entry+0xc8>)
 8000c26:	f000 fe91 	bl	800194c <_ux_host_stack_class_register>
 8000c2a:	4602      	mov	r2, r0
 8000c2c:	4b1e      	ldr	r3, [pc, #120]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c2e:	601a      	str	r2, [r3, #0]
			_ux_host_class_storage_entry);
	if (status != UX_SUCCESS)
 8000c30:	4b1d      	ldr	r3, [pc, #116]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c32:	681b      	ldr	r3, [r3, #0]
 8000c34:	2b00      	cmp	r3, #0
 8000c36:	d130      	bne.n	8000c9a <demo_thread_entry+0xaa>
		return;

	/* Register all the USB host controllers available in this system.  */
	status = ux_host_stack_hcd_register(_ux_system_host_hcd_stm32_name,
 8000c38:	2300      	movs	r3, #0
 8000c3a:	4a20      	ldr	r2, [pc, #128]	; (8000cbc <demo_thread_entry+0xcc>)
 8000c3c:	4920      	ldr	r1, [pc, #128]	; (8000cc0 <demo_thread_entry+0xd0>)
 8000c3e:	4821      	ldr	r0, [pc, #132]	; (8000cc4 <demo_thread_entry+0xd4>)
 8000c40:	f000 fec8 	bl	80019d4 <_ux_host_stack_hcd_register>
 8000c44:	4602      	mov	r2, r0
 8000c46:	4b18      	ldr	r3, [pc, #96]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c48:	601a      	str	r2, [r3, #0]
			_ux_hcd_stm32_initialize_hscore, 0x40040000, 0x0);
	if (status != UX_SUCCESS)
 8000c4a:	4b17      	ldr	r3, [pc, #92]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c4c:	681b      	ldr	r3, [r3, #0]
 8000c4e:	2b00      	cmp	r3, #0
 8000c50:	d125      	bne.n	8000c9e <demo_thread_entry+0xae>
		return;

	for (;;)
	{
		/* Find the storage class. */
		status = demo_class_storage_get();
 8000c52:	f000 f8b7 	bl	8000dc4 <demo_class_storage_get>
 8000c56:	4602      	mov	r2, r0
 8000c58:	4b13      	ldr	r3, [pc, #76]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c5a:	601a      	str	r2, [r3, #0]

		if (status != UX_SUCCESS)
 8000c5c:	4b12      	ldr	r3, [pc, #72]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c5e:	681b      	ldr	r3, [r3, #0]
 8000c60:	2b00      	cmp	r3, #0
 8000c62:	d112      	bne.n	8000c8a <demo_thread_entry+0x9a>
			continue;

		/* Find first file on media.  */
		status = fx_directory_first_entry_find(media, file_name);
 8000c64:	4b18      	ldr	r3, [pc, #96]	; (8000cc8 <demo_thread_entry+0xd8>)
 8000c66:	681b      	ldr	r3, [r3, #0]
 8000c68:	4918      	ldr	r1, [pc, #96]	; (8000ccc <demo_thread_entry+0xdc>)
 8000c6a:	4618      	mov	r0, r3
 8000c6c:	f005 f988 	bl	8005f80 <_fxe_directory_first_entry_find>
 8000c70:	4602      	mov	r2, r0
 8000c72:	4b0d      	ldr	r3, [pc, #52]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c74:	601a      	str	r2, [r3, #0]

		if (status != UX_SUCCESS)
 8000c76:	4b0c      	ldr	r3, [pc, #48]	; (8000ca8 <demo_thread_entry+0xb8>)
 8000c78:	681b      	ldr	r3, [r3, #0]
 8000c7a:	2b00      	cmp	r3, #0
 8000c7c:	d107      	bne.n	8000c8e <demo_thread_entry+0x9e>
			continue;

		demo_read_file();
 8000c7e:	f000 f827 	bl	8000cd0 <demo_read_file>

		tx_thread_sleep(10);
 8000c82:	200a      	movs	r0, #10
 8000c84:	f00b fd54 	bl	800c730 <_tx_thread_sleep>
 8000c88:	e7e3      	b.n	8000c52 <demo_thread_entry+0x62>
			continue;
 8000c8a:	bf00      	nop
 8000c8c:	e7e1      	b.n	8000c52 <demo_thread_entry+0x62>
			continue;
 8000c8e:	bf00      	nop
		status = demo_class_storage_get();
 8000c90:	e7df      	b.n	8000c52 <demo_thread_entry+0x62>
		return;
 8000c92:	bf00      	nop
 8000c94:	e004      	b.n	8000ca0 <demo_thread_entry+0xb0>
		return;
 8000c96:	bf00      	nop
 8000c98:	e002      	b.n	8000ca0 <demo_thread_entry+0xb0>
		return;
 8000c9a:	bf00      	nop
 8000c9c:	e000      	b.n	8000ca0 <demo_thread_entry+0xb0>
		return;
 8000c9e:	bf00      	nop
	}
}
 8000ca0:	3708      	adds	r7, #8
 8000ca2:	46bd      	mov	sp, r7
 8000ca4:	bd80      	pop	{r7, pc}
 8000ca6:	bf00      	nop
 8000ca8:	20000db4 	.word	0x20000db4
 8000cac:	08001031 	.word	0x08001031
 8000cb0:	20000000 	.word	0x20000000
 8000cb4:	08001075 	.word	0x08001075
 8000cb8:	20000014 	.word	0x20000014
 8000cbc:	40040000 	.word	0x40040000
 8000cc0:	08001311 	.word	0x08001311
 8000cc4:	200000ac 	.word	0x200000ac
 8000cc8:	200009a8 	.word	0x200009a8
 8000ccc:	20000784 	.word	0x20000784

08000cd0 <demo_read_file>:

void demo_read_file()
{
 8000cd0:	b580      	push	{r7, lr}
 8000cd2:	b0fe      	sub	sp, #504	; 0x1f8
 8000cd4:	af02      	add	r7, sp, #8
	ULONG files_count = 0;
 8000cd6:	2300      	movs	r3, #0
 8000cd8:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec
	FX_FILE my_file;
	ULONG requested_length;
	UINT file_attribute;
	ULONG error_count = 0;
 8000cdc:	2300      	movs	r3, #0
 8000cde:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8

	/* We come here if there is at least a file in the directory.   */
	do
	{
		/* Increment file count.  */
		files_count++;
 8000ce2:	f8d7 31ec 	ldr.w	r3, [r7, #492]	; 0x1ec
 8000ce6:	3301      	adds	r3, #1
 8000ce8:	f8c7 31ec 	str.w	r3, [r7, #492]	; 0x1ec

		/* Reset file attributes.  */
		file_attribute = 0;
 8000cec:	463b      	mov	r3, r7
 8000cee:	2200      	movs	r2, #0
 8000cf0:	601a      	str	r2, [r3, #0]

		/* Try to read the file attributes.  */
		status = fx_file_attributes_read(media, file_name, &file_attribute);
 8000cf2:	4b30      	ldr	r3, [pc, #192]	; (8000db4 <demo_read_file+0xe4>)
 8000cf4:	681b      	ldr	r3, [r3, #0]
 8000cf6:	463a      	mov	r2, r7
 8000cf8:	492f      	ldr	r1, [pc, #188]	; (8000db8 <demo_read_file+0xe8>)
 8000cfa:	4618      	mov	r0, r3
 8000cfc:	f005 f974 	bl	8005fe8 <_fxe_file_attributes_read>
 8000d00:	4602      	mov	r2, r0
 8000d02:	4b2e      	ldr	r3, [pc, #184]	; (8000dbc <demo_read_file+0xec>)
 8000d04:	601a      	str	r2, [r3, #0]

		/* If this is a directory, pass.  */
		if (!(file_attribute & 0x18) && (status == UX_SUCCESS))
 8000d06:	463b      	mov	r3, r7
 8000d08:	681b      	ldr	r3, [r3, #0]
 8000d0a:	f003 0318 	and.w	r3, r3, #24
 8000d0e:	2b00      	cmp	r3, #0
 8000d10:	d13b      	bne.n	8000d8a <demo_read_file+0xba>
 8000d12:	4b2a      	ldr	r3, [pc, #168]	; (8000dbc <demo_read_file+0xec>)
 8000d14:	681b      	ldr	r3, [r3, #0]
 8000d16:	2b00      	cmp	r3, #0
 8000d18:	d137      	bne.n	8000d8a <demo_read_file+0xba>
		{
			/* Try to open the file.  */
			status = fx_file_open(media, &my_file, file_name, FX_OPEN_FOR_READ);
 8000d1a:	4b26      	ldr	r3, [pc, #152]	; (8000db4 <demo_read_file+0xe4>)
 8000d1c:	6818      	ldr	r0, [r3, #0]
 8000d1e:	f107 0108 	add.w	r1, r7, #8
 8000d22:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8000d26:	9300      	str	r3, [sp, #0]
 8000d28:	2300      	movs	r3, #0
 8000d2a:	4a23      	ldr	r2, [pc, #140]	; (8000db8 <demo_read_file+0xe8>)
 8000d2c:	f005 f996 	bl	800605c <_fxe_file_open>
 8000d30:	4602      	mov	r2, r0
 8000d32:	4b22      	ldr	r3, [pc, #136]	; (8000dbc <demo_read_file+0xec>)
 8000d34:	601a      	str	r2, [r3, #0]
			if (status != UX_SUCCESS)
 8000d36:	4b21      	ldr	r3, [pc, #132]	; (8000dbc <demo_read_file+0xec>)
 8000d38:	681b      	ldr	r3, [r3, #0]
 8000d3a:	2b00      	cmp	r3, #0
 8000d3c:	d133      	bne.n	8000da6 <demo_read_file+0xd6>
				break;

			/* Read the entire file.  */
			while (status == UX_SUCCESS)
 8000d3e:	e019      	b.n	8000d74 <demo_read_file+0xa4>
			{
				/* Read the file in blocks */
				status = fx_file_read(&my_file, local_buffer, 1024, &requested_length);
 8000d40:	1d3b      	adds	r3, r7, #4
 8000d42:	f107 0008 	add.w	r0, r7, #8
 8000d46:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8000d4a:	491d      	ldr	r1, [pc, #116]	; (8000dc0 <demo_read_file+0xf0>)
 8000d4c:	f005 f9da 	bl	8006104 <_fxe_file_read>
 8000d50:	4602      	mov	r2, r0
 8000d52:	4b1a      	ldr	r3, [pc, #104]	; (8000dbc <demo_read_file+0xec>)
 8000d54:	601a      	str	r2, [r3, #0]

				/* Check if status OK.  */
				if (status != UX_SUCCESS)
 8000d56:	4b19      	ldr	r3, [pc, #100]	; (8000dbc <demo_read_file+0xec>)
 8000d58:	681b      	ldr	r3, [r3, #0]
 8000d5a:	2b00      	cmp	r3, #0
 8000d5c:	d005      	beq.n	8000d6a <demo_read_file+0x9a>
				{
					error_count++;
 8000d5e:	f8d7 31e8 	ldr.w	r3, [r7, #488]	; 0x1e8
 8000d62:	3301      	adds	r3, #1
 8000d64:	f8c7 31e8 	str.w	r3, [r7, #488]	; 0x1e8
					break;
 8000d68:	e00a      	b.n	8000d80 <demo_read_file+0xb0>
				}

				/* Check if end of file.  */
				if (requested_length != 1024)
 8000d6a:	1d3b      	adds	r3, r7, #4
 8000d6c:	681b      	ldr	r3, [r3, #0]
 8000d6e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000d72:	d104      	bne.n	8000d7e <demo_read_file+0xae>
			while (status == UX_SUCCESS)
 8000d74:	4b11      	ldr	r3, [pc, #68]	; (8000dbc <demo_read_file+0xec>)
 8000d76:	681b      	ldr	r3, [r3, #0]
 8000d78:	2b00      	cmp	r3, #0
 8000d7a:	d0e1      	beq.n	8000d40 <demo_read_file+0x70>
 8000d7c:	e000      	b.n	8000d80 <demo_read_file+0xb0>
					break;
 8000d7e:	bf00      	nop
			}

			/* Finished reading file either at the end or because of error. */
			fx_file_close(&my_file);
 8000d80:	f107 0308 	add.w	r3, r7, #8
 8000d84:	4618      	mov	r0, r3
 8000d86:	f005 f94f 	bl	8006028 <_fxe_file_close>
		}

		/* Ask FileX to find another file.  */
		status = fx_directory_next_entry_find(media, file_name);
 8000d8a:	4b0a      	ldr	r3, [pc, #40]	; (8000db4 <demo_read_file+0xe4>)
 8000d8c:	681b      	ldr	r3, [r3, #0]
 8000d8e:	490a      	ldr	r1, [pc, #40]	; (8000db8 <demo_read_file+0xe8>)
 8000d90:	4618      	mov	r0, r3
 8000d92:	f005 f90f 	bl	8005fb4 <_fxe_directory_next_entry_find>
 8000d96:	4602      	mov	r2, r0
 8000d98:	4b08      	ldr	r3, [pc, #32]	; (8000dbc <demo_read_file+0xec>)
 8000d9a:	601a      	str	r2, [r3, #0]

	} while (status == UX_SUCCESS);
 8000d9c:	4b07      	ldr	r3, [pc, #28]	; (8000dbc <demo_read_file+0xec>)
 8000d9e:	681b      	ldr	r3, [r3, #0]
 8000da0:	2b00      	cmp	r3, #0
 8000da2:	d09e      	beq.n	8000ce2 <demo_read_file+0x12>

	/* We get here we have exhausted all the files in the root directory. */
	return;
 8000da4:	e000      	b.n	8000da8 <demo_read_file+0xd8>
				break;
 8000da6:	bf00      	nop
	return;
 8000da8:	bf00      	nop
}
 8000daa:	f507 77f8 	add.w	r7, r7, #496	; 0x1f0
 8000dae:	46bd      	mov	sp, r7
 8000db0:	bd80      	pop	{r7, pc}
 8000db2:	bf00      	nop
 8000db4:	200009a8 	.word	0x200009a8
 8000db8:	20000784 	.word	0x20000784
 8000dbc:	20000db4 	.word	0x20000db4
 8000dc0:	20000290 	.word	0x20000290

08000dc4 <demo_class_storage_get>:

UINT demo_class_storage_get(void)
{
 8000dc4:	b580      	push	{r7, lr}
 8000dc6:	b082      	sub	sp, #8
 8000dc8:	af00      	add	r7, sp, #0
	UX_HOST_CLASS* class;

	/* Find the main storage container */
	status = ux_host_stack_class_get(_ux_system_host_class_storage_name, &class);
 8000dca:	1d3b      	adds	r3, r7, #4
 8000dcc:	4619      	mov	r1, r3
 8000dce:	481f      	ldr	r0, [pc, #124]	; (8000e4c <demo_class_storage_get+0x88>)
 8000dd0:	f000 fd7a 	bl	80018c8 <_ux_host_stack_class_get>
 8000dd4:	4602      	mov	r2, r0
 8000dd6:	4b1e      	ldr	r3, [pc, #120]	; (8000e50 <demo_class_storage_get+0x8c>)
 8000dd8:	601a      	str	r2, [r3, #0]
	if (status != UX_SUCCESS)
 8000dda:	4b1d      	ldr	r3, [pc, #116]	; (8000e50 <demo_class_storage_get+0x8c>)
 8000ddc:	681b      	ldr	r3, [r3, #0]
 8000dde:	2b00      	cmp	r3, #0
 8000de0:	d002      	beq.n	8000de8 <demo_class_storage_get+0x24>
		return (status);
 8000de2:	4b1b      	ldr	r3, [pc, #108]	; (8000e50 <demo_class_storage_get+0x8c>)
 8000de4:	681b      	ldr	r3, [r3, #0]
 8000de6:	e02c      	b.n	8000e42 <demo_class_storage_get+0x7e>
	do
	{
		/* We get the first instance of the storage device */
		do
		{
			status = ux_host_stack_class_instance_get(class, 0, (void**)&storage);
 8000de8:	687b      	ldr	r3, [r7, #4]
 8000dea:	4a1a      	ldr	r2, [pc, #104]	; (8000e54 <demo_class_storage_get+0x90>)
 8000dec:	2100      	movs	r1, #0
 8000dee:	4618      	mov	r0, r3
 8000df0:	f000 fda0 	bl	8001934 <_ux_host_stack_class_instance_get>
 8000df4:	4602      	mov	r2, r0
 8000df6:	4b16      	ldr	r3, [pc, #88]	; (8000e50 <demo_class_storage_get+0x8c>)
 8000df8:	601a      	str	r2, [r3, #0]
			tx_thread_sleep(10);
 8000dfa:	200a      	movs	r0, #10
 8000dfc:	f00b fc98 	bl	800c730 <_tx_thread_sleep>
		} while (status != UX_SUCCESS);
 8000e00:	4b13      	ldr	r3, [pc, #76]	; (8000e50 <demo_class_storage_get+0x8c>)
 8000e02:	681b      	ldr	r3, [r3, #0]
 8000e04:	2b00      	cmp	r3, #0
 8000e06:	d1ef      	bne.n	8000de8 <demo_class_storage_get+0x24>

		tx_thread_sleep(10);
 8000e08:	200a      	movs	r0, #10
 8000e0a:	f00b fc91 	bl	800c730 <_tx_thread_sleep>

	} while (storage->ux_host_class_storage_state != UX_HOST_CLASS_INSTANCE_LIVE);
 8000e0e:	4b11      	ldr	r3, [pc, #68]	; (8000e54 <demo_class_storage_get+0x90>)
 8000e10:	681b      	ldr	r3, [r3, #0]
 8000e12:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 8000e16:	2b01      	cmp	r3, #1
 8000e18:	d1e6      	bne.n	8000de8 <demo_class_storage_get+0x24>

	/* We try to get the first media attached to the class container.  */
	while (class->ux_host_class_media == UX_NULL)
 8000e1a:	e002      	b.n	8000e22 <demo_class_storage_get+0x5e>
	{
		tx_thread_sleep(10);
 8000e1c:	200a      	movs	r0, #10
 8000e1e:	f00b fc87 	bl	800c730 <_tx_thread_sleep>
	while (class->ux_host_class_media == UX_NULL)
 8000e22:	687b      	ldr	r3, [r7, #4]
 8000e24:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 8000e28:	2b00      	cmp	r3, #0
 8000e2a:	d0f7      	beq.n	8000e1c <demo_class_storage_get+0x58>
	}

	/* Setup media pointer.  */
	storage_media = (UX_HOST_CLASS_STORAGE_MEDIA*)class->ux_host_class_media;
 8000e2c:	687b      	ldr	r3, [r7, #4]
 8000e2e:	f8d3 3124 	ldr.w	r3, [r3, #292]	; 0x124
 8000e32:	4a09      	ldr	r2, [pc, #36]	; (8000e58 <demo_class_storage_get+0x94>)
 8000e34:	6013      	str	r3, [r2, #0]
	media = &storage_media->ux_host_class_storage_media;
 8000e36:	4b08      	ldr	r3, [pc, #32]	; (8000e58 <demo_class_storage_get+0x94>)
 8000e38:	681b      	ldr	r3, [r3, #0]
 8000e3a:	461a      	mov	r2, r3
 8000e3c:	4b07      	ldr	r3, [pc, #28]	; (8000e5c <demo_class_storage_get+0x98>)
 8000e3e:	601a      	str	r2, [r3, #0]

	return (UX_SUCCESS);
 8000e40:	2300      	movs	r3, #0
}
 8000e42:	4618      	mov	r0, r3
 8000e44:	3708      	adds	r7, #8
 8000e46:	46bd      	mov	sp, r7
 8000e48:	bd80      	pop	{r7, pc}
 8000e4a:	bf00      	nop
 8000e4c:	20000014 	.word	0x20000014
 8000e50:	20000db4 	.word	0x20000db4
 8000e54:	20000690 	.word	0x20000690
 8000e58:	20000db0 	.word	0x20000db0
 8000e5c:	200009a8 	.word	0x200009a8

08000e60 <USB_OTG_BSP_HS_Init>:

/** */
void USB_OTG_BSP_HS_Init(void)
{
 8000e60:	b580      	push	{r7, lr}
 8000e62:	b08c      	sub	sp, #48	; 0x30
 8000e64:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStruct;

	/* Configure USB FS GPIOs */
	__HAL_RCC_GPIOA_CLK_ENABLE();
 8000e66:	4b56      	ldr	r3, [pc, #344]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000e68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000e6a:	4a55      	ldr	r2, [pc, #340]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000e6c:	f043 0301 	orr.w	r3, r3, #1
 8000e70:	6313      	str	r3, [r2, #48]	; 0x30
 8000e72:	4b53      	ldr	r3, [pc, #332]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000e74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000e76:	f003 0301 	and.w	r3, r3, #1
 8000e7a:	61bb      	str	r3, [r7, #24]
 8000e7c:	69bb      	ldr	r3, [r7, #24]
	__HAL_RCC_GPIOB_CLK_ENABLE();
 8000e7e:	4b50      	ldr	r3, [pc, #320]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000e80:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000e82:	4a4f      	ldr	r2, [pc, #316]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000e84:	f043 0302 	orr.w	r3, r3, #2
 8000e88:	6313      	str	r3, [r2, #48]	; 0x30
 8000e8a:	4b4d      	ldr	r3, [pc, #308]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000e8c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000e8e:	f003 0302 	and.w	r3, r3, #2
 8000e92:	617b      	str	r3, [r7, #20]
 8000e94:	697b      	ldr	r3, [r7, #20]
	__HAL_RCC_GPIOC_CLK_ENABLE();
 8000e96:	4b4a      	ldr	r3, [pc, #296]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000e98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000e9a:	4a49      	ldr	r2, [pc, #292]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000e9c:	f043 0304 	orr.w	r3, r3, #4
 8000ea0:	6313      	str	r3, [r2, #48]	; 0x30
 8000ea2:	4b47      	ldr	r3, [pc, #284]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000ea4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000ea6:	f003 0304 	and.w	r3, r3, #4
 8000eaa:	613b      	str	r3, [r7, #16]
 8000eac:	693b      	ldr	r3, [r7, #16]
	__HAL_RCC_GPIOH_CLK_ENABLE();
 8000eae:	4b44      	ldr	r3, [pc, #272]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000eb0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000eb2:	4a43      	ldr	r2, [pc, #268]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000eb4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000eb8:	6313      	str	r3, [r2, #48]	; 0x30
 8000eba:	4b41      	ldr	r3, [pc, #260]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000ebc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000ebe:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000ec2:	60fb      	str	r3, [r7, #12]
 8000ec4:	68fb      	ldr	r3, [r7, #12]

	/* CLK */
	GPIO_InitStruct.Pin = GPIO_PIN_5;
 8000ec6:	2320      	movs	r3, #32
 8000ec8:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000eca:	2302      	movs	r3, #2
 8000ecc:	623b      	str	r3, [r7, #32]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ece:	2300      	movs	r3, #0
 8000ed0:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8000ed2:	2303      	movs	r3, #3
 8000ed4:	62bb      	str	r3, [r7, #40]	; 0x28
	GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000ed6:	230a      	movs	r3, #10
 8000ed8:	62fb      	str	r3, [r7, #44]	; 0x2c
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000eda:	f107 031c 	add.w	r3, r7, #28
 8000ede:	4619      	mov	r1, r3
 8000ee0:	4838      	ldr	r0, [pc, #224]	; (8000fc4 <USB_OTG_BSP_HS_Init+0x164>)
 8000ee2:	f009 ff67 	bl	800adb4 <HAL_GPIO_Init>

	/* D0 */
	GPIO_InitStruct.Pin = GPIO_PIN_3;
 8000ee6:	2308      	movs	r3, #8
 8000ee8:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000eea:	2302      	movs	r3, #2
 8000eec:	623b      	str	r3, [r7, #32]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000eee:	2300      	movs	r3, #0
 8000ef0:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8000ef2:	2303      	movs	r3, #3
 8000ef4:	62bb      	str	r3, [r7, #40]	; 0x28
	GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000ef6:	230a      	movs	r3, #10
 8000ef8:	62fb      	str	r3, [r7, #44]	; 0x2c
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000efa:	f107 031c 	add.w	r3, r7, #28
 8000efe:	4619      	mov	r1, r3
 8000f00:	4830      	ldr	r0, [pc, #192]	; (8000fc4 <USB_OTG_BSP_HS_Init+0x164>)
 8000f02:	f009 ff57 	bl	800adb4 <HAL_GPIO_Init>

	/* D1 D2 D3 D4 D5 D6 D7 */
	GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_5 | GPIO_PIN_10 | GPIO_PIN_11
 8000f06:	f643 4323 	movw	r3, #15395	; 0x3c23
 8000f0a:	61fb      	str	r3, [r7, #28]
			| GPIO_PIN_12 | GPIO_PIN_13;
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000f0c:	2302      	movs	r3, #2
 8000f0e:	623b      	str	r3, [r7, #32]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f10:	2300      	movs	r3, #0
 8000f12:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000f14:	230a      	movs	r3, #10
 8000f16:	62fb      	str	r3, [r7, #44]	; 0x2c
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000f18:	f107 031c 	add.w	r3, r7, #28
 8000f1c:	4619      	mov	r1, r3
 8000f1e:	482a      	ldr	r0, [pc, #168]	; (8000fc8 <USB_OTG_BSP_HS_Init+0x168>)
 8000f20:	f009 ff48 	bl	800adb4 <HAL_GPIO_Init>

	/* STP */
	GPIO_InitStruct.Pin = GPIO_PIN_0;
 8000f24:	2301      	movs	r3, #1
 8000f26:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000f28:	2302      	movs	r3, #2
 8000f2a:	623b      	str	r3, [r7, #32]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f2c:	2300      	movs	r3, #0
 8000f2e:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000f30:	230a      	movs	r3, #10
 8000f32:	62fb      	str	r3, [r7, #44]	; 0x2c
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000f34:	f107 031c 	add.w	r3, r7, #28
 8000f38:	4619      	mov	r1, r3
 8000f3a:	4824      	ldr	r0, [pc, #144]	; (8000fcc <USB_OTG_BSP_HS_Init+0x16c>)
 8000f3c:	f009 ff3a 	bl	800adb4 <HAL_GPIO_Init>

	/* NXT */
	GPIO_InitStruct.Pin = GPIO_PIN_4;
 8000f40:	2310      	movs	r3, #16
 8000f42:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000f44:	2302      	movs	r3, #2
 8000f46:	623b      	str	r3, [r7, #32]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f48:	2300      	movs	r3, #0
 8000f4a:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000f4c:	230a      	movs	r3, #10
 8000f4e:	62fb      	str	r3, [r7, #44]	; 0x2c
	HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8000f50:	f107 031c 	add.w	r3, r7, #28
 8000f54:	4619      	mov	r1, r3
 8000f56:	481e      	ldr	r0, [pc, #120]	; (8000fd0 <USB_OTG_BSP_HS_Init+0x170>)
 8000f58:	f009 ff2c 	bl	800adb4 <HAL_GPIO_Init>

	/* DIR */
	GPIO_InitStruct.Pin = GPIO_PIN_2;
 8000f5c:	2304      	movs	r3, #4
 8000f5e:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000f60:	2302      	movs	r3, #2
 8000f62:	623b      	str	r3, [r7, #32]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f64:	2300      	movs	r3, #0
 8000f66:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 8000f68:	230a      	movs	r3, #10
 8000f6a:	62fb      	str	r3, [r7, #44]	; 0x2c
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000f6c:	f107 031c 	add.w	r3, r7, #28
 8000f70:	4619      	mov	r1, r3
 8000f72:	4816      	ldr	r0, [pc, #88]	; (8000fcc <USB_OTG_BSP_HS_Init+0x16c>)
 8000f74:	f009 ff1e 	bl	800adb4 <HAL_GPIO_Init>

	/* Enable USB HS Clocks */
	__HAL_RCC_USB_OTG_HS_CLK_ENABLE();
 8000f78:	4b11      	ldr	r3, [pc, #68]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000f7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f7c:	4a10      	ldr	r2, [pc, #64]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000f7e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8000f82:	6313      	str	r3, [r2, #48]	; 0x30
 8000f84:	4b0e      	ldr	r3, [pc, #56]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000f86:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f88:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8000f8c:	60bb      	str	r3, [r7, #8]
 8000f8e:	68bb      	ldr	r3, [r7, #8]
	__HAL_RCC_USB_OTG_HS_ULPI_CLK_ENABLE();
 8000f90:	4b0b      	ldr	r3, [pc, #44]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000f92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f94:	4a0a      	ldr	r2, [pc, #40]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000f96:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000f9a:	6313      	str	r3, [r2, #48]	; 0x30
 8000f9c:	4b08      	ldr	r3, [pc, #32]	; (8000fc0 <USB_OTG_BSP_HS_Init+0x160>)
 8000f9e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000fa0:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8000fa4:	607b      	str	r3, [r7, #4]
 8000fa6:	687b      	ldr	r3, [r7, #4]

	/* Set USBHS Interrupt to the lowest priority */
	HAL_NVIC_SetPriority(OTG_HS_IRQn, 3, 0);
 8000fa8:	2200      	movs	r2, #0
 8000faa:	2103      	movs	r1, #3
 8000fac:	204d      	movs	r0, #77	; 0x4d
 8000fae:	f009 fd95 	bl	800aadc <HAL_NVIC_SetPriority>

	/* Enable USBHS Interrupt */
	HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
 8000fb2:	204d      	movs	r0, #77	; 0x4d
 8000fb4:	f009 fdc8 	bl	800ab48 <HAL_NVIC_EnableIRQ>
}
 8000fb8:	bf00      	nop
 8000fba:	3730      	adds	r7, #48	; 0x30
 8000fbc:	46bd      	mov	sp, r7
 8000fbe:	bd80      	pop	{r7, pc}
 8000fc0:	40023800 	.word	0x40023800
 8000fc4:	40020000 	.word	0x40020000
 8000fc8:	40020400 	.word	0x40020400
 8000fcc:	40020800 	.word	0x40020800
 8000fd0:	40021c00 	.word	0x40021c00

08000fd4 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8000fd4:	480d      	ldr	r0, [pc, #52]	; (800100c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8000fd6:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8000fd8:	480d      	ldr	r0, [pc, #52]	; (8001010 <LoopForever+0x6>)
  ldr r1, =_edata
 8000fda:	490e      	ldr	r1, [pc, #56]	; (8001014 <LoopForever+0xa>)
  ldr r2, =_sidata
 8000fdc:	4a0e      	ldr	r2, [pc, #56]	; (8001018 <LoopForever+0xe>)
  movs r3, #0
 8000fde:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000fe0:	e002      	b.n	8000fe8 <LoopCopyDataInit>

08000fe2 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000fe2:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000fe4:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000fe6:	3304      	adds	r3, #4

08000fe8 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000fe8:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8000fea:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8000fec:	d3f9      	bcc.n	8000fe2 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8000fee:	4a0b      	ldr	r2, [pc, #44]	; (800101c <LoopForever+0x12>)
  ldr r4, =_ebss
 8000ff0:	4c0b      	ldr	r4, [pc, #44]	; (8001020 <LoopForever+0x16>)
  movs r3, #0
 8000ff2:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000ff4:	e001      	b.n	8000ffa <LoopFillZerobss>

08000ff6 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000ff6:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000ff8:	3204      	adds	r2, #4

08000ffa <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8000ffa:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8000ffc:	d3fb      	bcc.n	8000ff6 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8000ffe:	f00a feed 	bl	800bddc <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8001002:	f00c fe3d 	bl	800dc80 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8001006:	f7ff fdb1 	bl	8000b6c <main>

0800100a <LoopForever>:

LoopForever:
    b LoopForever
 800100a:	e7fe      	b.n	800100a <LoopForever>
  ldr   r0, =_estack
 800100c:	20050000 	.word	0x20050000
  ldr r0, =_sdata
 8001010:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001014:	20000168 	.word	0x20000168
  ldr r2, =_sidata
 8001018:	0800dee0 	.word	0x0800dee0
  ldr r2, =_sbss
 800101c:	20000168 	.word	0x20000168
  ldr r4, =_ebss
 8001020:	200014f4 	.word	0x200014f4

08001024 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8001024:	e7fe      	b.n	8001024 <ADC_IRQHandler>

08001026 <HardFault_Handler>:
  .size Default_Handler, .-Default_Handler

HardFault_Handler:
  b HardFault_Handler
 8001026:	e7fe      	b.n	8001026 <HardFault_Handler>

08001028 <MemManage_Handler>:

MemManage_Handler:
  b MemManage_Handler
 8001028:	e7fe      	b.n	8001028 <MemManage_Handler>

0800102a <BusFault_Handler>:

BusFault_Handler:
  b BusFault_Handler
 800102a:	e7fe      	b.n	800102a <BusFault_Handler>

0800102c <UsageFault_Handler>:

UsageFault_Handler:
  b UsageFault_Handler
 800102c:	e7fe      	b.n	800102c <UsageFault_Handler>
	...

08001030 <_ux_host_class_hub_entry>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_entry(UX_HOST_CLASS_COMMAND *command)
{
 8001030:	b508      	push	{r3, lr}
UINT    status;


    /* The command request will tell us we need to do here, either a enumeration
       query, an activation or a deactivation.  */
    switch (command -> ux_host_class_command_request)
 8001032:	6803      	ldr	r3, [r0, #0]
 8001034:	2b02      	cmp	r3, #2
 8001036:	d017      	beq.n	8001068 <_ux_host_class_hub_entry+0x38>
 8001038:	2b03      	cmp	r3, #3
 800103a:	d011      	beq.n	8001060 <_ux_host_class_hub_entry+0x30>
 800103c:	2b01      	cmp	r3, #1
 800103e:	d006      	beq.n	800104e <_ux_host_class_hub_entry+0x1e>
        return(status);

    default:

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_FUNCTION_NOT_SUPPORTED);
 8001040:	2254      	movs	r2, #84	; 0x54
 8001042:	2107      	movs	r1, #7
 8001044:	2002      	movs	r0, #2
 8001046:	f000 fddb 	bl	8001c00 <_ux_system_error_handler>

        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

        /* Return error status.  */
        return(UX_FUNCTION_NOT_SUPPORTED);
 800104a:	2054      	movs	r0, #84	; 0x54
    }   
}
 800104c:	bd08      	pop	{r3, pc}
        if ((command -> ux_host_class_command_usage == UX_HOST_CLASS_COMMAND_USAGE_CSP) &&
 800104e:	68c3      	ldr	r3, [r0, #12]
 8001050:	2b02      	cmp	r3, #2
 8001052:	d10d      	bne.n	8001070 <_ux_host_class_hub_entry+0x40>
 8001054:	6983      	ldr	r3, [r0, #24]
 8001056:	2b09      	cmp	r3, #9
            return(UX_SUCCESS);                        
 8001058:	bf14      	ite	ne
 800105a:	2057      	movne	r0, #87	; 0x57
 800105c:	2000      	moveq	r0, #0
}
 800105e:	bd08      	pop	{r3, pc}
 8001060:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        status =  _ux_host_class_hub_deactivate(command);
 8001064:	f001 b96a 	b.w	800233c <_ux_host_class_hub_deactivate>
}
 8001068:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        status =  _ux_host_class_hub_activate(command);
 800106c:	f001 b876 	b.w	800215c <_ux_host_class_hub_activate>
            return(UX_NO_CLASS_MATCH);                        
 8001070:	2057      	movs	r0, #87	; 0x57
}
 8001072:	bd08      	pop	{r3, pc}

08001074 <_ux_host_class_storage_entry>:

UINT        status;

    /* The command request will tell us we need to do here, either a enumeration
       query, an activation or a deactivation.  */
    switch (command -> ux_host_class_command_request)
 8001074:	6803      	ldr	r3, [r0, #0]
 8001076:	2b02      	cmp	r3, #2
{
 8001078:	b570      	push	{r4, r5, r6, lr}
 800107a:	4604      	mov	r4, r0
 800107c:	b086      	sub	sp, #24
    switch (command -> ux_host_class_command_request)
 800107e:	d01a      	beq.n	80010b6 <_ux_host_class_storage_entry+0x42>
 8001080:	2b03      	cmp	r3, #3
 8001082:	d013      	beq.n	80010ac <_ux_host_class_storage_entry+0x38>
 8001084:	2b01      	cmp	r3, #1
 8001086:	d007      	beq.n	8001098 <_ux_host_class_storage_entry+0x24>
        return(status);

    default: 

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_FUNCTION_NOT_SUPPORTED);
 8001088:	2002      	movs	r0, #2
 800108a:	2254      	movs	r2, #84	; 0x54
 800108c:	2107      	movs	r1, #7
 800108e:	f000 fdb7 	bl	8001c00 <_ux_system_error_handler>

        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_FUNCTION_NOT_SUPPORTED, 0, 0, 0, UX_TRACE_ERRORS, 0, 0)

        /* Return an error.  */
        return(UX_FUNCTION_NOT_SUPPORTED);
 8001092:	2054      	movs	r0, #84	; 0x54
    }   
}
 8001094:	b006      	add	sp, #24
 8001096:	bd70      	pop	{r4, r5, r6, pc}
        if ((command -> ux_host_class_command_usage == UX_HOST_CLASS_COMMAND_USAGE_CSP) &&
 8001098:	68c3      	ldr	r3, [r0, #12]
 800109a:	2b02      	cmp	r3, #2
 800109c:	d119      	bne.n	80010d2 <_ux_host_class_storage_entry+0x5e>
 800109e:	6983      	ldr	r3, [r0, #24]
            return(UX_SUCCESS);                        
 80010a0:	2b08      	cmp	r3, #8
 80010a2:	bf14      	ite	ne
 80010a4:	2057      	movne	r0, #87	; 0x57
 80010a6:	2000      	moveq	r0, #0
}
 80010a8:	b006      	add	sp, #24
 80010aa:	bd70      	pop	{r4, r5, r6, pc}
 80010ac:	b006      	add	sp, #24
 80010ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        status =  _ux_host_class_storage_deactivate(command);
 80010b2:	f001 bbe1 	b.w	8002878 <_ux_host_class_storage_deactivate>
        if (command -> ux_host_class_command_class_ptr -> ux_host_class_media == UX_NULL)
 80010b6:	6b05      	ldr	r5, [r0, #48]	; 0x30
 80010b8:	f8d5 1124 	ldr.w	r1, [r5, #292]	; 0x124
 80010bc:	2900      	cmp	r1, #0
 80010be:	d036      	beq.n	800112e <_ux_host_class_storage_entry+0xba>
        if (command -> ux_host_class_command_class_ptr -> ux_host_class_thread_stack == UX_NULL)
 80010c0:	f8d5 6120 	ldr.w	r6, [r5, #288]	; 0x120
 80010c4:	b146      	cbz	r6, 80010d8 <_ux_host_class_storage_entry+0x64>
        status =  _ux_host_class_storage_activate(command);
 80010c6:	4620      	mov	r0, r4
}
 80010c8:	b006      	add	sp, #24
 80010ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        status =  _ux_host_class_storage_activate(command);
 80010ce:	f001 bb27 	b.w	8002720 <_ux_host_class_storage_activate>
            return(UX_NO_CLASS_MATCH);                        
 80010d2:	2057      	movs	r0, #87	; 0x57
}
 80010d4:	b006      	add	sp, #24
 80010d6:	bd70      	pop	{r4, r5, r6, pc}
                        _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_HOST_CLASS_STORAGE_THREAD_STACK_SIZE);
 80010d8:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80010dc:	4631      	mov	r1, r6
 80010de:	4630      	mov	r0, r6
 80010e0:	f000 fe04 	bl	8001cec <_ux_utility_memory_allocate>
            if (command -> ux_host_class_command_class_ptr -> ux_host_class_thread_stack == UX_NULL)
 80010e4:	6b23      	ldr	r3, [r4, #48]	; 0x30
            command -> ux_host_class_command_class_ptr -> ux_host_class_thread_stack =  
 80010e6:	f8c5 0120 	str.w	r0, [r5, #288]	; 0x120
            if (command -> ux_host_class_command_class_ptr -> ux_host_class_thread_stack == UX_NULL)
 80010ea:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
 80010ee:	b352      	cbz	r2, 8001146 <_ux_host_class_storage_entry+0xd2>
            status =  _ux_utility_thread_create(&command -> ux_host_class_command_class_ptr -> ux_host_class_thread,
 80010f0:	2114      	movs	r1, #20
 80010f2:	f44f 6500 	mov.w	r5, #2048	; 0x800
 80010f6:	9200      	str	r2, [sp, #0]
 80010f8:	f103 0058 	add.w	r0, r3, #88	; 0x58
 80010fc:	9501      	str	r5, [sp, #4]
 80010fe:	4a13      	ldr	r2, [pc, #76]	; (800114c <_ux_host_class_storage_entry+0xd8>)
 8001100:	e9cd 1102 	strd	r1, r1, [sp, #8]
 8001104:	e9cd 6604 	strd	r6, r6, [sp, #16]
 8001108:	4911      	ldr	r1, [pc, #68]	; (8001150 <_ux_host_class_storage_entry+0xdc>)
 800110a:	f001 f801 	bl	8002110 <_ux_utility_thread_create>
            if (status != UX_SUCCESS)
 800110e:	b920      	cbnz	r0, 800111a <_ux_host_class_storage_entry+0xa6>
            tx_thread_resume(&command -> ux_host_class_command_class_ptr -> ux_host_class_thread);
 8001110:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8001112:	3058      	adds	r0, #88	; 0x58
 8001114:	f00c f8a2 	bl	800d25c <_txe_thread_resume>
 8001118:	e7d5      	b.n	80010c6 <_ux_host_class_storage_entry+0x52>
                _ux_utility_memory_free(command -> ux_host_class_command_class_ptr -> ux_host_class_thread_stack);
 800111a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800111c:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
 8001120:	f000 fef8 	bl	8001f14 <_ux_utility_memory_free>
                command -> ux_host_class_command_class_ptr -> ux_host_class_thread_stack = UX_NULL;
 8001124:	6b23      	ldr	r3, [r4, #48]	; 0x30
                return(UX_THREAD_ERROR);
 8001126:	2016      	movs	r0, #22
                command -> ux_host_class_command_class_ptr -> ux_host_class_thread_stack = UX_NULL;
 8001128:	f8c3 6120 	str.w	r6, [r3, #288]	; 0x120
                return(UX_THREAD_ERROR);
 800112c:	e7b2      	b.n	8001094 <_ux_host_class_storage_entry+0x20>
                        _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_HOST_CLASS_STORAGE_MAX_MEDIA*sizeof(UX_HOST_CLASS_STORAGE_MEDIA));
 800112e:	f242 42d0 	movw	r2, #9424	; 0x24d0
 8001132:	4608      	mov	r0, r1
 8001134:	f000 fdda 	bl	8001cec <_ux_utility_memory_allocate>
            command -> ux_host_class_command_class_ptr -> ux_host_class_media =
 8001138:	f8c5 0124 	str.w	r0, [r5, #292]	; 0x124
            if (command -> ux_host_class_command_class_ptr -> ux_host_class_media == UX_NULL)
 800113c:	6b25      	ldr	r5, [r4, #48]	; 0x30
 800113e:	f8d5 3124 	ldr.w	r3, [r5, #292]	; 0x124
 8001142:	2b00      	cmp	r3, #0
 8001144:	d1bc      	bne.n	80010c0 <_ux_host_class_storage_entry+0x4c>
                return(UX_MEMORY_INSUFFICIENT);
 8001146:	2012      	movs	r0, #18
 8001148:	e7a4      	b.n	8001094 <_ux_host_class_storage_entry+0x20>
 800114a:	bf00      	nop
 800114c:	08001155 	.word	0x08001155
 8001150:	0800dd34 	.word	0x0800dd34

08001154 <_ux_host_class_storage_thread_entry>:
/*                                                                        */
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_class_storage_thread_entry(ULONG class_address)
{
 8001154:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001158:	4680      	mov	r8, r0
 800115a:	b083      	sub	sp, #12
    /* This thread goes on forever once started.  */
    while(1)
    {

        /* We need to wake every 2 seconds or so.  */
        _ux_utility_delay_ms(UX_HOST_CLASS_STORAGE_THREAD_SLEEP_TIME);
 800115c:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8001160:	f000 fdb8 	bl	8001cd4 <_ux_utility_delay_ms>

        /* We need to parse all the storage instances and check for a removable
           media flag.  */
        storage =  (UX_HOST_CLASS_STORAGE *) class -> ux_host_class_first_instance;
 8001164:	f8d8 404c 	ldr.w	r4, [r8, #76]	; 0x4c

        while (storage != UX_NULL)
 8001168:	b91c      	cbnz	r4, 8001172 <_ux_host_class_storage_thread_entry+0x1e>
 800116a:	e7f7      	b.n	800115c <_ux_host_class_storage_thread_entry+0x8>
                /* Other threads are now allowed to access this storage instance.  */
                status =  _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
            }

            /* Move to the next entry in the storage instances link.  */
            storage =  storage -> ux_host_class_storage_next_instance;
 800116c:	6824      	ldr	r4, [r4, #0]
        while (storage != UX_NULL)
 800116e:	2c00      	cmp	r4, #0
 8001170:	d0f4      	beq.n	800115c <_ux_host_class_storage_thread_entry+0x8>
            if ((storage -> ux_host_class_storage_state == UX_HOST_CLASS_INSTANCE_LIVE))
 8001172:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 8001176:	2b01      	cmp	r3, #1
 8001178:	d1f8      	bne.n	800116c <_ux_host_class_storage_thread_entry+0x18>
                status =  _ux_utility_semaphore_get(&storage -> ux_host_class_storage_semaphore, UX_WAIT_FOREVER);
 800117a:	f504 77c2 	add.w	r7, r4, #388	; 0x184
 800117e:	f04f 31ff 	mov.w	r1, #4294967295
 8001182:	4638      	mov	r0, r7
 8001184:	f000 ff84 	bl	8002090 <_ux_utility_semaphore_get>
                if (status != UX_SUCCESS)
 8001188:	2800      	cmp	r0, #0
 800118a:	d1e7      	bne.n	800115c <_ux_host_class_storage_thread_entry+0x8>
                for (lun_index = 0; lun_index <= storage -> ux_host_class_storage_max_lun; lun_index++)
 800118c:	4605      	mov	r5, r0
 800118e:	f104 06e0 	add.w	r6, r4, #224	; 0xe0
                                    memory =  storage_media -> ux_host_class_storage_media_memory;
 8001192:	f242 49c8 	movw	r9, #9416	; 0x24c8
                                    storage_media -> ux_host_class_storage_media_status = UX_HOST_CLASS_STORAGE_MEDIA_UNMOUNTED;
 8001196:	f242 4bb8 	movw	fp, #9400	; 0x24b8
 800119a:	e006      	b.n	80011aa <_ux_host_class_storage_thread_entry+0x56>
                        (storage -> ux_host_class_storage_lun_types[lun_index] == UX_HOST_CLASS_STORAGE_MEDIA_OPTICAL_DISK) ||
 800119c:	2b55      	cmp	r3, #85	; 0x55
 800119e:	d00d      	beq.n	80011bc <_ux_host_class_storage_thread_entry+0x68>
                for (lun_index = 0; lun_index <= storage -> ux_host_class_storage_max_lun; lun_index++)
 80011a0:	3501      	adds	r5, #1
 80011a2:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
 80011a6:	42ab      	cmp	r3, r5
 80011a8:	d362      	bcc.n	8001270 <_ux_host_class_storage_thread_entry+0x11c>
                    if (storage -> ux_host_class_storage_lun_removable_media_flags[lun_index] != UX_HOST_CLASS_STORAGE_MEDIA_REMOVABLE)
 80011aa:	f856 3f04 	ldr.w	r3, [r6, #4]!
 80011ae:	2b80      	cmp	r3, #128	; 0x80
 80011b0:	d1f6      	bne.n	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
                    if ((storage -> ux_host_class_storage_lun_types[lun_index] == UX_HOST_CLASS_STORAGE_MEDIA_FAT_DISK) ||
 80011b2:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
                        (storage -> ux_host_class_storage_lun_types[lun_index] == UX_HOST_CLASS_STORAGE_MEDIA_OPTICAL_DISK) ||
 80011b4:	2b07      	cmp	r3, #7
 80011b6:	bf18      	it	ne
 80011b8:	2b00      	cmpne	r3, #0
 80011ba:	d1ef      	bne.n	800119c <_ux_host_class_storage_thread_entry+0x48>
                        storage -> ux_host_class_storage_lun =  lun_index;
 80011bc:	f8c4 512c 	str.w	r5, [r4, #300]	; 0x12c
                        status =  _ux_host_class_storage_unit_ready_test(storage);
 80011c0:	4620      	mov	r0, r4
 80011c2:	f000 f895 	bl	80012f0 <_ux_host_class_storage_unit_ready_test>
                        if (status != UX_SUCCESS)
 80011c6:	4682      	mov	sl, r0
 80011c8:	2800      	cmp	r0, #0
 80011ca:	f040 8085 	bne.w	80012d8 <_ux_host_class_storage_thread_entry+0x184>
                        switch(storage -> ux_host_class_storage_sense_code >> 16)
 80011ce:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
 80011d2:	2b02      	cmp	r3, #2
 80011d4:	d050      	beq.n	8001278 <_ux_host_class_storage_thread_entry+0x124>
 80011d6:	2b06      	cmp	r3, #6
 80011d8:	d1e2      	bne.n	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
                                storage_media = (UX_HOST_CLASS_STORAGE_MEDIA *) class -> ux_host_class_media;
 80011da:	f8d8 1124 	ldr.w	r1, [r8, #292]	; 0x124
                                    if ((media -> fx_media_id != 0) && (media -> fx_media_driver_info == (VOID *) storage) &&
 80011de:	680b      	ldr	r3, [r1, #0]
 80011e0:	b30b      	cbz	r3, 8001226 <_ux_host_class_storage_thread_entry+0xd2>
 80011e2:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
 80011e6:	42a3      	cmp	r3, r4
 80011e8:	d11d      	bne.n	8001226 <_ux_host_class_storage_thread_entry+0xd2>
 80011ea:	f242 43bc 	movw	r3, #9404	; 0x24bc
 80011ee:	58ca      	ldr	r2, [r1, r3]
 80011f0:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
 80011f4:	429a      	cmp	r2, r3
 80011f6:	d116      	bne.n	8001226 <_ux_host_class_storage_thread_entry+0xd2>
                                        memory =  storage_media -> ux_host_class_storage_media_memory;
 80011f8:	f851 3009 	ldr.w	r3, [r1, r9]
                                        status =  _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
 80011fc:	4638      	mov	r0, r7
                                        memory =  storage_media -> ux_host_class_storage_media_memory;
 80011fe:	e9cd 1300 	strd	r1, r3, [sp]
                                        status =  _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
 8001202:	f000 ff69 	bl	80020d8 <_ux_utility_semaphore_put>
                                        fx_media_close(media);
 8001206:	9900      	ldr	r1, [sp, #0]
 8001208:	4608      	mov	r0, r1
 800120a:	f004 ff9f 	bl	800614c <_fxe_media_close>
                                        storage_media -> ux_host_class_storage_media_status =  UX_HOST_CLASS_STORAGE_MEDIA_UNMOUNTED;
 800120e:	9900      	ldr	r1, [sp, #0]
                                        status =  _ux_utility_semaphore_get(&storage -> ux_host_class_storage_semaphore, UX_WAIT_FOREVER);
 8001210:	4638      	mov	r0, r7
                                        storage_media -> ux_host_class_storage_media_status =  UX_HOST_CLASS_STORAGE_MEDIA_UNMOUNTED;
 8001212:	f841 a00b 	str.w	sl, [r1, fp]
                                        media -> fx_media_id =  0;
 8001216:	f8c1 a000 	str.w	sl, [r1]
                                        status =  _ux_utility_semaphore_get(&storage -> ux_host_class_storage_semaphore, UX_WAIT_FOREVER);
 800121a:	f04f 31ff 	mov.w	r1, #4294967295
 800121e:	f000 ff37 	bl	8002090 <_ux_utility_semaphore_get>
                                        if (status != UX_SUCCESS)
 8001222:	2800      	cmp	r0, #0
 8001224:	d05f      	beq.n	80012e6 <_ux_host_class_storage_thread_entry+0x192>
                                status =  _ux_host_class_storage_unit_ready_test(storage);
 8001226:	4620      	mov	r0, r4
 8001228:	f000 f862 	bl	80012f0 <_ux_host_class_storage_unit_ready_test>
                                if (status != UX_SUCCESS)
 800122c:	2800      	cmp	r0, #0
 800122e:	d14f      	bne.n	80012d0 <_ux_host_class_storage_thread_entry+0x17c>
                                if (storage -> ux_host_class_storage_sense_code == 0)
 8001230:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
 8001234:	2b00      	cmp	r3, #0
 8001236:	d1b3      	bne.n	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
                                    status =  _ux_host_class_storage_media_characteristics_get(storage);
 8001238:	4620      	mov	r0, r4
 800123a:	f001 fc7b 	bl	8002b34 <_ux_host_class_storage_media_characteristics_get>
                                    if (status != UX_SUCCESS)
 800123e:	2800      	cmp	r0, #0
 8001240:	d1ae      	bne.n	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
                                    status =  _ux_host_class_storage_media_format_capacity_get(storage);
 8001242:	4620      	mov	r0, r4
 8001244:	f001 fca4 	bl	8002b90 <_ux_host_class_storage_media_format_capacity_get>
                                    if (status != UX_SUCCESS)
 8001248:	4682      	mov	sl, r0
 800124a:	2800      	cmp	r0, #0
 800124c:	d1a8      	bne.n	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
                                    _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
 800124e:	4638      	mov	r0, r7
                for (lun_index = 0; lun_index <= storage -> ux_host_class_storage_max_lun; lun_index++)
 8001250:	3501      	adds	r5, #1
                                    _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
 8001252:	f000 ff41 	bl	80020d8 <_ux_utility_semaphore_put>
                                    _ux_host_class_storage_media_mount(storage, 0);
 8001256:	4651      	mov	r1, sl
 8001258:	4620      	mov	r0, r4
 800125a:	f001 fcbb 	bl	8002bd4 <_ux_host_class_storage_media_mount>
                                    _ux_utility_semaphore_get(&storage -> ux_host_class_storage_semaphore, UX_WAIT_FOREVER);
 800125e:	f04f 31ff 	mov.w	r1, #4294967295
 8001262:	4638      	mov	r0, r7
 8001264:	f000 ff14 	bl	8002090 <_ux_utility_semaphore_get>
                for (lun_index = 0; lun_index <= storage -> ux_host_class_storage_max_lun; lun_index++)
 8001268:	f8d4 3128 	ldr.w	r3, [r4, #296]	; 0x128
 800126c:	42ab      	cmp	r3, r5
 800126e:	d29c      	bcs.n	80011aa <_ux_host_class_storage_thread_entry+0x56>
                status =  _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
 8001270:	4638      	mov	r0, r7
 8001272:	f000 ff31 	bl	80020d8 <_ux_utility_semaphore_put>
 8001276:	e779      	b.n	800116c <_ux_host_class_storage_thread_entry+0x18>
                            storage_media = (UX_HOST_CLASS_STORAGE_MEDIA *) class -> ux_host_class_media;
 8001278:	f8d8 1124 	ldr.w	r1, [r8, #292]	; 0x124
                                if ((media -> fx_media_id != 0) && (media -> fx_media_driver_info == (VOID *) storage) &&
 800127c:	680b      	ldr	r3, [r1, #0]
 800127e:	2b00      	cmp	r3, #0
 8001280:	d08e      	beq.n	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
 8001282:	f8d1 3084 	ldr.w	r3, [r1, #132]	; 0x84
 8001286:	42a3      	cmp	r3, r4
 8001288:	d18a      	bne.n	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
 800128a:	f242 43bc 	movw	r3, #9404	; 0x24bc
 800128e:	58ca      	ldr	r2, [r1, r3]
 8001290:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
 8001294:	429a      	cmp	r2, r3
 8001296:	d183      	bne.n	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
                                    memory =  storage_media -> ux_host_class_storage_media_memory;
 8001298:	f851 3009 	ldr.w	r3, [r1, r9]
                                    status =  _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
 800129c:	4638      	mov	r0, r7
                                    memory =  storage_media -> ux_host_class_storage_media_memory;
 800129e:	e9cd 1300 	strd	r1, r3, [sp]
                                    status =  _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
 80012a2:	f000 ff19 	bl	80020d8 <_ux_utility_semaphore_put>
                                    fx_media_close(media);
 80012a6:	9900      	ldr	r1, [sp, #0]
 80012a8:	4608      	mov	r0, r1
 80012aa:	f004 ff4f 	bl	800614c <_fxe_media_close>
                                    storage_media -> ux_host_class_storage_media_status = UX_HOST_CLASS_STORAGE_MEDIA_UNMOUNTED;
 80012ae:	9900      	ldr	r1, [sp, #0]
                                    status =  _ux_utility_semaphore_get(&storage -> ux_host_class_storage_semaphore, UX_WAIT_FOREVER);
 80012b0:	4638      	mov	r0, r7
                                    storage_media -> ux_host_class_storage_media_status = UX_HOST_CLASS_STORAGE_MEDIA_UNMOUNTED;
 80012b2:	f841 a00b 	str.w	sl, [r1, fp]
                                    media -> fx_media_id =  0;
 80012b6:	f8c1 a000 	str.w	sl, [r1]
                                    status =  _ux_utility_semaphore_get(&storage -> ux_host_class_storage_semaphore, UX_WAIT_FOREVER);
 80012ba:	f04f 31ff 	mov.w	r1, #4294967295
 80012be:	f000 fee7 	bl	8002090 <_ux_utility_semaphore_get>
                                    if (status != UX_SUCCESS)
 80012c2:	2800      	cmp	r0, #0
 80012c4:	f47f af6c 	bne.w	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
                                    _ux_utility_memory_free(memory);
 80012c8:	9801      	ldr	r0, [sp, #4]
 80012ca:	f000 fe23 	bl	8001f14 <_ux_utility_memory_free>
 80012ce:	e767      	b.n	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
                                    _ux_host_class_storage_device_reset(storage);
 80012d0:	4620      	mov	r0, r4
 80012d2:	f001 fb5d 	bl	8002990 <_ux_host_class_storage_device_reset>
                                    break;
 80012d6:	e763      	b.n	80011a0 <_ux_host_class_storage_thread_entry+0x4c>
                            _ux_host_class_storage_device_reset(storage);
 80012d8:	4620      	mov	r0, r4
 80012da:	f001 fb59 	bl	8002990 <_ux_host_class_storage_device_reset>
                status =  _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
 80012de:	4638      	mov	r0, r7
 80012e0:	f000 fefa 	bl	80020d8 <_ux_utility_semaphore_put>
 80012e4:	e742      	b.n	800116c <_ux_host_class_storage_thread_entry+0x18>
                                        _ux_utility_memory_free(memory);
 80012e6:	9801      	ldr	r0, [sp, #4]
 80012e8:	f000 fe14 	bl	8001f14 <_ux_utility_memory_free>
 80012ec:	e79b      	b.n	8001226 <_ux_host_class_storage_thread_entry+0xd2>
 80012ee:	bf00      	nop

080012f0 <_ux_host_class_storage_unit_ready_test>:
#else
    command_length =  UX_HOST_CLASS_STORAGE_TEST_READY_COMMAND_LENGTH_SBC;
#endif

    /* Initialize the CBW for this command.  */
    _ux_host_class_storage_cbw_initialize(storage, 0, 0, command_length);
 80012f0:	2200      	movs	r2, #0
 80012f2:	2306      	movs	r3, #6
{
 80012f4:	b510      	push	{r4, lr}
    _ux_host_class_storage_cbw_initialize(storage, 0, 0, command_length);
 80012f6:	4611      	mov	r1, r2
{
 80012f8:	4604      	mov	r4, r0
    _ux_host_class_storage_cbw_initialize(storage, 0, 0, command_length);
 80012fa:	f001 fa5d 	bl	80027b8 <_ux_host_class_storage_cbw_initialize>
    
    /* Prepare the TEST UNIT READY command block.  */
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_TEST_READY_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_TEST_READY;
 80012fe:	2100      	movs	r1, #0
    
    /* Send the command to transport layer.  */
    status =  _ux_host_class_storage_transport(storage, UX_NULL);
 8001300:	4620      	mov	r0, r4
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_TEST_READY_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_TEST_READY;
 8001302:	f884 102b 	strb.w	r1, [r4, #43]	; 0x2b

    /* Return completion status.  */
    return(status);                                            
}
 8001306:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    status =  _ux_host_class_storage_transport(storage, UX_NULL);
 800130a:	f001 bdd5 	b.w	8002eb8 <_ux_host_class_storage_transport>
 800130e:	bf00      	nop

08001310 <_ux_hcd_stm32_initialize_hscore>:
ULONG                stm32_register;
ULONG                channel_index;
UINT                status;

    /* The controller initialized here is of STM32 type High Speed only.  */
    hcd -> ux_hcd_controller_type =  UX_HCD_STM32_CONTROLLER_HS;
 8001310:	2207      	movs	r2, #7
    
    /* Initialize the max bandwidth for periodic endpoints. On STM32, the spec says 
       no more than 90% to be allocated for periodic.  */
    hcd -> ux_hcd_available_bandwidth =  UX_HCD_STM32_AVAILABLE_BANDWIDTH;
 8001312:	f241 7370 	movw	r3, #6000	; 0x1770

    /* Allocate memory for this STM32 HCD instance.  */
    hcd_stm32 =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD_STM32));
 8001316:	2100      	movs	r1, #0
{
 8001318:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    hcd -> ux_hcd_controller_type =  UX_HCD_STM32_CONTROLLER_HS;
 800131c:	6542      	str	r2, [r0, #84]	; 0x54
{
 800131e:	4605      	mov	r5, r0
    hcd -> ux_hcd_available_bandwidth =  UX_HCD_STM32_AVAILABLE_BANDWIDTH;
 8001320:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
    hcd_stm32 =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD_STM32));
 8001324:	f44f 7282 	mov.w	r2, #260	; 0x104
 8001328:	4608      	mov	r0, r1
 800132a:	f000 fcdf 	bl	8001cec <_ux_utility_memory_allocate>
    if (hcd_stm32 == UX_NULL)
 800132e:	2800      	cmp	r0, #0
 8001330:	f000 80ee 	beq.w	8001510 <_ux_hcd_stm32_initialize_hscore+0x200>
    
    /* Initialize the number of channels for HS core.  */
    hcd_stm32 -> ux_hcd_stm32_nb_channels =  UX_HCD_STM32_HS_NB_CHANNELS;

    /* Allocate the list of eds.   */
    hcd_stm32 -> ux_hcd_stm32_ed_list =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD_STM32_ED) *_ux_system_host -> ux_system_host_max_ed);
 8001334:	4f79      	ldr	r7, [pc, #484]	; (800151c <_ux_hcd_stm32_initialize_hscore+0x20c>)
 8001336:	4604      	mov	r4, r0
    hcd_stm32 -> ux_hcd_stm32_base =  hcd -> ux_hcd_io;
 8001338:	f8d5 c0b4 	ldr.w	ip, [r5, #180]	; 0xb4
    hcd -> ux_hcd_status =  UX_HCD_STATUS_HALTED;
 800133c:	2600      	movs	r6, #0
    hcd_stm32 -> ux_hcd_stm32_ed_list =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD_STM32_ED) *_ux_system_host -> ux_system_host_max_ed);
 800133e:	683a      	ldr	r2, [r7, #0]
    hcd_stm32 -> ux_hcd_stm32_nb_channels =  UX_HCD_STM32_HS_NB_CHANNELS;
 8001340:	230c      	movs	r3, #12
    hcd -> ux_hcd_controller_hardware =  (VOID *) hcd_stm32;
 8001342:	f8c5 00c8 	str.w	r0, [r5, #200]	; 0xc8
    hcd_stm32 -> ux_hcd_stm32_ed_list =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD_STM32_ED) *_ux_system_host -> ux_system_host_max_ed);
 8001346:	4631      	mov	r1, r6
 8001348:	6a12      	ldr	r2, [r2, #32]
 800134a:	4630      	mov	r0, r6
    hcd_stm32 -> ux_hcd_stm32_base =  hcd -> ux_hcd_io;
 800134c:	f8c4 c0ec 	str.w	ip, [r4, #236]	; 0xec
    hcd_stm32 -> ux_hcd_stm32_ed_list =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD_STM32_ED) *_ux_system_host -> ux_system_host_max_ed);
 8001350:	eb02 0242 	add.w	r2, r2, r2, lsl #1
    hcd -> ux_hcd_entry_function =  _ux_hcd_stm32_entry;
 8001354:	f8df c1d0 	ldr.w	ip, [pc, #464]	; 8001528 <_ux_hcd_stm32_initialize_hscore+0x218>
    hcd_stm32 -> ux_hcd_stm32_hcd_owner =  hcd;
 8001358:	6025      	str	r5, [r4, #0]
    hcd_stm32 -> ux_hcd_stm32_ed_list =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD_STM32_ED) *_ux_system_host -> ux_system_host_max_ed);
 800135a:	0112      	lsls	r2, r2, #4
    hcd -> ux_hcd_status =  UX_HCD_STATUS_HALTED;
 800135c:	652e      	str	r6, [r5, #80]	; 0x50
    hcd -> ux_hcd_entry_function =  _ux_hcd_stm32_entry;
 800135e:	f8c5 c0c4 	str.w	ip, [r5, #196]	; 0xc4
    hcd_stm32 -> ux_hcd_stm32_nb_channels =  UX_HCD_STM32_HS_NB_CHANNELS;
 8001362:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
    hcd_stm32 -> ux_hcd_stm32_ed_list =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD_STM32_ED) *_ux_system_host -> ux_system_host_max_ed);
 8001366:	f000 fcc1 	bl	8001cec <_ux_utility_memory_allocate>
 800136a:	6060      	str	r0, [r4, #4]
    if (hcd_stm32 -> ux_hcd_stm32_ed_list == UX_NULL)
 800136c:	2800      	cmp	r0, #0
 800136e:	f000 80cf 	beq.w	8001510 <_ux_hcd_stm32_initialize_hscore+0x200>
        return(UX_MEMORY_INSUFFICIENT);

    /* Allocate the list of tds.  */
    hcd_stm32 -> ux_hcd_stm32_td_list =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD_STM32_TD) *_ux_system_host -> ux_system_host_max_td);
 8001372:	683b      	ldr	r3, [r7, #0]
 8001374:	4631      	mov	r1, r6
 8001376:	4630      	mov	r0, r6
 8001378:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800137a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800137e:	00d2      	lsls	r2, r2, #3
 8001380:	f000 fcb4 	bl	8001cec <_ux_utility_memory_allocate>
 8001384:	60a0      	str	r0, [r4, #8]
    if (hcd_stm32 -> ux_hcd_stm32_td_list == UX_NULL)
 8001386:	2800      	cmp	r0, #0
 8001388:	f000 80c2 	beq.w	8001510 <_ux_hcd_stm32_initialize_hscore+0x200>
        return(UX_MEMORY_INSUFFICIENT);

    /* Allocate the list of isochronous tds. */
    if (_ux_system_host -> ux_system_host_max_iso_td != 0)
 800138c:	683b      	ldr	r3, [r7, #0]
 800138e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001390:	b152      	cbz	r2, 80013a8 <_ux_hcd_stm32_initialize_hscore+0x98>
    {

        /* We need Iso TDs.  */
        hcd_stm32 -> ux_hcd_stm32_iso_td_list =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD_STM32_ISO_TD) *_ux_system_host -> ux_system_host_max_iso_td);
 8001392:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
 8001396:	4631      	mov	r1, r6
 8001398:	4630      	mov	r0, r6
 800139a:	0092      	lsls	r2, r2, #2
 800139c:	f000 fca6 	bl	8001cec <_ux_utility_memory_allocate>
 80013a0:	60e0      	str	r0, [r4, #12]
        if (hcd_stm32 -> ux_hcd_stm32_iso_td_list == UX_NULL)
 80013a2:	2800      	cmp	r0, #0
 80013a4:	f000 80b4 	beq.w	8001510 <_ux_hcd_stm32_initialize_hscore+0x200>
            return(UX_MEMORY_INSUFFICIENT);
    }
            
    /* Initialize the periodic tree.  */
    status =  _ux_hcd_stm32_periodic_tree_create(hcd_stm32);
 80013a8:	4620      	mov	r0, r4
 80013aa:	f000 fa05 	bl	80017b8 <_ux_hcd_stm32_periodic_tree_create>
    if (status != UX_SUCCESS)
 80013ae:	4680      	mov	r8, r0
 80013b0:	2800      	cmp	r0, #0
 80013b2:	f040 80af 	bne.w	8001514 <_ux_hcd_stm32_initialize_hscore+0x204>
        return(status);

    /* Since we know this is a high-speed controller, we can hardwire the version.  */
    hcd -> ux_hcd_version =  0x200;
 80013b6:	f44f 7300 	mov.w	r3, #512	; 0x200

    /* Reset the GINT Global Interrupt Mask register.  */
    _ux_hcd_stm32_register_clear(hcd_stm32, UX_HCD_STM32_OTG_FS_GAHBCFG, UX_HCD_STM32_OTG_FS_GAHBCFG_GINT);
 80013ba:	2201      	movs	r2, #1
 80013bc:	2108      	movs	r1, #8
 80013be:	4620      	mov	r0, r4
    hcd -> ux_hcd_version =  0x200;
 80013c0:	f8c5 30c0 	str.w	r3, [r5, #192]	; 0xc0
    _ux_hcd_stm32_register_clear(hcd_stm32, UX_HCD_STM32_OTG_FS_GAHBCFG, UX_HCD_STM32_OTG_FS_GAHBCFG_GINT);
 80013c4:	f000 fa6a 	bl	800189c <_ux_hcd_stm32_register_clear>
    
    /* PHY Selection.  Select ULPI and external VBUS drive. */
#ifdef  STM32F429I_DISCO_USBX  
     _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_GUSBCFG, (UX_HCD_STM32_OTG_FS_GUSBCFG_PHYSEL)); 
#else
     _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_GUSBCFG, (UX_HCD_STM32_OTG_FS_GUSBCFG_ULPI_UTMI_SEL | UX_HCD_STM32_OTG_FS_GUSBCFG_ULPIEVBUSD)); 
 80013c8:	f04f 1210 	mov.w	r2, #1048592	; 0x100010
 80013cc:	210c      	movs	r1, #12
 80013ce:	4620      	mov	r0, r4
 80013d0:	f000 fa70 	bl	80018b4 <_ux_hcd_stm32_register_set>
#endif

    /* Initialize the PHY Power options.  */
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_GCCFG , UX_HCD_STM32_OTG_FS_GCCFG_PWRDWN);
 80013d4:	4620      	mov	r0, r4
 80013d6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80013da:	2138      	movs	r1, #56	; 0x38
 80013dc:	f000 fa6a 	bl	80018b4 <_ux_hcd_stm32_register_set>

    /* Spec says wait for 10000 cycles ???.  */
    _ux_hcd_stm32_delay(1000);    
 80013e0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80013e4:	f002 f878 	bl	80034d8 <_ux_hcd_stm32_delay>
    /* Wait for AHB master Idle State.  */
    do
    {

        /* Spec says wait for 3 cycles.  */
        _ux_hcd_stm32_delay(3);    
 80013e8:	2003      	movs	r0, #3
 80013ea:	f002 f875 	bl	80034d8 <_ux_hcd_stm32_delay>

        /* Read the RST Control register.  */
        stm32_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL); 
 80013ee:	2110      	movs	r1, #16
 80013f0:	4620      	mov	r0, r4
 80013f2:	f000 fa5b 	bl	80018ac <_ux_hcd_stm32_register_read>

    } while ((stm32_register & UX_HCD_STM32_OTG_FS_GRSTCTL_AHBIDL) == 0);   
 80013f6:	2800      	cmp	r0, #0
 80013f8:	daf6      	bge.n	80013e8 <_ux_hcd_stm32_initialize_hscore+0xd8>

    /* Perform the core soft reset.  */
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL, UX_HCD_STM32_OTG_FS_GRSTCTL_CSRST); 
 80013fa:	2201      	movs	r2, #1
 80013fc:	2110      	movs	r1, #16
 80013fe:	4620      	mov	r0, r4
 8001400:	f000 fa58 	bl	80018b4 <_ux_hcd_stm32_register_set>
    /* Wait for Soft Reset to be completed.  */
    do
    {

        /* Read the RST Control register.  */
        stm32_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL); 
 8001404:	2110      	movs	r1, #16
 8001406:	4620      	mov	r0, r4
 8001408:	f000 fa50 	bl	80018ac <_ux_hcd_stm32_register_read>

    } while (stm32_register & UX_HCD_STM32_OTG_FS_GRSTCTL_CSRST);   
 800140c:	f010 0601 	ands.w	r6, r0, #1
 8001410:	d1f8      	bne.n	8001404 <_ux_hcd_stm32_initialize_hscore+0xf4>

    /* Spec says wait for 10 cycles.  */
    _ux_hcd_stm32_delay(10);    
 8001412:	200a      	movs	r0, #10
 8001414:	f002 f860 	bl	80034d8 <_ux_hcd_stm32_delay>

    /* Force the chip to be in host mode.  This is not for OTG support. */
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_GUSBCFG, UX_HCD_STM32_OTG_FS_GUSBCFG_FHMOD);
 8001418:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 800141c:	210c      	movs	r1, #12
 800141e:	4620      	mov	r0, r4
 8001420:	f000 fa48 	bl	80018b4 <_ux_hcd_stm32_register_set>

    /* Spec says wait for 500 ms cycles ???.  */
    _ux_hcd_stm32_delay(50000);    
 8001424:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001428:	f002 f856 	bl	80034d8 <_ux_hcd_stm32_delay>

    /* Restart the PHY clock. */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_PCGCCTL, 0); 
 800142c:	4632      	mov	r2, r6
 800142e:	f44f 6160 	mov.w	r1, #3584	; 0xe00
 8001432:	4620      	mov	r0, r4
 8001434:	f000 fa44 	bl	80018c0 <_ux_hcd_stm32_register_write>
    
    /* Select FS/LS PHY clock select to 48 MHZ.  */
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_HCFG, UX_HCD_STM32_OTG_FS_HCFG_FSLSPCS_LS_48MHZ); 
 8001438:	2201      	movs	r2, #1
 800143a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800143e:	4620      	mov	r0, r4
 8001440:	f000 fa38 	bl	80018b4 <_ux_hcd_stm32_register_set>

    /* Set the RX Fifo size. Set to 256 bytes in DWORDS.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GRXFSIZ, UX_HCD_STM32_HS_RX_FIFO_SIZE); 
 8001444:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001448:	2124      	movs	r1, #36	; 0x24
 800144a:	4620      	mov	r0, r4
 800144c:	f000 fa38 	bl	80018c0 <_ux_hcd_stm32_register_write>

    /* Set the Non periodic TX Fifo size. Set to 256 bytes in DWORDS.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GNPTXFSIZ, (UX_HCD_STM32_HS_NPTX_FIFO_SIZE << 16) | UX_HCD_STM32_HS_RX_FIFO_SIZE); 
 8001450:	f04f 2201 	mov.w	r2, #16777472	; 0x1000100
 8001454:	2128      	movs	r1, #40	; 0x28
 8001456:	4620      	mov	r0, r4
 8001458:	f000 fa32 	bl	80018c0 <_ux_hcd_stm32_register_write>
    
    /* Set the Periodic TX Fifo size. Set to 256 bytes in DWORDS.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HPTXFSIZ, (UX_HCD_STM32_HS_PTX_FIFO_SIZE << 16) | 
 800145c:	4a30      	ldr	r2, [pc, #192]	; (8001520 <_ux_hcd_stm32_initialize_hscore+0x210>)
 800145e:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001462:	4620      	mov	r0, r4
 8001464:	f000 fa2c 	bl	80018c0 <_ux_hcd_stm32_register_write>
                                (UX_HCD_STM32_HS_RX_FIFO_SIZE + UX_HCD_STM32_HS_PTX_FIFO_SIZE)); 

    /* Disable all interrupts.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTMSK, 0);
 8001468:	4632      	mov	r2, r6
 800146a:	2118      	movs	r1, #24
 800146c:	4620      	mov	r0, r4
 800146e:	f000 fa27 	bl	80018c0 <_ux_hcd_stm32_register_write>

    /* Flush the TX FIFO.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL, (UX_HCD_STM32_OTG_FS_GRSTCTL_TXFNUM_ALL|UX_HCD_STM32_OTG_FS_GRSTCTL_TXFFLSH));
 8001472:	f44f 7208 	mov.w	r2, #544	; 0x220
 8001476:	2110      	movs	r1, #16
 8001478:	4620      	mov	r0, r4
 800147a:	f000 fa21 	bl	80018c0 <_ux_hcd_stm32_register_write>

    /* Wait for flush to happen.  */
    while (_ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL) & UX_HCD_STM32_OTG_FS_GRSTCTL_TXFFLSH);
 800147e:	2110      	movs	r1, #16
 8001480:	4620      	mov	r0, r4
 8001482:	f000 fa13 	bl	80018ac <_ux_hcd_stm32_register_read>
 8001486:	0683      	lsls	r3, r0, #26
 8001488:	d4f9      	bmi.n	800147e <_ux_hcd_stm32_initialize_hscore+0x16e>
        
    /* Flush the RX FIFO.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL, UX_HCD_STM32_OTG_FS_GRSTCTL_RXFFLSH);
 800148a:	2210      	movs	r2, #16
 800148c:	4620      	mov	r0, r4
 800148e:	4611      	mov	r1, r2
 8001490:	f000 fa16 	bl	80018c0 <_ux_hcd_stm32_register_write>

    /* Wait for flush to happen.  */
    while (_ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL) & UX_HCD_STM32_OTG_FS_GRSTCTL_RXFFLSH);
 8001494:	2110      	movs	r1, #16
 8001496:	4620      	mov	r0, r4
 8001498:	f000 fa08 	bl	80018ac <_ux_hcd_stm32_register_read>
 800149c:	f010 0610 	ands.w	r6, r0, #16
 80014a0:	d1f8      	bne.n	8001494 <_ux_hcd_stm32_initialize_hscore+0x184>

    /* Clear all channel interrupts.  */
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 80014a2:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 80014a6:	b193      	cbz	r3, 80014ce <_ux_hcd_stm32_initialize_hscore+0x1be>
 80014a8:	f44f 67a1 	mov.w	r7, #1288	; 0x508
    {

        /* Clear the interrupt pending register.  */
        _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINT + 
 80014ac:	4639      	mov	r1, r7
 80014ae:	f04f 32ff 	mov.w	r2, #4294967295
 80014b2:	4620      	mov	r0, r4
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 80014b4:	3601      	adds	r6, #1
        _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINT + 
 80014b6:	f000 fa03 	bl	80018c0 <_ux_hcd_stm32_register_write>
                                (channel_index * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), 0xffffffff);                    

        /* Clear the interrupt mask register.  */
        _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
 80014ba:	1d39      	adds	r1, r7, #4
 80014bc:	2200      	movs	r2, #0
 80014be:	4620      	mov	r0, r4
 80014c0:	f000 f9fe 	bl	80018c0 <_ux_hcd_stm32_register_write>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 80014c4:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 80014c8:	3720      	adds	r7, #32
 80014ca:	42b3      	cmp	r3, r6
 80014cc:	d8ee      	bhi.n	80014ac <_ux_hcd_stm32_initialize_hscore+0x19c>
                                                                        UX_HCD_STM32_OTG_FS_GINTMSK_PRTIM     |
                                                                        UX_HCD_STM32_OTG_FS_GINTMSK_DISCINTM);

    /* The number of ports on the controller is fixed to 1. The number of ports needs to be reflected both 
       for the generic HCD container and the local stm32 container.  */
    hcd -> ux_hcd_nb_root_hubs             =  UX_HCD_STM32_NB_ROOT_PORTS;
 80014ce:	2601      	movs	r6, #1
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTSTS, 0xFFFFFFFF);
 80014d0:	4620      	mov	r0, r4
 80014d2:	f04f 32ff 	mov.w	r2, #4294967295
 80014d6:	2114      	movs	r1, #20
 80014d8:	f000 f9f2 	bl	80018c0 <_ux_hcd_stm32_register_write>
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTMSK,     UX_HCD_STM32_OTG_FS_GINTMSK_WKUINTM   |
 80014dc:	4a11      	ldr	r2, [pc, #68]	; (8001524 <_ux_hcd_stm32_initialize_hscore+0x214>)
 80014de:	4620      	mov	r0, r4
 80014e0:	2118      	movs	r1, #24
 80014e2:	f000 f9e7 	bl	80018b4 <_ux_hcd_stm32_register_set>
    hcd -> ux_hcd_nb_root_hubs             =  UX_HCD_STM32_NB_ROOT_PORTS;
 80014e6:	662e      	str	r6, [r5, #96]	; 0x60
    hcd_stm32 -> ux_hcd_stm32_nb_root_hubs =  UX_HCD_STM32_NB_ROOT_PORTS;

    /* The root port must now be powered to pick up device insertion.  */
    _ux_hcd_stm32_power_on_port(hcd_stm32, 0);
 80014e8:	2100      	movs	r1, #0
    hcd_stm32 -> ux_hcd_stm32_nb_root_hubs =  UX_HCD_STM32_NB_ROOT_PORTS;
 80014ea:	f8c4 60e8 	str.w	r6, [r4, #232]	; 0xe8
    _ux_hcd_stm32_power_on_port(hcd_stm32, 0);
 80014ee:	4620      	mov	r0, r4
 80014f0:	f000 f9c2 	bl	8001878 <_ux_hcd_stm32_power_on_port>

    /* The asynchronous queues are empty for now.  */
    hcd_stm32 -> ux_hcd_stm32_queue_empty =  UX_TRUE;

    /* The periodic scheduler is not active.  */
    hcd_stm32 -> ux_hcd_stm32_periodic_scheduler_active =  0;
 80014f4:	2300      	movs	r3, #0
    hcd_stm32 -> ux_hcd_stm32_queue_empty =  UX_TRUE;
 80014f6:	f8c4 60d4 	str.w	r6, [r4, #212]	; 0xd4

    /* Set the host controller into the operational state.  */
    hcd -> ux_hcd_status =  UX_HCD_STATUS_OPERATIONAL;

    /* Enable the global interrupt.  */
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_GAHBCFG, UX_HCD_STM32_OTG_FS_GAHBCFG_GINT); 
 80014fa:	4620      	mov	r0, r4
    hcd_stm32 -> ux_hcd_stm32_periodic_scheduler_active =  0;
 80014fc:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_GAHBCFG, UX_HCD_STM32_OTG_FS_GAHBCFG_GINT); 
 8001500:	4632      	mov	r2, r6
    hcd -> ux_hcd_status =  UX_HCD_STATUS_OPERATIONAL;
 8001502:	652e      	str	r6, [r5, #80]	; 0x50
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_GAHBCFG, UX_HCD_STM32_OTG_FS_GAHBCFG_GINT); 
 8001504:	2108      	movs	r1, #8
 8001506:	f000 f9d5 	bl	80018b4 <_ux_hcd_stm32_register_set>

    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 800150a:	4640      	mov	r0, r8
 800150c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8001510:	f04f 0812 	mov.w	r8, #18
}
 8001514:	4640      	mov	r0, r8
 8001516:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800151a:	bf00      	nop
 800151c:	20000db8 	.word	0x20000db8
 8001520:	01000200 	.word	0x01000200
 8001524:	a3000018 	.word	0xa3000018
 8001528:	08003541 	.word	0x08003541

0800152c <_ux_hcd_stm32_interrupt_handler>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_hcd_stm32_interrupt_handler(VOID)
{
 800152c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
ULONG                channel_index;
ULONG                stm32_grxstp_register;

    /* We need to parse the controller driver table to find all controllers that 
      are registered as STM32.  */
    for (hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_registered_hcd; hcd_index++)
 8001530:	4fa0      	ldr	r7, [pc, #640]	; (80017b4 <_ux_hcd_stm32_interrupt_handler+0x288>)
{
 8001532:	b083      	sub	sp, #12
    for (hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_registered_hcd; hcd_index++)
 8001534:	6838      	ldr	r0, [r7, #0]
 8001536:	6942      	ldr	r2, [r0, #20]
 8001538:	b1f2      	cbz	r2, 8001578 <_ux_hcd_stm32_interrupt_handler+0x4c>
 800153a:	2400      	movs	r4, #0
    {

        /* Check type of controller.  */
        if ((_ux_system_host -> ux_system_host_hcd_array[hcd_index].ux_hcd_controller_type == UX_HCD_STM32_CONTROLLER_FS)||
 800153c:	26cc      	movs	r6, #204	; 0xcc
 800153e:	e002      	b.n	8001546 <_ux_hcd_stm32_interrupt_handler+0x1a>
    for (hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_registered_hcd; hcd_index++)
 8001540:	3401      	adds	r4, #1
 8001542:	4294      	cmp	r4, r2
 8001544:	d218      	bcs.n	8001578 <_ux_hcd_stm32_interrupt_handler+0x4c>
        if ((_ux_system_host -> ux_system_host_hcd_array[hcd_index].ux_hcd_controller_type == UX_HCD_STM32_CONTROLLER_FS)||
 8001546:	6903      	ldr	r3, [r0, #16]
 8001548:	fb06 3804 	mla	r8, r6, r4, r3
 800154c:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
 8001550:	3b06      	subs	r3, #6
 8001552:	2b01      	cmp	r3, #1
 8001554:	d8f4      	bhi.n	8001540 <_ux_hcd_stm32_interrupt_handler+0x14>
             _ux_system_host -> ux_system_host_hcd_array[hcd_index].ux_hcd_controller_type == UX_HCD_STM32_CONTROLLER_HS)
        {

            /* Get the pointers to the generic HCD and STM32 specific areas.  */
            hcd =  &_ux_system_host -> ux_system_host_hcd_array[hcd_index];
            hcd_stm32 =  (UX_HCD_STM32 *) hcd -> ux_hcd_controller_hardware;
 8001556:	f8d8 50c8 	ldr.w	r5, [r8, #200]	; 0xc8

            /* Increase the interrupt count. This indicates the controller is still alive.  */
            hcd_stm32 -> ux_hcd_stm32_interrupt_count++;

            /* Check if the controller is operational, if not, skip it.  */
            if (hcd -> ux_hcd_status == UX_HCD_STATUS_OPERATIONAL)
 800155a:	f8d8 2050 	ldr.w	r2, [r8, #80]	; 0x50
            hcd_stm32 -> ux_hcd_stm32_interrupt_count++;
 800155e:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
            if (hcd -> ux_hcd_status == UX_HCD_STATUS_OPERATIONAL)
 8001562:	2a01      	cmp	r2, #1
            hcd_stm32 -> ux_hcd_stm32_interrupt_count++;
 8001564:	f103 0301 	add.w	r3, r3, #1
 8001568:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
            if (hcd -> ux_hcd_status == UX_HCD_STATUS_OPERATIONAL)
 800156c:	d007      	beq.n	800157e <_ux_hcd_stm32_interrupt_handler+0x52>
 800156e:	6838      	ldr	r0, [r7, #0]
    for (hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_registered_hcd; hcd_index++)
 8001570:	3401      	adds	r4, #1
 8001572:	6942      	ldr	r2, [r0, #20]
 8001574:	4294      	cmp	r4, r2
 8001576:	d3e6      	bcc.n	8001546 <_ux_hcd_stm32_interrupt_handler+0x1a>
                    }
                }
            }
        }
    }
}
 8001578:	b003      	add	sp, #12
 800157a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (hcd_stm32 -> ux_hcd_stm32_interruptible == UX_TRUE)
 800157e:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 8001582:	2b01      	cmp	r3, #1
 8001584:	f000 80dc 	beq.w	8001740 <_ux_hcd_stm32_interrupt_handler+0x214>
                interrupt_pending_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTSTS);
 8001588:	2114      	movs	r1, #20
 800158a:	4628      	mov	r0, r5
 800158c:	f000 f98e 	bl	80018ac <_ux_hcd_stm32_register_read>
                interrupt_enable_register  =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTMSK);
 8001590:	2118      	movs	r1, #24
                interrupt_pending_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTSTS);
 8001592:	4683      	mov	fp, r0
                interrupt_enable_register  =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTMSK);
 8001594:	4628      	mov	r0, r5
 8001596:	f000 f989 	bl	80018ac <_ux_hcd_stm32_register_read>
                if ((interrupt_enable_register & UX_HCD_STM32_OTG_FS_GINTSTS_SOF) && (interrupt_pending_register & UX_HCD_STM32_OTG_FS_GINTMSK_SOFM))
 800159a:	f010 0f08 	tst.w	r0, #8
                interrupt_enable_register  =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTMSK);
 800159e:	4682      	mov	sl, r0
                if ((interrupt_enable_register & UX_HCD_STM32_OTG_FS_GINTSTS_SOF) && (interrupt_pending_register & UX_HCD_STM32_OTG_FS_GINTMSK_SOFM))
 80015a0:	d002      	beq.n	80015a8 <_ux_hcd_stm32_interrupt_handler+0x7c>
 80015a2:	f01b 0f08 	tst.w	fp, #8
 80015a6:	d150      	bne.n	800164a <_ux_hcd_stm32_interrupt_handler+0x11e>
                if ((interrupt_enable_register & UX_HCD_STM32_OTG_FS_GINTSTS_HPRTINT) && 
 80015a8:	f01a 7f80 	tst.w	sl, #16777216	; 0x1000000
 80015ac:	d002      	beq.n	80015b4 <_ux_hcd_stm32_interrupt_handler+0x88>
 80015ae:	f01b 7f80 	tst.w	fp, #16777216	; 0x1000000
 80015b2:	d169      	bne.n	8001688 <_ux_hcd_stm32_interrupt_handler+0x15c>
                if ((interrupt_enable_register & UX_HCD_STM32_OTG_FS_GINTMSK_DISCINTM) && 
 80015b4:	f01a 5f00 	tst.w	sl, #536870912	; 0x20000000
 80015b8:	d003      	beq.n	80015c2 <_ux_hcd_stm32_interrupt_handler+0x96>
 80015ba:	f01b 5f00 	tst.w	fp, #536870912	; 0x20000000
 80015be:	f040 8083 	bne.w	80016c8 <_ux_hcd_stm32_interrupt_handler+0x19c>
                if ((interrupt_enable_register & UX_HCD_STM32_OTG_FS_GINTSTS_RFXLVL) && (interrupt_pending_register & UX_HCD_STM32_OTG_FS_GINTMSK_RFXLVLM))
 80015c2:	f01a 0f10 	tst.w	sl, #16
 80015c6:	d003      	beq.n	80015d0 <_ux_hcd_stm32_interrupt_handler+0xa4>
 80015c8:	f01b 0f10 	tst.w	fp, #16
 80015cc:	f040 809e 	bne.w	800170c <_ux_hcd_stm32_interrupt_handler+0x1e0>
                if ((interrupt_enable_register & UX_HCD_STM32_OTG_FS_GINTMSK_HCIM) && (interrupt_pending_register & UX_HCD_STM32_OTG_FS_GINTSTS_HCINT))
 80015d0:	f01a 7f00 	tst.w	sl, #33554432	; 0x2000000
 80015d4:	d0cb      	beq.n	800156e <_ux_hcd_stm32_interrupt_handler+0x42>
 80015d6:	f01b 7f00 	tst.w	fp, #33554432	; 0x2000000
 80015da:	d0c8      	beq.n	800156e <_ux_hcd_stm32_interrupt_handler+0x42>
                    host_channel_interrupt =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HAINT);
 80015dc:	f240 4114 	movw	r1, #1044	; 0x414
 80015e0:	4628      	mov	r0, r5
 80015e2:	f000 f963 	bl	80018ac <_ux_hcd_stm32_register_read>
                    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 80015e6:	f8d5 20d0 	ldr.w	r2, [r5, #208]	; 0xd0
                    host_channel_interrupt =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HAINT);
 80015ea:	4683      	mov	fp, r0
                    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 80015ec:	2a00      	cmp	r2, #0
 80015ee:	d0be      	beq.n	800156e <_ux_hcd_stm32_interrupt_handler+0x42>
 80015f0:	f04f 0800 	mov.w	r8, #0
                        if (host_channel_interrupt & (1 << channel_index))
 80015f4:	2301      	movs	r3, #1
 80015f6:	fa03 f308 	lsl.w	r3, r3, r8
 80015fa:	ea13 0f0b 	tst.w	r3, fp
 80015fe:	d109      	bne.n	8001614 <_ux_hcd_stm32_interrupt_handler+0xe8>
                    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8001600:	f108 0801 	add.w	r8, r8, #1
 8001604:	4590      	cmp	r8, r2
 8001606:	d2b2      	bcs.n	800156e <_ux_hcd_stm32_interrupt_handler+0x42>
                        if (host_channel_interrupt & (1 << channel_index))
 8001608:	2301      	movs	r3, #1
 800160a:	fa03 f308 	lsl.w	r3, r3, r8
 800160e:	ea13 0f0b 	tst.w	r3, fp
 8001612:	d0f5      	beq.n	8001600 <_ux_hcd_stm32_interrupt_handler+0xd4>
 8001614:	ea4f 1a48 	mov.w	sl, r8, lsl #5
                            host_channel_interrupt_status =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINT + 
 8001618:	4628      	mov	r0, r5
 800161a:	f50a 6aa1 	add.w	sl, sl, #1288	; 0x508
 800161e:	4651      	mov	r1, sl
 8001620:	f000 f944 	bl	80018ac <_ux_hcd_stm32_register_read>
                            _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINT + 
 8001624:	4651      	mov	r1, sl
 8001626:	4602      	mov	r2, r0
 8001628:	9001      	str	r0, [sp, #4]
 800162a:	4628      	mov	r0, r5
 800162c:	f000 f948 	bl	80018c0 <_ux_hcd_stm32_register_write>
                            _ux_hcd_stm32_asynch_queue_process(hcd_stm32, channel_index, host_channel_interrupt_status);
 8001630:	9b01      	ldr	r3, [sp, #4]
 8001632:	4641      	mov	r1, r8
 8001634:	4628      	mov	r0, r5
 8001636:	461a      	mov	r2, r3
                    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8001638:	f108 0801 	add.w	r8, r8, #1
                            _ux_hcd_stm32_asynch_queue_process(hcd_stm32, channel_index, host_channel_interrupt_status);
 800163c:	f001 fd58 	bl	80030f0 <_ux_hcd_stm32_asynch_queue_process>
 8001640:	f8d5 20d0 	ldr.w	r2, [r5, #208]	; 0xd0
                    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8001644:	4590      	cmp	r8, r2
 8001646:	d3d5      	bcc.n	80015f4 <_ux_hcd_stm32_interrupt_handler+0xc8>
 8001648:	e791      	b.n	800156e <_ux_hcd_stm32_interrupt_handler+0x42>
                    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTSTS, UX_HCD_STM32_OTG_FS_GINTSTS_SOF);
 800164a:	2208      	movs	r2, #8
 800164c:	2114      	movs	r1, #20
 800164e:	4628      	mov	r0, r5
 8001650:	f000 f936 	bl	80018c0 <_ux_hcd_stm32_register_write>
                    if ((hcd_stm32 -> ux_hcd_stm32_queue_empty == UX_FALSE) ||
 8001654:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 8001658:	b11b      	cbz	r3, 8001662 <_ux_hcd_stm32_interrupt_handler+0x136>
 800165a:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
 800165e:	2b00      	cmp	r3, #0
 8001660:	d0a2      	beq.n	80015a8 <_ux_hcd_stm32_interrupt_handler+0x7c>
                            if ((hcd_stm32 -> ux_hcd_stm32_controller_flag & UX_HCD_STM32_CONTROLLER_FLAG_SOF) == 0)
 8001662:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
 8001666:	0759      	lsls	r1, r3, #29
 8001668:	d49e      	bmi.n	80015a8 <_ux_hcd_stm32_interrupt_handler+0x7c>
                                hcd -> ux_hcd_thread_signal++;
 800166a:	f8d8 20ac 	ldr.w	r2, [r8, #172]	; 0xac
                                hcd_stm32 -> ux_hcd_stm32_controller_flag |= UX_HCD_STM32_CONTROLLER_FLAG_SOF;
 800166e:	f043 0304 	orr.w	r3, r3, #4
                                _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_hcd_semaphore);
 8001672:	6838      	ldr	r0, [r7, #0]
                                hcd -> ux_hcd_thread_signal++;
 8001674:	3201      	adds	r2, #1
                                hcd_stm32 -> ux_hcd_stm32_controller_flag |= UX_HCD_STM32_CONTROLLER_FLAG_SOF;
 8001676:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
                                _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_hcd_semaphore);
 800167a:	f500 7030 	add.w	r0, r0, #704	; 0x2c0
                                hcd -> ux_hcd_thread_signal++;
 800167e:	f8c8 20ac 	str.w	r2, [r8, #172]	; 0xac
                                _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_hcd_semaphore);
 8001682:	f000 fd29 	bl	80020d8 <_ux_utility_semaphore_put>
 8001686:	e78f      	b.n	80015a8 <_ux_hcd_stm32_interrupt_handler+0x7c>
                    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTSTS, UX_HCD_STM32_OTG_FS_GINTSTS_HPRTINT);
 8001688:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800168c:	2114      	movs	r1, #20
 800168e:	4628      	mov	r0, r5
 8001690:	f000 f916 	bl	80018c0 <_ux_hcd_stm32_register_write>
                    port_status =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT);
 8001694:	f44f 6188 	mov.w	r1, #1088	; 0x440
 8001698:	4628      	mov	r0, r5
 800169a:	f000 f907 	bl	80018ac <_ux_hcd_stm32_register_read>
                    if (port_status & UX_HCD_STM32_OTG_FS_HPRT_PCDET)
 800169e:	f010 0f02 	tst.w	r0, #2
                    port_status =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT);
 80016a2:	4681      	mov	r9, r0
                    port_status_modify &= ~(UX_HCD_STM32_OTG_FS_HPRT_PENA | UX_HCD_STM32_OTG_FS_HPRT_PCDET | UX_HCD_STM32_OTG_FS_HPRT_PENCHNG | UX_HCD_STM32_OTG_FS_HPRT_POCCHNG);
 80016a4:	f020 032e 	bic.w	r3, r0, #46	; 0x2e
                    if (port_status & UX_HCD_STM32_OTG_FS_HPRT_PCDET)
 80016a8:	d15d      	bne.n	8001766 <_ux_hcd_stm32_interrupt_handler+0x23a>
                    if (port_status & UX_HCD_STM32_OTG_FS_HPRT_PENCHNG)
 80016aa:	f019 0f08 	tst.w	r9, #8
 80016ae:	d14f      	bne.n	8001750 <_ux_hcd_stm32_interrupt_handler+0x224>
                    if (port_status & UX_HCD_STM32_OTG_FS_HPRT_POCCHNG)
 80016b0:	f019 0f20 	tst.w	r9, #32
 80016b4:	f43f af7e 	beq.w	80015b4 <_ux_hcd_stm32_interrupt_handler+0x88>
                        _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT, port_status_modify);                    
 80016b8:	f043 0220 	orr.w	r2, r3, #32
 80016bc:	f44f 6188 	mov.w	r1, #1088	; 0x440
 80016c0:	4628      	mov	r0, r5
 80016c2:	f000 f8fd 	bl	80018c0 <_ux_hcd_stm32_register_write>
 80016c6:	e775      	b.n	80015b4 <_ux_hcd_stm32_interrupt_handler+0x88>
                    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTSTS, UX_HCD_STM32_OTG_FS_GINTSTS_DISCINT);
 80016c8:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 80016cc:	2114      	movs	r1, #20
 80016ce:	4628      	mov	r0, r5
 80016d0:	f000 f8f6 	bl	80018c0 <_ux_hcd_stm32_register_write>
                    if ((port_status & UX_HCD_STM32_OTG_FS_HPRT_PCSTS) == 0)
 80016d4:	f019 0f01 	tst.w	r9, #1
 80016d8:	f47f af73 	bne.w	80015c2 <_ux_hcd_stm32_interrupt_handler+0x96>
                        if ((hcd_stm32 -> ux_hcd_stm32_controller_flag & UX_HCD_STM32_CONTROLLER_FLAG_DEVICE_ATTACHED) == 1)
 80016dc:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
 80016e0:	07db      	lsls	r3, r3, #31
 80016e2:	f57f af6e 	bpl.w	80015c2 <_ux_hcd_stm32_interrupt_handler+0x96>
                            hcd -> ux_hcd_root_hub_signal[0]++;
 80016e6:	f8d8 3064 	ldr.w	r3, [r8, #100]	; 0x64
                            _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_enum_semaphore);
 80016ea:	6838      	ldr	r0, [r7, #0]
                            hcd -> ux_hcd_root_hub_signal[0]++;
 80016ec:	3301      	adds	r3, #1
                            _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_enum_semaphore);
 80016ee:	f500 7080 	add.w	r0, r0, #256	; 0x100
                            hcd -> ux_hcd_root_hub_signal[0]++;
 80016f2:	f8c8 3064 	str.w	r3, [r8, #100]	; 0x64
                            _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_enum_semaphore);
 80016f6:	f000 fcef 	bl	80020d8 <_ux_utility_semaphore_put>
                            hcd_stm32 -> ux_hcd_stm32_controller_flag &= ~UX_HCD_STM32_CONTROLLER_FLAG_DEVICE_ATTACHED;
 80016fa:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
 80016fe:	f023 0301 	bic.w	r3, r3, #1
 8001702:	f043 0302 	orr.w	r3, r3, #2
 8001706:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
 800170a:	e75a      	b.n	80015c2 <_ux_hcd_stm32_interrupt_handler+0x96>
                    _ux_hcd_stm32_register_clear(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTMSK, UX_HCD_STM32_OTG_FS_GINTMSK_RFXLVLM); 
 800170c:	2210      	movs	r2, #16
 800170e:	2118      	movs	r1, #24
 8001710:	4628      	mov	r0, r5
 8001712:	f000 f8c3 	bl	800189c <_ux_hcd_stm32_register_clear>
                    stm32_grxstp_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GRXSTSR);
 8001716:	211c      	movs	r1, #28
 8001718:	4628      	mov	r0, r5
 800171a:	f000 f8c7 	bl	80018ac <_ux_hcd_stm32_register_read>
                    _ux_hcd_stm32_asynch_queue_process(hcd_stm32, channel_index, UX_HCD_STM32_OTG_FS_HCINT_RXFLVL);
 800171e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001722:	f000 010f 	and.w	r1, r0, #15
 8001726:	4628      	mov	r0, r5
 8001728:	f001 fce2 	bl	80030f0 <_ux_hcd_stm32_asynch_queue_process>
                    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_GINTMSK, UX_HCD_STM32_OTG_FS_GINTMSK_RFXLVLM); 
 800172c:	2210      	movs	r2, #16
 800172e:	2118      	movs	r1, #24
 8001730:	4628      	mov	r0, r5
 8001732:	f000 f8bf 	bl	80018b4 <_ux_hcd_stm32_register_set>
                if ((interrupt_enable_register & UX_HCD_STM32_OTG_FS_GINTMSK_HCIM) && (interrupt_pending_register & UX_HCD_STM32_OTG_FS_GINTSTS_HCINT))
 8001736:	f01a 7f00 	tst.w	sl, #33554432	; 0x2000000
 800173a:	f47f af4c 	bne.w	80015d6 <_ux_hcd_stm32_interrupt_handler+0xaa>
 800173e:	e716      	b.n	800156e <_ux_hcd_stm32_interrupt_handler+0x42>
                    hcd -> ux_hcd_status =  UX_HCD_STATUS_DEAD;
 8001740:	2302      	movs	r3, #2
                    _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_hcd_semaphore);
 8001742:	f500 7030 	add.w	r0, r0, #704	; 0x2c0
                    hcd -> ux_hcd_status =  UX_HCD_STATUS_DEAD;
 8001746:	f8c8 3050 	str.w	r3, [r8, #80]	; 0x50
                    _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_hcd_semaphore);
 800174a:	f000 fcc5 	bl	80020d8 <_ux_utility_semaphore_put>
 800174e:	e71b      	b.n	8001588 <_ux_hcd_stm32_interrupt_handler+0x5c>
                        port_status_modify |= UX_HCD_STM32_OTG_FS_HPRT_PENCHNG;
 8001750:	f043 0308 	orr.w	r3, r3, #8
                        _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT, port_status_modify);                    
 8001754:	f44f 6188 	mov.w	r1, #1088	; 0x440
 8001758:	4628      	mov	r0, r5
 800175a:	461a      	mov	r2, r3
 800175c:	9301      	str	r3, [sp, #4]
 800175e:	f000 f8af 	bl	80018c0 <_ux_hcd_stm32_register_write>
 8001762:	9b01      	ldr	r3, [sp, #4]
 8001764:	e7a4      	b.n	80016b0 <_ux_hcd_stm32_interrupt_handler+0x184>
                        port_status_modify |= UX_HCD_STM32_OTG_FS_HPRT_PCDET;
 8001766:	f043 0302 	orr.w	r3, r3, #2
                        _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT, port_status_modify);                    
 800176a:	f44f 6188 	mov.w	r1, #1088	; 0x440
 800176e:	4628      	mov	r0, r5
 8001770:	461a      	mov	r2, r3
 8001772:	9301      	str	r3, [sp, #4]
 8001774:	f000 f8a4 	bl	80018c0 <_ux_hcd_stm32_register_write>
                        if (port_status & UX_HCD_STM32_OTG_FS_HPRT_PCSTS)
 8001778:	f019 0f01 	tst.w	r9, #1
 800177c:	9b01      	ldr	r3, [sp, #4]
 800177e:	d094      	beq.n	80016aa <_ux_hcd_stm32_interrupt_handler+0x17e>
                            if ((hcd_stm32 -> ux_hcd_stm32_controller_flag & UX_HCD_STM32_CONTROLLER_FLAG_DEVICE_ATTACHED) == 0)
 8001780:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
 8001784:	07d2      	lsls	r2, r2, #31
 8001786:	d490      	bmi.n	80016aa <_ux_hcd_stm32_interrupt_handler+0x17e>
                                hcd -> ux_hcd_root_hub_signal[0]++;
 8001788:	f8d8 2064 	ldr.w	r2, [r8, #100]	; 0x64
                                interrupt_pending_register &= ~UX_HCD_STM32_OTG_FS_GINTSTS_DISCINT;
 800178c:	f02b 5b00 	bic.w	fp, fp, #536870912	; 0x20000000
                                 _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_enum_semaphore);
 8001790:	6838      	ldr	r0, [r7, #0]
                                hcd -> ux_hcd_root_hub_signal[0]++;
 8001792:	3201      	adds	r2, #1
                                 _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_enum_semaphore);
 8001794:	f500 7080 	add.w	r0, r0, #256	; 0x100
                                hcd -> ux_hcd_root_hub_signal[0]++;
 8001798:	f8c8 2064 	str.w	r2, [r8, #100]	; 0x64
                                 _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_enum_semaphore);
 800179c:	f000 fc9c 	bl	80020d8 <_ux_utility_semaphore_put>
                                hcd_stm32 -> ux_hcd_stm32_controller_flag &= ~UX_HCD_STM32_CONTROLLER_FLAG_DEVICE_DETACHED;
 80017a0:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
 80017a4:	9b01      	ldr	r3, [sp, #4]
 80017a6:	f022 0202 	bic.w	r2, r2, #2
 80017aa:	f042 0201 	orr.w	r2, r2, #1
 80017ae:	f8c5 20e4 	str.w	r2, [r5, #228]	; 0xe4
 80017b2:	e77a      	b.n	80016aa <_ux_hcd_stm32_interrupt_handler+0x17e>
 80017b4:	20000db8 	.word	0x20000db8

080017b8 <_ux_hcd_stm32_periodic_tree_create>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_periodic_tree_create(UX_HCD_STM32 *hcd_stm32)
{
 80017b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80017bc:	4605      	mov	r5, r0
 80017be:	b0c0      	sub	sp, #256	; 0x100
UX_HCD_STM32_ED     *ed_list[32];
UX_HCD_STM32_ED     *ed_start_list[32];
    
    
    /* Start with the 1st list - it has 32 entries.  */
    list_entries =  32;
 80017c0:	f04f 0920 	mov.w	r9, #32

    /* Create each list one by one starting from the 32ms list.  */
    for (list_index = 0; list_index < 6; list_index++)
 80017c4:	f04f 0a00 	mov.w	sl, #0
            if (ed == UX_NULL)
                return(UX_NO_ED_AVAILABLE);

            /* Mark this anchor ED as static by putting it as SKIPPED, the STM32  controller will 
               not look into its tail and head list and will simply jump to the next ED.  */
            ed -> ux_stm32_ed_status =  UX_HCD_STM32_ED_STATIC;
 80017c8:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
        for (current_list_entry = 0; current_list_entry < list_entries; current_list_entry++)
 80017cc:	f1b9 0f00 	cmp.w	r9, #0
 80017d0:	d01c      	beq.n	800180c <_ux_hcd_stm32_periodic_tree_create+0x54>
 80017d2:	f1ba 0f00 	cmp.w	sl, #0
 80017d6:	d034      	beq.n	8001842 <_ux_hcd_stm32_periodic_tree_create+0x8a>
 80017d8:	ac01      	add	r4, sp, #4
 80017da:	466e      	mov	r6, sp
 80017dc:	eb04 07c9 	add.w	r7, r4, r9, lsl #3
 80017e0:	e00b      	b.n	80017fa <_ux_hcd_stm32_periodic_tree_create+0x42>
                ed_start_list[current_list_entry] =  ed;
            }
            else
            {

                ed_list[current_list_entry * 2] -> ux_stm32_ed_next_ed =  ed;
 80017e2:	f854 2c04 	ldr.w	r2, [r4, #-4]
                ed_list[(current_list_entry * 2) + 1] -> ux_stm32_ed_next_ed =  ed;
 80017e6:	f854 3b08 	ldr.w	r3, [r4], #8
            ed -> ux_stm32_ed_status =  UX_HCD_STM32_ED_STATIC;
 80017ea:	f8c0 8010 	str.w	r8, [r0, #16]
        for (current_list_entry = 0; current_list_entry < list_entries; current_list_entry++)
 80017ee:	42bc      	cmp	r4, r7
                ed_list[current_list_entry * 2] -> ux_stm32_ed_next_ed =  ed;
 80017f0:	6090      	str	r0, [r2, #8]
            }

            /* Memorize this ED in the local list. We do this operation now, otherwise
               we would erase the previous list eds.  */
            ed_list[current_list_entry] =  ed;
 80017f2:	f846 0b04 	str.w	r0, [r6], #4
                ed_list[(current_list_entry * 2) + 1] -> ux_stm32_ed_next_ed =  ed;
 80017f6:	6098      	str	r0, [r3, #8]
        for (current_list_entry = 0; current_list_entry < list_entries; current_list_entry++)
 80017f8:	d008      	beq.n	800180c <_ux_hcd_stm32_periodic_tree_create+0x54>
            ed =  _ux_hcd_stm32_ed_obtain(hcd_stm32);
 80017fa:	4628      	mov	r0, r5
 80017fc:	f001 fe7c 	bl	80034f8 <_ux_hcd_stm32_ed_obtain>
            if (ed == UX_NULL)
 8001800:	2800      	cmp	r0, #0
 8001802:	d1ee      	bne.n	80017e2 <_ux_hcd_stm32_periodic_tree_create+0x2a>
                return(UX_NO_ED_AVAILABLE);
 8001804:	2014      	movs	r0, #20
        hcd_stm32 -> ux_hcd_stm32_interrupt_ed_list[current_list_entry] =  ed;
    }

    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 8001806:	b040      	add	sp, #256	; 0x100
 8001808:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    for (list_index = 0; list_index < 6; list_index++)
 800180c:	f10a 0a01 	add.w	sl, sl, #1
        list_entries =  list_entries >> 1;
 8001810:	ea4f 0959 	mov.w	r9, r9, lsr #1
    for (list_index = 0; list_index < 6; list_index++)
 8001814:	f1ba 0f06 	cmp.w	sl, #6
 8001818:	d1d8      	bne.n	80017cc <_ux_hcd_stm32_periodic_tree_create+0x14>
 800181a:	4a16      	ldr	r2, [pc, #88]	; (8001874 <_ux_hcd_stm32_periodic_tree_create+0xbc>)
 800181c:	f105 001c 	add.w	r0, r5, #28
 8001820:	f102 0180 	add.w	r1, r2, #128	; 0x80
        ed =  ed_start_list[_ux_system_host_hcd_periodic_tree_entries[current_list_entry]];
 8001824:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8001828:	ac40      	add	r4, sp, #256	; 0x100
 800182a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    for (current_list_entry = 0; current_list_entry < 32; current_list_entry++)
 800182e:	428a      	cmp	r2, r1
        hcd_stm32 -> ux_hcd_stm32_interrupt_ed_list[current_list_entry] =  ed;
 8001830:	f853 3c80 	ldr.w	r3, [r3, #-128]
 8001834:	f840 3f04 	str.w	r3, [r0, #4]!
    for (current_list_entry = 0; current_list_entry < 32; current_list_entry++)
 8001838:	d1f4      	bne.n	8001824 <_ux_hcd_stm32_periodic_tree_create+0x6c>
    return(UX_SUCCESS);
 800183a:	2000      	movs	r0, #0
}
 800183c:	b040      	add	sp, #256	; 0x100
 800183e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001842:	ac20      	add	r4, sp, #128	; 0x80
 8001844:	466e      	mov	r6, sp
 8001846:	eb04 0789 	add.w	r7, r4, r9, lsl #2
 800184a:	e007      	b.n	800185c <_ux_hcd_stm32_periodic_tree_create+0xa4>
                ed_start_list[current_list_entry] =  ed;
 800184c:	f844 0b04 	str.w	r0, [r4], #4
        for (current_list_entry = 0; current_list_entry < list_entries; current_list_entry++)
 8001850:	42bc      	cmp	r4, r7
            ed -> ux_stm32_ed_status =  UX_HCD_STM32_ED_STATIC;
 8001852:	f8c0 8010 	str.w	r8, [r0, #16]
            ed_list[current_list_entry] =  ed;
 8001856:	f846 0b04 	str.w	r0, [r6], #4
        for (current_list_entry = 0; current_list_entry < list_entries; current_list_entry++)
 800185a:	d005      	beq.n	8001868 <_ux_hcd_stm32_periodic_tree_create+0xb0>
            ed =  _ux_hcd_stm32_ed_obtain(hcd_stm32);
 800185c:	4628      	mov	r0, r5
 800185e:	f001 fe4b 	bl	80034f8 <_ux_hcd_stm32_ed_obtain>
            if (ed == UX_NULL)
 8001862:	2800      	cmp	r0, #0
 8001864:	d1f2      	bne.n	800184c <_ux_hcd_stm32_periodic_tree_create+0x94>
 8001866:	e7cd      	b.n	8001804 <_ux_hcd_stm32_periodic_tree_create+0x4c>
        list_entries =  list_entries >> 1;
 8001868:	ea4f 0959 	mov.w	r9, r9, lsr #1
    for (list_index = 0; list_index < 6; list_index++)
 800186c:	f04f 0a01 	mov.w	sl, #1
 8001870:	e7ac      	b.n	80017cc <_ux_hcd_stm32_periodic_tree_create+0x14>
 8001872:	bf00      	nop
 8001874:	20000028 	.word	0x20000028

08001878 <_ux_hcd_stm32_power_on_port>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_power_on_port(UX_HCD_STM32 *hcd_stm32, ULONG port_index)
{
 8001878:	b510      	push	{r4, lr}

    /* Check to see if this port is valid on this controller.  On STM32, there is only one. */
    if (port_index != 0)
 800187a:	b941      	cbnz	r1, 800188e <_ux_hcd_stm32_power_on_port+0x16>
 800187c:	460c      	mov	r4, r1

        return(UX_PORT_INDEX_UNKNOWN);
    }
    
    /* Set the power to the port.  */
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT, UX_HCD_STM32_OTG_FS_HPRT_PPWR);    
 800187e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001882:	f44f 6188 	mov.w	r1, #1088	; 0x440
 8001886:	f000 f815 	bl	80018b4 <_ux_hcd_stm32_register_set>

    /* This function never fails.  */
    return(UX_SUCCESS);
 800188a:	4620      	mov	r0, r4
}
 800188c:	bd10      	pop	{r4, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HCD, UX_PORT_INDEX_UNKNOWN);
 800188e:	2256      	movs	r2, #86	; 0x56
 8001890:	2101      	movs	r1, #1
 8001892:	2002      	movs	r0, #2
 8001894:	f000 f9b4 	bl	8001c00 <_ux_system_error_handler>
        return(UX_PORT_INDEX_UNKNOWN);
 8001898:	2056      	movs	r0, #86	; 0x56
}
 800189a:	bd10      	pop	{r4, pc}

0800189c <_ux_hcd_stm32_register_clear>:
/*                                                                        */
/**************************************************************************/
VOID  _ux_hcd_stm32_register_clear(UX_HCD_STM32 *hcd_stm32, ULONG stm32_register, ULONG value)
{
    
    *((ULONG *) (hcd_stm32 -> ux_hcd_stm32_base + stm32_register)) &=~ value;
 800189c:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 80018a0:	580b      	ldr	r3, [r1, r0]
 80018a2:	ea23 0202 	bic.w	r2, r3, r2
 80018a6:	500a      	str	r2, [r1, r0]
    return;
}
 80018a8:	4770      	bx	lr
 80018aa:	bf00      	nop

080018ac <_ux_hcd_stm32_register_read>:
/*                                                                        */
/**************************************************************************/
ULONG  _ux_hcd_stm32_register_read(UX_HCD_STM32 *hcd_stm32, ULONG stm32_register)
{

    return((ULONG)(*((ULONG *) (hcd_stm32 -> ux_hcd_stm32_base + stm32_register))));
 80018ac:	f8d0 30ec 	ldr.w	r3, [r0, #236]	; 0xec
}
 80018b0:	5858      	ldr	r0, [r3, r1]
 80018b2:	4770      	bx	lr

080018b4 <_ux_hcd_stm32_register_set>:
/*                                                                        */
/**************************************************************************/
VOID  _ux_hcd_stm32_register_set(UX_HCD_STM32 *hcd_stm32, ULONG stm32_register, ULONG value)
{
    
    *((ULONG *) (hcd_stm32 -> ux_hcd_stm32_base + stm32_register)) |=  value;
 80018b4:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 80018b8:	580b      	ldr	r3, [r1, r0]
 80018ba:	431a      	orrs	r2, r3
 80018bc:	500a      	str	r2, [r1, r0]
    return;
}
 80018be:	4770      	bx	lr

080018c0 <_ux_hcd_stm32_register_write>:
/**************************************************************************/
VOID  _ux_hcd_stm32_register_write(UX_HCD_STM32 *hcd_stm32, ULONG stm32_register, ULONG value)
{

    /* Write to the register.  */
    *((ULONG *) (hcd_stm32 -> ux_hcd_stm32_base + stm32_register)) =  value;
 80018c0:	f8d0 30ec 	ldr.w	r3, [r0, #236]	; 0xec
 80018c4:	505a      	str	r2, [r3, r1]

    /* Return to caller. */
    return;
}
 80018c6:	4770      	bx	lr

080018c8 <_ux_host_stack_class_get>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_class_get(UCHAR *class_name, UX_HOST_CLASS **host_class)
{
 80018c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80018cc:	b082      	sub	sp, #8

UX_HOST_CLASS       *class_ptr;
ULONG               class_index;
UINT                status;
UINT                class_name_length =  0;
 80018ce:	2400      	movs	r4, #0
{
 80018d0:	460e      	mov	r6, r1


    /* Get the length of the class name (exclude null-terminator).  */
    status =  _ux_utility_string_length_check(class_name, &class_name_length, UX_MAX_CLASS_NAME_LENGTH);
 80018d2:	223f      	movs	r2, #63	; 0x3f
UINT                class_name_length =  0;
 80018d4:	ab02      	add	r3, sp, #8
{
 80018d6:	4607      	mov	r7, r0
UINT                class_name_length =  0;
 80018d8:	f843 4d04 	str.w	r4, [r3, #-4]!
    status =  _ux_utility_string_length_check(class_name, &class_name_length, UX_MAX_CLASS_NAME_LENGTH);
 80018dc:	4619      	mov	r1, r3
 80018de:	f000 fbfd 	bl	80020dc <_ux_utility_string_length_check>
    if (status)
 80018e2:	bb00      	cbnz	r0, 8001926 <_ux_host_stack_class_get+0x5e>
        return(status);

    /* We need to parse the class driver table.  */
    class_ptr =  _ux_system_host -> ux_system_host_class_array;
 80018e4:	f8df 8048 	ldr.w	r8, [pc, #72]	; 8001930 <_ux_host_stack_class_get+0x68>
 80018e8:	f8d8 3000 	ldr.w	r3, [r8]
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 80018ec:	681a      	ldr	r2, [r3, #0]
    class_ptr =  _ux_system_host -> ux_system_host_class_array;
 80018ee:	689c      	ldr	r4, [r3, #8]
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 80018f0:	b1c2      	cbz	r2, 8001924 <_ux_host_stack_class_get+0x5c>
 80018f2:	4605      	mov	r5, r0
 80018f4:	e004      	b.n	8001900 <_ux_host_stack_class_get+0x38>
 80018f6:	3501      	adds	r5, #1
                return(UX_SUCCESS);
            }
        }

        /* Move to the next class.  */
        class_ptr++;
 80018f8:	f504 7494 	add.w	r4, r4, #296	; 0x128
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 80018fc:	4295      	cmp	r5, r2
 80018fe:	d211      	bcs.n	8001924 <_ux_host_stack_class_get+0x5c>
        if (class_ptr -> ux_host_class_status == UX_USED)
 8001900:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001902:	2b01      	cmp	r3, #1
 8001904:	d1f7      	bne.n	80018f6 <_ux_host_stack_class_get+0x2e>
            if (_ux_utility_memory_compare(class_ptr -> ux_host_class_name, class_name, class_name_length + 1) == UX_SUCCESS)
 8001906:	9a01      	ldr	r2, [sp, #4]
 8001908:	4639      	mov	r1, r7
 800190a:	4620      	mov	r0, r4
 800190c:	3201      	adds	r2, #1
 800190e:	f000 fa7b 	bl	8001e08 <_ux_utility_memory_compare>
 8001912:	b158      	cbz	r0, 800192c <_ux_host_stack_class_get+0x64>
 8001914:	f8d8 3000 	ldr.w	r3, [r8]
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 8001918:	3501      	adds	r5, #1
        class_ptr++;
 800191a:	f504 7494 	add.w	r4, r4, #296	; 0x128
 800191e:	681a      	ldr	r2, [r3, #0]
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 8001920:	4295      	cmp	r5, r2
 8001922:	d3ed      	bcc.n	8001900 <_ux_host_stack_class_get+0x38>

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_UNKNOWN, class_name, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* This class does not exist, return an error.  */    
    return(UX_HOST_CLASS_UNKNOWN);
 8001924:	2059      	movs	r0, #89	; 0x59
}
 8001926:	b002      	add	sp, #8
 8001928:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                *host_class =  class_ptr;
 800192c:	6034      	str	r4, [r6, #0]
                return(UX_SUCCESS);
 800192e:	e7fa      	b.n	8001926 <_ux_host_stack_class_get+0x5e>
 8001930:	20000db8 	.word	0x20000db8

08001934 <_ux_host_stack_class_instance_get>:
    
VOID    **current_class_instance;
    

    /* Start with the first class instance attached to the class container.  */
    current_class_instance =  host_class -> ux_host_class_first_instance;
 8001934:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    
    /* Check if there are any instances attached.  */
    if(current_class_instance == UX_NULL)
 8001936:	b123      	cbz	r3, 8001942 <_ux_host_stack_class_instance_get+0xe>

        return(UX_HOST_CLASS_INSTANCE_UNKNOWN);
    }

    /* Traverse the list of the class instances until we found the right one.  */        
    while (class_index-- != 0)
 8001938:	b129      	cbz	r1, 8001946 <_ux_host_stack_class_instance_get+0x12>
    {

        /* Points to the next class instance.  */
        current_class_instance =  *current_class_instance;
 800193a:	681b      	ldr	r3, [r3, #0]
 800193c:	3901      	subs	r1, #1

        /* Check if we have reached the end of the list of the class instances.  */
        if (current_class_instance == UX_NULL)
 800193e:	2b00      	cmp	r3, #0
 8001940:	d1fa      	bne.n	8001938 <_ux_host_stack_class_instance_get+0x4>
        return(UX_HOST_CLASS_INSTANCE_UNKNOWN);
 8001942:	205b      	movs	r0, #91	; 0x5b
    /* Update the class instance pointer from the caller.  */
    *class_instance =  current_class_instance;
    
    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 8001944:	4770      	bx	lr
    *class_instance =  current_class_instance;
 8001946:	6013      	str	r3, [r2, #0]
    return(UX_SUCCESS);
 8001948:	4608      	mov	r0, r1
 800194a:	4770      	bx	lr

0800194c <_ux_host_stack_class_register>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_class_register(UCHAR *class_name,
                        UINT (*class_entry_function)(struct UX_HOST_CLASS_COMMAND_STRUCT *))
{
 800194c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800194e:	b083      	sub	sp, #12

UX_HOST_CLASS       *class;
ULONG               class_index;
UINT                status;
UINT                class_name_length =  0;
 8001950:	2400      	movs	r4, #0
{
 8001952:	460d      	mov	r5, r1


    /* Get the length of the class name (exclude null-terminator).  */
    status =  _ux_utility_string_length_check(class_name, &class_name_length, UX_MAX_CLASS_NAME_LENGTH);
 8001954:	223f      	movs	r2, #63	; 0x3f
UINT                class_name_length =  0;
 8001956:	ab02      	add	r3, sp, #8
{
 8001958:	4607      	mov	r7, r0
UINT                class_name_length =  0;
 800195a:	f843 4d04 	str.w	r4, [r3, #-4]!
    status =  _ux_utility_string_length_check(class_name, &class_name_length, UX_MAX_CLASS_NAME_LENGTH);
 800195e:	4619      	mov	r1, r3
 8001960:	f000 fbbc 	bl	80020dc <_ux_utility_string_length_check>
    if (status)
 8001964:	4606      	mov	r6, r0
 8001966:	b9d8      	cbnz	r0, 80019a0 <_ux_host_stack_class_register+0x54>
        return(status);

    /* We need to parse the class table to find an empty spot.  */
    class =  _ux_system_host -> ux_system_host_class_array;
 8001968:	4b19      	ldr	r3, [pc, #100]	; (80019d0 <_ux_host_stack_class_register+0x84>)
 800196a:	681b      	ldr	r3, [r3, #0]
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 800196c:	6819      	ldr	r1, [r3, #0]
    class =  _ux_system_host -> ux_system_host_class_array;
 800196e:	689c      	ldr	r4, [r3, #8]
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 8001970:	b181      	cbz	r1, 8001994 <_ux_host_stack_class_register+0x48>
    {

        /* Check if this class is already used.  */
        if (class -> ux_host_class_status == UX_UNUSED)
 8001972:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001974:	b1bb      	cbz	r3, 80019a6 <_ux_host_stack_class_register+0x5a>
           mistake. To verify this, we simple check for the class entry point.  */
        else
        {

            /* Check for an already installed class entry function.  */
            if(class -> ux_host_class_entry_function == class_entry_function)
 8001976:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001978:	429d      	cmp	r5, r3
 800197a:	d020      	beq.n	80019be <_ux_host_stack_class_register+0x72>
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 800197c:	4603      	mov	r3, r0
 800197e:	e004      	b.n	800198a <_ux_host_stack_class_register+0x3e>
        if (class -> ux_host_class_status == UX_UNUSED)
 8001980:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001982:	b182      	cbz	r2, 80019a6 <_ux_host_stack_class_register+0x5a>
            if(class -> ux_host_class_entry_function == class_entry_function)
 8001984:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8001986:	42aa      	cmp	r2, r5
 8001988:	d019      	beq.n	80019be <_ux_host_stack_class_register+0x72>
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 800198a:	3301      	adds	r3, #1
                return(UX_HOST_CLASS_ALREADY_INSTALLED);
            }
        }

        /* Move to the next class.  */
        class++;
 800198c:	f504 7494 	add.w	r4, r4, #296	; 0x128
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 8001990:	428b      	cmp	r3, r1
 8001992:	d1f5      	bne.n	8001980 <_ux_host_stack_class_register+0x34>

    /* Error trap. */
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_INIT, UX_MEMORY_ARRAY_FULL);

    /* No more entries in the class table.  */
    return(UX_MEMORY_ARRAY_FULL);
 8001994:	261a      	movs	r6, #26
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_INIT, UX_MEMORY_ARRAY_FULL);
 8001996:	2103      	movs	r1, #3
 8001998:	2002      	movs	r0, #2
 800199a:	4632      	mov	r2, r6
 800199c:	f000 f930 	bl	8001c00 <_ux_system_error_handler>
}
 80019a0:	4630      	mov	r0, r6
 80019a2:	b003      	add	sp, #12
 80019a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            _ux_utility_memory_copy(class -> ux_host_class_name, class_name, class_name_length + 1);
 80019a6:	9a01      	ldr	r2, [sp, #4]
 80019a8:	4620      	mov	r0, r4
 80019aa:	4639      	mov	r1, r7
 80019ac:	3201      	adds	r2, #1
 80019ae:	f000 fa47 	bl	8001e40 <_ux_utility_memory_copy>
            class -> ux_host_class_status =  UX_USED;
 80019b2:	2301      	movs	r3, #1
}
 80019b4:	4630      	mov	r0, r6
            class -> ux_host_class_status =  UX_USED;
 80019b6:	e9c4 3510 	strd	r3, r5, [r4, #64]	; 0x40
}
 80019ba:	b003      	add	sp, #12
 80019bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_INIT, UX_HOST_CLASS_ALREADY_INSTALLED);
 80019be:	2258      	movs	r2, #88	; 0x58
 80019c0:	2103      	movs	r1, #3
 80019c2:	2002      	movs	r0, #2
                return(UX_HOST_CLASS_ALREADY_INSTALLED);
 80019c4:	4616      	mov	r6, r2
                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_INIT, UX_HOST_CLASS_ALREADY_INSTALLED);
 80019c6:	f000 f91b 	bl	8001c00 <_ux_system_error_handler>
}
 80019ca:	4630      	mov	r0, r6
 80019cc:	b003      	add	sp, #12
 80019ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80019d0:	20000db8 	.word	0x20000db8

080019d4 <_ux_host_stack_hcd_register>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_hcd_register(UCHAR *hcd_name,
                                    UINT (*hcd_init_function)(struct UX_HCD_STRUCT *), ULONG hcd_param1, ULONG hcd_param2)
{
 80019d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80019d8:	b083      	sub	sp, #12

UX_HCD      *hcd;
ULONG       hcd_index;
UINT        status;
UINT        hcd_name_length =  0;
 80019da:	2600      	movs	r6, #0
{
 80019dc:	460d      	mov	r5, r1
 80019de:	4617      	mov	r7, r2
UINT        hcd_name_length =  0;
 80019e0:	ac02      	add	r4, sp, #8

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_HCD_REGISTER, hcd_name, 0, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    /* Get the length of the class name (exclude null-terminator).  */
    status =  _ux_utility_string_length_check(hcd_name, &hcd_name_length, UX_MAX_HCD_NAME_LENGTH);
 80019e2:	223f      	movs	r2, #63	; 0x3f
{
 80019e4:	4680      	mov	r8, r0
UINT        hcd_name_length =  0;
 80019e6:	f844 6d04 	str.w	r6, [r4, #-4]!
    status =  _ux_utility_string_length_check(hcd_name, &hcd_name_length, UX_MAX_HCD_NAME_LENGTH);
 80019ea:	4621      	mov	r1, r4
{
 80019ec:	461e      	mov	r6, r3
    status =  _ux_utility_string_length_check(hcd_name, &hcd_name_length, UX_MAX_HCD_NAME_LENGTH);
 80019ee:	f000 fb75 	bl	80020dc <_ux_utility_string_length_check>
    if (status)
 80019f2:	b938      	cbnz	r0, 8001a04 <_ux_host_stack_hcd_register+0x30>
        return(status);

    /* We need to parse the controller driver table to find an empty spot.  */
    hcd =  _ux_system_host -> ux_system_host_hcd_array;
 80019f4:	f8df 904c 	ldr.w	r9, [pc, #76]	; 8001a44 <_ux_host_stack_hcd_register+0x70>
 80019f8:	f8d9 3000 	ldr.w	r3, [r9]
 80019fc:	e9d3 2403 	ldrd	r2, r4, [r3, #12]
    for(hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_max_hcd; hcd_index++)
 8001a00:	b93a      	cbnz	r2, 8001a12 <_ux_host_stack_hcd_register+0x3e>
        /* Try the next HCD structure */
        hcd++;            
    }    

    /* We have exhausted the array of the HCDs, return an error.  */
    return(UX_MEMORY_INSUFFICIENT);
 8001a02:	2012      	movs	r0, #18
}
 8001a04:	b003      	add	sp, #12
 8001a06:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    for(hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_max_hcd; hcd_index++)
 8001a0a:	3001      	adds	r0, #1
        hcd++;            
 8001a0c:	34cc      	adds	r4, #204	; 0xcc
    for(hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_max_hcd; hcd_index++)
 8001a0e:	4290      	cmp	r0, r2
 8001a10:	d0f7      	beq.n	8001a02 <_ux_host_stack_hcd_register+0x2e>
        if(hcd -> ux_hcd_status == UX_UNUSED)
 8001a12:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8001a14:	2b00      	cmp	r3, #0
 8001a16:	d1f8      	bne.n	8001a0a <_ux_host_stack_hcd_register+0x36>
            _ux_utility_memory_copy(hcd -> ux_hcd_name, hcd_name, hcd_name_length + 1);
 8001a18:	9a01      	ldr	r2, [sp, #4]
 8001a1a:	4641      	mov	r1, r8
 8001a1c:	4620      	mov	r0, r4
 8001a1e:	3201      	adds	r2, #1
 8001a20:	f000 fa0e 	bl	8001e40 <_ux_utility_memory_copy>
            _ux_system_host -> ux_system_host_registered_hcd++;
 8001a24:	f8d9 2000 	ldr.w	r2, [r9]
            hcd -> ux_hcd_status =  UX_USED;
 8001a28:	2101      	movs	r1, #1
            hcd -> ux_hcd_io =   hcd_param1;
 8001a2a:	f8c4 70b4 	str.w	r7, [r4, #180]	; 0xb4
            _ux_system_host -> ux_system_host_registered_hcd++;
 8001a2e:	6953      	ldr	r3, [r2, #20]
            status =  hcd_init_function(hcd);
 8001a30:	4620      	mov	r0, r4
            hcd -> ux_hcd_irq =  hcd_param2;
 8001a32:	65e6      	str	r6, [r4, #92]	; 0x5c
            _ux_system_host -> ux_system_host_registered_hcd++;
 8001a34:	440b      	add	r3, r1
            hcd -> ux_hcd_status =  UX_USED;
 8001a36:	6521      	str	r1, [r4, #80]	; 0x50
            _ux_system_host -> ux_system_host_registered_hcd++;
 8001a38:	6153      	str	r3, [r2, #20]
            status =  hcd_init_function(hcd);
 8001a3a:	47a8      	blx	r5
}
 8001a3c:	b003      	add	sp, #12
 8001a3e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001a42:	bf00      	nop
 8001a44:	20000db8 	.word	0x20000db8

08001a48 <_ux_host_stack_initialize>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_initialize(UINT (*ux_system_host_change_function)(ULONG, UX_HOST_CLASS *, VOID *))
{
 8001a48:	b5f0      	push	{r4, r5, r6, r7, lr}
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_INITIALIZE, 0, 0, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    /* Initialize some of the global so that we don't have to recompile the
       core code when one item is adjusted.  */
    _ux_system_host -> ux_system_host_max_class =     UX_MAX_CLASS_DRIVER;
 8001a4a:	4d66      	ldr	r5, [pc, #408]	; (8001be4 <_ux_host_stack_initialize+0x19c>)
 8001a4c:	2208      	movs	r2, #8
    _ux_system_host -> ux_system_host_max_hcd =       UX_MAX_HCD;
    _ux_system_host -> ux_system_host_max_devices =   UX_MAX_DEVICES;
    _ux_system_host -> ux_system_host_max_ed =        UX_MAX_ED;
 8001a4e:	f04f 0c50 	mov.w	ip, #80	; 0x50
    _ux_system_host -> ux_system_host_max_td =        UX_MAX_TD;
 8001a52:	2720      	movs	r7, #32
    _ux_system_host -> ux_system_host_max_class =     UX_MAX_CLASS_DRIVER;
 8001a54:	682b      	ldr	r3, [r5, #0]
    _ux_system_host -> ux_system_host_max_iso_td =    UX_MAX_ISO_TD;
 8001a56:	2480      	movs	r4, #128	; 0x80
    _ux_system_host -> ux_system_host_max_hcd =       UX_MAX_HCD;
 8001a58:	2602      	movs	r6, #2
    _ux_system_host -> ux_system_host_change_function =  ux_system_host_change_function;

    /* Allocate memory for the HCDs.
     * sizeof(UX_HCD)*UX_MAX_HCD overflow is checked outside of the function.
     */
    memory =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD)*UX_MAX_HCD);
 8001a5a:	2100      	movs	r1, #0
{
 8001a5c:	b087      	sub	sp, #28
    _ux_system_host -> ux_system_host_change_function =  ux_system_host_change_function;
 8001a5e:	f8c3 02e0 	str.w	r0, [r3, #736]	; 0x2e0
    _ux_system_host -> ux_system_host_max_class =     UX_MAX_CLASS_DRIVER;
 8001a62:	601a      	str	r2, [r3, #0]
    memory =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD)*UX_MAX_HCD);
 8001a64:	4608      	mov	r0, r1
    _ux_system_host -> ux_system_host_max_devices =   UX_MAX_DEVICES;
 8001a66:	61da      	str	r2, [r3, #28]
    memory =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD)*UX_MAX_HCD);
 8001a68:	f44f 72cc 	mov.w	r2, #408	; 0x198
    _ux_system_host -> ux_system_host_max_iso_td =    UX_MAX_ISO_TD;
 8001a6c:	629c      	str	r4, [r3, #40]	; 0x28
    _ux_system_host -> ux_system_host_max_hcd =       UX_MAX_HCD;
 8001a6e:	60de      	str	r6, [r3, #12]
    _ux_system_host -> ux_system_host_max_td =        UX_MAX_TD;
 8001a70:	e9c3 c708 	strd	ip, r7, [r3, #32]
    memory =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HCD)*UX_MAX_HCD);
 8001a74:	f000 f93a 	bl	8001cec <_ux_utility_memory_allocate>

    /* Check for successful allocation.  */
    if (memory == UX_NULL)
 8001a78:	2800      	cmp	r0, #0
 8001a7a:	f000 80a9 	beq.w	8001bd0 <_ux_host_stack_initialize+0x188>

    /* Set to success by default.  */
    status = UX_SUCCESS;

    /* Store memory in system structure.  */
    _ux_system_host -> ux_system_host_hcd_array =  (UX_HCD *) memory;
 8001a7e:	682b      	ldr	r3, [r5, #0]

    /* Allocate memory for the classes.
     * sizeof(UX_HOST_CLASS)*UX_MAX_CLASS_DRIVER overflow is checked outside of the function.
     */
    memory =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HOST_CLASS)*UX_MAX_CLASS_DRIVER);
 8001a80:	2100      	movs	r1, #0
 8001a82:	f44f 6214 	mov.w	r2, #2368	; 0x940
    _ux_system_host -> ux_system_host_hcd_array =  (UX_HCD *) memory;
 8001a86:	6118      	str	r0, [r3, #16]
    memory =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HOST_CLASS)*UX_MAX_CLASS_DRIVER);
 8001a88:	4608      	mov	r0, r1
 8001a8a:	f000 f92f 	bl	8001cec <_ux_utility_memory_allocate>

    /* Check for successful allocation.  */
    if (memory == UX_NULL)
 8001a8e:	2800      	cmp	r0, #0
 8001a90:	d076      	beq.n	8001b80 <_ux_host_stack_initialize+0x138>
        status = UX_MEMORY_INSUFFICIENT;
    else

        /* Store memory in system structure.  */
        _ux_system_host -> ux_system_host_class_array =  (UX_HOST_CLASS *) memory;
 8001a92:	682b      	ldr	r3, [r5, #0]
    /* Allocate memory for the device containers.
     * sizeof(UX_DEVICE)*UX_MAX_DEVICES overflow is checked outside of the function.
     */
    if (status == UX_SUCCESS)
    {
        memory =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_DEVICE)*UX_MAX_DEVICES);
 8001a94:	2100      	movs	r1, #0
 8001a96:	f44f 6236 	mov.w	r2, #2912	; 0xb60
        _ux_system_host -> ux_system_host_class_array =  (UX_HOST_CLASS *) memory;
 8001a9a:	6098      	str	r0, [r3, #8]
        memory =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_DEVICE)*UX_MAX_DEVICES);
 8001a9c:	4608      	mov	r0, r1
 8001a9e:	f000 f925 	bl	8001cec <_ux_utility_memory_allocate>

        /* Check for successful allocation.  */
        if(memory == UX_NULL)
 8001aa2:	2800      	cmp	r0, #0
 8001aa4:	d06c      	beq.n	8001b80 <_ux_host_stack_initialize+0x138>
            status = UX_MEMORY_INSUFFICIENT;
        else

            /* Store memory in system structure.  */
            _ux_system_host -> ux_system_host_device_array =  (UX_DEVICE *) memory;
 8001aa6:	682f      	ldr	r7, [r5, #0]
    }

    /* Obtain enough stack for the two USBX host threads.  */
    if (status == UX_SUCCESS)
    {
        _ux_system_host -> ux_system_host_enum_thread_stack =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY,
 8001aa8:	2100      	movs	r1, #0
 8001aaa:	f44f 6200 	mov.w	r2, #2048	; 0x800
            _ux_system_host -> ux_system_host_device_array =  (UX_DEVICE *) memory;
 8001aae:	61b8      	str	r0, [r7, #24]
        _ux_system_host -> ux_system_host_enum_thread_stack =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY,
 8001ab0:	4608      	mov	r0, r1
 8001ab2:	f000 f91b 	bl	8001cec <_ux_utility_memory_allocate>
                                                                            UX_HOST_ENUM_THREAD_STACK_SIZE);

        /* Check for successful allocation.  */
        if (_ux_system_host -> ux_system_host_enum_thread_stack == UX_NULL)
 8001ab6:	682c      	ldr	r4, [r5, #0]
        _ux_system_host -> ux_system_host_enum_thread_stack =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY,
 8001ab8:	6338      	str	r0, [r7, #48]	; 0x30
        if (_ux_system_host -> ux_system_host_enum_thread_stack == UX_NULL)
 8001aba:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001abc:	2b00      	cmp	r3, #0
 8001abe:	f000 808b 	beq.w	8001bd8 <_ux_host_stack_initialize+0x190>
    }

    /* Allocate another stack area.  */
    if (status == UX_SUCCESS)
    {
        _ux_system_host -> ux_system_host_hcd_thread_stack =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY,
 8001ac2:	2100      	movs	r1, #0
 8001ac4:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001ac8:	4608      	mov	r0, r1
 8001aca:	f000 f90f 	bl	8001cec <_ux_utility_memory_allocate>
 8001ace:	f8c4 0124 	str.w	r0, [r4, #292]	; 0x124
                                                                            UX_HOST_HCD_THREAD_STACK_SIZE);

        /* Check for successful allocation.  */
        if (_ux_system_host -> ux_system_host_hcd_thread_stack == UX_NULL)
 8001ad2:	682c      	ldr	r4, [r5, #0]
 8001ad4:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 8001ad8:	2b00      	cmp	r3, #0
 8001ada:	d07d      	beq.n	8001bd8 <_ux_host_stack_initialize+0x190>
    }

    /* Create the semaphores used by the hub and root hub to awake the enumeration thread.  */
    if (status == UX_SUCCESS)
    {
        status =  _ux_utility_semaphore_create(&_ux_system_host -> ux_system_host_enum_semaphore, "ux_system_host_enum_semaphore", 0);
 8001adc:	2200      	movs	r2, #0
 8001ade:	f504 7080 	add.w	r0, r4, #256	; 0x100
 8001ae2:	4941      	ldr	r1, [pc, #260]	; (8001be8 <_ux_host_stack_initialize+0x1a0>)
 8001ae4:	f000 fac4 	bl	8002070 <_ux_utility_semaphore_create>
        if(status != UX_SUCCESS)
 8001ae8:	4602      	mov	r2, r0
 8001aea:	2800      	cmp	r0, #0
 8001aec:	d176      	bne.n	8001bdc <_ux_host_stack_initialize+0x194>
    }

    /* Create the semaphores used by the HCD to perform the completion phase of transfer_requests.  */
    if (status == UX_SUCCESS)
    {
        status =  _ux_utility_semaphore_create(&_ux_system_host -> ux_system_host_hcd_semaphore, "ux_system_host_hcd_semaphore", 0);
 8001aee:	6828      	ldr	r0, [r5, #0]
 8001af0:	493e      	ldr	r1, [pc, #248]	; (8001bec <_ux_host_stack_initialize+0x1a4>)
 8001af2:	f500 7030 	add.w	r0, r0, #704	; 0x2c0
 8001af6:	f000 fabb 	bl	8002070 <_ux_utility_semaphore_create>
        if(status != UX_SUCCESS)
 8001afa:	4603      	mov	r3, r0
 8001afc:	2800      	cmp	r0, #0
 8001afe:	d16d      	bne.n	8001bdc <_ux_host_stack_initialize+0x194>
    }

    /* Create the enumeration thread of USBX.  */
    if (status == UX_SUCCESS)
    {
        status =  _ux_utility_thread_create(&_ux_system_host -> ux_system_host_enum_thread, "ux_system_host_enum_thread", _ux_host_stack_enum_thread_entry,
 8001b00:	682a      	ldr	r2, [r5, #0]
 8001b02:	2114      	movs	r1, #20
 8001b04:	2701      	movs	r7, #1
 8001b06:	f44f 6400 	mov.w	r4, #2048	; 0x800
 8001b0a:	e9cd 0704 	strd	r0, r7, [sp, #16]
 8001b0e:	e9cd 1102 	strd	r1, r1, [sp, #8]
 8001b12:	9401      	str	r4, [sp, #4]
 8001b14:	f102 0038 	add.w	r0, r2, #56	; 0x38
 8001b18:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8001b1a:	4a35      	ldr	r2, [pc, #212]	; (8001bf0 <_ux_host_stack_initialize+0x1a8>)
 8001b1c:	9100      	str	r1, [sp, #0]
 8001b1e:	4935      	ldr	r1, [pc, #212]	; (8001bf4 <_ux_host_stack_initialize+0x1ac>)
 8001b20:	f000 faf6 	bl	8002110 <_ux_utility_thread_create>
                            0, _ux_system_host -> ux_system_host_enum_thread_stack,
                            UX_HOST_ENUM_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_ENUM,
                            UX_THREAD_PRIORITY_ENUM, UX_NO_TIME_SLICE, TX_AUTO_START);
                            
        /* Check the completion status.  */
        if(status != UX_SUCCESS)
 8001b24:	b990      	cbnz	r0, 8001b4c <_ux_host_stack_initialize+0x104>
    }

    /* Create the HCD thread of USBX.  */
    if (status == UX_SUCCESS)
    {
        status =  _ux_utility_thread_create(&_ux_system_host -> ux_system_host_hcd_thread, "ux_host_stack_hcd_thread", _ux_host_stack_hcd_thread_entry,
 8001b26:	682a      	ldr	r2, [r5, #0]
 8001b28:	4603      	mov	r3, r0
 8001b2a:	9004      	str	r0, [sp, #16]
 8001b2c:	9705      	str	r7, [sp, #20]
 8001b2e:	f502 7094 	add.w	r0, r2, #296	; 0x128
 8001b32:	9401      	str	r4, [sp, #4]
 8001b34:	e9cd 6602 	strd	r6, r6, [sp, #8]
 8001b38:	f8d2 1124 	ldr.w	r1, [r2, #292]	; 0x124
 8001b3c:	4a2e      	ldr	r2, [pc, #184]	; (8001bf8 <_ux_host_stack_initialize+0x1b0>)
 8001b3e:	9100      	str	r1, [sp, #0]
 8001b40:	492e      	ldr	r1, [pc, #184]	; (8001bfc <_ux_host_stack_initialize+0x1b4>)
 8001b42:	f000 fae5 	bl	8002110 <_ux_utility_thread_create>
                            0, _ux_system_host -> ux_system_host_hcd_thread_stack,
                            UX_HOST_HCD_THREAD_STACK_SIZE, UX_THREAD_PRIORITY_HCD,
                            UX_THREAD_PRIORITY_HCD, UX_NO_TIME_SLICE,TX_AUTO_START);

        /* Check the completion status.  */
        if(status != UX_SUCCESS)
 8001b46:	4606      	mov	r6, r0
 8001b48:	2800      	cmp	r0, #0
 8001b4a:	d03e      	beq.n	8001bca <_ux_host_stack_initialize+0x182>
 8001b4c:	682c      	ldr	r4, [r5, #0]
            status = UX_THREAD_ERROR;
 8001b4e:	2616      	movs	r6, #22
    /* Last resource, _ux_system_host -> ux_system_host_hcd_thread is not created or created error,
     * no need to delete it.  */
#endif

    /* Delete _ux_system_host -> ux_system_host_enum_thread.  */
    if (_ux_system_host -> ux_system_host_enum_thread.tx_thread_id != 0)
 8001b50:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001b52:	b1d3      	cbz	r3, 8001b8a <_ux_host_stack_initialize+0x142>
        _ux_utility_thread_delete(&_ux_system_host -> ux_system_host_enum_thread);
 8001b54:	f104 0038 	add.w	r0, r4, #56	; 0x38
 8001b58:	f000 faf6 	bl	8002148 <_ux_utility_thread_delete>
 8001b5c:	682c      	ldr	r4, [r5, #0]
    
    /* Delete _ux_system_host -> ux_system_host_hcd_semaphore.  */
    if (_ux_system_host -> ux_system_host_hcd_semaphore.tx_semaphore_id != 0)
 8001b5e:	f8d4 32c0 	ldr.w	r3, [r4, #704]	; 0x2c0
 8001b62:	b1b3      	cbz	r3, 8001b92 <_ux_host_stack_initialize+0x14a>
        _ux_utility_semaphore_delete(&_ux_system_host -> ux_system_host_hcd_semaphore);
 8001b64:	f504 7030 	add.w	r0, r4, #704	; 0x2c0
 8001b68:	f000 fa90 	bl	800208c <_ux_utility_semaphore_delete>
 8001b6c:	682c      	ldr	r4, [r5, #0]

    /* Delete _ux_system_host -> ux_system_host_enum_semaphore.  */
    if (_ux_system_host -> ux_system_host_enum_semaphore.tx_semaphore_id != 0)
 8001b6e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 8001b72:	b193      	cbz	r3, 8001b9a <_ux_host_stack_initialize+0x152>
        _ux_utility_semaphore_delete(&_ux_system_host -> ux_system_host_enum_semaphore);
 8001b74:	f504 7080 	add.w	r0, r4, #256	; 0x100
 8001b78:	f000 fa88 	bl	800208c <_ux_utility_semaphore_delete>
 8001b7c:	682c      	ldr	r4, [r5, #0]
 8001b7e:	e00c      	b.n	8001b9a <_ux_host_stack_initialize+0x152>
 8001b80:	682c      	ldr	r4, [r5, #0]
        if(memory == UX_NULL)
 8001b82:	2612      	movs	r6, #18
    if (_ux_system_host -> ux_system_host_enum_thread.tx_thread_id != 0)
 8001b84:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001b86:	2b00      	cmp	r3, #0
 8001b88:	d1e4      	bne.n	8001b54 <_ux_host_stack_initialize+0x10c>
    if (_ux_system_host -> ux_system_host_hcd_semaphore.tx_semaphore_id != 0)
 8001b8a:	f8d4 32c0 	ldr.w	r3, [r4, #704]	; 0x2c0
 8001b8e:	2b00      	cmp	r3, #0
 8001b90:	d1e8      	bne.n	8001b64 <_ux_host_stack_initialize+0x11c>
    if (_ux_system_host -> ux_system_host_enum_semaphore.tx_semaphore_id != 0)
 8001b92:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
 8001b96:	2b00      	cmp	r3, #0
 8001b98:	d1ec      	bne.n	8001b74 <_ux_host_stack_initialize+0x12c>

    /* Free _ux_system_host -> ux_system_host_hcd_thread_stack.  */
    if (_ux_system_host -> ux_system_host_hcd_thread_stack)
 8001b9a:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
 8001b9e:	b110      	cbz	r0, 8001ba6 <_ux_host_stack_initialize+0x15e>
        _ux_utility_memory_free(_ux_system_host -> ux_system_host_hcd_thread_stack);
 8001ba0:	f000 f9b8 	bl	8001f14 <_ux_utility_memory_free>
 8001ba4:	682c      	ldr	r4, [r5, #0]

    /* Free _ux_system_host -> ux_system_host_enum_thread_stack.  */
    if (_ux_system_host -> ux_system_host_enum_thread_stack)
 8001ba6:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8001ba8:	b110      	cbz	r0, 8001bb0 <_ux_host_stack_initialize+0x168>
        _ux_utility_memory_free(_ux_system_host -> ux_system_host_enum_thread_stack);
 8001baa:	f000 f9b3 	bl	8001f14 <_ux_utility_memory_free>
 8001bae:	682c      	ldr	r4, [r5, #0]
    
    /* Free _ux_system_host -> ux_system_host_device_array.  */
    if (_ux_system_host -> ux_system_host_device_array)
 8001bb0:	69a0      	ldr	r0, [r4, #24]
 8001bb2:	b110      	cbz	r0, 8001bba <_ux_host_stack_initialize+0x172>
        _ux_utility_memory_free(_ux_system_host -> ux_system_host_device_array);
 8001bb4:	f000 f9ae 	bl	8001f14 <_ux_utility_memory_free>
 8001bb8:	682c      	ldr	r4, [r5, #0]
    
    /* Free _ux_system_host -> ux_system_host_class_array.  */
    if (_ux_system_host -> ux_system_host_class_array)
 8001bba:	68a0      	ldr	r0, [r4, #8]
 8001bbc:	b110      	cbz	r0, 8001bc4 <_ux_host_stack_initialize+0x17c>
        _ux_utility_memory_free(_ux_system_host -> ux_system_host_class_array);
 8001bbe:	f000 f9a9 	bl	8001f14 <_ux_utility_memory_free>
 8001bc2:	682c      	ldr	r4, [r5, #0]

    /* Free _ux_system_host -> ux_system_host_hcd_array.  */
    _ux_utility_memory_free(_ux_system_host -> ux_system_host_hcd_array);
 8001bc4:	6920      	ldr	r0, [r4, #16]
 8001bc6:	f000 f9a5 	bl	8001f14 <_ux_utility_memory_free>

    /* Return completion status to caller.  */
    return(status);
}
 8001bca:	4630      	mov	r0, r6
 8001bcc:	b007      	add	sp, #28
 8001bce:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8001bd0:	2612      	movs	r6, #18
}
 8001bd2:	4630      	mov	r0, r6
 8001bd4:	b007      	add	sp, #28
 8001bd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
            status = UX_MEMORY_INSUFFICIENT;
 8001bd8:	2612      	movs	r6, #18
 8001bda:	e7d3      	b.n	8001b84 <_ux_host_stack_initialize+0x13c>
 8001bdc:	682c      	ldr	r4, [r5, #0]
            status = UX_SEMAPHORE_ERROR;
 8001bde:	2615      	movs	r6, #21
 8001be0:	e7d0      	b.n	8001b84 <_ux_host_stack_initialize+0x13c>
 8001be2:	bf00      	nop
 8001be4:	20000db8 	.word	0x20000db8
 8001be8:	0800dd4c 	.word	0x0800dd4c
 8001bec:	0800dd6c 	.word	0x0800dd6c
 8001bf0:	08004161 	.word	0x08004161
 8001bf4:	0800dd8c 	.word	0x0800dd8c
 8001bf8:	08004189 	.word	0x08004189
 8001bfc:	0800dda8 	.word	0x0800dda8

08001c00 <_ux_system_error_handler>:
/**************************************************************************/
VOID   _ux_system_error_handler(UINT system_level, UINT system_context, UINT error_code)
{
 
    /* Save the last system error code.  */
    _ux_system -> ux_system_last_error =  error_code;
 8001c00:	4b06      	ldr	r3, [pc, #24]	; (8001c1c <_ux_system_error_handler+0x1c>)
 8001c02:	681b      	ldr	r3, [r3, #0]
{
 8001c04:	b430      	push	{r4, r5}
 
    /* Increment the total number of system errors.  */
    _ux_system -> ux_system_error_count++;
 8001c06:	6ddc      	ldr	r4, [r3, #92]	; 0x5c

    /* Is there an application call back function to call ? */
    if (_ux_system -> ux_system_error_callback_function != UX_NULL)
 8001c08:	6f5d      	ldr	r5, [r3, #116]	; 0x74
    _ux_system -> ux_system_error_count++;
 8001c0a:	3401      	adds	r4, #1
 8001c0c:	e9c3 2416 	strd	r2, r4, [r3, #88]	; 0x58
    if (_ux_system -> ux_system_error_callback_function != UX_NULL)
 8001c10:	b115      	cbz	r5, 8001c18 <_ux_system_error_handler+0x18>
    {    

        /* The callback function is defined, call it.  */
        _ux_system -> ux_system_error_callback_function(system_level, system_context, error_code);
 8001c12:	462b      	mov	r3, r5
    }
}
 8001c14:	bc30      	pop	{r4, r5}
        _ux_system -> ux_system_error_callback_function(system_level, system_context, error_code);
 8001c16:	4718      	bx	r3
}
 8001c18:	bc30      	pop	{r4, r5}
 8001c1a:	4770      	bx	lr
 8001c1c:	20000dc0 	.word	0x20000dc0

08001c20 <_ux_system_initialize>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_system_initialize(VOID *regular_memory_pool_start, ULONG regular_memory_size, 
                            VOID *cache_safe_memory_pool_start, ULONG cache_safe_memory_size)
{
 8001c20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001c24:	460d      	mov	r5, r1
 8001c26:	4604      	mov	r4, r0
VOID                *regular_memory_pool_end;
UINT                status;
ULONG               memory_pool_offset;

    /* Reset memory block */
    _ux_utility_memory_set(regular_memory_pool_start, 0, regular_memory_size);
 8001c28:	2100      	movs	r1, #0
{
 8001c2a:	4616      	mov	r6, r2
    _ux_utility_memory_set(regular_memory_pool_start, 0, regular_memory_size);
 8001c2c:	462a      	mov	r2, r5
{
 8001c2e:	461f      	mov	r7, r3
    _ux_utility_memory_set(regular_memory_pool_start, 0, regular_memory_size);
 8001c30:	f000 f9fc 	bl	800202c <_ux_utility_memory_set>
    _ux_system -> ux_system_regular_memory_pool_start =  (UX_MEMORY_BLOCK *) (((UCHAR *) regular_memory_pool_start) 
                                                            + memory_pool_offset);

    /* Make sure the regular memory pool is aligned properly */
    int_memory_pool_start =   (ALIGN_TYPE) _ux_system -> ux_system_regular_memory_pool_start;
    int_memory_pool_start +=  UX_ALIGN_MIN;
 8001c34:	f204 5363 	addw	r3, r4, #1379	; 0x563
    _ux_system_host =  (UX_SYSTEM_HOST *) (((UCHAR *) regular_memory_pool_start) + memory_pool_offset);
 8001c38:	4a21      	ldr	r2, [pc, #132]	; (8001cc0 <_ux_system_initialize+0xa0>)
    int_memory_pool_start &=  ~((ALIGN_TYPE)UX_ALIGN_MIN);
    
    /* Set the end of the regular memory pool.  */
    regular_memory_pool_end =  (void *) (((UCHAR *) regular_memory_pool_start) + regular_memory_size);
 8001c3a:	4425      	add	r5, r4
    _ux_system_host =  (UX_SYSTEM_HOST *) (((UCHAR *) regular_memory_pool_start) + memory_pool_offset);
 8001c3c:	f104 0c78 	add.w	ip, r4, #120	; 0x78
    int_memory_pool_start &=  ~((ALIGN_TYPE)UX_ALIGN_MIN);
 8001c40:	f023 030f 	bic.w	r3, r3, #15
    _ux_system_slave =  (UX_SYSTEM_SLAVE *) (((UCHAR *) regular_memory_pool_start) + memory_pool_offset);
 8001c44:	f504 7058 	add.w	r0, r4, #864	; 0x360
 8001c48:	491e      	ldr	r1, [pc, #120]	; (8001cc4 <_ux_system_initialize+0xa4>)
    _ux_system_host =  (UX_SYSTEM_HOST *) (((UCHAR *) regular_memory_pool_start) + memory_pool_offset);
 8001c4a:	f8c2 c000 	str.w	ip, [r2]

    /* Check if we have memory available.  */
    if (int_memory_pool_start >= (ALIGN_TYPE)regular_memory_pool_end)
 8001c4e:	429d      	cmp	r5, r3
    _ux_system -> ux_system_regular_memory_pool_start =  (UX_MEMORY_BLOCK *) (((UCHAR *) regular_memory_pool_start) 
 8001c50:	f204 5254 	addw	r2, r4, #1364	; 0x554
    _ux_system =  (UX_SYSTEM *) regular_memory_pool_start;
 8001c54:	f8df 8078 	ldr.w	r8, [pc, #120]	; 8001cd0 <_ux_system_initialize+0xb0>
    _ux_system_slave =  (UX_SYSTEM_SLAVE *) (((UCHAR *) regular_memory_pool_start) + memory_pool_offset);
 8001c58:	6008      	str	r0, [r1, #0]
    _ux_system =  (UX_SYSTEM *) regular_memory_pool_start;
 8001c5a:	f8c8 4000 	str.w	r4, [r8]
    _ux_system -> ux_system_regular_memory_pool_start =  (UX_MEMORY_BLOCK *) (((UCHAR *) regular_memory_pool_start) 
 8001c5e:	6022      	str	r2, [r4, #0]
    if (int_memory_pool_start >= (ALIGN_TYPE)regular_memory_pool_end)
 8001c60:	d92b      	bls.n	8001cba <_ux_system_initialize+0x9a>
        /* No memory available.  */
        return(UX_MEMORY_INSUFFICIENT);
    }

    /* Now, we have a project structure allocated, save the regular memory allocation details */
    _ux_system -> ux_system_regular_memory_pool_size =     (ULONG) (((ALIGN_TYPE) regular_memory_pool_end) - int_memory_pool_start);
 8001c62:	1ae9      	subs	r1, r5, r3
    _ux_system -> ux_system_regular_memory_pool_start =    (UX_MEMORY_BLOCK *) int_memory_pool_start;

    /* Build the first free memory block */
    memory_block =                             _ux_system -> ux_system_regular_memory_pool_start;
    memory_block -> ux_memory_block_size =     _ux_system -> ux_system_regular_memory_pool_size - (ULONG)sizeof(UX_MEMORY_BLOCK);
    memory_block -> ux_memory_block_status =   UX_MEMORY_UNUSED;
 8001c64:	4d18      	ldr	r5, [pc, #96]	; (8001cc8 <_ux_system_initialize+0xa8>)
    _ux_system -> ux_system_regular_memory_pool_start =    (UX_MEMORY_BLOCK *) int_memory_pool_start;
 8001c66:	6023      	str	r3, [r4, #0]
    memory_block -> ux_memory_block_size =     _ux_system -> ux_system_regular_memory_pool_size - (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001c68:	f1a1 0210 	sub.w	r2, r1, #16
    _ux_system -> ux_system_regular_memory_pool_free =     _ux_system -> ux_system_regular_memory_pool_size;
 8001c6c:	e9c4 1101 	strd	r1, r1, [r4, #4]
    memory_block -> ux_memory_block_status =   UX_MEMORY_UNUSED;
 8001c70:	e9c3 2500 	strd	r2, r5, [r3]

    /* Check the definition of the cache safe pool. If the application or controller do not require any cache safe memory,
       define the cached safe memory region as the regular memory region.  */
    if (cache_safe_memory_pool_start == UX_NULL)
 8001c74:	b1ee      	cbz	r6, 8001cb2 <_ux_system_initialize+0x92>
    else
    {
    
        /* Make sure the cache safe memory pool is aligned properly */
        int_memory_pool_start =   (ALIGN_TYPE) cache_safe_memory_pool_start;
        int_memory_pool_start +=  UX_ALIGN_MIN;
 8001c76:	f106 000f 	add.w	r0, r6, #15
        int_memory_pool_start &=  ~((ALIGN_TYPE)UX_ALIGN_MIN);
    
        /* Save the cache safe memory allocation details */
        _ux_system -> ux_system_cache_safe_memory_pool_size =     cache_safe_memory_size - UX_ALIGN_MIN;
 8001c7a:	f1a7 020f 	sub.w	r2, r7, #15
        _ux_system -> ux_system_cache_safe_memory_pool_free =     _ux_system -> ux_system_cache_safe_memory_pool_size;
        _ux_system -> ux_system_cache_safe_memory_pool_start =    (UX_MEMORY_BLOCK *) int_memory_pool_start;
    
        /* Reset this memory block */
        _ux_utility_memory_set(_ux_system -> ux_system_cache_safe_memory_pool_start, 0, _ux_system -> ux_system_cache_safe_memory_pool_size);
 8001c7e:	2100      	movs	r1, #0
        int_memory_pool_start &=  ~((ALIGN_TYPE)UX_ALIGN_MIN);
 8001c80:	f020 000f 	bic.w	r0, r0, #15
        _ux_system -> ux_system_cache_safe_memory_pool_free =     _ux_system -> ux_system_cache_safe_memory_pool_size;
 8001c84:	e9c4 2204 	strd	r2, r2, [r4, #16]
        _ux_system -> ux_system_cache_safe_memory_pool_start =    (UX_MEMORY_BLOCK *) int_memory_pool_start;
 8001c88:	60e0      	str	r0, [r4, #12]
        _ux_utility_memory_set(_ux_system -> ux_system_cache_safe_memory_pool_start, 0, _ux_system -> ux_system_cache_safe_memory_pool_size);
 8001c8a:	f000 f9cf 	bl	800202c <_ux_utility_memory_set>
    
        /* Build the first free memory block */
        memory_block =                             _ux_system -> ux_system_cache_safe_memory_pool_start;
 8001c8e:	f8d8 4000 	ldr.w	r4, [r8]
 8001c92:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
        memory_block -> ux_memory_block_size =     _ux_system -> ux_system_cache_safe_memory_pool_size - (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001c96:	3b10      	subs	r3, #16
 8001c98:	e9c2 3500 	strd	r3, r5, [r2]
    _ux_system -> ux_system_debug_log_size = UX_DEBUG_LOG_SIZE;
    
#endif

    /* Create the Mutex object used by USBX to control critical sections.  */
    status =  _ux_utility_mutex_create(&_ux_system -> ux_system_mutex, "ux_system_mutex");
 8001c9c:	f104 001c 	add.w	r0, r4, #28
 8001ca0:	490a      	ldr	r1, [pc, #40]	; (8001ccc <_ux_system_initialize+0xac>)
 8001ca2:	f000 f9c7 	bl	8002034 <_ux_utility_mutex_create>
    if(status != UX_SUCCESS)
        return(UX_MUTEX_ERROR);
 8001ca6:	2800      	cmp	r0, #0
 8001ca8:	bf14      	ite	ne
 8001caa:	2017      	movne	r0, #23
 8001cac:	2000      	moveq	r0, #0

    return(UX_SUCCESS);
}
 8001cae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        _ux_system -> ux_system_cache_safe_memory_pool_free =  _ux_system -> ux_system_regular_memory_pool_free;
 8001cb2:	e9c4 1104 	strd	r1, r1, [r4, #16]
        _ux_system -> ux_system_cache_safe_memory_pool_start = _ux_system -> ux_system_regular_memory_pool_start;
 8001cb6:	60e3      	str	r3, [r4, #12]
 8001cb8:	e7f0      	b.n	8001c9c <_ux_system_initialize+0x7c>
        return(UX_MEMORY_INSUFFICIENT);
 8001cba:	2012      	movs	r0, #18
}
 8001cbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001cc0:	20000db8 	.word	0x20000db8
 8001cc4:	20000dc4 	.word	0x20000dc4
 8001cc8:	12345678 	.word	0x12345678
 8001ccc:	0800ddc4 	.word	0x0800ddc4
 8001cd0:	20000dc0 	.word	0x20000dc0

08001cd4 <_ux_utility_delay_ms>:
{

ULONG   ticks;

    /* translate ms into ticks. */
    ticks = (ms_wait * UX_PERIODIC_RATE) / 1000;
 8001cd4:	2364      	movs	r3, #100	; 0x64
 8001cd6:	4a04      	ldr	r2, [pc, #16]	; (8001ce8 <_ux_utility_delay_ms+0x14>)
 8001cd8:	fb03 f000 	mul.w	r0, r3, r0
 8001cdc:	fba2 3000 	umull	r3, r0, r2, r0
 8001ce0:	0980      	lsrs	r0, r0, #6
    
    /* For safety add 1 to ticks.  */
    ticks++;

    /* Call ThreadX sleep function.  */
    tx_thread_sleep(ticks);
 8001ce2:	3001      	adds	r0, #1
 8001ce4:	f00a bd24 	b.w	800c730 <_tx_thread_sleep>
 8001ce8:	10624dd3 	.word	0x10624dd3

08001cec <_ux_utility_memory_allocate>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  *_ux_utility_memory_allocate(ULONG memory_alignment, ULONG memory_cache_flag,
                                   ULONG memory_size_requested)
{
 8001cec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
UCHAR               *memory_buffer;
ALIGN_TYPE          int_memory_buffer;


    /* Get the mutex as this is a critical section.  */
    _ux_utility_mutex_on(&_ux_system -> ux_system_mutex);
 8001cf0:	f8df 9110 	ldr.w	r9, [pc, #272]	; 8001e04 <_ux_utility_memory_allocate+0x118>
{
 8001cf4:	4605      	mov	r5, r0
 8001cf6:	4614      	mov	r4, r2
 8001cf8:	4688      	mov	r8, r1
    _ux_utility_mutex_on(&_ux_system -> ux_system_mutex);
 8001cfa:	f8d9 0000 	ldr.w	r0, [r9]
       now is that the memory block might not be a size that is a multiple of 16, so we need
       to add the amount of memory required such that the memory buffer after the block has 
       the correct alignment. For example, if the memory block has a size of 24, then we need
       to make sure it is placed on an 8-byte alignment that is after a 16-byte alignment so
       that the memory right after the memory block is 16-byte aligned (8 + 24 = 32).  */
    memory_size_requested =  (memory_size_requested +    UX_ALIGN_MIN) & (~(ULONG)UX_ALIGN_MIN);
 8001cfe:	340f      	adds	r4, #15
    _ux_utility_mutex_on(&_ux_system -> ux_system_mutex);
 8001d00:	301c      	adds	r0, #28
 8001d02:	f000 f9a7 	bl	8002054 <_ux_utility_mutex_on>
    if (memory_alignment < UX_ALIGN_MIN)
 8001d06:	f1a5 030f 	sub.w	r3, r5, #15
    memory_size_requested =  (memory_size_requested +    UX_ALIGN_MIN) & (~(ULONG)UX_ALIGN_MIN);
 8001d0a:	f024 040f 	bic.w	r4, r4, #15
    /* Try to find the best block for this memory by requesting the maximum amount of
       memory we'll need which is calculated as follows: the amount memory requested by
       the caller plus the maximum amount of memory wasted due to alignment plus 2 memory
       blocks structs - one for the new memory block we'll create for the user block and one
       that we might create if there is extra memory after doing the alignment.  */
    memory_block =  _ux_utility_memory_free_block_best_get(memory_cache_flag, memory_size_requested + memory_for_alignment + (ULONG)sizeof(UX_MEMORY_BLOCK));
 8001d0e:	4640      	mov	r0, r8
    if (memory_alignment < UX_ALIGN_MIN)
 8001d10:	3311      	adds	r3, #17
 8001d12:	f104 0710 	add.w	r7, r4, #16
        memory_alignment =  UX_ALIGN_MIN;
 8001d16:	bf88      	it	hi
 8001d18:	250f      	movhi	r5, #15
    memory_block =  _ux_utility_memory_free_block_best_get(memory_cache_flag, memory_size_requested + memory_for_alignment + (ULONG)sizeof(UX_MEMORY_BLOCK));
 8001d1a:	19e9      	adds	r1, r5, r7
 8001d1c:	f000 f95c 	bl	8001fd8 <_ux_utility_memory_free_block_best_get>

    /* If the block returned is NULL, there is no free memory in the pool
       for that size. */
    if (memory_block == UX_NULL)
 8001d20:	2800      	cmp	r0, #0
 8001d22:	d05e      	beq.n	8001de2 <_ux_utility_memory_allocate+0xf6>
        /* Return NULL to indicate no block was found.  */
        return(UX_NULL);
    }

    /* Get the memory buffer for this block.  */
    int_memory_buffer = (ALIGN_TYPE) ((UCHAR *) memory_block + sizeof(UX_MEMORY_BLOCK));
 8001d24:	f100 0610 	add.w	r6, r0, #16
 8001d28:	6881      	ldr	r1, [r0, #8]
 8001d2a:	6802      	ldr	r2, [r0, #0]

    /* Are we already aligned?  */
    if ((int_memory_buffer & (memory_alignment - 1)) == 0)
 8001d2c:	422e      	tst	r6, r5
 8001d2e:	d047      	beq.n	8001dc0 <_ux_utility_memory_allocate+0xd4>

        /* Align the buffer. The first thing we do is increment by the size of a
           memory block because we have to make sure we have enough memory for at
           least that.  */
        int_memory_buffer +=  (ULONG)sizeof(UX_MEMORY_BLOCK);
        int_memory_buffer +=  memory_alignment - 1;
 8001d30:	f105 0310 	add.w	r3, r5, #16
        /* Setup the new memory block. Note that its size is updated again later.  */
        new_memory_block =  (UX_MEMORY_BLOCK *) (int_memory_buffer - (ULONG)sizeof(UX_MEMORY_BLOCK));
        new_memory_block -> ux_memory_block_previous =  memory_block;
        new_memory_block -> ux_memory_block_next =  memory_block -> ux_memory_block_next;
        new_memory_block -> ux_memory_block_size =  memory_block -> ux_memory_block_size;
        new_memory_block -> ux_memory_block_status =  UX_MEMORY_USED;
 8001d34:	f8df c0c8 	ldr.w	ip, [pc, #200]	; 8001e00 <_ux_utility_memory_allocate+0x114>
        int_memory_buffer +=  memory_alignment - 1;
 8001d38:	4433      	add	r3, r6
        int_memory_buffer &=  ~(((ALIGN_TYPE) memory_alignment) - 1);
 8001d3a:	ea23 0505 	bic.w	r5, r3, r5
        new_memory_block =  (UX_MEMORY_BLOCK *) (int_memory_buffer - (ULONG)sizeof(UX_MEMORY_BLOCK));
 8001d3e:	f1a5 0310 	sub.w	r3, r5, #16

        /* Update the current memory block.  */
        int_memory_buffer =  (ALIGN_TYPE) ((UCHAR *) memory_block + sizeof(UX_MEMORY_BLOCK));
        memory_block -> ux_memory_block_next =  new_memory_block;
        memory_block -> ux_memory_block_size =  (ULONG) ((ALIGN_TYPE) new_memory_block - int_memory_buffer);
 8001d42:	eba3 0e06 	sub.w	lr, r3, r6
        new_memory_block -> ux_memory_block_next =  memory_block -> ux_memory_block_next;
 8001d46:	e9c3 1002 	strd	r1, r0, [r3, #8]
        new_memory_block -> ux_memory_block_size =  memory_block -> ux_memory_block_size;
 8001d4a:	f845 2c10 	str.w	r2, [r5, #-16]
        new_memory_block -> ux_memory_block_status =  UX_MEMORY_USED;
 8001d4e:	f8c3 c004 	str.w	ip, [r3, #4]
        memory_block -> ux_memory_block_size =  (ULONG) ((ALIGN_TYPE) new_memory_block - int_memory_buffer);
 8001d52:	f8c0 e000 	str.w	lr, [r0]

        /* Update the new memory block's size.  */
        new_memory_block -> ux_memory_block_size -=  (memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK));
 8001d56:	f855 6c10 	ldr.w	r6, [r5, #-16]
        memory_block -> ux_memory_block_next =  new_memory_block;
 8001d5a:	6083      	str	r3, [r0, #8]
        new_memory_block -> ux_memory_block_size -=  (memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK));
 8001d5c:	eba6 060e 	sub.w	r6, r6, lr
 8001d60:	3e10      	subs	r6, #16

        /* Calculate how much memory is leftover in the new memory block after doing
           the alignment.  */
        leftover =  new_memory_block -> ux_memory_block_size - memory_size_requested;
 8001d62:	1b32      	subs	r2, r6, r4
        new_memory_block -> ux_memory_block_size -=  (memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK));
 8001d64:	f845 6c10 	str.w	r6, [r5, #-16]

        /* Can we fit another block after the new block? */
        if (leftover > sizeof(UX_MEMORY_BLOCK))
 8001d68:	2a10      	cmp	r2, #16
 8001d6a:	d90e      	bls.n	8001d8a <_ux_utility_memory_allocate+0x9e>
        {

            /* Setup the leftover memory block.  */
            leftover_memory_block = (UX_MEMORY_BLOCK *) ((ALIGN_TYPE) new_memory_block + sizeof(UX_MEMORY_BLOCK) + memory_size_requested);
            leftover_memory_block -> ux_memory_block_next =  new_memory_block -> ux_memory_block_next;
 8001d6c:	6899      	ldr	r1, [r3, #8]
            leftover_memory_block = (UX_MEMORY_BLOCK *) ((ALIGN_TYPE) new_memory_block + sizeof(UX_MEMORY_BLOCK) + memory_size_requested);
 8001d6e:	19d8      	adds	r0, r3, r7
            leftover_memory_block -> ux_memory_block_previous =  new_memory_block;
            leftover_memory_block -> ux_memory_block_size =  leftover - (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001d70:	f1a2 0610 	sub.w	r6, r2, #16
            leftover_memory_block -> ux_memory_block_previous =  new_memory_block;
 8001d74:	e9c0 1302 	strd	r1, r3, [r0, #8]
            leftover_memory_block -> ux_memory_block_size =  leftover - (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001d78:	51de      	str	r6, [r3, r7]
            leftover_memory_block -> ux_memory_block_status =  UX_MEMORY_UNUSED;

            new_memory_block -> ux_memory_block_next =  leftover_memory_block;
            new_memory_block -> ux_memory_block_size -=  leftover;
 8001d7a:	f855 6c10 	ldr.w	r6, [r5, #-16]
            leftover_memory_block -> ux_memory_block_status =  UX_MEMORY_UNUSED;
 8001d7e:	491f      	ldr	r1, [pc, #124]	; (8001dfc <_ux_utility_memory_allocate+0x110>)
            new_memory_block -> ux_memory_block_size -=  leftover;
 8001d80:	1ab6      	subs	r6, r6, r2
            leftover_memory_block -> ux_memory_block_status =  UX_MEMORY_UNUSED;
 8001d82:	6041      	str	r1, [r0, #4]
            new_memory_block -> ux_memory_block_next =  leftover_memory_block;
 8001d84:	6098      	str	r0, [r3, #8]
            new_memory_block -> ux_memory_block_size -=  leftover;
 8001d86:	f845 6c10 	str.w	r6, [r5, #-16]
        }

        /* Declare how much memory we removed from the pool.  */
        memory_removed_from_pool =  new_memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001d8a:	f106 0710 	add.w	r7, r6, #16
 8001d8e:	f103 0610 	add.w	r6, r3, #16

    /* The memory to be returned is after the block header.  */
    memory_buffer =  ((UCHAR *) memory_block) + sizeof(UX_MEMORY_BLOCK);

    /* Clear the memory block.  */
    _ux_utility_memory_set(memory_buffer, 0, memory_size_requested);
 8001d92:	4622      	mov	r2, r4
 8001d94:	4630      	mov	r0, r6
 8001d96:	2100      	movs	r1, #0
 8001d98:	f000 f948 	bl	800202c <_ux_utility_memory_set>

    /* Update the memory free in the pool.  */
    if (_ux_system -> ux_system_cache_safe_memory_pool_start == _ux_system -> ux_system_regular_memory_pool_start)
 8001d9c:	f8d9 0000 	ldr.w	r0, [r9]
 8001da0:	68c2      	ldr	r2, [r0, #12]
 8001da2:	6803      	ldr	r3, [r0, #0]
 8001da4:	429a      	cmp	r2, r3
 8001da6:	d018      	beq.n	8001dda <_ux_utility_memory_allocate+0xee>
        _ux_system -> ux_system_regular_memory_pool_free -= memory_removed_from_pool;
    }
    else
    {

       switch (memory_cache_flag)
 8001da8:	f1b8 0f01 	cmp.w	r8, #1
 8001dac:	d115      	bne.n	8001dda <_ux_utility_memory_allocate+0xee>
       {

            case UX_CACHE_SAFE_MEMORY:
                /* Update the amount of free memory in the cache safe memory pool.  */
                _ux_system -> ux_system_cache_safe_memory_pool_free -= memory_removed_from_pool;
 8001dae:	6943      	ldr	r3, [r0, #20]
 8001db0:	1bdf      	subs	r7, r3, r7
 8001db2:	6147      	str	r7, [r0, #20]

        }
    }

    /* Release the protection.  */
    _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8001db4:	301c      	adds	r0, #28
 8001db6:	f000 f94b 	bl	8002050 <_ux_utility_mutex_off>

    /* The memory block pointer contains a memory area properly
       aligned.  */
    return(memory_buffer);
}                                
 8001dba:	4630      	mov	r0, r6
 8001dbc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        new_memory_block =  (UX_MEMORY_BLOCK *) ((UCHAR *) memory_block + sizeof(UX_MEMORY_BLOCK) + memory_size_requested);
 8001dc0:	19c3      	adds	r3, r0, r7
        new_memory_block -> ux_memory_block_size =  memory_block -> ux_memory_block_size - memory_size_requested - (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001dc2:	1b12      	subs	r2, r2, r4
        new_memory_block -> ux_memory_block_status =  UX_MEMORY_UNUSED;
 8001dc4:	4d0d      	ldr	r5, [pc, #52]	; (8001dfc <_ux_utility_memory_allocate+0x110>)
        new_memory_block -> ux_memory_block_next =  memory_block -> ux_memory_block_next;
 8001dc6:	6099      	str	r1, [r3, #8]
        new_memory_block -> ux_memory_block_size =  memory_block -> ux_memory_block_size - memory_size_requested - (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001dc8:	3a10      	subs	r2, #16
        memory_block -> ux_memory_block_status =  UX_MEMORY_USED;
 8001dca:	490d      	ldr	r1, [pc, #52]	; (8001e00 <_ux_utility_memory_allocate+0x114>)
        new_memory_block -> ux_memory_block_previous =  memory_block;
 8001dcc:	60d8      	str	r0, [r3, #12]
        new_memory_block -> ux_memory_block_size =  memory_block -> ux_memory_block_size - memory_size_requested - (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001dce:	51c2      	str	r2, [r0, r7]
        new_memory_block -> ux_memory_block_status =  UX_MEMORY_UNUSED;
 8001dd0:	605d      	str	r5, [r3, #4]
        memory_block -> ux_memory_block_next =  new_memory_block;
 8001dd2:	6083      	str	r3, [r0, #8]
        memory_block -> ux_memory_block_status =  UX_MEMORY_USED;
 8001dd4:	e9c0 4100 	strd	r4, r1, [r0]
 8001dd8:	e7db      	b.n	8001d92 <_ux_utility_memory_allocate+0xa6>
                _ux_system -> ux_system_regular_memory_pool_free -= memory_removed_from_pool;
 8001dda:	6883      	ldr	r3, [r0, #8]
 8001ddc:	1bdf      	subs	r7, r3, r7
 8001dde:	6087      	str	r7, [r0, #8]
            break;
 8001de0:	e7e8      	b.n	8001db4 <_ux_utility_memory_allocate+0xc8>
        _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8001de2:	f8d9 3000 	ldr.w	r3, [r9]
        return(UX_NULL);
 8001de6:	4606      	mov	r6, r0
        _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8001de8:	f103 001c 	add.w	r0, r3, #28
 8001dec:	f000 f930 	bl	8002050 <_ux_utility_mutex_off>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, UX_MEMORY_INSUFFICIENT);
 8001df0:	2212      	movs	r2, #18
 8001df2:	2108      	movs	r1, #8
 8001df4:	2002      	movs	r0, #2
 8001df6:	f7ff ff03 	bl	8001c00 <_ux_system_error_handler>
        return(UX_NULL);
 8001dfa:	e7de      	b.n	8001dba <_ux_utility_memory_allocate+0xce>
 8001dfc:	12345678 	.word	0x12345678
 8001e00:	87654321 	.word	0x87654321
 8001e04:	20000dc0 	.word	0x20000dc0

08001e08 <_ux_utility_memory_compare>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_memory_compare(VOID *memory_source, VOID *memory_destination, ULONG length)
{
 8001e08:	4402      	add	r2, r0
    /* Setup source and destination byte oriented pointers.  */
    source =  (UCHAR *) memory_source;
    destination =  (UCHAR *) memory_destination;

    /* Loop to compare blocks.  */
    while(length--)
 8001e0a:	4290      	cmp	r0, r2
 8001e0c:	d016      	beq.n	8001e3c <_ux_utility_memory_compare+0x34>
{
 8001e0e:	b410      	push	{r4}
    {

        /* Compare a single byte.  */
        if(*destination++ != *source++)
 8001e10:	f811 4b01 	ldrb.w	r4, [r1], #1
 8001e14:	f810 3b01 	ldrb.w	r3, [r0], #1
 8001e18:	429c      	cmp	r4, r3
 8001e1a:	d107      	bne.n	8001e2c <_ux_utility_memory_compare+0x24>
    while(length--)
 8001e1c:	4290      	cmp	r0, r2
 8001e1e:	d009      	beq.n	8001e34 <_ux_utility_memory_compare+0x2c>
        if(*destination++ != *source++)
 8001e20:	f811 4b01 	ldrb.w	r4, [r1], #1
 8001e24:	f810 3b01 	ldrb.w	r3, [r0], #1
 8001e28:	429c      	cmp	r4, r3
 8001e2a:	d0f7      	beq.n	8001e1c <_ux_utility_memory_compare+0x14>
        {

            /* Not equal, return an error.  */
            return(UX_ERROR);
 8001e2c:	20ff      	movs	r0, #255	; 0xff
        }
    } 
    
    /* Blocks are equal, return success.  */           
    return(UX_SUCCESS); 
}
 8001e2e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001e32:	4770      	bx	lr
    return(UX_SUCCESS); 
 8001e34:	2000      	movs	r0, #0
}
 8001e36:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001e3a:	4770      	bx	lr
    return(UX_SUCCESS); 
 8001e3c:	2000      	movs	r0, #0
}
 8001e3e:	4770      	bx	lr

08001e40 <_ux_utility_memory_copy>:
    /* Setup byte oriented source and destination pointers.  */
    source =  (UCHAR *) memory_source;
    destination =  (UCHAR *) memory_destination;

    /* Loop to perform the copy.  */
    while(length--)
 8001e40:	2a00      	cmp	r2, #0
 8001e42:	d065      	beq.n	8001f10 <_ux_utility_memory_copy+0xd0>
 8001e44:	1d03      	adds	r3, r0, #4
{
 8001e46:	b4f0      	push	{r4, r5, r6, r7}
 8001e48:	1d0c      	adds	r4, r1, #4
 8001e4a:	42a0      	cmp	r0, r4
 8001e4c:	bf38      	it	cc
 8001e4e:	4299      	cmpcc	r1, r3
 8001e50:	d354      	bcc.n	8001efc <_ux_utility_memory_copy+0xbc>
 8001e52:	2a0b      	cmp	r2, #11
 8001e54:	d952      	bls.n	8001efc <_ux_utility_memory_copy+0xbc>
 8001e56:	424b      	negs	r3, r1
 8001e58:	1e55      	subs	r5, r2, #1
 8001e5a:	f003 0303 	and.w	r3, r3, #3
 8001e5e:	1cdc      	adds	r4, r3, #3
 8001e60:	42a5      	cmp	r5, r4
 8001e62:	d331      	bcc.n	8001ec8 <_ux_utility_memory_copy+0x88>
 8001e64:	2b00      	cmp	r3, #0
 8001e66:	d046      	beq.n	8001ef6 <_ux_utility_memory_copy+0xb6>
    {

        /* Copy one byte.  */
        *destination++ =  *source++;
 8001e68:	780c      	ldrb	r4, [r1, #0]
 8001e6a:	2b01      	cmp	r3, #1
 8001e6c:	f101 0c01 	add.w	ip, r1, #1
 8001e70:	f100 0701 	add.w	r7, r0, #1
    while(length--)
 8001e74:	f1a2 0502 	sub.w	r5, r2, #2
        *destination++ =  *source++;
 8001e78:	7004      	strb	r4, [r0, #0]
 8001e7a:	d00f      	beq.n	8001e9c <_ux_utility_memory_copy+0x5c>
 8001e7c:	784c      	ldrb	r4, [r1, #1]
 8001e7e:	2b03      	cmp	r3, #3
 8001e80:	f101 0c02 	add.w	ip, r1, #2
 8001e84:	f100 0702 	add.w	r7, r0, #2
    while(length--)
 8001e88:	f1a2 0503 	sub.w	r5, r2, #3
        *destination++ =  *source++;
 8001e8c:	7044      	strb	r4, [r0, #1]
 8001e8e:	d105      	bne.n	8001e9c <_ux_utility_memory_copy+0x5c>
 8001e90:	788c      	ldrb	r4, [r1, #2]
 8001e92:	f101 0c03 	add.w	ip, r1, #3
 8001e96:	1cc7      	adds	r7, r0, #3
    while(length--)
 8001e98:	1f15      	subs	r5, r2, #4
        *destination++ =  *source++;
 8001e9a:	7084      	strb	r4, [r0, #2]
 8001e9c:	1ad2      	subs	r2, r2, r3
 8001e9e:	4419      	add	r1, r3
 8001ea0:	4418      	add	r0, r3
    while(length--)
 8001ea2:	2300      	movs	r3, #0
 8001ea4:	0896      	lsrs	r6, r2, #2
 8001ea6:	3301      	adds	r3, #1
        *destination++ =  *source++;
 8001ea8:	f851 4b04 	ldr.w	r4, [r1], #4
 8001eac:	429e      	cmp	r6, r3
 8001eae:	f840 4b04 	str.w	r4, [r0], #4
 8001eb2:	d8f8      	bhi.n	8001ea6 <_ux_utility_memory_copy+0x66>
 8001eb4:	f022 0303 	bic.w	r3, r2, #3
 8001eb8:	429a      	cmp	r2, r3
 8001eba:	eb0c 0103 	add.w	r1, ip, r3
 8001ebe:	eb07 0003 	add.w	r0, r7, r3
 8001ec2:	eba5 0503 	sub.w	r5, r5, r3
 8001ec6:	d014      	beq.n	8001ef2 <_ux_utility_memory_copy+0xb2>
 8001ec8:	780b      	ldrb	r3, [r1, #0]
 8001eca:	7003      	strb	r3, [r0, #0]
    while(length--)
 8001ecc:	b18d      	cbz	r5, 8001ef2 <_ux_utility_memory_copy+0xb2>
        *destination++ =  *source++;
 8001ece:	784b      	ldrb	r3, [r1, #1]
    while(length--)
 8001ed0:	2d01      	cmp	r5, #1
        *destination++ =  *source++;
 8001ed2:	7043      	strb	r3, [r0, #1]
    while(length--)
 8001ed4:	d00d      	beq.n	8001ef2 <_ux_utility_memory_copy+0xb2>
        *destination++ =  *source++;
 8001ed6:	788b      	ldrb	r3, [r1, #2]
    while(length--)
 8001ed8:	2d02      	cmp	r5, #2
        *destination++ =  *source++;
 8001eda:	7083      	strb	r3, [r0, #2]
    while(length--)
 8001edc:	d009      	beq.n	8001ef2 <_ux_utility_memory_copy+0xb2>
        *destination++ =  *source++;
 8001ede:	78cb      	ldrb	r3, [r1, #3]
    while(length--)
 8001ee0:	2d03      	cmp	r5, #3
        *destination++ =  *source++;
 8001ee2:	70c3      	strb	r3, [r0, #3]
    while(length--)
 8001ee4:	d005      	beq.n	8001ef2 <_ux_utility_memory_copy+0xb2>
        *destination++ =  *source++;
 8001ee6:	790b      	ldrb	r3, [r1, #4]
    while(length--)
 8001ee8:	2d04      	cmp	r5, #4
        *destination++ =  *source++;
 8001eea:	7103      	strb	r3, [r0, #4]
    while(length--)
 8001eec:	d001      	beq.n	8001ef2 <_ux_utility_memory_copy+0xb2>
        *destination++ =  *source++;
 8001eee:	794b      	ldrb	r3, [r1, #5]
 8001ef0:	7143      	strb	r3, [r0, #5]
    }

    /* Return to caller.  */
    return; 
}
 8001ef2:	bcf0      	pop	{r4, r5, r6, r7}
 8001ef4:	4770      	bx	lr
    while(length--)
 8001ef6:	4607      	mov	r7, r0
 8001ef8:	468c      	mov	ip, r1
 8001efa:	e7cf      	b.n	8001e9c <_ux_utility_memory_copy+0x5c>
 8001efc:	3801      	subs	r0, #1
 8001efe:	440a      	add	r2, r1
        *destination++ =  *source++;
 8001f00:	f811 3b01 	ldrb.w	r3, [r1], #1
    while(length--)
 8001f04:	4291      	cmp	r1, r2
        *destination++ =  *source++;
 8001f06:	f800 3f01 	strb.w	r3, [r0, #1]!
    while(length--)
 8001f0a:	d1f9      	bne.n	8001f00 <_ux_utility_memory_copy+0xc0>
}
 8001f0c:	bcf0      	pop	{r4, r5, r6, r7}
 8001f0e:	4770      	bx	lr
 8001f10:	4770      	bx	lr
 8001f12:	bf00      	nop

08001f14 <_ux_utility_memory_free>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_memory_free(VOID *memory)
{
 8001f14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
UX_MEMORY_BLOCK     *next_block;
ULONG               memory_size_returned;
UCHAR               *memory_address;

    /* Get the mutex as this is a critical section.  */
    _ux_utility_mutex_on(&_ux_system -> ux_system_mutex);
 8001f16:	4d2d      	ldr	r5, [pc, #180]	; (8001fcc <_ux_utility_memory_free+0xb8>)
{
 8001f18:	4604      	mov	r4, r0
    _ux_utility_mutex_on(&_ux_system -> ux_system_mutex);
 8001f1a:	6828      	ldr	r0, [r5, #0]
 8001f1c:	301c      	adds	r0, #28
 8001f1e:	f000 f899 	bl	8002054 <_ux_utility_mutex_on>
    
    /* Keep track of the memory returned to the pool.  */
    memory_size_returned = memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);

    /* Check this memory block to see if it valid.  */
    if (memory_block -> ux_memory_block_status != UX_MEMORY_USED)
 8001f22:	f854 2c0c 	ldr.w	r2, [r4, #-12]
 8001f26:	4b2a      	ldr	r3, [pc, #168]	; (8001fd0 <_ux_utility_memory_free+0xbc>)
 8001f28:	429a      	cmp	r2, r3
 8001f2a:	d143      	bne.n	8001fb4 <_ux_utility_memory_free+0xa0>
        /* Return to caller.  */
        return;
    }

    /* We mark this memory block as being unused.  */
    memory_block -> ux_memory_block_status =  UX_MEMORY_UNUSED;
 8001f2c:	4829      	ldr	r0, [pc, #164]	; (8001fd4 <_ux_utility_memory_free+0xc0>)
    memory_block =  (UX_MEMORY_BLOCK *) (((UCHAR *) memory) - sizeof(UX_MEMORY_BLOCK));
 8001f2e:	f1a4 0210 	sub.w	r2, r4, #16
    memory_size_returned = memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001f32:	f854 7c10 	ldr.w	r7, [r4, #-16]
    memory_block -> ux_memory_block_status =  UX_MEMORY_UNUSED;
 8001f36:	f844 0c0c 	str.w	r0, [r4, #-12]
    
    /* Now we must concatenate as many free blocks as possible,
       that include the blocks before and the blocks after the current
       block.  Scan memory backwards.  */

     while (memory_block -> ux_memory_block_previous !=UX_NULL)
 8001f3a:	e003      	b.n	8001f44 <_ux_utility_memory_free+0x30>
     {

        /* Check if the block is free.  */            
        if (memory_block -> ux_memory_block_previous -> ux_memory_block_status == UX_MEMORY_UNUSED)
 8001f3c:	6859      	ldr	r1, [r3, #4]
 8001f3e:	4281      	cmp	r1, r0
 8001f40:	d103      	bne.n	8001f4a <_ux_utility_memory_free+0x36>
 8001f42:	461a      	mov	r2, r3
     while (memory_block -> ux_memory_block_previous !=UX_NULL)
 8001f44:	68d3      	ldr	r3, [r2, #12]
 8001f46:	2b00      	cmp	r3, #0
 8001f48:	d1f8      	bne.n	8001f3c <_ux_utility_memory_free+0x28>
            break;
    }

    /* The pointer to the memory block is now our first free block. We use this 
       starting address to concatenate all the contiguous memory block.  */
    next_block =  memory_block -> ux_memory_block_next;
 8001f4a:	6893      	ldr	r3, [r2, #8]
    while (next_block != UX_NULL)
 8001f4c:	b18b      	cbz	r3, 8001f72 <_ux_utility_memory_free+0x5e>
    {

        /* Determine if the memory block is used.  */
        if (next_block -> ux_memory_block_status == UX_MEMORY_USED)
 8001f4e:	4e20      	ldr	r6, [pc, #128]	; (8001fd0 <_ux_utility_memory_free+0xbc>)
 8001f50:	6859      	ldr	r1, [r3, #4]
 8001f52:	42b1      	cmp	r1, r6
 8001f54:	d02b      	beq.n	8001fae <_ux_utility_memory_free+0x9a>
 8001f56:	6810      	ldr	r0, [r2, #0]
 8001f58:	e002      	b.n	8001f60 <_ux_utility_memory_free+0x4c>
 8001f5a:	6859      	ldr	r1, [r3, #4]
 8001f5c:	42b1      	cmp	r1, r6
 8001f5e:	d026      	beq.n	8001fae <_ux_utility_memory_free+0x9a>
            next_block -> ux_memory_block_previous =  memory_block;
            break;
        }

        memory_block -> ux_memory_block_next =  next_block -> ux_memory_block_next;
        memory_block -> ux_memory_block_size +=  next_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001f60:	6819      	ldr	r1, [r3, #0]
        memory_block -> ux_memory_block_next =  next_block -> ux_memory_block_next;
 8001f62:	689c      	ldr	r4, [r3, #8]
        memory_block -> ux_memory_block_size +=  next_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001f64:	3110      	adds	r1, #16
        memory_block -> ux_memory_block_next =  next_block -> ux_memory_block_next;
 8001f66:	6094      	str	r4, [r2, #8]
        memory_block -> ux_memory_block_size +=  next_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001f68:	4408      	add	r0, r1
        next_block =  next_block -> ux_memory_block_next;                       
 8001f6a:	689b      	ldr	r3, [r3, #8]
        memory_block -> ux_memory_block_size +=  next_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001f6c:	6010      	str	r0, [r2, #0]
    while (next_block != UX_NULL)
 8001f6e:	2b00      	cmp	r3, #0
 8001f70:	d1f3      	bne.n	8001f5a <_ux_utility_memory_free+0x46>
    }

    /* Update the memory free in the appropriate pool.  We need to know if this 
       block is in regular memory or cache safe memory.  */
    if(_ux_system -> ux_system_cache_safe_memory_pool_start == _ux_system -> ux_system_regular_memory_pool_start)
 8001f72:	6828      	ldr	r0, [r5, #0]
    memory_size_returned = memory_block -> ux_memory_block_size + (ULONG)sizeof(UX_MEMORY_BLOCK);
 8001f74:	3710      	adds	r7, #16
    if(_ux_system -> ux_system_cache_safe_memory_pool_start == _ux_system -> ux_system_regular_memory_pool_start)
 8001f76:	6803      	ldr	r3, [r0, #0]
 8001f78:	68c1      	ldr	r1, [r0, #12]
 8001f7a:	4299      	cmp	r1, r3
 8001f7c:	d00e      	beq.n	8001f9c <_ux_utility_memory_free+0x88>

        /* Which pool is this memory in ?  */
        memory_address = (UCHAR *) _ux_system -> ux_system_regular_memory_pool_start;
        
        /* If the memory address is in this range, we are in the regular memory pool.  */
        if ((UCHAR *) memory_block >= memory_address && (UCHAR *) memory_block < (memory_address + _ux_system -> ux_system_regular_memory_pool_size))
 8001f7e:	4293      	cmp	r3, r2
 8001f80:	d908      	bls.n	8001f94 <_ux_utility_memory_free+0x80>
            _ux_system -> ux_system_regular_memory_pool_free += memory_size_returned;

        else
        
            /* Update the cache safe memory pool.  */
            _ux_system -> ux_system_cache_safe_memory_pool_free += memory_size_returned;
 8001f82:	6943      	ldr	r3, [r0, #20]
        
    }

    /* Release the protection.  */
    _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8001f84:	301c      	adds	r0, #28
            _ux_system -> ux_system_cache_safe_memory_pool_free += memory_size_returned;
 8001f86:	441f      	add	r7, r3
 8001f88:	f840 7c08 	str.w	r7, [r0, #-8]

    /* Return to caller.  */
    return;
}
 8001f8c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8001f90:	f000 b85e 	b.w	8002050 <_ux_utility_mutex_off>
        if ((UCHAR *) memory_block >= memory_address && (UCHAR *) memory_block < (memory_address + _ux_system -> ux_system_regular_memory_pool_size))
 8001f94:	6841      	ldr	r1, [r0, #4]
 8001f96:	440b      	add	r3, r1
 8001f98:	429a      	cmp	r2, r3
 8001f9a:	d2f2      	bcs.n	8001f82 <_ux_utility_memory_free+0x6e>
            _ux_system -> ux_system_regular_memory_pool_free += memory_size_returned;
 8001f9c:	6883      	ldr	r3, [r0, #8]
    _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8001f9e:	301c      	adds	r0, #28
            _ux_system -> ux_system_regular_memory_pool_free += memory_size_returned;
 8001fa0:	441f      	add	r7, r3
 8001fa2:	f840 7c14 	str.w	r7, [r0, #-20]
}
 8001fa6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8001faa:	f000 b851 	b.w	8002050 <_ux_utility_mutex_off>
            memory_block -> ux_memory_block_next =  next_block;
 8001fae:	6093      	str	r3, [r2, #8]
            next_block -> ux_memory_block_previous =  memory_block;
 8001fb0:	60da      	str	r2, [r3, #12]
            break;
 8001fb2:	e7de      	b.n	8001f72 <_ux_utility_memory_free+0x5e>
        _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8001fb4:	6828      	ldr	r0, [r5, #0]
 8001fb6:	301c      	adds	r0, #28
 8001fb8:	f000 f84a 	bl	8002050 <_ux_utility_mutex_off>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, UX_MEMORY_CORRUPTED);
 8001fbc:	2219      	movs	r2, #25
 8001fbe:	2108      	movs	r1, #8
 8001fc0:	2002      	movs	r0, #2
}
 8001fc2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, UX_MEMORY_CORRUPTED);
 8001fc6:	f7ff be1b 	b.w	8001c00 <_ux_system_error_handler>
 8001fca:	bf00      	nop
 8001fcc:	20000dc0 	.word	0x20000dc0
 8001fd0:	87654321 	.word	0x87654321
 8001fd4:	12345678 	.word	0x12345678

08001fd8 <_ux_utility_memory_free_block_best_get>:

    /* Reset the free memory block.  */
    best_memory_block =  UX_NULL;
    
    /* Check the type of memory we need.  */
    switch (memory_cache_flag)
 8001fd8:	b1e8      	cbz	r0, 8002016 <_ux_utility_memory_free_block_best_get+0x3e>
 8001fda:	2801      	cmp	r0, #1
 8001fdc:	d119      	bne.n	8002012 <_ux_utility_memory_free_block_best_get+0x3a>
            break;
            
        case UX_CACHE_SAFE_MEMORY       :

            /* Start at the beginning of the cache safe memory pool.  */
            memory_block =  _ux_system -> ux_system_cache_safe_memory_pool_start;
 8001fde:	4b11      	ldr	r3, [pc, #68]	; (8002024 <_ux_utility_memory_free_block_best_get+0x4c>)
 8001fe0:	681b      	ldr	r3, [r3, #0]
 8001fe2:	68db      	ldr	r3, [r3, #12]
            return(UX_NULL);

    }

    /* Loop on all memory blocks from the beginning.  */
    while (memory_block != UX_NULL)
 8001fe4:	b1ab      	cbz	r3, 8002012 <_ux_utility_memory_free_block_best_get+0x3a>
 8001fe6:	2000      	movs	r0, #0
{
 8001fe8:	b430      	push	{r4, r5}
    {

        /* Check the memory block status.  */
        if (memory_block -> ux_memory_block_status == UX_MEMORY_UNUSED)
 8001fea:	4c0f      	ldr	r4, [pc, #60]	; (8002028 <_ux_utility_memory_free_block_best_get+0x50>)
 8001fec:	e001      	b.n	8001ff2 <_ux_utility_memory_free_block_best_get+0x1a>
                }                    
            }
        }

        /* Search the next free block until the end.  */            
        memory_block =  memory_block -> ux_memory_block_next;
 8001fee:	689b      	ldr	r3, [r3, #8]
    while (memory_block != UX_NULL)
 8001ff0:	b16b      	cbz	r3, 800200e <_ux_utility_memory_free_block_best_get+0x36>
        if (memory_block -> ux_memory_block_status == UX_MEMORY_UNUSED)
 8001ff2:	685a      	ldr	r2, [r3, #4]
 8001ff4:	42a2      	cmp	r2, r4
 8001ff6:	d1fa      	bne.n	8001fee <_ux_utility_memory_free_block_best_get+0x16>
            if (memory_block -> ux_memory_block_size > memory_size_requested)
 8001ff8:	681a      	ldr	r2, [r3, #0]
 8001ffa:	428a      	cmp	r2, r1
 8001ffc:	d9f7      	bls.n	8001fee <_ux_utility_memory_free_block_best_get+0x16>
                if (best_memory_block == UX_NULL)
 8001ffe:	b170      	cbz	r0, 800201e <_ux_utility_memory_free_block_best_get+0x46>
                    if (memory_block -> ux_memory_block_size < best_memory_block -> ux_memory_block_size)
 8002000:	6805      	ldr	r5, [r0, #0]
 8002002:	42aa      	cmp	r2, r5
 8002004:	bf38      	it	cc
 8002006:	4618      	movcc	r0, r3
        memory_block =  memory_block -> ux_memory_block_next;
 8002008:	689b      	ldr	r3, [r3, #8]
    while (memory_block != UX_NULL)
 800200a:	2b00      	cmp	r3, #0
 800200c:	d1f1      	bne.n	8001ff2 <_ux_utility_memory_free_block_best_get+0x1a>
    }

    /* If no free memory block was found, the return value will be NULL.  */
    return(best_memory_block);        
}                                
 800200e:	bc30      	pop	{r4, r5}
 8002010:	4770      	bx	lr
            return(UX_NULL);
 8002012:	2000      	movs	r0, #0
 8002014:	4770      	bx	lr
            memory_block =  _ux_system -> ux_system_regular_memory_pool_start;
 8002016:	4b03      	ldr	r3, [pc, #12]	; (8002024 <_ux_utility_memory_free_block_best_get+0x4c>)
 8002018:	681b      	ldr	r3, [r3, #0]
 800201a:	681b      	ldr	r3, [r3, #0]
            break;
 800201c:	e7e2      	b.n	8001fe4 <_ux_utility_memory_free_block_best_get+0xc>
 800201e:	4618      	mov	r0, r3
 8002020:	e7e5      	b.n	8001fee <_ux_utility_memory_free_block_best_get+0x16>
 8002022:	bf00      	nop
 8002024:	20000dc0 	.word	0x20000dc0
 8002028:	12345678 	.word	0x12345678

0800202c <_ux_utility_memory_set>:

    /* Setup the working pointer */
    work_ptr =  (UCHAR *) destination;

    /* Loop to set the memory.  */
    while(length--)
 800202c:	b10a      	cbz	r2, 8002032 <_ux_utility_memory_set+0x6>
 800202e:	f00b be56 	b.w	800dcde <memset>
        *work_ptr++ =  value;
    }

    /* Return to caller.  */
    return; 
}
 8002032:	4770      	bx	lr

08002034 <_ux_utility_mutex_create>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_mutex_create(TX_MUTEX *mutex, CHAR *mutex_name)
{
 8002034:	b510      	push	{r4, lr}

UINT    status;


    /* Call ThreadX to create the Mutex object.  */
    status =  tx_mutex_create(mutex, (CHAR *) mutex_name, TX_NO_INHERIT);   
 8002036:	2334      	movs	r3, #52	; 0x34
 8002038:	2200      	movs	r2, #0
 800203a:	f00a fe9f 	bl	800cd7c <_txe_mutex_create>

    /* Check for status.  */
    if (status != UX_SUCCESS)
 800203e:	4604      	mov	r4, r0
 8002040:	b120      	cbz	r0, 800204c <_ux_utility_mutex_create+0x18>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
 8002042:	4602      	mov	r2, r0
 8002044:	2108      	movs	r1, #8
 8002046:	2002      	movs	r0, #2
 8002048:	f7ff fdda 	bl	8001c00 <_ux_system_error_handler>
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_MUTEX_ERROR, mutex, 0, 0, UX_TRACE_ERRORS, 0, 0)

    }
    /* Return completion status.  */
    return(status);
}
 800204c:	4620      	mov	r0, r4
 800204e:	bd10      	pop	{r4, pc}

08002050 <_ux_utility_mutex_off>:
/**************************************************************************/
VOID  _ux_utility_mutex_off(TX_MUTEX *mutex)
{

    /* Call ThreadX to release protection.  */
    tx_mutex_put(mutex);
 8002050:	f00a bf32 	b.w	800ceb8 <_txe_mutex_put>

08002054 <_ux_utility_mutex_on>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_utility_mutex_on(TX_MUTEX *mutex)
{
 8002054:	b508      	push	{r3, lr}

UINT    status;

    /* Call ThreadX to get system mutex.  */
    status =  tx_mutex_get(mutex, TX_WAIT_FOREVER);
 8002056:	f04f 31ff 	mov.w	r1, #4294967295
 800205a:	f00a fef9 	bl	800ce50 <_txe_mutex_get>

    /* Check for status.  */
    if (status != UX_SUCCESS)
 800205e:	b900      	cbnz	r0, 8002062 <_ux_utility_mutex_on+0xe>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
    }

    /* Return to caller.  */
    return;
}
 8002060:	bd08      	pop	{r3, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
 8002062:	4602      	mov	r2, r0
 8002064:	2108      	movs	r1, #8
 8002066:	2002      	movs	r0, #2
}
 8002068:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
 800206c:	f7ff bdc8 	b.w	8001c00 <_ux_system_error_handler>

08002070 <_ux_utility_semaphore_create>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_semaphore_create(TX_SEMAPHORE *semaphore, CHAR *semaphore_name, UINT initial_count)
{
 8002070:	b510      	push	{r4, lr}

UINT    status;

    /* Call ThreadX to create the semaphore.  */
    status =  tx_semaphore_create(semaphore, (CHAR *) semaphore_name, initial_count);
 8002072:	2320      	movs	r3, #32
 8002074:	f00a ff3c 	bl	800cef0 <_txe_semaphore_create>

    /* Check for status.  */
    if (status != UX_SUCCESS)
 8002078:	4604      	mov	r4, r0
 800207a:	b120      	cbz	r0, 8002086 <_ux_utility_semaphore_create+0x16>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
 800207c:	4602      	mov	r2, r0
 800207e:	2108      	movs	r1, #8
 8002080:	2002      	movs	r0, #2
 8002082:	f7ff fdbd 	bl	8001c00 <_ux_system_error_handler>

    }

    /* Return completion status.  */
    return(status);
}
 8002086:	4620      	mov	r0, r4
 8002088:	bd10      	pop	{r4, pc}
 800208a:	bf00      	nop

0800208c <_ux_utility_semaphore_delete>:
{

UINT    status;

    /* Call ThreadX Semaphore delete function.  */
    status =  tx_semaphore_delete(semaphore);
 800208c:	f00a bf8a 	b.w	800cfa4 <_txe_semaphore_delete>

08002090 <_ux_utility_semaphore_get>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_semaphore_get(TX_SEMAPHORE *semaphore, ULONG semaphore_signal)
{
 8002090:	b570      	push	{r4, r5, r6, lr}
 8002092:	b08e      	sub	sp, #56	; 0x38
 8002094:	460d      	mov	r5, r1
 8002096:	4604      	mov	r4, r0
ULONG       time_slice;
TX_THREAD   *next_thread;
TX_THREAD   *suspended_thread;

    /* Call TX to know my own tread.  */
    my_thread = tx_thread_identify();
 8002098:	f00a fab2 	bl	800c600 <_tx_thread_identify>

    /* Retrieve information about the previously created thread "my_thread." */
    tx_thread_info_get(my_thread, &name, &state, &run_count,
 800209c:	a90d      	add	r1, sp, #52	; 0x34
 800209e:	ab0b      	add	r3, sp, #44	; 0x2c
 80020a0:	aa0a      	add	r2, sp, #40	; 0x28
 80020a2:	ae0c      	add	r6, sp, #48	; 0x30
 80020a4:	9104      	str	r1, [sp, #16]
 80020a6:	a909      	add	r1, sp, #36	; 0x24
 80020a8:	9201      	str	r2, [sp, #4]
 80020aa:	aa07      	add	r2, sp, #28
 80020ac:	9100      	str	r1, [sp, #0]
 80020ae:	a906      	add	r1, sp, #24
 80020b0:	e9cd 3602 	strd	r3, r6, [sp, #8]
 80020b4:	ab08      	add	r3, sp, #32
 80020b6:	f00b f88d 	bl	800d1d4 <_txe_thread_info_get>
                       &priority, &preemption_threshold,
                       &time_slice, &next_thread,&suspended_thread);

    /* Is this the lowest priority thread in the system trying to use TX services ? */
    if (priority > _ux_system -> ux_system_thread_lowest_priority)
 80020ba:	4b06      	ldr	r3, [pc, #24]	; (80020d4 <_ux_utility_semaphore_get+0x44>)
 80020bc:	9a09      	ldr	r2, [sp, #36]	; 0x24
        _ux_system -> ux_system_thread_lowest_priority = priority;
        
    }

    /* Get ThreadX semaphore instance.  */
    status =  tx_semaphore_get(semaphore, semaphore_signal);
 80020be:	4620      	mov	r0, r4
    if (priority > _ux_system -> ux_system_thread_lowest_priority)
 80020c0:	681b      	ldr	r3, [r3, #0]
 80020c2:	6999      	ldr	r1, [r3, #24]
 80020c4:	4291      	cmp	r1, r2
    status =  tx_semaphore_get(semaphore, semaphore_signal);
 80020c6:	4629      	mov	r1, r5
        _ux_system -> ux_system_thread_lowest_priority = priority;
 80020c8:	bf38      	it	cc
 80020ca:	619a      	strcc	r2, [r3, #24]
    status =  tx_semaphore_get(semaphore, semaphore_signal);
 80020cc:	f00a ff88 	bl	800cfe0 <_txe_semaphore_get>

    /* Return completion status.  */
    return(status);
}
 80020d0:	b00e      	add	sp, #56	; 0x38
 80020d2:	bd70      	pop	{r4, r5, r6, pc}
 80020d4:	20000dc0 	.word	0x20000dc0

080020d8 <_ux_utility_semaphore_put>:
{

UINT    status;

    /* Put a ThreadX semaphore.  */
    status =  tx_semaphore_put(semaphore);
 80020d8:	f00a bfa2 	b.w	800d020 <_txe_semaphore_put>

080020dc <_ux_utility_string_length_check>:
{

UINT    string_length;


    if (string == UX_NULL)
 80020dc:	b1a0      	cbz	r0, 8002108 <_ux_utility_string_length_check+0x2c>
        return(UX_ERROR);

    string_length = 0;
 80020de:	2300      	movs	r3, #0
{
 80020e0:	b510      	push	{r4, lr}
 80020e2:	1e44      	subs	r4, r0, #1
 80020e4:	e002      	b.n	80020ec <_ux_utility_string_length_check+0x10>
    {

        if (string[string_length] == '\0')
            break;

        string_length++;
 80020e6:	3301      	adds	r3, #1
        if (string_length > max_string_length)
 80020e8:	4293      	cmp	r3, r2
 80020ea:	d806      	bhi.n	80020fa <_ux_utility_string_length_check+0x1e>
        if (string[string_length] == '\0')
 80020ec:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 80020f0:	2800      	cmp	r0, #0
 80020f2:	d1f8      	bne.n	80020e6 <_ux_utility_string_length_check+0xa>

            return(UX_ERROR);
        }
    }

    if (string_length_ptr)
 80020f4:	b151      	cbz	r1, 800210c <_ux_utility_string_length_check+0x30>
        *string_length_ptr = string_length;
 80020f6:	600b      	str	r3, [r1, #0]

    return(UX_SUCCESS); 
}
 80020f8:	bd10      	pop	{r4, pc}
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, UX_ERROR);
 80020fa:	22ff      	movs	r2, #255	; 0xff
 80020fc:	2108      	movs	r1, #8
 80020fe:	2002      	movs	r0, #2
 8002100:	f7ff fd7e 	bl	8001c00 <_ux_system_error_handler>
            return(UX_ERROR);
 8002104:	20ff      	movs	r0, #255	; 0xff
}
 8002106:	bd10      	pop	{r4, pc}
        return(UX_ERROR);
 8002108:	20ff      	movs	r0, #255	; 0xff
}
 800210a:	4770      	bx	lr
    return(UX_SUCCESS); 
 800210c:	4608      	mov	r0, r1
}
 800210e:	bd10      	pop	{r4, pc}

08002110 <_ux_utility_thread_create>:
UINT  _ux_utility_thread_create(TX_THREAD *thread_ptr, CHAR *name, 
                VOID (*entry_function)(ULONG), ULONG entry_input,
                VOID *stack_start, ULONG stack_size, 
                UINT priority, UINT preempt_threshold,
                ULONG time_slice, UINT auto_start)
{
 8002110:	b570      	push	{r4, r5, r6, lr}
 8002112:	b088      	sub	sp, #32

UINT    status;


    /* Call ThreadX to create USBX thread.  */
    status =  tx_thread_create(thread_ptr,name,entry_function,entry_input,
 8002114:	24c8      	movs	r4, #200	; 0xc8
{
 8002116:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 8002118:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    status =  tx_thread_create(thread_ptr,name,entry_function,entry_input,
 800211a:	9406      	str	r4, [sp, #24]
{
 800211c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    status =  tx_thread_create(thread_ptr,name,entry_function,entry_input,
 800211e:	e9cd 6500 	strd	r6, r5, [sp]
{
 8002122:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    status =  tx_thread_create(thread_ptr,name,entry_function,entry_input,
 8002124:	9403      	str	r4, [sp, #12]
 8002126:	9502      	str	r5, [sp, #8]
{
 8002128:	9c11      	ldr	r4, [sp, #68]	; 0x44
 800212a:	9d10      	ldr	r5, [sp, #64]	; 0x40
    status =  tx_thread_create(thread_ptr,name,entry_function,entry_input,
 800212c:	e9cd 5404 	strd	r5, r4, [sp, #16]
 8002130:	f00a ff82 	bl	800d038 <_txe_thread_create>
                    stack_start,stack_size, priority,preempt_threshold,time_slice,auto_start);

    /* Check for status.  */
    if (status != UX_SUCCESS)
 8002134:	4604      	mov	r4, r0
 8002136:	b120      	cbz	r0, 8002142 <_ux_utility_thread_create+0x32>
    {

        /* Error trap. */
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_UTILITY, status);
 8002138:	4602      	mov	r2, r0
 800213a:	2108      	movs	r1, #8
 800213c:	2002      	movs	r0, #2
 800213e:	f7ff fd5f 	bl	8001c00 <_ux_system_error_handler>
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_THREAD_ERROR, thread_ptr, 0, 0, UX_TRACE_ERRORS, 0, 0)

    }
    /* Return completion status.  */
    return(status);
}
 8002142:	4620      	mov	r0, r4
 8002144:	b008      	add	sp, #32
 8002146:	bd70      	pop	{r4, r5, r6, pc}

08002148 <_ux_utility_thread_delete>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_thread_delete(TX_THREAD *thread_ptr)
{
 8002148:	b510      	push	{r4, lr}
 800214a:	4604      	mov	r4, r0

UINT    status;


    /* Call ThreadX to terminate the USBX thread.  */
    tx_thread_terminate(thread_ptr);
 800214c:	f00b f892 	bl	800d274 <_txe_thread_terminate>

    /* Call ThreadX to delete the USBX thread.  */
    status =  tx_thread_delete(thread_ptr);
 8002150:	4620      	mov	r0, r4

    /* Return completion status.  */
    return(status);
}
 8002152:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    status =  tx_thread_delete(thread_ptr);
 8002156:	f00b b827 	b.w	800d1a8 <_txe_thread_delete>
 800215a:	bf00      	nop

0800215c <_ux_host_class_hub_activate>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_activate(UX_HOST_CLASS_COMMAND *command)
{
 800215c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}


    /* We need to make sure that the enumeration thread knows about at least
       one active HUB instance and the function to call when the thread
       is awaken.  */
    _ux_system_host -> ux_system_host_enum_hub_function =  _ux_host_class_hub_change_detect;
 800215e:	4e1e      	ldr	r6, [pc, #120]	; (80021d8 <_ux_host_class_hub_activate+0x7c>)
    /* The HUB is always activated by the device descriptor and not the
       instance descriptor.  */
    device =  (UX_DEVICE *) command -> ux_host_class_command_container;

    /* Instantiate this HUB class.  */
    hub =  (UX_HOST_CLASS_HUB *) _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HOST_CLASS_HUB));
 8002160:	2100      	movs	r1, #0
    _ux_system_host -> ux_system_host_enum_hub_function =  _ux_host_class_hub_change_detect;
 8002162:	4c1e      	ldr	r4, [pc, #120]	; (80021dc <_ux_host_class_hub_activate+0x80>)
{
 8002164:	4605      	mov	r5, r0
    _ux_system_host -> ux_system_host_enum_hub_function =  _ux_host_class_hub_change_detect;
 8002166:	6833      	ldr	r3, [r6, #0]
    hub =  (UX_HOST_CLASS_HUB *) _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HOST_CLASS_HUB));
 8002168:	4608      	mov	r0, r1
 800216a:	224c      	movs	r2, #76	; 0x4c
    device =  (UX_DEVICE *) command -> ux_host_class_command_container;
 800216c:	686f      	ldr	r7, [r5, #4]
    _ux_system_host -> ux_system_host_enum_hub_function =  _ux_host_class_hub_change_detect;
 800216e:	f8c3 4120 	str.w	r4, [r3, #288]	; 0x120
    hub =  (UX_HOST_CLASS_HUB *) _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_HOST_CLASS_HUB));
 8002172:	f7ff fdbb 	bl	8001cec <_ux_utility_memory_allocate>
    if (hub == UX_NULL)
 8002176:	b358      	cbz	r0, 80021d0 <_ux_host_class_hub_activate+0x74>
        return(UX_MEMORY_INSUFFICIENT);
        
    /* Store the class container into this instance.  */
    hub -> ux_host_class_hub_class =  command -> ux_host_class_command_class_ptr;
 8002178:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800217a:	4604      	mov	r4, r0
 800217c:	e9c0 3701 	strd	r3, r7, [r0, #4]
    /* Store the device container instance in the HUB instance, this is for 
       the class instance when it needs to talk to the USBX stack.  */
    hub -> ux_host_class_hub_device =  device;

    /* Configure the HUB.  */
    status =  _ux_host_class_hub_configure(hub);     
 8002180:	f000 f87a 	bl	8002278 <_ux_host_class_hub_configure>
    if (status == UX_SUCCESS)
 8002184:	4605      	mov	r5, r0
 8002186:	b120      	cbz	r0, 8002192 <_ux_host_class_hub_activate+0x36>
    }

    /* We get here when an error occurred.  */

    /* Free the hub instance.  */
    _ux_utility_memory_free(hub);
 8002188:	4620      	mov	r0, r4
 800218a:	f7ff fec3 	bl	8001f14 <_ux_utility_memory_free>
    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_REGISTER(UX_TRACE_HOST_OBJECT_TYPE_INTERFACE, hub, 0, 0, 0)

    /* Return completion status.  */
    return(status);    
}
 800218e:	4628      	mov	r0, r5
 8002190:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        status =  _ux_host_class_hub_descriptor_get(hub);        
 8002192:	4620      	mov	r0, r4
 8002194:	f000 f90e 	bl	80023b4 <_ux_host_class_hub_descriptor_get>
        if (status == UX_SUCCESS)
 8002198:	4605      	mov	r5, r0
 800219a:	2800      	cmp	r0, #0
 800219c:	d1f4      	bne.n	8002188 <_ux_host_class_hub_activate+0x2c>
            _ux_host_class_hub_ports_power(hub);
 800219e:	4620      	mov	r0, r4
 80021a0:	f000 fa3c 	bl	800261c <_ux_host_class_hub_ports_power>
            status =  _ux_host_class_hub_interrupt_endpoint_start(hub);      
 80021a4:	4620      	mov	r0, r4
 80021a6:	f000 f9af 	bl	8002508 <_ux_host_class_hub_interrupt_endpoint_start>
            if (status == UX_SUCCESS)
 80021aa:	4605      	mov	r5, r0
 80021ac:	2800      	cmp	r0, #0
 80021ae:	d1eb      	bne.n	8002188 <_ux_host_class_hub_activate+0x2c>
                _ux_host_stack_class_instance_create(hub -> ux_host_class_hub_class, (VOID *) hub);
 80021b0:	4621      	mov	r1, r4
 80021b2:	6860      	ldr	r0, [r4, #4]
 80021b4:	f001 fe30 	bl	8003e18 <_ux_host_stack_class_instance_create>
                if (_ux_system_host -> ux_system_host_change_function != UX_NULL)
 80021b8:	6833      	ldr	r3, [r6, #0]
                hub -> ux_host_class_hub_state =  UX_HOST_CLASS_INSTANCE_LIVE;
 80021ba:	2001      	movs	r0, #1
                device -> ux_device_class_instance =  (VOID *) hub;
 80021bc:	64fc      	str	r4, [r7, #76]	; 0x4c
                if (_ux_system_host -> ux_system_host_change_function != UX_NULL)
 80021be:	f8d3 32e0 	ldr.w	r3, [r3, #736]	; 0x2e0
                hub -> ux_host_class_hub_state =  UX_HOST_CLASS_INSTANCE_LIVE;
 80021c2:	61a0      	str	r0, [r4, #24]
                if (_ux_system_host -> ux_system_host_change_function != UX_NULL)
 80021c4:	2b00      	cmp	r3, #0
 80021c6:	d0e2      	beq.n	800218e <_ux_host_class_hub_activate+0x32>
                    _ux_system_host ->  ux_system_host_change_function(UX_DEVICE_INSERTION, hub -> ux_host_class_hub_class, (VOID *) hub);
 80021c8:	4622      	mov	r2, r4
 80021ca:	6861      	ldr	r1, [r4, #4]
 80021cc:	4798      	blx	r3
 80021ce:	e7de      	b.n	800218e <_ux_host_class_hub_activate+0x32>
        return(UX_MEMORY_INSUFFICIENT);
 80021d0:	2512      	movs	r5, #18
}
 80021d2:	4628      	mov	r0, r5
 80021d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80021d6:	bf00      	nop
 80021d8:	20000db8 	.word	0x20000db8
 80021dc:	080021e1 	.word	0x080021e1

080021e0 <_ux_host_class_hub_change_detect>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_class_hub_change_detect(VOID)
{
 80021e0:	b510      	push	{r4, lr}
 80021e2:	b082      	sub	sp, #8

    /* Get the class container first.  */
    _ux_host_stack_class_get(_ux_system_host_class_hub_name, &class);

    /* We start with the first index of the class instance.  */
    class_index =  0;
 80021e4:	2400      	movs	r4, #0
    _ux_host_stack_class_get(_ux_system_host_class_hub_name, &class);
 80021e6:	480c      	ldr	r0, [pc, #48]	; (8002218 <_ux_host_class_hub_change_detect+0x38>)
 80021e8:	4669      	mov	r1, sp
 80021ea:	f7ff fb6d 	bl	80018c8 <_ux_host_stack_class_get>
    /* We have found the class, now parse the instances.  */
    do
    {

        /* Get class instance.  */
        status =  _ux_host_stack_class_instance_get(class, class_index++, (VOID **) &hub);
 80021ee:	aa01      	add	r2, sp, #4
 80021f0:	4621      	mov	r1, r4
 80021f2:	9800      	ldr	r0, [sp, #0]
 80021f4:	f7ff fb9e 	bl	8001934 <_ux_host_stack_class_instance_get>

        /* Check completion status.  */
        if (status == UX_SUCCESS)
 80021f8:	b108      	cbz	r0, 80021fe <_ux_host_class_hub_change_detect+0x1e>
        }
    } while (status == UX_SUCCESS);    

    /* We have parsed all the HUB instances.  */
    return;
}
 80021fa:	b002      	add	sp, #8
 80021fc:	bd10      	pop	{r4, pc}
            if (hub -> ux_host_class_hub_change_semaphore != 0)
 80021fe:	9801      	ldr	r0, [sp, #4]
 8002200:	6a03      	ldr	r3, [r0, #32]
 8002202:	b90b      	cbnz	r3, 8002208 <_ux_host_class_hub_change_detect+0x28>
        status =  _ux_host_stack_class_instance_get(class, class_index++, (VOID **) &hub);
 8002204:	3401      	adds	r4, #1
 8002206:	e7f2      	b.n	80021ee <_ux_host_class_hub_change_detect+0xe>
                _ux_host_class_hub_change_process(hub);
 8002208:	f000 f808 	bl	800221c <_ux_host_class_hub_change_process>
                hub -> ux_host_class_hub_change_semaphore--;
 800220c:	9a01      	ldr	r2, [sp, #4]
 800220e:	6a13      	ldr	r3, [r2, #32]
 8002210:	3b01      	subs	r3, #1
 8002212:	6213      	str	r3, [r2, #32]
 8002214:	e7f6      	b.n	8002204 <_ux_host_class_hub_change_detect+0x24>
 8002216:	bf00      	nop
 8002218:	20000000 	.word	0x20000000

0800221c <_ux_host_class_hub_change_process>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_change_process(UX_HOST_CLASS_HUB *hub)
{
 800221c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
UINT            port_index;
UINT            status;
    

    /* Now get the transfer_request attached to the interrupt endpoint.  */
    transfer_request =  &hub -> ux_host_class_hub_interrupt_endpoint -> ux_endpoint_transfer_request;
 8002220:	68c7      	ldr	r7, [r0, #12]
{
 8002222:	4606      	mov	r6, r0
    /* The interrupt pipe buffer contains the status change for each of the ports 
       the length of the buffer can be 1 or 2 depending on the number of ports.
       Usually, since HUBs can be bus powered the maximum number of ports is 4. 
       We must be taking precautions on how we read the buffer content for
       big endian machines.  */
    if (transfer_request -> ux_transfer_request_actual_length == 1)
 8002224:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    transfer_request =  &hub -> ux_host_class_hub_interrupt_endpoint -> ux_endpoint_transfer_request;
 8002226:	f107 0830 	add.w	r8, r7, #48	; 0x30
 800222a:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    if (transfer_request -> ux_transfer_request_actual_length == 1)
 800222c:	2b01      	cmp	r3, #1
 800222e:	d11f      	bne.n	8002270 <_ux_host_class_hub_change_process+0x54>
        port_status_change_bits =  (USHORT) *transfer_request -> ux_transfer_request_data_pointer;
 8002230:	7805      	ldrb	r5, [r0, #0]
    else
        port_status_change_bits =  (USHORT)_ux_utility_short_get(transfer_request -> ux_transfer_request_data_pointer);

    /* Scan all bits and report the change on each port.  */
    for (port_index = 1; port_index <= hub -> ux_host_class_hub_descriptor.bNbPorts; port_index++)
 8002232:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8002234:	b13a      	cbz	r2, 8002246 <_ux_host_class_hub_change_process+0x2a>
 8002236:	2401      	movs	r4, #1
    {

        if (port_status_change_bits & (1<<port_index))
 8002238:	fa45 f304 	asr.w	r3, r5, r4
 800223c:	07d9      	lsls	r1, r3, #31
 800223e:	d40e      	bmi.n	800225e <_ux_host_class_hub_change_process+0x42>
    for (port_index = 1; port_index <= hub -> ux_host_class_hub_descriptor.bNbPorts; port_index++)
 8002240:	3401      	adds	r4, #1
 8002242:	4294      	cmp	r4, r2
 8002244:	d9f8      	bls.n	8002238 <_ux_host_class_hub_change_process+0x1c>
            _ux_host_class_hub_port_change_process(hub, port_index);
    }

    /* The HUB could also have changed.  */
    if (port_status_change_bits & 1)
 8002246:	07eb      	lsls	r3, r5, #31
 8002248:	d502      	bpl.n	8002250 <_ux_host_class_hub_change_process+0x34>
        _ux_host_class_hub_hub_change_process(hub);
 800224a:	4630      	mov	r0, r6
 800224c:	f000 f95a 	bl	8002504 <_ux_host_class_hub_hub_change_process>
        
    /* The actual length should be cleared for the next transfer.  */
    transfer_request -> ux_transfer_request_actual_length =  0;
 8002250:	2300      	movs	r3, #0

    /* Resend the request to the stack.  */
    status = _ux_host_stack_transfer_request(transfer_request);
 8002252:	4640      	mov	r0, r8
    transfer_request -> ux_transfer_request_actual_length =  0;
 8002254:	643b      	str	r3, [r7, #64]	; 0x40

    /* Return completion status.  */
    return(status);
}
 8002256:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    status = _ux_host_stack_transfer_request(transfer_request);
 800225a:	f002 b8c9 	b.w	80043f0 <_ux_host_stack_transfer_request>
            _ux_host_class_hub_port_change_process(hub, port_index);
 800225e:	4621      	mov	r1, r4
 8002260:	4630      	mov	r0, r6
 8002262:	f000 f987 	bl	8002574 <_ux_host_class_hub_port_change_process>
    for (port_index = 1; port_index <= hub -> ux_host_class_hub_descriptor.bNbPorts; port_index++)
 8002266:	3401      	adds	r4, #1
 8002268:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 800226a:	4294      	cmp	r4, r2
 800226c:	d9e4      	bls.n	8002238 <_ux_host_class_hub_change_process+0x1c>
 800226e:	e7ea      	b.n	8002246 <_ux_host_class_hub_change_process+0x2a>
        port_status_change_bits =  (USHORT)_ux_utility_short_get(transfer_request -> ux_transfer_request_data_pointer);
 8002270:	f002 f976 	bl	8004560 <_ux_utility_short_get>
 8002274:	b285      	uxth	r5, r0
 8002276:	e7dc      	b.n	8002232 <_ux_host_class_hub_change_process+0x16>

08002278 <_ux_host_class_hub_configure>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_configure(UX_HOST_CLASS_HUB *hub)
{
 8002278:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800227c:	b082      	sub	sp, #8
UX_TRANSFER             *transfer_request;


    /* A HUB normally has one configuration. So retrieve the 1st configuration
       only.  */
    _ux_host_stack_device_configuration_get(hub -> ux_host_class_hub_device, 0, &configuration);
 800227e:	2100      	movs	r1, #0
{
 8002280:	4606      	mov	r6, r0
    _ux_host_stack_device_configuration_get(hub -> ux_host_class_hub_device, 0, &configuration);
 8002282:	6880      	ldr	r0, [r0, #8]
 8002284:	aa01      	add	r2, sp, #4
 8002286:	f001 fe15 	bl	8003eb4 <_ux_host_stack_device_configuration_get>
        
    /* Get the device container for this configuration.  */
    device =  configuration -> ux_configuration_device;
 800228a:	9b01      	ldr	r3, [sp, #4]
       the device.  */
    control_endpoint =  &device -> ux_device_control_endpoint;
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    /* Allocate a buffer for the device status: 2 bytes.  */        
    device_status_data =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 2);
 800228c:	2202      	movs	r2, #2
 800228e:	2101      	movs	r1, #1
    device =  configuration -> ux_configuration_device;
 8002290:	6b5c      	ldr	r4, [r3, #52]	; 0x34
    device_status_data =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 2);
 8002292:	f04f 30ff 	mov.w	r0, #4294967295
    parent_device =  device -> ux_device_parent;
 8002296:	f8d4 8044 	ldr.w	r8, [r4, #68]	; 0x44
    device_status_data =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 2);
 800229a:	f7ff fd27 	bl	8001cec <_ux_utility_memory_allocate>
    if (device_status_data == UX_NULL)
 800229e:	2800      	cmp	r0, #0
 80022a0:	d041      	beq.n	8002326 <_ux_host_class_hub_configure+0xae>
        return(UX_MEMORY_INSUFFICIENT);

    /* Create a transfer_request for the GET_STATUS request, 2 bytes are returned.  */
    transfer_request -> ux_transfer_request_requested_length =  2;
    transfer_request -> ux_transfer_request_data_pointer =      device_status_data;
    transfer_request -> ux_transfer_request_function =          UX_GET_STATUS;
 80022a2:	2300      	movs	r3, #0
    transfer_request -> ux_transfer_request_requested_length =  2;
 80022a4:	2702      	movs	r7, #2
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 80022a6:	2280      	movs	r2, #128	; 0x80
 80022a8:	4605      	mov	r5, r0
    transfer_request -> ux_transfer_request_value =             0;
    transfer_request -> ux_transfer_request_index =             0;
 80022aa:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 80022ae:	f8c4 20d8 	str.w	r2, [r4, #216]	; 0xd8
    transfer_request -> ux_transfer_request_requested_length =  2;
 80022b2:	e9c4 0733 	strd	r0, r7, [r4, #204]	; 0xcc
    transfer_request -> ux_transfer_request_value =             0;
 80022b6:	e9c4 3337 	strd	r3, r3, [r4, #220]	; 0xdc

    /* Send request to HCD layer.  */
    status =  _ux_host_stack_transfer_request(transfer_request);
 80022ba:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
 80022be:	f002 f897 	bl	80043f0 <_ux_host_stack_transfer_request>

    /* Check the status and the length of the data returned.  */
    if ((status == UX_SUCCESS) && (transfer_request -> ux_transfer_request_actual_length == 2))
 80022c2:	bb20      	cbnz	r0, 800230e <_ux_host_class_hub_configure+0x96>
 80022c4:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80022c8:	42bb      	cmp	r3, r7
 80022ca:	d120      	bne.n	800230e <_ux_host_class_hub_configure+0x96>
    {
        
        /* The data returned is good, now analyze power source.  */
        if (*device_status_data & UX_STATUS_DEVICE_SELF_POWERED)
 80022cc:	782a      	ldrb	r2, [r5, #0]
            device -> ux_device_power_source =  UX_DEVICE_SELF_POWERED;
        else
            device -> ux_device_power_source =  UX_DEVICE_BUS_POWERED;

        /* Free the buffer resource now.  */
        _ux_utility_memory_free(device_status_data);
 80022ce:	4628      	mov	r0, r5
            device -> ux_device_power_source =  UX_DEVICE_BUS_POWERED;
 80022d0:	f012 0f01 	tst.w	r2, #1
 80022d4:	bf08      	it	eq
 80022d6:	2301      	moveq	r3, #1
 80022d8:	61e3      	str	r3, [r4, #28]
        _ux_utility_memory_free(device_status_data);
 80022da:	f7ff fe1b 	bl	8001f14 <_ux_utility_memory_free>
        return(UX_CONNECTION_INCOMPATIBLE);
    }               
    
    /* Check the HUB power source and check the parent power source for 
       incompatible connections.  */
    if (hub -> ux_host_class_hub_device -> ux_device_power_source == UX_DEVICE_BUS_POWERED)
 80022de:	68b3      	ldr	r3, [r6, #8]
 80022e0:	69db      	ldr	r3, [r3, #28]
    {
        
        /* If the device is NULL, the parent is the root HUB and we don't have to worry 
           if the parent is not the root HUB, check for its power source.  */
        if ((parent_device != UX_NULL) && (parent_device -> ux_device_power_source == UX_DEVICE_BUS_POWERED))
 80022e2:	2b01      	cmp	r3, #1
 80022e4:	d106      	bne.n	80022f4 <_ux_host_class_hub_configure+0x7c>
 80022e6:	f1b8 0f00 	cmp.w	r8, #0
 80022ea:	d003      	beq.n	80022f4 <_ux_host_class_hub_configure+0x7c>
 80022ec:	f8d8 301c 	ldr.w	r3, [r8, #28]
 80022f0:	2b01      	cmp	r3, #1
 80022f2:	d01c      	beq.n	800232e <_ux_host_class_hub_configure+0xb6>
            return(UX_CONNECTION_INCOMPATIBLE);
        }            
    }
    
    /* We have the valid configuration. Ask the USBX stack to set this configuration.  */        
    status =  _ux_host_stack_device_configuration_select(configuration);
 80022f4:	9801      	ldr	r0, [sp, #4]
 80022f6:	f001 fdfd 	bl	8003ef4 <_ux_host_stack_device_configuration_select>

    /* If the operation went well, the HUB default alternate setting for the HUB interface is 
       active and the interrupt endpoint is now enabled. We have to memorize the first interface 
       since the interrupt endpoint is hooked to it. */
    status =  _ux_host_stack_configuration_interface_get(configuration, 0, 0, &hub -> ux_host_class_hub_interface);
 80022fa:	2200      	movs	r2, #0
 80022fc:	f106 0310 	add.w	r3, r6, #16
 8002300:	9801      	ldr	r0, [sp, #4]
 8002302:	4611      	mov	r1, r2
 8002304:	f001 fdb0 	bl	8003e68 <_ux_host_stack_configuration_interface_get>

    /* Return completion status.  */
    return(status);
}
 8002308:	b002      	add	sp, #8
 800230a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        _ux_utility_memory_free(device_status_data);
 800230e:	4628      	mov	r0, r5
 8002310:	f7ff fe00 	bl	8001f14 <_ux_utility_memory_free>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HUB, UX_CONNECTION_INCOMPATIBLE);
 8002314:	2002      	movs	r0, #2
 8002316:	225a      	movs	r2, #90	; 0x5a
 8002318:	2106      	movs	r1, #6
 800231a:	f7ff fc71 	bl	8001c00 <_ux_system_error_handler>
        return(UX_CONNECTION_INCOMPATIBLE);
 800231e:	205a      	movs	r0, #90	; 0x5a
}
 8002320:	b002      	add	sp, #8
 8002322:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8002326:	2012      	movs	r0, #18
}
 8002328:	b002      	add	sp, #8
 800232a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HUB, UX_CONNECTION_INCOMPATIBLE);
 800232e:	4638      	mov	r0, r7
 8002330:	225a      	movs	r2, #90	; 0x5a
 8002332:	2106      	movs	r1, #6
 8002334:	f7ff fc64 	bl	8001c00 <_ux_system_error_handler>
            return(UX_CONNECTION_INCOMPATIBLE);
 8002338:	205a      	movs	r0, #90	; 0x5a
 800233a:	e7f1      	b.n	8002320 <_ux_host_class_hub_configure+0xa8>

0800233c <_ux_host_class_hub_deactivate>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_deactivate(UX_HOST_CLASS_COMMAND *command)
{
 800233c:	b570      	push	{r4, r5, r6, lr}
UX_TRANSFER             *transfer_request;
UINT                    port_index;


    /* Get the instance to the class.  */
    hub =  (UX_HOST_CLASS_HUB *) command -> ux_host_class_command_instance;
 800233e:	6885      	ldr	r5, [r0, #8]

    /* Get the HCD used by this instance.  */
    hcd =  hub -> ux_host_class_hub_device -> ux_device_hcd;

    /* The HUB is being shut down.  */
    hub -> ux_host_class_hub_state =  UX_HOST_CLASS_INSTANCE_SHUTDOWN;
 8002340:	2302      	movs	r3, #2
    
    /* We need to abort transactions on the interrupt pipe.  */
    _ux_host_stack_endpoint_transfer_abort(hub -> ux_host_class_hub_interrupt_endpoint);
 8002342:	e9d5 2002 	ldrd	r2, r0, [r5, #8]
    hcd =  hub -> ux_host_class_hub_device -> ux_device_hcd;
 8002346:	6d16      	ldr	r6, [r2, #80]	; 0x50
    hub -> ux_host_class_hub_state =  UX_HOST_CLASS_INSTANCE_SHUTDOWN;
 8002348:	61ab      	str	r3, [r5, #24]
    _ux_host_stack_endpoint_transfer_abort(hub -> ux_host_class_hub_interrupt_endpoint);
 800234a:	f001 ff05 	bl	8004158 <_ux_host_stack_endpoint_transfer_abort>

    /* Each device which is downstream on the HUB ports must be removed.  */
    for (port_index = 1; port_index <= hub -> ux_host_class_hub_descriptor.bNbPorts; port_index++)
 800234e:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8002350:	b142      	cbz	r2, 8002364 <_ux_host_class_hub_deactivate+0x28>
 8002352:	2401      	movs	r4, #1
 8002354:	6c69      	ldr	r1, [r5, #68]	; 0x44
    {

        /* Is there a device on this port?  */
        if (hub -> ux_host_class_hub_port_state & (1UL << port_index))
 8002356:	fa21 f304 	lsr.w	r3, r1, r4
 800235a:	07db      	lsls	r3, r3, #31
 800235c:	d41e      	bmi.n	800239c <_ux_host_class_hub_deactivate+0x60>
    for (port_index = 1; port_index <= hub -> ux_host_class_hub_descriptor.bNbPorts; port_index++)
 800235e:	3401      	adds	r4, #1
 8002360:	4294      	cmp	r4, r2
 8002362:	d9f8      	bls.n	8002356 <_ux_host_class_hub_deactivate+0x1a>
        }
    }

    /* If the Hub class instance has a interrupt pipe with a data payload associated with it
       it must be freed.  First get the transfer request. */
    transfer_request =  &hub -> ux_host_class_hub_interrupt_endpoint -> ux_endpoint_transfer_request;
 8002364:	68ec      	ldr	r4, [r5, #12]

    /* Abort the data transfer on the interrupt endpoint.  */
    _ux_host_stack_endpoint_transfer_abort(hub -> ux_host_class_hub_interrupt_endpoint);
 8002366:	4620      	mov	r0, r4
 8002368:	f001 fef6 	bl	8004158 <_ux_host_stack_endpoint_transfer_abort>

    /* The enumeration thread needs to sleep a while to allow the application or the class that may be using
       endpoints to exit properly.  */
    _ux_utility_thread_schedule_other(UX_THREAD_PRIORITY_ENUM); 
 800236c:	2014      	movs	r0, #20
 800236e:	f002 f90f 	bl	8004590 <_ux_utility_thread_schedule_other>

    /* Then de allocate the memory.  */
    _ux_utility_memory_free(transfer_request -> ux_transfer_request_data_pointer);
 8002372:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8002374:	f7ff fdce 	bl	8001f14 <_ux_utility_memory_free>

    /* Destroy the instance.  */
    _ux_host_stack_class_instance_destroy(hub -> ux_host_class_hub_class, (VOID *) hub);
 8002378:	4629      	mov	r1, r5
 800237a:	6868      	ldr	r0, [r5, #4]
 800237c:	f001 fd5a 	bl	8003e34 <_ux_host_stack_class_instance_destroy>

    /* Before we free the device resources, we need to inform the application
        that the device is removed.  */
    if (_ux_system_host -> ux_system_host_change_function != UX_NULL)
 8002380:	4b0b      	ldr	r3, [pc, #44]	; (80023b0 <_ux_host_class_hub_deactivate+0x74>)
 8002382:	681b      	ldr	r3, [r3, #0]
 8002384:	f8d3 32e0 	ldr.w	r3, [r3, #736]	; 0x2e0
 8002388:	b11b      	cbz	r3, 8002392 <_ux_host_class_hub_deactivate+0x56>
    {
        
        /* Inform the application the device is removed.  */
        _ux_system_host -> ux_system_host_change_function(UX_DEVICE_REMOVAL, hub -> ux_host_class_hub_class, (VOID *) hub);
 800238a:	462a      	mov	r2, r5
 800238c:	6869      	ldr	r1, [r5, #4]
 800238e:	2002      	movs	r0, #2
 8002390:	4798      	blx	r3

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_UNREGISTER(hub);

    /* Free the memory block used by the class.  */
    _ux_utility_memory_free(hub);
 8002392:	4628      	mov	r0, r5
 8002394:	f7ff fdbe 	bl	8001f14 <_ux_utility_memory_free>

    /* Return successful completion.  */
    return(UX_SUCCESS);         
}
 8002398:	2000      	movs	r0, #0
 800239a:	bd70      	pop	{r4, r5, r6, pc}
            _ux_host_stack_device_remove(hcd, hub -> ux_host_class_hub_device, port_index);
 800239c:	4622      	mov	r2, r4
 800239e:	68a9      	ldr	r1, [r5, #8]
 80023a0:	4630      	mov	r0, r6
    for (port_index = 1; port_index <= hub -> ux_host_class_hub_descriptor.bNbPorts; port_index++)
 80023a2:	3401      	adds	r4, #1
            _ux_host_stack_device_remove(hcd, hub -> ux_host_class_hub_device, port_index);
 80023a4:	f001 fdda 	bl	8003f5c <_ux_host_stack_device_remove>
 80023a8:	6aea      	ldr	r2, [r5, #44]	; 0x2c
    for (port_index = 1; port_index <= hub -> ux_host_class_hub_descriptor.bNbPorts; port_index++)
 80023aa:	4294      	cmp	r4, r2
 80023ac:	d9d2      	bls.n	8002354 <_ux_host_class_hub_deactivate+0x18>
 80023ae:	e7d9      	b.n	8002364 <_ux_host_class_hub_deactivate+0x28>
 80023b0:	20000db8 	.word	0x20000db8

080023b4 <_ux_host_class_hub_descriptor_get>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_descriptor_get(UX_HOST_CLASS_HUB *hub)
{
 80023b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80023b8:	4607      	mov	r7, r0
    /* We need to get the default control endpoint transfer request pointer.  */
    control_endpoint =  &hub -> ux_host_class_hub_device -> ux_device_control_endpoint;
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    /* Need to allocate memory for the descriptor.  */
    descriptor =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HUB_DESCRIPTOR_LENGTH);
 80023ba:	2209      	movs	r2, #9
 80023bc:	2101      	movs	r1, #1
 80023be:	f04f 30ff 	mov.w	r0, #4294967295
    control_endpoint =  &hub -> ux_host_class_hub_device -> ux_device_control_endpoint;
 80023c2:	68bc      	ldr	r4, [r7, #8]
    descriptor =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HUB_DESCRIPTOR_LENGTH);
 80023c4:	f7ff fc92 	bl	8001cec <_ux_utility_memory_allocate>
    if (descriptor == UX_NULL)
 80023c8:	b328      	cbz	r0, 8002416 <_ux_host_class_hub_descriptor_get+0x62>
 80023ca:	4605      	mov	r5, r0

    /* Create a transfer request for the GET_DESCRIPTOR request.  */
    transfer_request -> ux_transfer_request_data_pointer =      descriptor;
    transfer_request -> ux_transfer_request_requested_length =  UX_HUB_DESCRIPTOR_LENGTH;
    transfer_request -> ux_transfer_request_function =          UX_HOST_CLASS_HUB_GET_DESCRIPTOR;
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_DEVICE;
 80023cc:	21a0      	movs	r1, #160	; 0xa0
    transfer_request -> ux_transfer_request_requested_length =  UX_HUB_DESCRIPTOR_LENGTH;
 80023ce:	2009      	movs	r0, #9
    transfer_request -> ux_transfer_request_value =             (UX_HUB_DESCRIPTOR_ITEM << 8);
 80023d0:	f44f 5224 	mov.w	r2, #10496	; 0x2900
    transfer_request -> ux_transfer_request_index =             0;
 80023d4:	2300      	movs	r3, #0
    transfer_request -> ux_transfer_request_function =          UX_HOST_CLASS_HUB_GET_DESCRIPTOR;
 80023d6:	f04f 0806 	mov.w	r8, #6
    transfer_request -> ux_transfer_request_requested_length =  UX_HUB_DESCRIPTOR_LENGTH;
 80023da:	f8c4 00d0 	str.w	r0, [r4, #208]	; 0xd0

    /* Send request to HCD layer.  */
    status =  _ux_host_stack_transfer_request(transfer_request);
 80023de:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
    transfer_request -> ux_transfer_request_data_pointer =      descriptor;
 80023e2:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_DEVICE;
 80023e6:	e9c4 1836 	strd	r1, r8, [r4, #216]	; 0xd8
    transfer_request -> ux_transfer_request_index =             0;
 80023ea:	e9c4 2338 	strd	r2, r3, [r4, #224]	; 0xe0
    status =  _ux_host_stack_transfer_request(transfer_request);
 80023ee:	f001 ffff 	bl	80043f0 <_ux_host_stack_transfer_request>

    /* Did the transfer succeed?  */
    if (status == UX_SUCCESS)
 80023f2:	4606      	mov	r6, r0
 80023f4:	b948      	cbnz	r0, 800240a <_ux_host_class_hub_descriptor_get+0x56>
    {

        /* Is the length valid?  */
        if (transfer_request -> ux_transfer_request_actual_length == UX_HUB_DESCRIPTOR_LENGTH)
 80023f6:	f8d4 40d4 	ldr.w	r4, [r4, #212]	; 0xd4
 80023fa:	2c09      	cmp	r4, #9
 80023fc:	d00f      	beq.n	800241e <_ux_host_class_hub_descriptor_get+0x6a>

            /* If trace is enabled, insert this event into the trace buffer.  */
            UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_DESCRIPTOR_CORRUPTED, descriptor, 0, 0, UX_TRACE_ERRORS, 0, 0)

            /* The descriptor must be corrupted if we got an invalid length.  */
            status =  UX_DESCRIPTOR_CORRUPTED;
 80023fe:	2642      	movs	r6, #66	; 0x42
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HUB, UX_DESCRIPTOR_CORRUPTED);
 8002400:	4641      	mov	r1, r8
 8002402:	2002      	movs	r0, #2
 8002404:	4632      	mov	r2, r6
 8002406:	f7ff fbfb 	bl	8001c00 <_ux_system_error_handler>
        }
    }

    /* Free the memory for the descriptor.  */
    _ux_utility_memory_free(descriptor);
 800240a:	4628      	mov	r0, r5
 800240c:	f7ff fd82 	bl	8001f14 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(status);
}
 8002410:	4630      	mov	r0, r6
 8002412:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8002416:	2612      	movs	r6, #18
}
 8002418:	4630      	mov	r0, r6
 800241a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            _ux_utility_descriptor_parse(descriptor, _ux_system_hub_descriptor_structure, UX_HUB_DESCRIPTOR_ENTRIES,
 800241e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8002422:	2208      	movs	r2, #8
 8002424:	4936      	ldr	r1, [pc, #216]	; (8002500 <_ux_host_class_hub_descriptor_get+0x14c>)
 8002426:	4628      	mov	r0, r5
 8002428:	f002 f856 	bl	80044d8 <_ux_utility_descriptor_parse>
            switch (hub -> ux_host_class_hub_device -> ux_device_descriptor.bDeviceProtocol)
 800242c:	68bb      	ldr	r3, [r7, #8]
 800242e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8002430:	2a01      	cmp	r2, #1
 8002432:	d05b      	beq.n	80024ec <_ux_host_class_hub_descriptor_get+0x138>
 8002434:	d3e9      	bcc.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
 8002436:	2a02      	cmp	r2, #2
 8002438:	d151      	bne.n	80024de <_ux_host_class_hub_descriptor_get+0x12a>
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 800243a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800243c:	2900      	cmp	r1, #0
 800243e:	d0e4      	beq.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 8002440:	2701      	movs	r7, #1
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 8002442:	f241 7070 	movw	r0, #6000	; 0x1770
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 8002446:	42b9      	cmp	r1, r7
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 8002448:	f8c3 712c 	str.w	r7, [r3, #300]	; 0x12c
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 800244c:	f8c3 0130 	str.w	r0, [r3, #304]	; 0x130
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 8002450:	d9db      	bls.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
 8002452:	2902      	cmp	r1, #2
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 8002454:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 8002458:	f8c3 0138 	str.w	r0, [r3, #312]	; 0x138
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 800245c:	d0d5      	beq.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 800245e:	2204      	movs	r2, #4
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 8002460:	2903      	cmp	r1, #3
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 8002462:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 8002466:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 800246a:	d0ce      	beq.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 800246c:	2008      	movs	r0, #8
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 800246e:	f241 7270 	movw	r2, #6000	; 0x1770
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 8002472:	2904      	cmp	r1, #4
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 8002474:	f8c3 0144 	str.w	r0, [r3, #324]	; 0x144
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 8002478:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 800247c:	d0c5      	beq.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 800247e:	2010      	movs	r0, #16
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 8002480:	2905      	cmp	r1, #5
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 8002482:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 8002486:	f8c3 014c 	str.w	r0, [r3, #332]	; 0x14c
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 800248a:	d0be      	beq.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 800248c:	2020      	movs	r0, #32
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 800248e:	2906      	cmp	r1, #6
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 8002490:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 8002494:	f8c3 0154 	str.w	r0, [r3, #340]	; 0x154
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 8002498:	d0b7      	beq.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 800249a:	2040      	movs	r0, #64	; 0x40
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 800249c:	2907      	cmp	r1, #7
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 800249e:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 80024a2:	f8c3 015c 	str.w	r0, [r3, #348]	; 0x15c
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 80024a6:	d0b0      	beq.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 80024a8:	2080      	movs	r0, #128	; 0x80
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 80024aa:	2908      	cmp	r1, #8
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 80024ac:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 80024b0:	f8c3 0164 	str.w	r0, [r3, #356]	; 0x164
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 80024b4:	d0a9      	beq.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 80024b6:	f44f 7080 	mov.w	r0, #256	; 0x100
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 80024ba:	2909      	cmp	r1, #9
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 80024bc:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 80024c0:	f8c3 016c 	str.w	r0, [r3, #364]	; 0x16c
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 80024c4:	d0a1      	beq.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 80024c6:	4638      	mov	r0, r7
 80024c8:	fa00 f704 	lsl.w	r7, r0, r4
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 80024cc:	3401      	adds	r4, #1
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 80024ce:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
 80024d2:	3308      	adds	r3, #8
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 80024d4:	428c      	cmp	r4, r1
                    hub -> ux_host_class_hub_device -> ux_device_hub_tt[port_index].ux_hub_tt_port_mapping =   (ULONG)(1 << port_index);
 80024d6:	f8c3 716c 	str.w	r7, [r3, #364]	; 0x16c
                for (port_index = 0; port_index < hub -> ux_host_class_hub_descriptor.bNbPorts;port_index++)
 80024da:	d1f5      	bne.n	80024c8 <_ux_host_class_hub_descriptor_get+0x114>
 80024dc:	e795      	b.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HUB, UX_DESCRIPTOR_CORRUPTED);
 80024de:	2242      	movs	r2, #66	; 0x42
 80024e0:	4641      	mov	r1, r8
 80024e2:	2002      	movs	r0, #2
                status =  UX_DESCRIPTOR_CORRUPTED;
 80024e4:	4616      	mov	r6, r2
                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HUB, UX_DESCRIPTOR_CORRUPTED);
 80024e6:	f7ff fb8b 	bl	8001c00 <_ux_system_error_handler>
 80024ea:	e78e      	b.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
                hub -> ux_host_class_hub_device -> ux_device_hub_tt[0].ux_hub_tt_port_mapping =   UX_TT_MASK;
 80024ec:	f240 11ff 	movw	r1, #511	; 0x1ff
                hub -> ux_host_class_hub_device -> ux_device_hub_tt[0].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 80024f0:	f241 7270 	movw	r2, #6000	; 0x1770
                hub -> ux_host_class_hub_device -> ux_device_hub_tt[0].ux_hub_tt_port_mapping =   UX_TT_MASK;
 80024f4:	f8c3 112c 	str.w	r1, [r3, #300]	; 0x12c
                hub -> ux_host_class_hub_device -> ux_device_hub_tt[0].ux_hub_tt_max_bandwidth =  UX_TT_BANDWIDTH;
 80024f8:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
                break;          
 80024fc:	e785      	b.n	800240a <_ux_host_class_hub_descriptor_get+0x56>
 80024fe:	bf00      	nop
 8002500:	200000dc 	.word	0x200000dc

08002504 <_ux_host_class_hub_hub_change_process>:

    UX_PARAMETER_NOT_USED(hub);

    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 8002504:	2000      	movs	r0, #0
 8002506:	4770      	bx	lr

08002508 <_ux_host_class_hub_interrupt_endpoint_start>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_interrupt_endpoint_start(UX_HOST_CLASS_HUB *hub)
{
 8002508:	b570      	push	{r4, r5, r6, lr}
UINT            status;
UX_TRANSFER     *transfer_request;


    /* Search the interrupt endpoint. It is attached to the interface container.  */
    status =  _ux_host_stack_interface_endpoint_get(hub -> ux_host_class_hub_interface, 0, &hub -> ux_host_class_hub_interrupt_endpoint);
 800250a:	f100 020c 	add.w	r2, r0, #12
{
 800250e:	4604      	mov	r4, r0
    status =  _ux_host_stack_interface_endpoint_get(hub -> ux_host_class_hub_interface, 0, &hub -> ux_host_class_hub_interrupt_endpoint);
 8002510:	2100      	movs	r1, #0
 8002512:	6900      	ldr	r0, [r0, #16]
 8002514:	f001 fe74 	bl	8004200 <_ux_host_stack_interface_endpoint_get>

    /* Check completion status.  */
    if (status != UX_SUCCESS)
 8002518:	4605      	mov	r5, r0
 800251a:	b970      	cbnz	r0, 800253a <_ux_host_class_hub_interrupt_endpoint_start+0x32>
        return(status);
    
    /* Do a sanity check on the nature of the endpoint. Must be interrupt and its direction must be IN.  */        
    if (((hub -> ux_host_class_hub_interrupt_endpoint -> ux_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_IN) &&
 800251c:	68e6      	ldr	r6, [r4, #12]
 800251e:	6973      	ldr	r3, [r6, #20]
 8002520:	061b      	lsls	r3, r3, #24
 8002522:	d504      	bpl.n	800252e <_ux_host_class_hub_interrupt_endpoint_start+0x26>
        ((hub -> ux_host_class_hub_interrupt_endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) == UX_INTERRUPT_ENDPOINT))
 8002524:	69b3      	ldr	r3, [r6, #24]
 8002526:	f003 0303 	and.w	r3, r3, #3
    if (((hub -> ux_host_class_hub_interrupt_endpoint -> ux_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_IN) &&
 800252a:	2b03      	cmp	r3, #3
 800252c:	d007      	beq.n	800253e <_ux_host_class_hub_interrupt_endpoint_start+0x36>

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_ENDPOINT_HANDLE_UNKNOWN, hub -> ux_host_class_hub_interrupt_endpoint, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* Return error.  */
    return(UX_ENDPOINT_HANDLE_UNKNOWN);
 800252e:	2553      	movs	r5, #83	; 0x53
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HUB, UX_ENDPOINT_HANDLE_UNKNOWN);
 8002530:	2106      	movs	r1, #6
 8002532:	2002      	movs	r0, #2
 8002534:	462a      	mov	r2, r5
 8002536:	f7ff fb63 	bl	8001c00 <_ux_system_error_handler>
}
 800253a:	4628      	mov	r0, r5
 800253c:	bd70      	pop	{r4, r5, r6, pc}
        transfer_request -> ux_transfer_request_requested_length =  hub -> ux_host_class_hub_interrupt_endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 800253e:	69f2      	ldr	r2, [r6, #28]
        hub -> ux_host_class_hub_interrupt_endpoint -> ux_endpoint_transfer_request.ux_transfer_request_type =  UX_REQUEST_IN;
 8002540:	2080      	movs	r0, #128	; 0x80
        transfer_request -> ux_transfer_request_completion_function =  _ux_host_class_hub_transfer_request_completed;
 8002542:	4b0b      	ldr	r3, [pc, #44]	; (8002570 <_ux_host_class_hub_interrupt_endpoint_start+0x68>)
        transfer_request -> ux_transfer_request_data_pointer =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 
 8002544:	2101      	movs	r1, #1
        hub -> ux_host_class_hub_interrupt_endpoint -> ux_endpoint_transfer_request.ux_transfer_request_type =  UX_REQUEST_IN;
 8002546:	6470      	str	r0, [r6, #68]	; 0x44
        transfer_request -> ux_transfer_request_data_pointer =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 
 8002548:	f04f 30ff 	mov.w	r0, #4294967295
        transfer_request -> ux_transfer_request_actual_length =  0;
 800254c:	6435      	str	r5, [r6, #64]	; 0x40
        transfer_request -> ux_transfer_request_class_instance =  (VOID *) hub;
 800254e:	67b4      	str	r4, [r6, #120]	; 0x78
        transfer_request -> ux_transfer_request_requested_length =  hub -> ux_host_class_hub_interrupt_endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8002550:	63f2      	str	r2, [r6, #60]	; 0x3c
        transfer_request -> ux_transfer_request_completion_function =  _ux_host_class_hub_transfer_request_completed;
 8002552:	6573      	str	r3, [r6, #84]	; 0x54
        transfer_request -> ux_transfer_request_data_pointer =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 
 8002554:	f7ff fbca 	bl	8001cec <_ux_utility_memory_allocate>
 8002558:	63b0      	str	r0, [r6, #56]	; 0x38
        if (transfer_request -> ux_transfer_request_data_pointer == UX_NULL)
 800255a:	b128      	cbz	r0, 8002568 <_ux_host_class_hub_interrupt_endpoint_start+0x60>
        status =  _ux_host_stack_transfer_request(transfer_request);
 800255c:	f106 0030 	add.w	r0, r6, #48	; 0x30
}
 8002560:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        status =  _ux_host_stack_transfer_request(transfer_request);
 8002564:	f001 bf44 	b.w	80043f0 <_ux_host_stack_transfer_request>
            hub -> ux_host_class_hub_interrupt_endpoint = UX_NULL;
 8002568:	60e5      	str	r5, [r4, #12]
            return(UX_MEMORY_INSUFFICIENT);
 800256a:	2512      	movs	r5, #18
 800256c:	e7e5      	b.n	800253a <_ux_host_class_hub_interrupt_endpoint_start+0x32>
 800256e:	bf00      	nop
 8002570:	080026f1 	.word	0x080026f1

08002574 <_ux_host_class_hub_port_change_process>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_port_change_process(UX_HOST_CLASS_HUB *hub, UINT port)
{
 8002574:	b570      	push	{r4, r5, r6, lr}
 8002576:	b082      	sub	sp, #8
 8002578:	4605      	mov	r5, r0
 800257a:	460e      	mov	r6, r1
USHORT      port_change;
UINT        status;
    

    /* First step is to retrieve the status on the port with a GET_STATUS.  */
    status =  _ux_host_class_hub_status_get(hub, port, &port_status, &port_change);
 800257c:	f10d 0306 	add.w	r3, sp, #6
 8002580:	aa01      	add	r2, sp, #4
 8002582:	f000 f877 	bl	8002674 <_ux_host_class_hub_status_get>
    if (status != UX_SUCCESS)
 8002586:	4604      	mov	r4, r0
 8002588:	b958      	cbnz	r0, 80025a2 <_ux_host_class_hub_port_change_process+0x2e>
        return(status);
            
    /* On return of the GET_STATUS, the port change field has been updated 
       check for each of the bits it may contain.  */
    if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_CONNECTION)
 800258a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800258e:	07da      	lsls	r2, r3, #31
 8002590:	d413      	bmi.n	80025ba <_ux_host_class_hub_port_change_process+0x46>
        _ux_host_class_hub_port_change_connection_process(hub, port, port_status);       

    if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_ENABLE)
 8002592:	0798      	lsls	r0, r3, #30
 8002594:	d41b      	bmi.n	80025ce <_ux_host_class_hub_port_change_process+0x5a>
        _ux_host_class_hub_port_change_enable_process(hub, port, port_status);       

    if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_SUSPEND)
 8002596:	0759      	lsls	r1, r3, #29
 8002598:	d423      	bmi.n	80025e2 <_ux_host_class_hub_port_change_process+0x6e>
        _ux_host_class_hub_port_change_suspend_process(hub, port, port_status);       

    if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_OVER_CURRENT)
 800259a:	071a      	lsls	r2, r3, #28
 800259c:	d42b      	bmi.n	80025f6 <_ux_host_class_hub_port_change_process+0x82>
        _ux_host_class_hub_port_change_over_current_process(hub, port, port_status);       

    if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_RESET)
 800259e:	06db      	lsls	r3, r3, #27
 80025a0:	d402      	bmi.n	80025a8 <_ux_host_class_hub_port_change_process+0x34>
        _ux_host_class_hub_port_change_reset_process(hub, port, port_status);       
           
    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 80025a2:	4620      	mov	r0, r4
 80025a4:	b002      	add	sp, #8
 80025a6:	bd70      	pop	{r4, r5, r6, pc}
        _ux_host_class_hub_port_change_reset_process(hub, port, port_status);       
 80025a8:	4628      	mov	r0, r5
 80025aa:	4631      	mov	r1, r6
 80025ac:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 80025b0:	f000 f82c 	bl	800260c <_ux_host_class_hub_port_change_reset_process>
}
 80025b4:	4620      	mov	r0, r4
 80025b6:	b002      	add	sp, #8
 80025b8:	bd70      	pop	{r4, r5, r6, pc}
        _ux_host_class_hub_port_change_connection_process(hub, port, port_status);       
 80025ba:	4628      	mov	r0, r5
 80025bc:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 80025c0:	4631      	mov	r1, r6
 80025c2:	f002 f811 	bl	80045e8 <_ux_host_class_hub_port_change_connection_process>
 80025c6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_ENABLE)
 80025ca:	0798      	lsls	r0, r3, #30
 80025cc:	d5e3      	bpl.n	8002596 <_ux_host_class_hub_port_change_process+0x22>
        _ux_host_class_hub_port_change_enable_process(hub, port, port_status);       
 80025ce:	4631      	mov	r1, r6
 80025d0:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 80025d4:	4628      	mov	r0, r5
 80025d6:	f002 f88b 	bl	80046f0 <_ux_host_class_hub_port_change_enable_process>
 80025da:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_SUSPEND)
 80025de:	0759      	lsls	r1, r3, #29
 80025e0:	d5db      	bpl.n	800259a <_ux_host_class_hub_port_change_process+0x26>
        _ux_host_class_hub_port_change_suspend_process(hub, port, port_status);       
 80025e2:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 80025e6:	4631      	mov	r1, r6
 80025e8:	4628      	mov	r0, r5
 80025ea:	f000 f813 	bl	8002614 <_ux_host_class_hub_port_change_suspend_process>
 80025ee:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_OVER_CURRENT)
 80025f2:	071a      	lsls	r2, r3, #28
 80025f4:	d5d3      	bpl.n	800259e <_ux_host_class_hub_port_change_process+0x2a>
        _ux_host_class_hub_port_change_over_current_process(hub, port, port_status);       
 80025f6:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 80025fa:	4631      	mov	r1, r6
 80025fc:	4628      	mov	r0, r5
 80025fe:	f002 f87b 	bl	80046f8 <_ux_host_class_hub_port_change_over_current_process>
 8002602:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_RESET)
 8002606:	06db      	lsls	r3, r3, #27
 8002608:	d5cb      	bpl.n	80025a2 <_ux_host_class_hub_port_change_process+0x2e>
 800260a:	e7cd      	b.n	80025a8 <_ux_host_class_hub_port_change_process+0x34>

0800260c <_ux_host_class_hub_port_change_reset_process>:

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_HUB_PORT_CHANGE_RESET_PROCESS, hub, port, port_status, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

    /* Here we simply clear the condition so that we don't get awaken again.  */
    _ux_host_class_hub_feature(hub, port, UX_CLEAR_FEATURE, UX_HOST_CLASS_HUB_C_PORT_RESET);
 800260c:	2314      	movs	r3, #20
 800260e:	2201      	movs	r2, #1
 8002610:	f001 bfd6 	b.w	80045c0 <_ux_host_class_hub_feature>

08002614 <_ux_host_class_hub_port_change_suspend_process>:

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_HUB_PORT_CHANGE_SUSPEND_PROCESS, hub, port, port_status, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

    /* Here we simply clear the condition so that we don't get awaken again.  */
    _ux_host_class_hub_feature(hub, port, UX_CLEAR_FEATURE, UX_HOST_CLASS_HUB_C_PORT_SUSPEND);
 8002614:	2312      	movs	r3, #18
 8002616:	2201      	movs	r2, #1
 8002618:	f001 bfd2 	b.w	80045c0 <_ux_host_class_hub_feature>

0800261c <_ux_host_class_hub_ports_power>:
UINT        port_index;
UINT        status;
    

    /* Check for the power management mode: no power switching.  */
    if(hub -> ux_host_class_hub_descriptor.wHubCharacteristics & UX_HOST_CLASS_HUB_NO_POWER_SWITCHING)
 800261c:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800261e:	079b      	lsls	r3, r3, #30
 8002620:	d426      	bmi.n	8002670 <_ux_host_class_hub_ports_power+0x54>
{
 8002622:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        return(UX_SUCCESS);

    /* All ports must be powered individually.  */
    nb_ports =  hub -> ux_host_class_hub_descriptor.bNbPorts;
 8002626:	6ac7      	ldr	r7, [r0, #44]	; 0x2c

    /* Perform the function to all ports: the port index starts from 1 as the port 0 is for the HUB.  */
    for (port_index = 1; port_index <= nb_ports; port_index++)
 8002628:	b1ff      	cbz	r7, 800266a <_ux_host_class_hub_ports_power+0x4e>
 800262a:	2401      	movs	r4, #1
 800262c:	4605      	mov	r5, r0
 800262e:	46a0      	mov	r8, r4
 8002630:	e006      	b.n	8002640 <_ux_host_class_hub_ports_power+0x24>
        /* Check the function result and update HUB status if there was a problem.  */
        if (status != UX_SUCCESS)
        {

            /* Set the HUB status to not powered.  */
            hub -> ux_host_class_hub_port_power  &= (UINT)~(1 << port_index);
 8002632:	6cab      	ldr	r3, [r5, #72]	; 0x48
    for (port_index = 1; port_index <= nb_ports; port_index++)
 8002634:	3401      	adds	r4, #1
            hub -> ux_host_class_hub_port_power  &= (UINT)~(1 << port_index);
 8002636:	ea23 0306 	bic.w	r3, r3, r6
    for (port_index = 1; port_index <= nb_ports; port_index++)
 800263a:	42a7      	cmp	r7, r4
            hub -> ux_host_class_hub_port_power  &= (UINT)~(1 << port_index);
 800263c:	64ab      	str	r3, [r5, #72]	; 0x48
    for (port_index = 1; port_index <= nb_ports; port_index++)
 800263e:	d314      	bcc.n	800266a <_ux_host_class_hub_ports_power+0x4e>
        status =  _ux_host_class_hub_feature(hub, port_index, UX_SET_FEATURE, UX_HOST_CLASS_HUB_PORT_POWER);
 8002640:	2308      	movs	r3, #8
 8002642:	2203      	movs	r2, #3
 8002644:	4621      	mov	r1, r4
 8002646:	4628      	mov	r0, r5
 8002648:	f001 ffba 	bl	80045c0 <_ux_host_class_hub_feature>
 800264c:	fa08 f604 	lsl.w	r6, r8, r4
        if (status != UX_SUCCESS)
 8002650:	2800      	cmp	r0, #0
 8002652:	d1ee      	bne.n	8002632 <_ux_host_class_hub_ports_power+0x16>
        }
        else
        {
        
            /* Now we need to wait for the power to be stable.  */
            _ux_utility_delay_ms(((ULONG) (hub -> ux_host_class_hub_descriptor.bPwrOn2PwrGood) * 2));
 8002654:	6b68      	ldr	r0, [r5, #52]	; 0x34
    for (port_index = 1; port_index <= nb_ports; port_index++)
 8002656:	3401      	adds	r4, #1
            _ux_utility_delay_ms(((ULONG) (hub -> ux_host_class_hub_descriptor.bPwrOn2PwrGood) * 2));
 8002658:	0040      	lsls	r0, r0, #1
 800265a:	f7ff fb3b 	bl	8001cd4 <_ux_utility_delay_ms>
        
            /* Set the HUB status to powered.  */
            hub -> ux_host_class_hub_port_power  |= (UINT)(1 << port_index);
 800265e:	6cab      	ldr	r3, [r5, #72]	; 0x48
    for (port_index = 1; port_index <= nb_ports; port_index++)
 8002660:	42a7      	cmp	r7, r4
            hub -> ux_host_class_hub_port_power  |= (UINT)(1 << port_index);
 8002662:	ea43 0306 	orr.w	r3, r3, r6
 8002666:	64ab      	str	r3, [r5, #72]	; 0x48
    for (port_index = 1; port_index <= nb_ports; port_index++)
 8002668:	d2ea      	bcs.n	8002640 <_ux_host_class_hub_ports_power+0x24>
        }
    }

    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 800266a:	2000      	movs	r0, #0
 800266c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002670:	2000      	movs	r0, #0
 8002672:	4770      	bx	lr

08002674 <_ux_host_class_hub_status_get>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_status_get(UX_HOST_CLASS_HUB *hub, UINT port, USHORT *port_status, USHORT *port_change)
{
 8002674:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002678:	4691      	mov	r9, r2
UINT            target;
UINT            status;


    /* We need to get the default control endpoint transfer request pointer.  */
    control_endpoint =  &hub -> ux_host_class_hub_device -> ux_device_control_endpoint;
 800267a:	6884      	ldr	r4, [r0, #8]
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    /* The target is DEVICE for the HUB and OTHER for the downstream ports.  */
    if (port == 0)
 800267c:	460e      	mov	r6, r1
 800267e:	2900      	cmp	r1, #0
 8002680:	bf14      	ite	ne
 8002682:	27a3      	movne	r7, #163	; 0xa3
 8002684:	27a0      	moveq	r7, #160	; 0xa0
        target =  UX_REQUEST_TARGET_DEVICE;        
    else
        target =  UX_REQUEST_TARGET_OTHER;
        
    /* Allocate a buffer for the port status and change: 2 words.  */        
    port_data =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 4);
 8002686:	2204      	movs	r2, #4
 8002688:	2101      	movs	r1, #1
 800268a:	f04f 30ff 	mov.w	r0, #4294967295
{
 800268e:	4698      	mov	r8, r3
    port_data =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 4);
 8002690:	f7ff fb2c 	bl	8001cec <_ux_utility_memory_allocate>
    if(port_data == UX_NULL)
 8002694:	b1e8      	cbz	r0, 80026d2 <_ux_host_class_hub_status_get+0x5e>
        return(UX_MEMORY_INSUFFICIENT);

    /* Create a transfer request for the GET_STATUS request.  */
    transfer_request -> ux_transfer_request_requested_length =  4;
 8002696:	2204      	movs	r2, #4
    transfer_request -> ux_transfer_request_data_pointer =      port_data;
    transfer_request -> ux_transfer_request_function =          UX_HOST_CLASS_HUB_GET_STATUS;
 8002698:	2300      	movs	r3, #0
    transfer_request -> ux_transfer_request_data_pointer =      port_data;
 800269a:	f8c4 00cc 	str.w	r0, [r4, #204]	; 0xcc
 800269e:	4605      	mov	r5, r0
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | target;
    transfer_request -> ux_transfer_request_value =             0;
    transfer_request -> ux_transfer_request_index =             port;
 80026a0:	f8c4 60e4 	str.w	r6, [r4, #228]	; 0xe4

    /* Send request to HCD layer.  */
    status =  _ux_host_stack_transfer_request(transfer_request);
 80026a4:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | target;
 80026a8:	f8c4 70d8 	str.w	r7, [r4, #216]	; 0xd8
    transfer_request -> ux_transfer_request_requested_length =  4;
 80026ac:	f8c4 20d0 	str.w	r2, [r4, #208]	; 0xd0
    transfer_request -> ux_transfer_request_value =             0;
 80026b0:	e9c4 3337 	strd	r3, r3, [r4, #220]	; 0xdc
    status =  _ux_host_stack_transfer_request(transfer_request);
 80026b4:	f001 fe9c 	bl	80043f0 <_ux_host_stack_transfer_request>

    /* Check for error and completion of the transfer.  */
    if (status == UX_SUCCESS)
 80026b8:	4606      	mov	r6, r0
 80026ba:	b920      	cbnz	r0, 80026c6 <_ux_host_class_hub_status_get+0x52>
    {

        if (transfer_request -> ux_transfer_request_actual_length == 4)
 80026bc:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80026c0:	2b04      	cmp	r3, #4
 80026c2:	d00a      	beq.n	80026da <_ux_host_class_hub_status_get+0x66>
        }
        else
        {

            /* Invalid length. Return error.  */
            status =  UX_TRANSFER_DATA_LESS_THAN_EXPECTED;
 80026c4:	2629      	movs	r6, #41	; 0x29
        }
    }

    /* Free the buffer resource now.  */
    _ux_utility_memory_free(port_data);
 80026c6:	4628      	mov	r0, r5
 80026c8:	f7ff fc24 	bl	8001f14 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(status);
}
 80026cc:	4630      	mov	r0, r6
 80026ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return(UX_MEMORY_INSUFFICIENT);
 80026d2:	2612      	movs	r6, #18
}
 80026d4:	4630      	mov	r0, r6
 80026d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            *port_status =  (USHORT)_ux_utility_short_get(port_data);
 80026da:	4628      	mov	r0, r5
 80026dc:	f001 ff40 	bl	8004560 <_ux_utility_short_get>
 80026e0:	f8a9 0000 	strh.w	r0, [r9]
            *port_change =  (USHORT)_ux_utility_short_get(port_data+2);
 80026e4:	1ca8      	adds	r0, r5, #2
 80026e6:	f001 ff3b 	bl	8004560 <_ux_utility_short_get>
 80026ea:	f8a8 0000 	strh.w	r0, [r8]
 80026ee:	e7ea      	b.n	80026c6 <_ux_host_class_hub_status_get+0x52>

080026f0 <_ux_host_class_hub_transfer_request_completed>:
    /* Get the class instance for this transfer request.  */
    hub =  (UX_HOST_CLASS_HUB *) transfer_request -> ux_transfer_request_class_instance;


    /* Check the state of the transfer.  If there is an error, we do not proceed with this report.  */
    if (transfer_request -> ux_transfer_request_completion_code != UX_SUCCESS)
 80026f0:	6d43      	ldr	r3, [r0, #84]	; 0x54
    hub =  (UX_HOST_CLASS_HUB *) transfer_request -> ux_transfer_request_class_instance;
 80026f2:	6c82      	ldr	r2, [r0, #72]	; 0x48
    if (transfer_request -> ux_transfer_request_completion_code != UX_SUCCESS)
 80026f4:	b13b      	cbz	r3, 8002706 <_ux_host_class_hub_transfer_request_completed+0x16>
    {

        /* We have an error. We do not rehook another transfer if the device instance is shutting down or
           if the transfer was aborted by the class.  */
        if ((hub -> ux_host_class_hub_state ==  UX_HOST_CLASS_INSTANCE_SHUTDOWN) || 
            (transfer_request -> ux_transfer_request_completion_code == UX_TRANSFER_STATUS_ABORT) ||
 80026f6:	2b04      	cmp	r3, #4
 80026f8:	bf18      	it	ne
 80026fa:	2b22      	cmpne	r3, #34	; 0x22
 80026fc:	d002      	beq.n	8002704 <_ux_host_class_hub_transfer_request_completed+0x14>
        if ((hub -> ux_host_class_hub_state ==  UX_HOST_CLASS_INSTANCE_SHUTDOWN) || 
 80026fe:	6993      	ldr	r3, [r2, #24]
            (transfer_request -> ux_transfer_request_completion_code == UX_TRANSFER_STATUS_ABORT) ||
 8002700:	2b02      	cmp	r3, #2
 8002702:	d109      	bne.n	8002718 <_ux_host_class_hub_transfer_request_completed+0x28>
       call the HUB instance which has a status change.  */
    _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_enum_semaphore);

    /* Return to caller.  */
    return;
}
 8002704:	4770      	bx	lr
    hub -> ux_host_class_hub_change_semaphore++;
 8002706:	6a13      	ldr	r3, [r2, #32]
    _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_enum_semaphore);
 8002708:	4904      	ldr	r1, [pc, #16]	; (800271c <_ux_host_class_hub_transfer_request_completed+0x2c>)
    hub -> ux_host_class_hub_change_semaphore++;
 800270a:	3301      	adds	r3, #1
    _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_enum_semaphore);
 800270c:	6808      	ldr	r0, [r1, #0]
    hub -> ux_host_class_hub_change_semaphore++;
 800270e:	6213      	str	r3, [r2, #32]
    _ux_utility_semaphore_put(&_ux_system_host -> ux_system_host_enum_semaphore);
 8002710:	f500 7080 	add.w	r0, r0, #256	; 0x100
 8002714:	f7ff bce0 	b.w	80020d8 <_ux_utility_semaphore_put>
            _ux_host_stack_transfer_request(transfer_request);
 8002718:	f001 be6a 	b.w	80043f0 <_ux_host_stack_transfer_request>
 800271c:	20000db8 	.word	0x20000db8

08002720 <_ux_host_class_storage_activate>:
/*                                                                        */
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_activate(UX_HOST_CLASS_COMMAND *command)
{
 8002720:	b570      	push	{r4, r5, r6, lr}
 8002722:	4606      	mov	r6, r0
       device descriptor.  */
    interface =  (UX_INTERFACE *) command -> ux_host_class_command_container;

    /* Obtain memory for this class instance.  The memory used MUST BE allocated from a CACHE SAFE memory
       since the buffer for the CSW is an array contained within each storage instance. */
    storage =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, sizeof(UX_HOST_CLASS_STORAGE));
 8002724:	f44f 72d2 	mov.w	r2, #420	; 0x1a4
 8002728:	2101      	movs	r1, #1
 800272a:	f04f 30ff 	mov.w	r0, #4294967295
    interface =  (UX_INTERFACE *) command -> ux_host_class_command_container;
 800272e:	6875      	ldr	r5, [r6, #4]
    storage =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, sizeof(UX_HOST_CLASS_STORAGE));
 8002730:	f7ff fadc 	bl	8001cec <_ux_utility_memory_allocate>
    if (storage == UX_NULL)
 8002734:	2800      	cmp	r0, #0
 8002736:	d036      	beq.n	80027a6 <_ux_host_class_storage_activate+0x86>

    /* Store the interface container into the storage class instance.  */
    storage -> ux_host_class_storage_interface =  interface;

    /* Store the device container into the storage class instance.  */
    storage -> ux_host_class_storage_device =  interface -> ux_interface_configuration -> ux_configuration_device;
 8002738:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800273a:	4604      	mov	r4, r0

    /* Create this class instance.  */
    _ux_host_stack_class_instance_create(command -> ux_host_class_command_class_ptr, (VOID *) storage);
 800273c:	4601      	mov	r1, r0
    storage -> ux_host_class_storage_class =  command -> ux_host_class_command_class_ptr;
 800273e:	6b30      	ldr	r0, [r6, #48]	; 0x30
    storage -> ux_host_class_storage_device =  interface -> ux_interface_configuration -> ux_configuration_device;
 8002740:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    storage -> ux_host_class_storage_class =  command -> ux_host_class_command_class_ptr;
 8002742:	6060      	str	r0, [r4, #4]
    storage -> ux_host_class_storage_device =  interface -> ux_interface_configuration -> ux_configuration_device;
 8002744:	e9c4 3502 	strd	r3, r5, [r4, #8]
    _ux_host_stack_class_instance_create(command -> ux_host_class_command_class_ptr, (VOID *) storage);
 8002748:	f001 fb66 	bl	8003e18 <_ux_host_stack_class_instance_create>

    /* This instance of the device must also be stored in the interface container.  */
    interface -> ux_interface_class_instance =  (VOID *) storage;
 800274c:	636c      	str	r4, [r5, #52]	; 0x34

    /* Configure the USB storage device.  */
    status =  _ux_host_class_storage_configure(storage);
 800274e:	4620      	mov	r0, r4
 8002750:	f000 f85a 	bl	8002808 <_ux_host_class_storage_configure>

    /* Create the semaphore to protect multiple threads from accessing the same storage instance.  */
    if (status == UX_SUCCESS)
 8002754:	4606      	mov	r6, r0
 8002756:	b150      	cbz	r0, 800276e <_ux_host_class_storage_activate+0x4e>
    {

        /* Last one, semaphore not created or created error, no need to free.  */

        /* Error, destroy the class and return an error.  */
        _ux_host_stack_class_instance_destroy(storage -> ux_host_class_storage_class, (VOID *) storage);
 8002758:	4621      	mov	r1, r4
 800275a:	6860      	ldr	r0, [r4, #4]
 800275c:	f001 fb6a 	bl	8003e34 <_ux_host_stack_class_instance_destroy>

        /* This instance of the device must also be removed in the interface container.  */
        interface -> ux_interface_class_instance =  (VOID *) UX_NULL;
 8002760:	2300      	movs	r3, #0

        /* Free memory for class instance.  */
        _ux_utility_memory_free(storage);
 8002762:	4620      	mov	r0, r4
        interface -> ux_interface_class_instance =  (VOID *) UX_NULL;
 8002764:	636b      	str	r3, [r5, #52]	; 0x34
        _ux_utility_memory_free(storage);
 8002766:	f7ff fbd5 	bl	8001f14 <_ux_utility_memory_free>
    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_REGISTER(UX_TRACE_HOST_OBJECT_TYPE_INTERFACE, storage, 0, 0, 0)

    /* Return completion status. Force it to success. */
    return(UX_SUCCESS);
}
 800276a:	4630      	mov	r0, r6
 800276c:	bd70      	pop	{r4, r5, r6, pc}
        status = _ux_utility_semaphore_create(&storage -> ux_host_class_storage_semaphore, "ux_host_class_storage_semaphore", 1);
 800276e:	2201      	movs	r2, #1
 8002770:	490f      	ldr	r1, [pc, #60]	; (80027b0 <_ux_host_class_storage_activate+0x90>)
 8002772:	f504 70c2 	add.w	r0, r4, #388	; 0x184
 8002776:	f7ff fc7b 	bl	8002070 <_ux_utility_semaphore_create>
        if (status != UX_SUCCESS)
 800277a:	4606      	mov	r6, r0
 800277c:	b9b0      	cbnz	r0, 80027ac <_ux_host_class_storage_activate+0x8c>
    storage -> ux_host_class_storage_state =  UX_HOST_CLASS_INSTANCE_MOUNTING;
 800277e:	2303      	movs	r3, #3
    _ux_host_class_storage_device_initialize(storage);
 8002780:	4620      	mov	r0, r4
    storage -> ux_host_class_storage_state =  UX_HOST_CLASS_INSTANCE_MOUNTING;
 8002782:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
    _ux_host_class_storage_device_initialize(storage);
 8002786:	f000 f8bf 	bl	8002908 <_ux_host_class_storage_device_initialize>
    if (_ux_system_host -> ux_system_host_change_function != UX_NULL)
 800278a:	4b0a      	ldr	r3, [pc, #40]	; (80027b4 <_ux_host_class_storage_activate+0x94>)
    storage -> ux_host_class_storage_state =  UX_HOST_CLASS_INSTANCE_LIVE;
 800278c:	2001      	movs	r0, #1
    if (_ux_system_host -> ux_system_host_change_function != UX_NULL)
 800278e:	681b      	ldr	r3, [r3, #0]
    storage -> ux_host_class_storage_state =  UX_HOST_CLASS_INSTANCE_LIVE;
 8002790:	f8c4 00dc 	str.w	r0, [r4, #220]	; 0xdc
    if (_ux_system_host -> ux_system_host_change_function != UX_NULL)
 8002794:	f8d3 32e0 	ldr.w	r3, [r3, #736]	; 0x2e0
 8002798:	2b00      	cmp	r3, #0
 800279a:	d0e6      	beq.n	800276a <_ux_host_class_storage_activate+0x4a>
        _ux_system_host ->  ux_system_host_change_function(UX_DEVICE_INSERTION, storage -> ux_host_class_storage_class, (VOID *) storage);
 800279c:	4622      	mov	r2, r4
 800279e:	6861      	ldr	r1, [r4, #4]
 80027a0:	4798      	blx	r3
}
 80027a2:	4630      	mov	r0, r6
 80027a4:	bd70      	pop	{r4, r5, r6, pc}
        return(UX_MEMORY_INSUFFICIENT);
 80027a6:	2612      	movs	r6, #18
}
 80027a8:	4630      	mov	r0, r6
 80027aa:	bd70      	pop	{r4, r5, r6, pc}
            status = UX_SEMAPHORE_ERROR;
 80027ac:	2615      	movs	r6, #21
 80027ae:	e7d3      	b.n	8002758 <_ux_host_class_storage_activate+0x38>
 80027b0:	0800ddd4 	.word	0x0800ddd4
 80027b4:	20000db8 	.word	0x20000db8

080027b8 <_ux_host_class_storage_cbw_initialize>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_class_storage_cbw_initialize(UX_HOST_CLASS_STORAGE *storage, UINT direction,
                                            ULONG data_transfer_length, UINT command_length)
{
 80027b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80027ba:	4604      	mov	r4, r0
 80027bc:	4617      	mov	r7, r2
 80027be:	460e      	mov	r6, r1

    /* Use a pointer for the cbw, easier to manipulate.  */
    cbw =  (UCHAR *) storage -> ux_host_class_storage_cbw;

    /* Store the signature of the CBW.  */
    _ux_utility_long_put(cbw, UX_HOST_CLASS_STORAGE_CBW_SIGNATURE_MASK);
 80027c0:	301c      	adds	r0, #28
 80027c2:	490f      	ldr	r1, [pc, #60]	; (8002800 <_ux_host_class_storage_cbw_initialize+0x48>)
{
 80027c4:	461d      	mov	r5, r3
    _ux_utility_long_put(cbw, UX_HOST_CLASS_STORAGE_CBW_SIGNATURE_MASK);
 80027c6:	f001 feaf 	bl	8004528 <_ux_utility_long_put>
    
    /* Set the Tag, this value is simply an arbitrary number that is echoed by 
       the device in the CSW.  */
    _ux_utility_long_put(cbw + UX_HOST_CLASS_STORAGE_CBW_TAG, UX_HOST_CLASS_STORAGE_CBW_TAG_MASK);
 80027ca:	f104 0020 	add.w	r0, r4, #32
 80027ce:	490d      	ldr	r1, [pc, #52]	; (8002804 <_ux_host_class_storage_cbw_initialize+0x4c>)
 80027d0:	f001 feaa 	bl	8004528 <_ux_utility_long_put>

    /* Store the Data Transfer Length expected for the data payload.  */
    _ux_utility_long_put(cbw + UX_HOST_CLASS_STORAGE_CBW_DATA_LENGTH, data_transfer_length);
 80027d4:	4639      	mov	r1, r7
 80027d6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80027da:	f001 fea5 	bl	8004528 <_ux_utility_long_put>

    /* Store the CBW Flag field that contains the transfer direction.  */
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_FLAGS) =  (UCHAR)direction;
    
    /* Store the LUN value.  */
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_LUN) =  (UCHAR)storage -> ux_host_class_storage_lun;
 80027de:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_FLAGS) =  (UCHAR)direction;
 80027e2:	f884 6028 	strb.w	r6, [r4, #40]	; 0x28

    /* Store the size of the SCSI command block that follows.  */
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB_LENGTH) =  (UCHAR)command_length;

    /* Reset the SCSI command block.  */
    _ux_utility_memory_set(cbw + UX_HOST_CLASS_STORAGE_CBW_CB, 0, (ULONG) command_length);
 80027e6:	462a      	mov	r2, r5
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB_LENGTH) =  (UCHAR)command_length;
 80027e8:	f884 502a 	strb.w	r5, [r4, #42]	; 0x2a
    _ux_utility_memory_set(cbw + UX_HOST_CLASS_STORAGE_CBW_CB, 0, (ULONG) command_length);
 80027ec:	f104 002b 	add.w	r0, r4, #43	; 0x2b
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_LUN) =  (UCHAR)storage -> ux_host_class_storage_lun;
 80027f0:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
    _ux_utility_memory_set(cbw + UX_HOST_CLASS_STORAGE_CBW_CB, 0, (ULONG) command_length);
 80027f4:	2100      	movs	r1, #0

    /* Return to caller.  */
    return;
}
 80027f6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    _ux_utility_memory_set(cbw + UX_HOST_CLASS_STORAGE_CBW_CB, 0, (ULONG) command_length);
 80027fa:	f7ff bc17 	b.w	800202c <_ux_utility_memory_set>
 80027fe:	bf00      	nop
 8002800:	43425355 	.word	0x43425355
 8002804:	55534243 	.word	0x55534243

08002808 <_ux_host_class_storage_configure>:
UX_DEVICE               *parent_device;


    /* If the device has been configured already, we don't need to do it
       again.  */
    if (storage -> ux_host_class_storage_device -> ux_device_state == UX_DEVICE_CONFIGURED)
 8002808:	6883      	ldr	r3, [r0, #8]
 800280a:	689a      	ldr	r2, [r3, #8]
 800280c:	2a03      	cmp	r2, #3
 800280e:	d017      	beq.n	8002840 <_ux_host_class_storage_configure+0x38>
        return(UX_SUCCESS);

    /* A storage device normally has one configuration. So retrieve the 1st configuration
       only.  */
    status =  _ux_host_stack_device_configuration_get(storage -> ux_host_class_storage_device, 0, &configuration);
 8002810:	2100      	movs	r1, #0
{
 8002812:	b510      	push	{r4, lr}
 8002814:	b082      	sub	sp, #8
 8002816:	4604      	mov	r4, r0
    status =  _ux_host_stack_device_configuration_get(storage -> ux_host_class_storage_device, 0, &configuration);
 8002818:	4618      	mov	r0, r3
 800281a:	aa01      	add	r2, sp, #4
 800281c:	f001 fb4a 	bl	8003eb4 <_ux_host_stack_device_configuration_get>

    /* Check completion status.  */
    if (status != UX_SUCCESS)
 8002820:	b980      	cbnz	r0, 8002844 <_ux_host_class_storage_configure+0x3c>
        return(UX_CONFIGURATION_HANDLE_UNKNOWN);
    }
        
    /* Check the storage device power source and check the parent power source for 
       incompatible connections.  */
    if (storage -> ux_host_class_storage_device -> ux_device_power_source == UX_DEVICE_BUS_POWERED)
 8002822:	68a3      	ldr	r3, [r4, #8]
 8002824:	69da      	ldr	r2, [r3, #28]
 8002826:	2a01      	cmp	r2, #1
 8002828:	d104      	bne.n	8002834 <_ux_host_class_storage_configure+0x2c>
    {

        /* Pickup pointer to parent device.  */
        parent_device =  storage -> ux_host_class_storage_device -> ux_device_parent;
 800282a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        
        /* If the device is NULL, the parent is the root hub and we don't have to worry 
           if the parent is not the root hub, check for its power source.  */
        if ((parent_device != UX_NULL) && (parent_device -> ux_device_power_source == UX_DEVICE_BUS_POWERED))
 800282c:	b113      	cbz	r3, 8002834 <_ux_host_class_storage_configure+0x2c>
 800282e:	69db      	ldr	r3, [r3, #28]
 8002830:	2b01      	cmp	r3, #1
 8002832:	d01a      	beq.n	800286a <_ux_host_class_storage_configure+0x62>
            return(UX_CONNECTION_INCOMPATIBLE);
        }            
    }
    
    /* We have the valid configuration. Ask the USBX stack to set this configuration.  */        
    status =  _ux_host_stack_device_configuration_select(configuration);
 8002834:	9801      	ldr	r0, [sp, #4]
 8002836:	f001 fb5d 	bl	8003ef4 <_ux_host_stack_device_configuration_select>
    if (status != UX_SUCCESS)
 800283a:	b150      	cbz	r0, 8002852 <_ux_host_class_storage_configure+0x4a>
        storage -> ux_host_class_storage_interface -> ux_interface_class_instance =  (VOID *) storage;
    }

    /* Return completion status.  */
    return(status);
}
 800283c:	b002      	add	sp, #8
 800283e:	bd10      	pop	{r4, pc}
        return(UX_SUCCESS);
 8002840:	2000      	movs	r0, #0
}
 8002842:	4770      	bx	lr
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_CONFIGURATION_HANDLE_UNKNOWN);
 8002844:	2002      	movs	r0, #2
 8002846:	2251      	movs	r2, #81	; 0x51
 8002848:	2107      	movs	r1, #7
 800284a:	f7ff f9d9 	bl	8001c00 <_ux_system_error_handler>
        return(UX_CONFIGURATION_HANDLE_UNKNOWN);
 800284e:	2051      	movs	r0, #81	; 0x51
 8002850:	e7f4      	b.n	800283c <_ux_host_class_storage_configure+0x34>
    status =  _ux_host_stack_configuration_interface_get(configuration, 0, 0, &storage -> ux_host_class_storage_interface);
 8002852:	4602      	mov	r2, r0
 8002854:	4601      	mov	r1, r0
 8002856:	f104 030c 	add.w	r3, r4, #12
 800285a:	9801      	ldr	r0, [sp, #4]
 800285c:	f001 fb04 	bl	8003e68 <_ux_host_stack_configuration_interface_get>
    if (status != UX_SUCCESS)
 8002860:	2800      	cmp	r0, #0
 8002862:	d0eb      	beq.n	800283c <_ux_host_class_storage_configure+0x34>
        storage -> ux_host_class_storage_interface -> ux_interface_class_instance =  (VOID *) storage;
 8002864:	68e3      	ldr	r3, [r4, #12]
 8002866:	635c      	str	r4, [r3, #52]	; 0x34
 8002868:	e7e8      	b.n	800283c <_ux_host_class_storage_configure+0x34>
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_CONNECTION_INCOMPATIBLE);
 800286a:	2002      	movs	r0, #2
 800286c:	225a      	movs	r2, #90	; 0x5a
 800286e:	2107      	movs	r1, #7
 8002870:	f7ff f9c6 	bl	8001c00 <_ux_system_error_handler>
            return(UX_CONNECTION_INCOMPATIBLE);
 8002874:	205a      	movs	r0, #90	; 0x5a
 8002876:	e7e1      	b.n	800283c <_ux_host_class_storage_configure+0x34>

08002878 <_ux_host_class_storage_deactivate>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_deactivate(UX_HOST_CLASS_COMMAND *command)
{
 8002878:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
UX_HOST_CLASS                   *class;
VOID                            *memory;


    /* Get the instance for this class.  */
    storage =  (UX_HOST_CLASS_STORAGE *) command -> ux_host_class_command_instance;
 800287a:	6884      	ldr	r4, [r0, #8]
    
    /* Point the media structure to the first media in the container.  */
    storage_media =  (UX_HOST_CLASS_STORAGE_MEDIA *) class -> ux_host_class_media;

    /* The storage device is being shut down.  */
    storage -> ux_host_class_storage_state =  UX_HOST_CLASS_INSTANCE_SHUTDOWN;
 800287c:	2302      	movs	r3, #2
    storage_media =  (UX_HOST_CLASS_STORAGE_MEDIA *) class -> ux_host_class_media;
 800287e:	6862      	ldr	r2, [r4, #4]
       with a DEVICE_NOT_RESPONDING error code.  
       
       First we take care of endpoint OUT.  */

    /* We need to abort transactions on the bulk pipes.  */
    if (storage -> ux_host_class_storage_bulk_out_endpoint != UX_NULL)
 8002880:	6920      	ldr	r0, [r4, #16]
    storage_media =  (UX_HOST_CLASS_STORAGE_MEDIA *) class -> ux_host_class_media;
 8002882:	f8d2 5124 	ldr.w	r5, [r2, #292]	; 0x124
    storage -> ux_host_class_storage_state =  UX_HOST_CLASS_INSTANCE_SHUTDOWN;
 8002886:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
    if (storage -> ux_host_class_storage_bulk_out_endpoint != UX_NULL)
 800288a:	b108      	cbz	r0, 8002890 <_ux_host_class_storage_deactivate+0x18>
        _ux_host_stack_endpoint_transfer_abort(storage -> ux_host_class_storage_bulk_out_endpoint);
 800288c:	f001 fc64 	bl	8004158 <_ux_host_stack_endpoint_transfer_abort>
    
    /* Then endpoint IN.  */       
    if (storage -> ux_host_class_storage_bulk_in_endpoint != UX_NULL)
 8002890:	6960      	ldr	r0, [r4, #20]
 8002892:	b108      	cbz	r0, 8002898 <_ux_host_class_storage_deactivate+0x20>
        _ux_host_stack_endpoint_transfer_abort(storage -> ux_host_class_storage_bulk_in_endpoint);
 8002894:	f001 fc60 	bl	8004158 <_ux_host_stack_endpoint_transfer_abort>
    }
#endif

    /* The enumeration thread needs to sleep a while to allow the application or the class that may be using
       endpoints to exit properly.  */
    _ux_utility_thread_schedule_other(UX_THREAD_PRIORITY_ENUM); 
 8002898:	2014      	movs	r0, #20
 800289a:	f001 fe79 	bl	8004590 <_ux_utility_thread_schedule_other>

        /* Get the FileX Media attached to this media.  */
        media = &storage_media -> ux_host_class_storage_media;

        /* Check if the media belongs to the device being removed.  */
        if (((UX_HOST_CLASS_STORAGE *) media -> fx_media_driver_info) == storage)
 800289e:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 80028a2:	42a3      	cmp	r3, r4
 80028a4:	d104      	bne.n	80028b0 <_ux_host_class_storage_deactivate+0x38>
        {

            /* Check if the media was properly opened.  */
            if (storage_media -> ux_host_class_storage_media_status == UX_HOST_CLASS_STORAGE_MEDIA_MOUNTED)
 80028a6:	f242 46b8 	movw	r6, #9400	; 0x24b8
 80028aa:	59ab      	ldr	r3, [r5, r6]
 80028ac:	2b01      	cmp	r3, #1
 80028ae:	d01b      	beq.n	80028e8 <_ux_host_class_storage_deactivate+0x70>
        /* Move to next entry in the media array.  */
        storage_media++;
    }

    /* Protect thread reentry to this instance.  */
    _ux_utility_semaphore_get(&storage -> ux_host_class_storage_semaphore, UX_WAIT_FOREVER);
 80028b0:	f504 75c2 	add.w	r5, r4, #388	; 0x184
 80028b4:	f04f 31ff 	mov.w	r1, #4294967295
 80028b8:	4628      	mov	r0, r5
 80028ba:	f7ff fbe9 	bl	8002090 <_ux_utility_semaphore_get>

    /* Destroy the instance.  */
    _ux_host_stack_class_instance_destroy(storage -> ux_host_class_storage_class, (VOID *) storage);
 80028be:	4621      	mov	r1, r4
 80028c0:	6860      	ldr	r0, [r4, #4]
 80028c2:	f001 fab7 	bl	8003e34 <_ux_host_stack_class_instance_destroy>

    /* Destroy the protection semaphore.  */
    _ux_utility_semaphore_delete(&storage -> ux_host_class_storage_semaphore);
 80028c6:	4628      	mov	r0, r5
 80028c8:	f7ff fbe0 	bl	800208c <_ux_utility_semaphore_delete>

    /* Before we free the device resources, we need to inform the application
        that the device is removed.  */
    if (_ux_system_host -> ux_system_host_change_function != UX_NULL)
 80028cc:	4b0d      	ldr	r3, [pc, #52]	; (8002904 <_ux_host_class_storage_deactivate+0x8c>)
 80028ce:	681b      	ldr	r3, [r3, #0]
 80028d0:	f8d3 32e0 	ldr.w	r3, [r3, #736]	; 0x2e0
 80028d4:	b11b      	cbz	r3, 80028de <_ux_host_class_storage_deactivate+0x66>
    {
        
        /* Inform the application the device is removed.  */
        _ux_system_host -> ux_system_host_change_function(UX_DEVICE_REMOVAL, storage -> ux_host_class_storage_class, (VOID *) storage);
 80028d6:	4622      	mov	r2, r4
 80028d8:	6861      	ldr	r1, [r4, #4]
 80028da:	2002      	movs	r0, #2
 80028dc:	4798      	blx	r3

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_UNREGISTER(storage);

    /* Free the storage instance memory.  */
    _ux_utility_memory_free(storage);
 80028de:	4620      	mov	r0, r4
 80028e0:	f7ff fb18 	bl	8001f14 <_ux_utility_memory_free>

    /* Return successful completion.  */
    return(UX_SUCCESS);         
}
 80028e4:	2000      	movs	r0, #0
 80028e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                memory =  storage_media -> ux_host_class_storage_media_memory;
 80028e8:	f242 43c8 	movw	r3, #9416	; 0x24c8
                fx_media_close(media);
 80028ec:	4628      	mov	r0, r5
                memory =  storage_media -> ux_host_class_storage_media_memory;
 80028ee:	58ef      	ldr	r7, [r5, r3]
                fx_media_close(media);
 80028f0:	f003 fc2c 	bl	800614c <_fxe_media_close>
                storage_media -> ux_host_class_storage_media_status =  UX_HOST_CLASS_STORAGE_MEDIA_UNMOUNTED;
 80028f4:	2300      	movs	r3, #0
                _ux_utility_memory_free(memory);
 80028f6:	4638      	mov	r0, r7
                storage_media -> ux_host_class_storage_media_status =  UX_HOST_CLASS_STORAGE_MEDIA_UNMOUNTED;
 80028f8:	51ab      	str	r3, [r5, r6]
                media -> fx_media_id =  0;
 80028fa:	602b      	str	r3, [r5, #0]
                _ux_utility_memory_free(memory);
 80028fc:	f7ff fb0a 	bl	8001f14 <_ux_utility_memory_free>
 8002900:	e7d6      	b.n	80028b0 <_ux_host_class_storage_deactivate+0x38>
 8002902:	bf00      	nop
 8002904:	20000db8 	.word	0x20000db8

08002908 <_ux_host_class_storage_device_initialize>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_device_initialize(UX_HOST_CLASS_STORAGE *storage)
{
 8002908:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800290a:	4605      	mov	r5, r0

UINT        status;
ULONG       lun_index;

    /* Check the device protocol support and initialize the transport layer.  */
    status =  _ux_host_class_storage_device_support_check(storage);
 800290c:	f000 f866 	bl	80029dc <_ux_host_class_storage_device_support_check>
    if (status != UX_SUCCESS)
 8002910:	4604      	mov	r4, r0
 8002912:	b108      	cbz	r0, 8002918 <_ux_host_class_storage_device_initialize+0x10>
    }

    /* Some LUNs may succeed and some may fail. For simplicity's sake, we just
       return success. The storage thread will try to remount the ones that failed.  */
    return(UX_SUCCESS);
}
 8002914:	4620      	mov	r0, r4
 8002916:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    status =  _ux_host_class_storage_max_lun_get(storage);
 8002918:	4628      	mov	r0, r5
 800291a:	f000 f8c9 	bl	8002ab0 <_ux_host_class_storage_max_lun_get>
    if (status != UX_SUCCESS)
 800291e:	4604      	mov	r4, r0
 8002920:	2800      	cmp	r0, #0
 8002922:	d1f7      	bne.n	8002914 <_ux_host_class_storage_device_initialize+0xc>
    status =  _ux_host_class_storage_endpoints_get(storage);
 8002924:	4628      	mov	r0, r5
 8002926:	f000 f875 	bl	8002a14 <_ux_host_class_storage_endpoints_get>
    if (status != UX_SUCCESS)
 800292a:	4604      	mov	r4, r0
 800292c:	2800      	cmp	r0, #0
 800292e:	d1f1      	bne.n	8002914 <_ux_host_class_storage_device_initialize+0xc>
    for (lun_index = 0; lun_index <= storage -> ux_host_class_storage_max_lun; lun_index++)
 8002930:	4606      	mov	r6, r0
    _ux_utility_delay_ms(UX_HOST_CLASS_STORAGE_DEVICE_INIT_DELAY);
 8002932:	20c8      	movs	r0, #200	; 0xc8
 8002934:	f505 7798 	add.w	r7, r5, #304	; 0x130
 8002938:	f7ff f9cc 	bl	8001cd4 <_ux_utility_delay_ms>
 800293c:	e011      	b.n	8002962 <_ux_host_class_storage_device_initialize+0x5a>
        if (status != UX_SUCCESS)
 800293e:	bb1a      	cbnz	r2, 8002988 <_ux_host_class_storage_device_initialize+0x80>
        status =  _ux_host_class_storage_media_format_capacity_get(storage);
 8002940:	f000 f926 	bl	8002b90 <_ux_host_class_storage_media_format_capacity_get>
        if (status != UX_SUCCESS)
 8002944:	bb10      	cbnz	r0, 800298c <_ux_host_class_storage_device_initialize+0x84>
        storage -> ux_host_class_storage_lun_types[lun_index] = storage -> ux_host_class_storage_media_type;
 8002946:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
        switch (storage -> ux_host_class_storage_media_type)
 800294a:	2b07      	cmp	r3, #7
        storage -> ux_host_class_storage_lun_types[lun_index] = storage -> ux_host_class_storage_media_type;
 800294c:	603b      	str	r3, [r7, #0]
        switch (storage -> ux_host_class_storage_media_type)
 800294e:	d016      	beq.n	800297e <_ux_host_class_storage_device_initialize+0x76>
 8002950:	2b55      	cmp	r3, #85	; 0x55
 8002952:	d014      	beq.n	800297e <_ux_host_class_storage_device_initialize+0x76>
 8002954:	b19b      	cbz	r3, 800297e <_ux_host_class_storage_device_initialize+0x76>
    for (lun_index = 0; lun_index <= storage -> ux_host_class_storage_max_lun; lun_index++)
 8002956:	3601      	adds	r6, #1
 8002958:	f8d5 3128 	ldr.w	r3, [r5, #296]	; 0x128
 800295c:	3704      	adds	r7, #4
 800295e:	42b3      	cmp	r3, r6
 8002960:	d3d8      	bcc.n	8002914 <_ux_host_class_storage_device_initialize+0xc>
        storage -> ux_host_class_storage_lun =  lun_index;
 8002962:	f8c5 612c 	str.w	r6, [r5, #300]	; 0x12c
        status =  _ux_host_class_storage_media_characteristics_get(storage);
 8002966:	4628      	mov	r0, r5
 8002968:	f000 f8e4 	bl	8002b34 <_ux_host_class_storage_media_characteristics_get>
 800296c:	4602      	mov	r2, r0
        status =  _ux_host_class_storage_media_format_capacity_get(storage);
 800296e:	4628      	mov	r0, r5
        if (status == UX_HOST_CLASS_MEDIA_NOT_SUPPORTED)
 8002970:	2a62      	cmp	r2, #98	; 0x62
 8002972:	d1e4      	bne.n	800293e <_ux_host_class_storage_device_initialize+0x36>
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_HOST_CLASS_MEDIA_NOT_SUPPORTED);
 8002974:	2107      	movs	r1, #7
 8002976:	2002      	movs	r0, #2
 8002978:	f7ff f942 	bl	8001c00 <_ux_system_error_handler>
            continue;
 800297c:	e7eb      	b.n	8002956 <_ux_host_class_storage_device_initialize+0x4e>
            _ux_host_class_storage_media_mount(storage, 0);
 800297e:	2100      	movs	r1, #0
 8002980:	4628      	mov	r0, r5
 8002982:	f000 f927 	bl	8002bd4 <_ux_host_class_storage_media_mount>
            break;
 8002986:	e7e6      	b.n	8002956 <_ux_host_class_storage_device_initialize+0x4e>
        status =  _ux_host_class_storage_media_characteristics_get(storage);
 8002988:	4614      	mov	r4, r2
 800298a:	e7c3      	b.n	8002914 <_ux_host_class_storage_device_initialize+0xc>
        status =  _ux_host_class_storage_media_format_capacity_get(storage);
 800298c:	4604      	mov	r4, r0
 800298e:	e7c1      	b.n	8002914 <_ux_host_class_storage_device_initialize+0xc>

08002990 <_ux_host_class_storage_device_reset>:
/*                                                                        */
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_device_reset(UX_HOST_CLASS_STORAGE *storage)
{
 8002990:	b538      	push	{r3, r4, r5, lr}
    if (storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceProtocol == UX_HOST_CLASS_STORAGE_PROTOCOL_BO)
    {
#endif

    /* We need to get the default control endpoint transfer request pointer.  */
    control_endpoint =  &storage -> ux_host_class_storage_device -> ux_device_control_endpoint;
 8002992:	6884      	ldr	r4, [r0, #8]
{
 8002994:	4605      	mov	r5, r0
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    /* We need to prevent other threads from simultaneously using the endpoint. */
    _ux_utility_semaphore_get(&control_endpoint -> ux_endpoint_device -> ux_device_protection_semaphore, UX_WAIT_FOREVER);
 8002996:	f04f 31ff 	mov.w	r1, #4294967295
 800299a:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 800299e:	3024      	adds	r0, #36	; 0x24
 80029a0:	f7ff fb76 	bl	8002090 <_ux_utility_semaphore_get>
    transfer_request -> ux_transfer_request_data_pointer =      UX_NULL;
    transfer_request -> ux_transfer_request_requested_length =  0;
    transfer_request -> ux_transfer_request_function =          UX_HOST_CLASS_STORAGE_RESET;
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_OUT | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE;
    transfer_request -> ux_transfer_request_value =             0;
    transfer_request -> ux_transfer_request_index  =            storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceNumber;
 80029a4:	68eb      	ldr	r3, [r5, #12]
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_OUT | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE;
 80029a6:	2121      	movs	r1, #33	; 0x21
    transfer_request -> ux_transfer_request_function =          UX_HOST_CLASS_STORAGE_RESET;
 80029a8:	20ff      	movs	r0, #255	; 0xff
    transfer_request -> ux_transfer_request_index  =            storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceNumber;
 80029aa:	695a      	ldr	r2, [r3, #20]
    transfer_request -> ux_transfer_request_data_pointer =      UX_NULL;
 80029ac:	2300      	movs	r3, #0
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_OUT | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE;
 80029ae:	f8c4 10d8 	str.w	r1, [r4, #216]	; 0xd8
    transfer_request -> ux_transfer_request_index  =            storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceNumber;
 80029b2:	f8c4 20e4 	str.w	r2, [r4, #228]	; 0xe4
    transfer_request -> ux_transfer_request_value =             0;
 80029b6:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
    transfer_request -> ux_transfer_request_function =          UX_HOST_CLASS_STORAGE_RESET;
 80029ba:	f8c4 00dc 	str.w	r0, [r4, #220]	; 0xdc

    /* Send request to HCD layer.  */
    status =  _ux_host_stack_transfer_request(transfer_request);
 80029be:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
    transfer_request -> ux_transfer_request_requested_length =  0;
 80029c2:	e9c4 3333 	strd	r3, r3, [r4, #204]	; 0xcc
    status =  _ux_host_stack_transfer_request(transfer_request);
 80029c6:	f001 fd13 	bl	80043f0 <_ux_host_stack_transfer_request>
 80029ca:	4604      	mov	r4, r0

    /* Per the spec, reset the endpoints as well.  */
    _ux_host_stack_endpoint_reset(storage -> ux_host_class_storage_bulk_in_endpoint);
 80029cc:	6968      	ldr	r0, [r5, #20]
 80029ce:	f001 fba3 	bl	8004118 <_ux_host_stack_endpoint_reset>
    _ux_host_stack_endpoint_reset(storage -> ux_host_class_storage_bulk_out_endpoint);
 80029d2:	6928      	ldr	r0, [r5, #16]
 80029d4:	f001 fba0 	bl	8004118 <_ux_host_stack_endpoint_reset>
    }

    /* In case the device is not a BO device, we always succeed.  */
    return(UX_SUCCESS);
#endif
}
 80029d8:	4620      	mov	r0, r4
 80029da:	bd38      	pop	{r3, r4, r5, pc}

080029dc <_ux_host_class_storage_device_support_check>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_device_support_check(UX_HOST_CLASS_STORAGE *storage)
{
 80029dc:	b508      	push	{r3, lr}

    /* Check for the protocol type (BO/CB/CBI) and update the transport functions.  */
    switch(storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceProtocol)
 80029de:	68c3      	ldr	r3, [r0, #12]
 80029e0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80029e2:	2a50      	cmp	r2, #80	; 0x50
 80029e4:	d10c      	bne.n	8002a00 <_ux_host_class_storage_device_support_check+0x24>

        return(UX_HOST_CLASS_PROTOCOL_ERROR);
    }

    /* Check for the sub class and make sure we support it.  */
    switch (storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceSubClass)
 80029e6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
        storage -> ux_host_class_storage_transport =  _ux_host_class_storage_transport_bo;
 80029e8:	4b09      	ldr	r3, [pc, #36]	; (8002a10 <_ux_host_class_storage_device_support_check+0x34>)
 80029ea:	2a06      	cmp	r2, #6
 80029ec:	f8c0 3178 	str.w	r3, [r0, #376]	; 0x178
 80029f0:	d806      	bhi.n	8002a00 <_ux_host_class_storage_device_support_check+0x24>
 80029f2:	2301      	movs	r3, #1
 80029f4:	4093      	lsls	r3, r2
 80029f6:	f013 0f66 	tst.w	r3, #102	; 0x66
 80029fa:	d001      	beq.n	8002a00 <_ux_host_class_storage_device_support_check+0x24>
    case UX_HOST_CLASS_STORAGE_SUBCLASS_RBC:
    case UX_HOST_CLASS_STORAGE_SUBCLASS_SCSI:
    case UX_HOST_CLASS_STORAGE_SUBCLASS_SFF8020:
    case UX_HOST_CLASS_STORAGE_SUBCLASS_SFF8070:

        return(UX_SUCCESS);
 80029fc:	2000      	movs	r0, #0
        /* If trace is enabled, insert this event into the trace buffer.  */
        UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_PROTOCOL_ERROR, storage, 0, 0, UX_TRACE_ERRORS, 0, 0)
        
        return(UX_HOST_CLASS_PROTOCOL_ERROR);
    }
}
 80029fe:	bd08      	pop	{r3, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_HOST_CLASS_PROTOCOL_ERROR);
 8002a00:	2260      	movs	r2, #96	; 0x60
 8002a02:	2107      	movs	r1, #7
 8002a04:	2002      	movs	r0, #2
 8002a06:	f7ff f8fb 	bl	8001c00 <_ux_system_error_handler>
        return(UX_HOST_CLASS_PROTOCOL_ERROR);
 8002a0a:	2060      	movs	r0, #96	; 0x60
}
 8002a0c:	bd08      	pop	{r3, pc}
 8002a0e:	bf00      	nop
 8002a10:	08002eed 	.word	0x08002eed

08002a14 <_ux_host_class_storage_endpoints_get>:
/*                                                                        */
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_endpoints_get(UX_HOST_CLASS_STORAGE *storage)
{
 8002a14:	b530      	push	{r4, r5, lr}
 8002a16:	4605      	mov	r5, r0
UINT            endpoint_index;
UX_ENDPOINT     *endpoint;


    /* Search for the bulk OUT endpoint. It is attached to the interface container.  */
    for (endpoint_index = 0; endpoint_index < storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bNumEndpoints;
 8002a18:	68c0      	ldr	r0, [r0, #12]
{
 8002a1a:	b083      	sub	sp, #12
    for (endpoint_index = 0; endpoint_index < storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bNumEndpoints;
 8002a1c:	69c3      	ldr	r3, [r0, #28]
 8002a1e:	2b00      	cmp	r3, #0
 8002a20:	d03b      	beq.n	8002a9a <_ux_host_class_storage_endpoints_get+0x86>
 8002a22:	2400      	movs	r4, #0
                        endpoint_index++)
    {

        /* Get an endpoint.  */
        _ux_host_stack_interface_endpoint_get(storage -> ux_host_class_storage_interface, endpoint_index, &endpoint);
 8002a24:	4621      	mov	r1, r4
 8002a26:	aa01      	add	r2, sp, #4
 8002a28:	f001 fbea 	bl	8004200 <_ux_host_stack_interface_endpoint_get>

        /* We have an endpoint. Check if endpoint is bulk and OUT.  */
        if (((endpoint -> ux_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_OUT) &&
 8002a2c:	9901      	ldr	r1, [sp, #4]
                        endpoint_index++)
 8002a2e:	3401      	adds	r4, #1
        if (((endpoint -> ux_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_OUT) &&
 8002a30:	694b      	ldr	r3, [r1, #20]
 8002a32:	f013 0280 	ands.w	r2, r3, #128	; 0x80
 8002a36:	d104      	bne.n	8002a42 <_ux_host_class_storage_endpoints_get+0x2e>
            ((endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) == UX_BULK_ENDPOINT))
 8002a38:	698b      	ldr	r3, [r1, #24]
 8002a3a:	f003 0303 	and.w	r3, r3, #3
        if (((endpoint -> ux_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_OUT) &&
 8002a3e:	2b02      	cmp	r3, #2
 8002a40:	d021      	beq.n	8002a86 <_ux_host_class_storage_endpoints_get+0x72>
    for (endpoint_index = 0; endpoint_index < storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bNumEndpoints;
 8002a42:	68eb      	ldr	r3, [r5, #12]
 8002a44:	69da      	ldr	r2, [r3, #28]
 8002a46:	4618      	mov	r0, r3
 8002a48:	42a2      	cmp	r2, r4
 8002a4a:	d8eb      	bhi.n	8002a24 <_ux_host_class_storage_endpoints_get+0x10>
            break;
        }
    }

    /* The bulk OUT endpoint is mandatory.  */
    if (storage -> ux_host_class_storage_bulk_out_endpoint == UX_NULL)
 8002a4c:	692a      	ldr	r2, [r5, #16]
 8002a4e:	b33a      	cbz	r2, 8002aa0 <_ux_host_class_storage_endpoints_get+0x8c>

        return(UX_ENDPOINT_HANDLE_UNKNOWN);
    }

    /* Search for the bulk IN endpoint. It is attached to the interface container.  */
    for (endpoint_index = 0; endpoint_index < storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bNumEndpoints;
 8002a50:	69da      	ldr	r2, [r3, #28]
 8002a52:	4618      	mov	r0, r3
 8002a54:	b192      	cbz	r2, 8002a7c <_ux_host_class_storage_endpoints_get+0x68>
 8002a56:	2400      	movs	r4, #0
                        endpoint_index++)
    {

        /* Get an endpoint.  */
        _ux_host_stack_interface_endpoint_get(storage -> ux_host_class_storage_interface, endpoint_index, &endpoint);
 8002a58:	aa01      	add	r2, sp, #4
 8002a5a:	4621      	mov	r1, r4
 8002a5c:	f001 fbd0 	bl	8004200 <_ux_host_stack_interface_endpoint_get>

        /* We have an endpoint. Check if endpoint is bulk and IN.  */
        if (((endpoint -> ux_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_IN) &&
 8002a60:	9b01      	ldr	r3, [sp, #4]
                        endpoint_index++)
 8002a62:	3401      	adds	r4, #1
        if (((endpoint -> ux_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_IN) &&
 8002a64:	695a      	ldr	r2, [r3, #20]
 8002a66:	0612      	lsls	r2, r2, #24
 8002a68:	d504      	bpl.n	8002a74 <_ux_host_class_storage_endpoints_get+0x60>
            ((endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) == UX_BULK_ENDPOINT))
 8002a6a:	699a      	ldr	r2, [r3, #24]
 8002a6c:	f002 0203 	and.w	r2, r2, #3
        if (((endpoint -> ux_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_IN) &&
 8002a70:	2a02      	cmp	r2, #2
 8002a72:	d00c      	beq.n	8002a8e <_ux_host_class_storage_endpoints_get+0x7a>
    for (endpoint_index = 0; endpoint_index < storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bNumEndpoints;
 8002a74:	68e8      	ldr	r0, [r5, #12]
 8002a76:	69c3      	ldr	r3, [r0, #28]
 8002a78:	42a3      	cmp	r3, r4
 8002a7a:	d8ed      	bhi.n	8002a58 <_ux_host_class_storage_endpoints_get+0x44>
 8002a7c:	696b      	ldr	r3, [r5, #20]
            break;
        }
    }

    /* The bulk IN endpoint is mandatory */
    if (storage -> ux_host_class_storage_bulk_in_endpoint == UX_NULL)
 8002a7e:	b17b      	cbz	r3, 8002aa0 <_ux_host_class_storage_endpoints_get+0x8c>
        }
    }
#endif

    /* Return successful completion.  */
    return(UX_SUCCESS);
 8002a80:	2000      	movs	r0, #0
}
 8002a82:	b003      	add	sp, #12
 8002a84:	bd30      	pop	{r4, r5, pc}
            storage -> ux_host_class_storage_bulk_out_endpoint =  endpoint;
 8002a86:	6129      	str	r1, [r5, #16]
 8002a88:	68eb      	ldr	r3, [r5, #12]
            endpoint -> ux_endpoint_transfer_request.ux_transfer_request_type =  UX_REQUEST_OUT;
 8002a8a:	644a      	str	r2, [r1, #68]	; 0x44
 8002a8c:	e7e0      	b.n	8002a50 <_ux_host_class_storage_endpoints_get+0x3c>
            endpoint -> ux_endpoint_transfer_request.ux_transfer_request_type =  UX_REQUEST_IN;
 8002a8e:	2280      	movs	r2, #128	; 0x80
    return(UX_SUCCESS);
 8002a90:	2000      	movs	r0, #0
            storage -> ux_host_class_storage_bulk_in_endpoint =  endpoint;
 8002a92:	616b      	str	r3, [r5, #20]
            endpoint -> ux_endpoint_transfer_request.ux_transfer_request_type =  UX_REQUEST_IN;
 8002a94:	645a      	str	r2, [r3, #68]	; 0x44
}
 8002a96:	b003      	add	sp, #12
 8002a98:	bd30      	pop	{r4, r5, pc}
    if (storage -> ux_host_class_storage_bulk_out_endpoint == UX_NULL)
 8002a9a:	692b      	ldr	r3, [r5, #16]
 8002a9c:	2b00      	cmp	r3, #0
 8002a9e:	d1ed      	bne.n	8002a7c <_ux_host_class_storage_endpoints_get+0x68>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_ENDPOINT_HANDLE_UNKNOWN);
 8002aa0:	2253      	movs	r2, #83	; 0x53
 8002aa2:	2107      	movs	r1, #7
 8002aa4:	2002      	movs	r0, #2
 8002aa6:	f7ff f8ab 	bl	8001c00 <_ux_system_error_handler>
        return(UX_ENDPOINT_HANDLE_UNKNOWN);
 8002aaa:	2053      	movs	r0, #83	; 0x53
}
 8002aac:	b003      	add	sp, #12
 8002aae:	bd30      	pop	{r4, r5, pc}

08002ab0 <_ux_host_class_storage_max_lun_get>:
/*                                                                        */
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_max_lun_get(UX_HOST_CLASS_STORAGE *storage)
{
 8002ab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceProtocol == UX_HOST_CLASS_STORAGE_PROTOCOL_BO)
    {
#endif

    /* We need to get the default control endpoint transfer_request pointer.  */
    control_endpoint =  &storage -> ux_host_class_storage_device -> ux_device_control_endpoint;
 8002ab2:	6884      	ldr	r4, [r0, #8]
    storage -> ux_host_class_storage_max_lun =  0;
 8002ab4:	2700      	movs	r7, #0
{
 8002ab6:	4605      	mov	r5, r0
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    /* We need to prevent other threads from simultaneously using the control endpoint. */
    _ux_utility_semaphore_get(&control_endpoint -> ux_endpoint_device -> ux_device_protection_semaphore, UX_WAIT_FOREVER);
 8002ab8:	f04f 31ff 	mov.w	r1, #4294967295
    storage -> ux_host_class_storage_max_lun =  0;
 8002abc:	f8c0 7128 	str.w	r7, [r0, #296]	; 0x128
    _ux_utility_semaphore_get(&control_endpoint -> ux_endpoint_device -> ux_device_protection_semaphore, UX_WAIT_FOREVER);
 8002ac0:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
 8002ac4:	3024      	adds	r0, #36	; 0x24
 8002ac6:	f7ff fae3 	bl	8002090 <_ux_utility_semaphore_get>

    /* Need to allocate memory for the descriptor.  */
    storage_data_buffer =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 1);
 8002aca:	2201      	movs	r2, #1
 8002acc:	f04f 30ff 	mov.w	r0, #4294967295
 8002ad0:	4611      	mov	r1, r2
 8002ad2:	f7ff f90b 	bl	8001cec <_ux_utility_memory_allocate>
    if (storage_data_buffer == UX_NULL)
 8002ad6:	b1d8      	cbz	r0, 8002b10 <_ux_host_class_storage_max_lun_get+0x60>
    transfer_request -> ux_transfer_request_data_pointer =      storage_data_buffer;
    transfer_request -> ux_transfer_request_requested_length =  1;
    transfer_request -> ux_transfer_request_function =          UX_HOST_CLASS_STORAGE_GET_MAX_LUN;
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE;
    transfer_request -> ux_transfer_request_value =             0;
    transfer_request -> ux_transfer_request_index =             storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceNumber;
 8002ad8:	68eb      	ldr	r3, [r5, #12]
 8002ada:	4606      	mov	r6, r0
    transfer_request -> ux_transfer_request_requested_length =  1;
 8002adc:	2101      	movs	r1, #1
    transfer_request -> ux_transfer_request_data_pointer =      storage_data_buffer;
 8002ade:	f8c4 00cc 	str.w	r0, [r4, #204]	; 0xcc
    transfer_request -> ux_transfer_request_function =          UX_HOST_CLASS_STORAGE_GET_MAX_LUN;
 8002ae2:	22fe      	movs	r2, #254	; 0xfe
    transfer_request -> ux_transfer_request_index =             storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceNumber;
 8002ae4:	6958      	ldr	r0, [r3, #20]
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE;
 8002ae6:	23a1      	movs	r3, #161	; 0xa1
    transfer_request -> ux_transfer_request_requested_length =  1;
 8002ae8:	f8c4 10d0 	str.w	r1, [r4, #208]	; 0xd0
    transfer_request -> ux_transfer_request_index =             storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceNumber;
 8002aec:	e9c4 7038 	strd	r7, r0, [r4, #224]	; 0xe0
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_CLASS | UX_REQUEST_TARGET_INTERFACE;
 8002af0:	e9c4 3236 	strd	r3, r2, [r4, #216]	; 0xd8

    /* Send request to HCD layer.  */
    status =  _ux_host_stack_transfer_request(transfer_request);
 8002af4:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
 8002af8:	f001 fc7a 	bl	80043f0 <_ux_host_stack_transfer_request>

    /* Check for correct transfer and entire descriptor returned.  */
    if ((status == UX_SUCCESS) && (transfer_request -> ux_transfer_request_actual_length == 1))
 8002afc:	b918      	cbnz	r0, 8002b06 <_ux_host_class_storage_max_lun_get+0x56>
 8002afe:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8002b02:	2b01      	cmp	r3, #1
 8002b04:	d006      	beq.n	8002b14 <_ux_host_class_storage_max_lun_get+0x64>
            UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_MEMORY_ERROR, storage, 0, 0, UX_TRACE_ERRORS, 0, 0)
        }
    }

    /* Free all used resources.  */
    _ux_utility_memory_free(storage_data_buffer);
 8002b06:	4630      	mov	r0, r6
 8002b08:	f7ff fa04 	bl	8001f14 <_ux_utility_memory_free>
#ifdef UX_HOST_CLASS_STORAGE_INCLUDE_LEGACY_PROTOCOL_SUPPORT
    }
#endif

    /* We always succeed.  */
    return(UX_SUCCESS);
 8002b0c:	2000      	movs	r0, #0
}
 8002b0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8002b10:	2012      	movs	r0, #18
}
 8002b12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        storage -> ux_host_class_storage_max_lun =  *storage_data_buffer;
 8002b14:	7833      	ldrb	r3, [r6, #0]
        if (storage -> ux_host_class_storage_max_lun > UX_MAX_HOST_LUN - 1)
 8002b16:	2b0f      	cmp	r3, #15
 8002b18:	d802      	bhi.n	8002b20 <_ux_host_class_storage_max_lun_get+0x70>
        storage -> ux_host_class_storage_max_lun =  *storage_data_buffer;
 8002b1a:	f8c5 3128 	str.w	r3, [r5, #296]	; 0x128
 8002b1e:	e7f2      	b.n	8002b06 <_ux_host_class_storage_max_lun_get+0x56>
            storage -> ux_host_class_storage_max_lun =  UX_MAX_HOST_LUN - 1;
 8002b20:	230f      	movs	r3, #15
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_HOST_CLASS_MEMORY_ERROR);
 8002b22:	2261      	movs	r2, #97	; 0x61
 8002b24:	2107      	movs	r1, #7
 8002b26:	2002      	movs	r0, #2
            storage -> ux_host_class_storage_max_lun =  UX_MAX_HOST_LUN - 1;
 8002b28:	f8c5 3128 	str.w	r3, [r5, #296]	; 0x128
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_HOST_CLASS_MEMORY_ERROR);
 8002b2c:	f7ff f868 	bl	8001c00 <_ux_system_error_handler>
 8002b30:	e7e9      	b.n	8002b06 <_ux_host_class_storage_max_lun_get+0x56>
 8002b32:	bf00      	nop

08002b34 <_ux_host_class_storage_media_characteristics_get>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_media_characteristics_get(UX_HOST_CLASS_STORAGE *storage)
{
 8002b34:	b570      	push	{r4, r5, r6, lr}
#else
    command_length =  UX_HOST_CLASS_STORAGE_INQUIRY_COMMAND_LENGTH_SBC;
#endif

    /* Initialize the CBW for this command.  */
    _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_IN, UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH, command_length);
 8002b36:	2224      	movs	r2, #36	; 0x24
 8002b38:	2180      	movs	r1, #128	; 0x80
 8002b3a:	2306      	movs	r3, #6
{
 8002b3c:	4605      	mov	r5, r0
    
    /* Prepare the INQUIRY command block.  */
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_INQUIRY_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_INQUIRY;
 8002b3e:	2412      	movs	r4, #18
    _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_IN, UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH, command_length);
 8002b40:	f7ff fe3a 	bl	80027b8 <_ux_host_class_storage_cbw_initialize>
    
    /* Store the length of the Inquiry Response.  */
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_INQUIRY_ALLOCATION_LENGTH) =  UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH;
 8002b44:	2224      	movs	r2, #36	; 0x24

    /* Obtain a block of memory for the answer.  */
    inquiry_response =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH);
 8002b46:	2101      	movs	r1, #1
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_INQUIRY_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_INQUIRY;
 8002b48:	f885 402b 	strb.w	r4, [r5, #43]	; 0x2b
    inquiry_response =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH);
 8002b4c:	f04f 30ff 	mov.w	r0, #4294967295
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_INQUIRY_ALLOCATION_LENGTH) =  UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH;
 8002b50:	f885 202f 	strb.w	r2, [r5, #47]	; 0x2f
    inquiry_response =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_LENGTH);
 8002b54:	f7ff f8ca 	bl	8001cec <_ux_utility_memory_allocate>
    if (inquiry_response == UX_NULL)
 8002b58:	b148      	cbz	r0, 8002b6e <_ux_host_class_storage_media_characteristics_get+0x3a>
        return(UX_MEMORY_INSUFFICIENT);
    
    /* Send the command to transport layer.  */
    status =  _ux_host_class_storage_transport(storage, inquiry_response);
 8002b5a:	4601      	mov	r1, r0
 8002b5c:	4606      	mov	r6, r0
 8002b5e:	4628      	mov	r0, r5
 8002b60:	f000 f9aa 	bl	8002eb8 <_ux_host_class_storage_transport>

    /* If we have a transport error, there is not much we can do, simply return the
       error.  */
    if (status == UX_SUCCESS)
 8002b64:	4604      	mov	r4, r0
 8002b66:	b120      	cbz	r0, 8002b72 <_ux_host_class_storage_media_characteristics_get+0x3e>
           we will default to 512 bytes for a regular drive and 2048 bytes for a CD-ROM or optical drive.  */
        status =  _ux_host_class_storage_media_capacity_get(storage);
    }       

    /* Free the memory resource used for the command response.  */
    _ux_utility_memory_free(inquiry_response);
 8002b68:	4630      	mov	r0, r6
 8002b6a:	f7ff f9d3 	bl	8001f14 <_ux_utility_memory_free>
    
    /* Return completion status.  */
    return(status);                                            
}
 8002b6e:	4620      	mov	r0, r4
 8002b70:	bd70      	pop	{r4, r5, r6, pc}
        storage -> ux_host_class_storage_media_type =                                                       *(inquiry_response + UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_PERIPHERAL_TYPE);
 8002b72:	7832      	ldrb	r2, [r6, #0]
        status =  _ux_host_class_storage_media_capacity_get(storage);
 8002b74:	4628      	mov	r0, r5
        storage -> ux_host_class_storage_lun_removable_media_flags[storage -> ux_host_class_storage_lun] =  *(inquiry_response + UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_REMOVABLE_MEDIA);
 8002b76:	f8d5 312c 	ldr.w	r3, [r5, #300]	; 0x12c
        storage -> ux_host_class_storage_media_type =                                                       *(inquiry_response + UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_PERIPHERAL_TYPE);
 8002b7a:	f8c5 20e0 	str.w	r2, [r5, #224]	; 0xe0
        storage -> ux_host_class_storage_lun_removable_media_flags[storage -> ux_host_class_storage_lun] =  *(inquiry_response + UX_HOST_CLASS_STORAGE_INQUIRY_RESPONSE_REMOVABLE_MEDIA);
 8002b7e:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8002b82:	7873      	ldrb	r3, [r6, #1]
 8002b84:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
        status =  _ux_host_class_storage_media_capacity_get(storage);
 8002b88:	f001 fe68 	bl	800485c <_ux_host_class_storage_media_capacity_get>
 8002b8c:	4604      	mov	r4, r0
 8002b8e:	e7eb      	b.n	8002b68 <_ux_host_class_storage_media_characteristics_get+0x34>

08002b90 <_ux_host_class_storage_media_format_capacity_get>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_media_format_capacity_get(UX_HOST_CLASS_STORAGE *storage)
{
 8002b90:	b538      	push	{r3, r4, r5, lr}
#else
    command_length =  UX_HOST_CLASS_STORAGE_READ_FORMAT_COMMAND_LENGTH_SBC;
#endif

    /* Initialize the CBW for this command.  */
    _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_IN, UX_HOST_CLASS_STORAGE_READ_FORMAT_RESPONSE_LENGTH, command_length);
 8002b92:	22fc      	movs	r2, #252	; 0xfc
 8002b94:	230a      	movs	r3, #10
 8002b96:	2180      	movs	r1, #128	; 0x80
{
 8002b98:	4604      	mov	r4, r0
    _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_IN, UX_HOST_CLASS_STORAGE_READ_FORMAT_RESPONSE_LENGTH, command_length);
 8002b9a:	f7ff fe0d 	bl	80027b8 <_ux_host_class_storage_cbw_initialize>
    
    /* Prepare the READ FORMAT CAPACITY command block.  */
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_READ_FORMAT_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_READ_FORMAT_CAPACITY;
 8002b9e:	2323      	movs	r3, #35	; 0x23
    
    /* Store the number of sectors to read.  */
    _ux_utility_short_put_big_endian(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_READ_FORMAT_PARAMETER_LIST_LENGTH, UX_HOST_CLASS_STORAGE_READ_FORMAT_RESPONSE_LENGTH);
 8002ba0:	f104 0032 	add.w	r0, r4, #50	; 0x32
 8002ba4:	21fc      	movs	r1, #252	; 0xfc
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_READ_FORMAT_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_READ_FORMAT_CAPACITY;
 8002ba6:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
    _ux_utility_short_put_big_endian(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_READ_FORMAT_PARAMETER_LIST_LENGTH, UX_HOST_CLASS_STORAGE_READ_FORMAT_RESPONSE_LENGTH);
 8002baa:	f001 fcdf 	bl	800456c <_ux_utility_short_put_big_endian>

    /* Obtain a block of memory for the answer.  */
    read_format_capacity_response =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_READ_FORMAT_RESPONSE_LENGTH);
 8002bae:	22fc      	movs	r2, #252	; 0xfc
 8002bb0:	2101      	movs	r1, #1
 8002bb2:	f04f 30ff 	mov.w	r0, #4294967295
 8002bb6:	f7ff f899 	bl	8001cec <_ux_utility_memory_allocate>
    if (read_format_capacity_response == UX_NULL)
 8002bba:	b148      	cbz	r0, 8002bd0 <_ux_host_class_storage_media_format_capacity_get+0x40>
 8002bbc:	4605      	mov	r5, r0
        return(UX_MEMORY_INSUFFICIENT);
    
    /* Send the command to transport layer.  */
    _ux_host_class_storage_transport(storage, read_format_capacity_response);
 8002bbe:	4620      	mov	r0, r4
 8002bc0:	4629      	mov	r1, r5
 8002bc2:	f000 f979 	bl	8002eb8 <_ux_host_class_storage_transport>

    /* Free the memory resource used for the command response.  */
    _ux_utility_memory_free(read_format_capacity_response);
 8002bc6:	4628      	mov	r0, r5
 8002bc8:	f7ff f9a4 	bl	8001f14 <_ux_utility_memory_free>

    /* If we have a transport error, there is not much we can do, we do not fail.  */
    return(UX_SUCCESS);                                            
 8002bcc:	2000      	movs	r0, #0
}
 8002bce:	bd38      	pop	{r3, r4, r5, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8002bd0:	2012      	movs	r0, #18
}
 8002bd2:	bd38      	pop	{r3, r4, r5, pc}

08002bd4 <_ux_host_class_storage_media_mount>:
/*                                                                        */
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_media_mount(UX_HOST_CLASS_STORAGE *storage, ULONG sector)
{
 8002bd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002bd6:	4606      	mov	r6, r0
 8002bd8:	460f      	mov	r7, r1
    }
#endif

    /* Obtain memory for reading the partition sector, we do not use the storage instance
       memory because this function is reentrant.  */
    sector_memory =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, storage -> ux_host_class_storage_sector_size);
 8002bda:	f04f 30ff 	mov.w	r0, #4294967295
 8002bde:	2101      	movs	r1, #1
 8002be0:	f8d6 2170 	ldr.w	r2, [r6, #368]	; 0x170
 8002be4:	f7ff f882 	bl	8001cec <_ux_utility_memory_allocate>
    if (sector_memory == UX_NULL)
 8002be8:	b368      	cbz	r0, 8002c46 <_ux_host_class_storage_media_mount+0x72>
 8002bea:	4605      	mov	r5, r0
        return(UX_MEMORY_INSUFFICIENT);

    /* Check if the device is now ready.  */
    status =  _ux_host_class_storage_unit_ready_test(storage);
 8002bec:	4630      	mov	r0, r6
 8002bee:	f7fe fb7f 	bl	80012f0 <_ux_host_class_storage_unit_ready_test>

    /* Check the status. There may be a transport error or the device is not ready.  */
    if (status == UX_SUCCESS)
 8002bf2:	4604      	mov	r4, r0
 8002bf4:	b138      	cbz	r0, 8002c06 <_ux_host_class_storage_media_mount+0x32>
    /* Check the status. There may be a transport error or the device is not ready.  */
    if (status != UX_SUCCESS)
    {

        /* In any case, we free the sector memory.  */
        _ux_utility_memory_free(sector_memory);
 8002bf6:	4628      	mov	r0, r5
 8002bf8:	f7ff f98c 	bl	8001f14 <_ux_utility_memory_free>

        if (status == UX_HOST_CLASS_STORAGE_SENSE_ERROR)

            /* The media is not there, so we will try to check for it at the storage
               thread level every x seconds.  */
            return(UX_SUCCESS);
 8002bfc:	2c03      	cmp	r4, #3
 8002bfe:	bf08      	it	eq
 8002c00:	2400      	moveq	r4, #0
    /* Free all resources used.  */
    _ux_utility_memory_free(sector_memory);

    /* Return completion status.  */
    return(status);
}
 8002c02:	4620      	mov	r0, r4
 8002c04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        status =  _ux_host_class_storage_media_read(storage, sector, 1, sector_memory);
 8002c06:	462b      	mov	r3, r5
 8002c08:	2201      	movs	r2, #1
 8002c0a:	4639      	mov	r1, r7
 8002c0c:	4630      	mov	r0, r6
 8002c0e:	f000 f889 	bl	8002d24 <_ux_host_class_storage_media_read>
    if (status != UX_SUCCESS)
 8002c12:	4604      	mov	r4, r0
 8002c14:	2800      	cmp	r0, #0
 8002c16:	d1ee      	bne.n	8002bf6 <_ux_host_class_storage_media_mount+0x22>
    if (_ux_utility_short_get(sector_memory + 510) == UX_HOST_CLASS_STORAGE_PARTITION_SIGNATURE)
 8002c18:	f505 70ff 	add.w	r0, r5, #510	; 0x1fe
 8002c1c:	f001 fca0 	bl	8004560 <_ux_utility_short_get>
 8002c20:	f64a 2355 	movw	r3, #43605	; 0xaa55
 8002c24:	4298      	cmp	r0, r3
 8002c26:	d127      	bne.n	8002c78 <_ux_host_class_storage_media_mount+0xa4>
        if ((*sector_memory == 0xe9) || ((*sector_memory == 0xeb) && *(sector_memory + 2) == 0x90))
 8002c28:	782b      	ldrb	r3, [r5, #0]
 8002c2a:	2be9      	cmp	r3, #233	; 0xe9
 8002c2c:	d011      	beq.n	8002c52 <_ux_host_class_storage_media_mount+0x7e>
 8002c2e:	2beb      	cmp	r3, #235	; 0xeb
 8002c30:	d00c      	beq.n	8002c4c <_ux_host_class_storage_media_mount+0x78>
        _ux_host_class_storage_partition_read(storage, sector_memory, sector);
 8002c32:	463a      	mov	r2, r7
 8002c34:	4629      	mov	r1, r5
 8002c36:	4630      	mov	r0, r6
 8002c38:	f000 f8b2 	bl	8002da0 <_ux_host_class_storage_partition_read>
        _ux_utility_memory_free(sector_memory);
 8002c3c:	4628      	mov	r0, r5
 8002c3e:	f7ff f969 	bl	8001f14 <_ux_utility_memory_free>
}
 8002c42:	4620      	mov	r0, r4
 8002c44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8002c46:	2412      	movs	r4, #18
}
 8002c48:	4620      	mov	r0, r4
 8002c4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((*sector_memory == 0xe9) || ((*sector_memory == 0xeb) && *(sector_memory + 2) == 0x90))
 8002c4c:	78ab      	ldrb	r3, [r5, #2]
 8002c4e:	2b90      	cmp	r3, #144	; 0x90
 8002c50:	d1ef      	bne.n	8002c32 <_ux_host_class_storage_media_mount+0x5e>
            if (_ux_utility_short_get(sector_memory + 0x16) != 0x0 ||  _ux_utility_long_get(sector_memory + 0x24) != 0x0)
 8002c52:	f105 0016 	add.w	r0, r5, #22
 8002c56:	f001 fc83 	bl	8004560 <_ux_utility_short_get>
 8002c5a:	b928      	cbnz	r0, 8002c68 <_ux_host_class_storage_media_mount+0x94>
 8002c5c:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8002c60:	f001 fc60 	bl	8004524 <_ux_utility_long_get>
 8002c64:	2800      	cmp	r0, #0
 8002c66:	d0e4      	beq.n	8002c32 <_ux_host_class_storage_media_mount+0x5e>
                _ux_host_class_storage_media_open(storage, sector);
 8002c68:	4639      	mov	r1, r7
 8002c6a:	4630      	mov	r0, r6
 8002c6c:	f000 f80a 	bl	8002c84 <_ux_host_class_storage_media_open>
                _ux_utility_memory_free(sector_memory);
 8002c70:	4628      	mov	r0, r5
 8002c72:	f7ff f94f 	bl	8001f14 <_ux_utility_memory_free>
                return(UX_SUCCESS);
 8002c76:	e7c4      	b.n	8002c02 <_ux_host_class_storage_media_mount+0x2e>
    return(status);
 8002c78:	24ff      	movs	r4, #255	; 0xff
    _ux_utility_memory_free(sector_memory);
 8002c7a:	4628      	mov	r0, r5
 8002c7c:	f7ff f94a 	bl	8001f14 <_ux_utility_memory_free>
}
 8002c80:	4620      	mov	r0, r4
 8002c82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08002c84 <_ux_host_class_storage_media_open>:

    /* We need the class container.  */
    class =  storage -> ux_host_class_storage_class;
    
    /* Point the media structure to the first media in the container.  */
    storage_media =  (UX_HOST_CLASS_STORAGE_MEDIA *) class -> ux_host_class_media;
 8002c84:	6843      	ldr	r3, [r0, #4]
{
 8002c86:	b5f0      	push	{r4, r5, r6, r7, lr}
    storage_media =  (UX_HOST_CLASS_STORAGE_MEDIA *) class -> ux_host_class_media;
 8002c88:	f8d3 4124 	ldr.w	r4, [r3, #292]	; 0x124
{
 8002c8c:	b085      	sub	sp, #20

        /* Get the FileX media pointer for that media.  */
        media =  &storage_media -> ux_host_class_storage_media;
        
        /* Is the media valid?  */
        if (media -> fx_media_id == 0)
 8002c8e:	6823      	ldr	r3, [r4, #0]
 8002c90:	bb83      	cbnz	r3, 8002cf4 <_ux_host_class_storage_media_open+0x70>
 8002c92:	4605      	mov	r5, r0

            /* Save the storage instance in the media instance.  */
            media -> fx_media_driver_info =  (VOID *) storage;
                            
            /* Save the number of hidden sectors in this partition.  */
            storage_media -> ux_host_class_storage_media_partition_start =  hidden_sectors;
 8002c94:	f504 5313 	add.w	r3, r4, #9408	; 0x24c0

            /* Save the LUN number in the storage media instance.  */
            storage_media -> ux_host_class_storage_media_lun =  storage -> ux_host_class_storage_lun;
 8002c98:	f242 40bc 	movw	r0, #9404	; 0x24bc

            /* Save the Sector size in the storage media instance.  */
            storage_media -> ux_host_class_storage_media_sector_size =  storage -> ux_host_class_storage_sector_size;
 8002c9c:	f242 46c4 	movw	r6, #9412	; 0x24c4
            storage_media -> ux_host_class_storage_media_lun =  storage -> ux_host_class_storage_lun;
 8002ca0:	f8d5 712c 	ldr.w	r7, [r5, #300]	; 0x12c
               The default buffer size is 8K. The value used for the definition is UX_HOST_CLASS_STORAGE_MEMORY_BUFFER_SIZE. 
               This value can be changed to save on memory space but should not be smaller than 
               the media sector size (which should be 512 bytes). Because USB devices are SCSI 
               devices and there is a great deal of overhead when doing read/writes, it is better   
               to leave the default buffer size or even increase it. */
            storage_media -> ux_host_class_storage_media_memory =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_MEMORY_BUFFER_SIZE);
 8002ca4:	f44f 6280 	mov.w	r2, #1024	; 0x400
            media -> fx_media_driver_info =  (VOID *) storage;
 8002ca8:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
            storage_media -> ux_host_class_storage_media_partition_start =  hidden_sectors;
 8002cac:	6019      	str	r1, [r3, #0]
            storage_media -> ux_host_class_storage_media_memory =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_MEMORY_BUFFER_SIZE);
 8002cae:	2101      	movs	r1, #1
            storage_media -> ux_host_class_storage_media_sector_size =  storage -> ux_host_class_storage_sector_size;
 8002cb0:	f8d5 3170 	ldr.w	r3, [r5, #368]	; 0x170
            storage_media -> ux_host_class_storage_media_lun =  storage -> ux_host_class_storage_lun;
 8002cb4:	5027      	str	r7, [r4, r0]
            storage_media -> ux_host_class_storage_media_memory =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_MEMORY_BUFFER_SIZE);
 8002cb6:	f04f 30ff 	mov.w	r0, #4294967295
            media -> fx_media_reserved_for_user =  (ALIGN_TYPE) storage_media;
 8002cba:	f8c4 4898 	str.w	r4, [r4, #2200]	; 0x898
            storage_media -> ux_host_class_storage_media_sector_size =  storage -> ux_host_class_storage_sector_size;
 8002cbe:	51a3      	str	r3, [r4, r6]
            storage_media -> ux_host_class_storage_media_memory =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_MEMORY_BUFFER_SIZE);
 8002cc0:	f242 46c8 	movw	r6, #9416	; 0x24c8
 8002cc4:	f7ff f812 	bl	8001cec <_ux_utility_memory_allocate>
 8002cc8:	51a0      	str	r0, [r4, r6]
            if (storage_media -> ux_host_class_storage_media_memory == UX_NULL)
 8002cca:	b1e0      	cbz	r0, 8002d06 <_ux_host_class_storage_media_open+0x82>

            /* If trace is enabled, insert this event into the trace buffer.  */
            UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_STORAGE_MEDIA_OPEN, storage, media, 0, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

            /* Ask FileX to mount the partition.  */
            status =  fx_media_open(media, UX_HOST_CLASS_STORAGE_MEDIA_NAME, _ux_host_class_storage_driver_entry,
 8002ccc:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8002cd0:	f242 47b8 	movw	r7, #9400	; 0x24b8
 8002cd4:	9000      	str	r0, [sp, #0]
 8002cd6:	462b      	mov	r3, r5
 8002cd8:	9201      	str	r2, [sp, #4]
 8002cda:	4620      	mov	r0, r4
 8002cdc:	9702      	str	r7, [sp, #8]
 8002cde:	4a0f      	ldr	r2, [pc, #60]	; (8002d1c <_ux_host_class_storage_media_open+0x98>)
 8002ce0:	490f      	ldr	r1, [pc, #60]	; (8002d20 <_ux_host_class_storage_media_open+0x9c>)
 8002ce2:	f003 fa4d 	bl	8006180 <_fxe_media_open>
                                        storage, storage_media -> ux_host_class_storage_media_memory, 
                                        UX_HOST_CLASS_STORAGE_MEMORY_BUFFER_SIZE);

            /* If the media is mounted, update the status for the application.  */
            if (status == UX_SUCCESS)
 8002ce6:	4605      	mov	r5, r0
 8002ce8:	b988      	cbnz	r0, 8002d0e <_ux_host_class_storage_media_open+0x8a>
                storage_media -> ux_host_class_storage_media_status = UX_HOST_CLASS_STORAGE_MEDIA_MOUNTED;
 8002cea:	2301      	movs	r3, #1
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_MEMORY_ERROR, storage, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* Return error.  */    
    return(UX_HOST_CLASS_MEMORY_ERROR);
}
 8002cec:	4628      	mov	r0, r5
                storage_media -> ux_host_class_storage_media_status = UX_HOST_CLASS_STORAGE_MEDIA_MOUNTED;
 8002cee:	51e3      	str	r3, [r4, r7]
}
 8002cf0:	b005      	add	sp, #20
 8002cf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_HOST_CLASS_MEMORY_ERROR);
 8002cf4:	2261      	movs	r2, #97	; 0x61
 8002cf6:	2107      	movs	r1, #7
 8002cf8:	2002      	movs	r0, #2
    return(UX_HOST_CLASS_MEMORY_ERROR);
 8002cfa:	4615      	mov	r5, r2
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_HOST_CLASS_MEMORY_ERROR);
 8002cfc:	f7fe ff80 	bl	8001c00 <_ux_system_error_handler>
}
 8002d00:	4628      	mov	r0, r5
 8002d02:	b005      	add	sp, #20
 8002d04:	bdf0      	pop	{r4, r5, r6, r7, pc}
                return(UX_MEMORY_INSUFFICIENT);
 8002d06:	2512      	movs	r5, #18
}
 8002d08:	4628      	mov	r0, r5
 8002d0a:	b005      	add	sp, #20
 8002d0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                _ux_utility_memory_free(storage_media -> ux_host_class_storage_media_memory);
 8002d0e:	59a0      	ldr	r0, [r4, r6]
 8002d10:	f7ff f900 	bl	8001f14 <_ux_utility_memory_free>
}
 8002d14:	4628      	mov	r0, r5
 8002d16:	b005      	add	sp, #20
 8002d18:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002d1a:	bf00      	nop
 8002d1c:	0800476d 	.word	0x0800476d
 8002d20:	0800ddf4 	.word	0x0800ddf4

08002d24 <_ux_host_class_storage_media_read>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT _ux_host_class_storage_media_read(UX_HOST_CLASS_STORAGE* storage, ULONG sector_start,
		ULONG sector_count, UCHAR* data_pointer)
{
 8002d24:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002d28:	4604      	mov	r4, r0
 8002d2a:	4616      	mov	r6, r2
 8002d2c:	468b      	mov	fp, r1
 8002d2e:	469a      	mov	sl, r3
 8002d30:	f100 092d 	add.w	r9, r0, #45	; 0x2d
 8002d34:	f100 0832 	add.w	r8, r0, #50	; 0x32
 8002d38:	b297      	uxth	r7, r2
 8002d3a:	250a      	movs	r5, #10
#else
		command_length = UX_HOST_CLASS_STORAGE_READ_COMMAND_LENGTH_SBC;
#endif

		/* Initialize the CBW for this command.  */
		_ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_IN,
 8002d3c:	f8d4 2170 	ldr.w	r2, [r4, #368]	; 0x170
 8002d40:	230a      	movs	r3, #10
 8002d42:	2180      	movs	r1, #128	; 0x80
 8002d44:	4620      	mov	r0, r4
 8002d46:	fb02 f206 	mul.w	r2, r2, r6
 8002d4a:	f7ff fd35 	bl	80027b8 <_ux_host_class_storage_cbw_initialize>
				sector_count * storage->ux_host_class_storage_sector_size, command_length);

		/* Prepare the MEDIA READ command block.  */
		*(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_READ_OPERATION) =
 8002d4e:	f04f 0328 	mov.w	r3, #40	; 0x28
				UX_HOST_CLASS_STORAGE_SCSI_READ16;

		/* Store the sector start (LBA field).  */
		_ux_utility_long_put_big_endian(
 8002d52:	4659      	mov	r1, fp
 8002d54:	4648      	mov	r0, r9
		*(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_READ_OPERATION) =
 8002d56:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
		_ux_utility_long_put_big_endian(
 8002d5a:	f001 fbed 	bl	8004538 <_ux_utility_long_put_big_endian>
				cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_READ_LBA, sector_start);

		/* Store the number of sectors to read.  */
		_ux_utility_short_put_big_endian(
 8002d5e:	4639      	mov	r1, r7
 8002d60:	4640      	mov	r0, r8
 8002d62:	f001 fc03 	bl	800456c <_ux_utility_short_put_big_endian>
				cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_READ_TRANSFER_LENGTH,
				(USHORT)sector_count);

		/* Send the command to transport layer.  */
		status = _ux_host_class_storage_transport(storage, data_pointer);
 8002d66:	4651      	mov	r1, sl
 8002d68:	4620      	mov	r0, r4
 8002d6a:	f000 f8a5 	bl	8002eb8 <_ux_host_class_storage_transport>
		if (status != UX_SUCCESS)
 8002d6e:	b928      	cbnz	r0, 8002d7c <_ux_host_class_storage_media_read+0x58>
			return (status);

		/* Did the command succeed?  */
		if (storage->ux_host_class_storage_sense_code == UX_SUCCESS)
 8002d70:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
 8002d74:	b123      	cbz	r3, 8002d80 <_ux_host_class_storage_media_read+0x5c>
	while (media_retry-- != 0)
 8002d76:	3d01      	subs	r5, #1
 8002d78:	d1e0      	bne.n	8002d3c <_ux_host_class_storage_media_read+0x18>
		/* The command did not succeed. Retry.  */
	}

	/* Check if the media in the device has been removed. If so
	 * we have to tell FileX that the media is closed.  */
	return (UX_HOST_CLASS_STORAGE_SENSE_ERROR);
 8002d7a:	2003      	movs	r0, #3
}
 8002d7c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					!= sector_count * storage->ux_host_class_storage_sector_size)
 8002d80:	f8d4 3170 	ldr.w	r3, [r4, #368]	; 0x170
			if (storage->ux_host_class_storage_data_phase_length
 8002d84:	f8d4 2174 	ldr.w	r2, [r4, #372]	; 0x174
					!= sector_count * storage->ux_host_class_storage_sector_size)
 8002d88:	fb03 f606 	mul.w	r6, r3, r6
			if (storage->ux_host_class_storage_data_phase_length
 8002d8c:	42b2      	cmp	r2, r6
 8002d8e:	d0f5      	beq.n	8002d7c <_ux_host_class_storage_media_read+0x58>
				_ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS,
 8002d90:	2002      	movs	r0, #2
 8002d92:	2229      	movs	r2, #41	; 0x29
 8002d94:	2107      	movs	r1, #7
 8002d96:	f7fe ff33 	bl	8001c00 <_ux_system_error_handler>
				return (UX_ERROR);
 8002d9a:	20ff      	movs	r0, #255	; 0xff
 8002d9c:	e7ee      	b.n	8002d7c <_ux_host_class_storage_media_read+0x58>
 8002d9e:	bf00      	nop

08002da0 <_ux_host_class_storage_partition_read>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_partition_read(UX_HOST_CLASS_STORAGE *storage, UCHAR *sector_memory, ULONG sector)
{
 8002da0:	b570      	push	{r4, r5, r6, lr}
    /* There are 4 partitions in a partition table.  */
    for (partition_index = 0; partition_index < 4; partition_index++)
    {

        /* Check if we recognize this partition entry.  */
        switch(*(sector_memory + UX_HOST_CLASS_STORAGE_PARTITION_TYPE))
 8002da2:	f891 31c2 	ldrb.w	r3, [r1, #450]	; 0x1c2
{
 8002da6:	460c      	mov	r4, r1
 8002da8:	4605      	mov	r5, r0
 8002daa:	4616      	mov	r6, r2
 8002dac:	2b0f      	cmp	r3, #15
 8002dae:	d80a      	bhi.n	8002dc6 <_ux_host_class_storage_partition_read+0x26>
 8002db0:	2201      	movs	r2, #1
 8002db2:	f645 0152 	movw	r1, #22610	; 0x5852
 8002db6:	fa02 f303 	lsl.w	r3, r2, r3
 8002dba:	420b      	tst	r3, r1
 8002dbc:	d132      	bne.n	8002e24 <_ux_host_class_storage_partition_read+0x84>
 8002dbe:	f248 0220 	movw	r2, #32800	; 0x8020
 8002dc2:	4213      	tst	r3, r2
 8002dc4:	d165      	bne.n	8002e92 <_ux_host_class_storage_partition_read+0xf2>
UINT        status =  UX_ERROR;
 8002dc6:	20ff      	movs	r0, #255	; 0xff
        switch(*(sector_memory + UX_HOST_CLASS_STORAGE_PARTITION_TYPE))
 8002dc8:	f894 31d2 	ldrb.w	r3, [r4, #466]	; 0x1d2
 8002dcc:	2b0f      	cmp	r3, #15
 8002dce:	d80a      	bhi.n	8002de6 <_ux_host_class_storage_partition_read+0x46>
 8002dd0:	2201      	movs	r2, #1
 8002dd2:	f645 0152 	movw	r1, #22610	; 0x5852
 8002dd6:	fa02 f303 	lsl.w	r3, r2, r3
 8002dda:	420b      	tst	r3, r1
 8002ddc:	d12b      	bne.n	8002e36 <_ux_host_class_storage_partition_read+0x96>
 8002dde:	f248 0220 	movw	r2, #32800	; 0x8020
 8002de2:	4213      	tst	r3, r2
 8002de4:	d143      	bne.n	8002e6e <_ux_host_class_storage_partition_read+0xce>
 8002de6:	f894 31e2 	ldrb.w	r3, [r4, #482]	; 0x1e2
 8002dea:	2b0f      	cmp	r3, #15
 8002dec:	d80a      	bhi.n	8002e04 <_ux_host_class_storage_partition_read+0x64>
 8002dee:	2201      	movs	r2, #1
 8002df0:	f645 0152 	movw	r1, #22610	; 0x5852
 8002df4:	fa02 f303 	lsl.w	r3, r2, r3
 8002df8:	420b      	tst	r3, r1
 8002dfa:	d125      	bne.n	8002e48 <_ux_host_class_storage_partition_read+0xa8>
 8002dfc:	f248 0220 	movw	r2, #32800	; 0x8020
 8002e00:	4213      	tst	r3, r2
 8002e02:	d13d      	bne.n	8002e80 <_ux_host_class_storage_partition_read+0xe0>
 8002e04:	f894 31f2 	ldrb.w	r3, [r4, #498]	; 0x1f2
 8002e08:	2b0f      	cmp	r3, #15
 8002e0a:	d80a      	bhi.n	8002e22 <_ux_host_class_storage_partition_read+0x82>
 8002e0c:	2201      	movs	r2, #1
 8002e0e:	f645 0152 	movw	r1, #22610	; 0x5852
 8002e12:	fa02 f303 	lsl.w	r3, r2, r3
 8002e16:	420b      	tst	r3, r1
 8002e18:	d11f      	bne.n	8002e5a <_ux_host_class_storage_partition_read+0xba>
 8002e1a:	f248 0220 	movw	r2, #32800	; 0x8020
 8002e1e:	4213      	tst	r3, r2
 8002e20:	d140      	bne.n	8002ea4 <_ux_host_class_storage_partition_read+0x104>
        sector_memory +=  UX_HOST_CLASS_STORAGE_PARTITION_TABLE_SIZE;
    }

    /* Return completion status.  */
    return(status);
}
 8002e22:	bd70      	pop	{r4, r5, r6, pc}
            status =  _ux_host_class_storage_media_open(storage, sector + _ux_utility_long_get(sector_memory + UX_HOST_CLASS_STORAGE_PARTITION_SECTORS_BEFORE));
 8002e24:	f504 70e3 	add.w	r0, r4, #454	; 0x1c6
 8002e28:	f001 fb7c 	bl	8004524 <_ux_utility_long_get>
 8002e2c:	1981      	adds	r1, r0, r6
 8002e2e:	4628      	mov	r0, r5
 8002e30:	f7ff ff28 	bl	8002c84 <_ux_host_class_storage_media_open>
 8002e34:	e7c8      	b.n	8002dc8 <_ux_host_class_storage_partition_read+0x28>
 8002e36:	f504 70eb 	add.w	r0, r4, #470	; 0x1d6
 8002e3a:	f001 fb73 	bl	8004524 <_ux_utility_long_get>
 8002e3e:	1831      	adds	r1, r6, r0
 8002e40:	4628      	mov	r0, r5
 8002e42:	f7ff ff1f 	bl	8002c84 <_ux_host_class_storage_media_open>
 8002e46:	e7ce      	b.n	8002de6 <_ux_host_class_storage_partition_read+0x46>
 8002e48:	f504 70f3 	add.w	r0, r4, #486	; 0x1e6
 8002e4c:	f001 fb6a 	bl	8004524 <_ux_utility_long_get>
 8002e50:	1831      	adds	r1, r6, r0
 8002e52:	4628      	mov	r0, r5
 8002e54:	f7ff ff16 	bl	8002c84 <_ux_host_class_storage_media_open>
 8002e58:	e7d4      	b.n	8002e04 <_ux_host_class_storage_partition_read+0x64>
 8002e5a:	f504 70fb 	add.w	r0, r4, #502	; 0x1f6
 8002e5e:	f001 fb61 	bl	8004524 <_ux_utility_long_get>
 8002e62:	1981      	adds	r1, r0, r6
 8002e64:	4628      	mov	r0, r5
}
 8002e66:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            status =  _ux_host_class_storage_media_open(storage, sector + _ux_utility_long_get(sector_memory + UX_HOST_CLASS_STORAGE_PARTITION_SECTORS_BEFORE));
 8002e6a:	f7ff bf0b 	b.w	8002c84 <_ux_host_class_storage_media_open>
            status =  _ux_host_class_storage_media_mount(storage, sector + _ux_utility_long_get(sector_memory + UX_HOST_CLASS_STORAGE_PARTITION_SECTORS_BEFORE));
 8002e6e:	f504 70eb 	add.w	r0, r4, #470	; 0x1d6
 8002e72:	f001 fb57 	bl	8004524 <_ux_utility_long_get>
 8002e76:	1831      	adds	r1, r6, r0
 8002e78:	4628      	mov	r0, r5
 8002e7a:	f7ff feab 	bl	8002bd4 <_ux_host_class_storage_media_mount>
 8002e7e:	e7b2      	b.n	8002de6 <_ux_host_class_storage_partition_read+0x46>
 8002e80:	f504 70f3 	add.w	r0, r4, #486	; 0x1e6
 8002e84:	f001 fb4e 	bl	8004524 <_ux_utility_long_get>
 8002e88:	1831      	adds	r1, r6, r0
 8002e8a:	4628      	mov	r0, r5
 8002e8c:	f7ff fea2 	bl	8002bd4 <_ux_host_class_storage_media_mount>
 8002e90:	e7b8      	b.n	8002e04 <_ux_host_class_storage_partition_read+0x64>
 8002e92:	f504 70e3 	add.w	r0, r4, #454	; 0x1c6
 8002e96:	f001 fb45 	bl	8004524 <_ux_utility_long_get>
 8002e9a:	1831      	adds	r1, r6, r0
 8002e9c:	4628      	mov	r0, r5
 8002e9e:	f7ff fe99 	bl	8002bd4 <_ux_host_class_storage_media_mount>
 8002ea2:	e791      	b.n	8002dc8 <_ux_host_class_storage_partition_read+0x28>
 8002ea4:	f504 70fb 	add.w	r0, r4, #502	; 0x1f6
 8002ea8:	f001 fb3c 	bl	8004524 <_ux_utility_long_get>
 8002eac:	1981      	adds	r1, r0, r6
 8002eae:	4628      	mov	r0, r5
}
 8002eb0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            status =  _ux_host_class_storage_media_mount(storage, sector + _ux_utility_long_get(sector_memory + UX_HOST_CLASS_STORAGE_PARTITION_SECTORS_BEFORE));
 8002eb4:	f7ff be8e 	b.w	8002bd4 <_ux_host_class_storage_media_mount>

08002eb8 <_ux_host_class_storage_transport>:
UINT        status;
UINT        csw_status;


    /* Reset the sense code.  */
    storage -> ux_host_class_storage_sense_code =  UX_SUCCESS;
 8002eb8:	2200      	movs	r2, #0
{
 8002eba:	b538      	push	{r3, r4, r5, lr}

    /* Send the command to the appropriate transport.  */
    status =  storage -> ux_host_class_storage_transport(storage, data_pointer);
 8002ebc:	f8d0 3178 	ldr.w	r3, [r0, #376]	; 0x178
{
 8002ec0:	4604      	mov	r4, r0
    storage -> ux_host_class_storage_sense_code =  UX_SUCCESS;
 8002ec2:	f8c0 217c 	str.w	r2, [r0, #380]	; 0x17c
    status =  storage -> ux_host_class_storage_transport(storage, data_pointer);
 8002ec6:	4798      	blx	r3
    if (storage -> ux_host_class_storage_interface -> ux_interface_descriptor.bInterfaceProtocol != UX_HOST_CLASS_STORAGE_PROTOCOL_CBI)
    {
#endif

    /* Check the status.  */
    if (status != UX_SUCCESS)
 8002ec8:	4605      	mov	r5, r0
 8002eca:	b910      	cbnz	r0, 8002ed2 <_ux_host_class_storage_transport+0x1a>
        /* There was a more serious error. Just give up!  */
        return(status);

    /* The command transfer was OK but maybe we have a CSW error.  */
    csw_status =  storage -> ux_host_class_storage_csw[UX_HOST_CLASS_STORAGE_CSW_STATUS];
    if (csw_status == 0)
 8002ecc:	f894 30a8 	ldrb.w	r3, [r4, #168]	; 0xa8
 8002ed0:	b90b      	cbnz	r3, 8002ed6 <_ux_host_class_storage_transport+0x1e>
            /* There was a more serious error. Just give up!  */
            return(status);
        }
    }
#endif
}
 8002ed2:	4628      	mov	r0, r5
 8002ed4:	bd38      	pop	{r3, r4, r5, pc}
    status =  _ux_host_class_storage_request_sense(storage);
 8002ed6:	4620      	mov	r0, r4
 8002ed8:	f001 fd36 	bl	8004948 <_ux_host_class_storage_request_sense>
    if (status != UX_SUCCESS)
 8002edc:	4605      	mov	r5, r0
 8002ede:	2800      	cmp	r0, #0
 8002ee0:	d0f7      	beq.n	8002ed2 <_ux_host_class_storage_transport+0x1a>
        _ux_host_class_storage_device_reset(storage);
 8002ee2:	4620      	mov	r0, r4
 8002ee4:	f7ff fd54 	bl	8002990 <_ux_host_class_storage_device_reset>
        return(status);
 8002ee8:	e7f3      	b.n	8002ed2 <_ux_host_class_storage_transport+0x1a>
 8002eea:	bf00      	nop

08002eec <_ux_host_class_storage_transport_bo>:
/*                                                                        */
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_transport_bo(UX_HOST_CLASS_STORAGE *storage, UCHAR *data_pointer)
{
 8002eec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
ULONG           data_phase_transfer_size;
UCHAR           *get_status_response;


    /* Get the pointer to the transfer request.  */
    transfer_request =  &storage -> ux_host_class_storage_bulk_out_endpoint -> ux_endpoint_transfer_request;
 8002ef0:	6906      	ldr	r6, [r0, #16]
    /* Use a pointer for the cbw, easier to manipulate.  */
    cbw =  (UCHAR *) storage -> ux_host_class_storage_cbw;

    /* Fill in the transfer request parameters.  */
    transfer_request -> ux_transfer_request_data_pointer =      cbw;
    transfer_request -> ux_transfer_request_requested_length =  UX_HOST_CLASS_STORAGE_CBW_LENGTH;
 8002ef2:	231f      	movs	r3, #31
    cbw =  (UCHAR *) storage -> ux_host_class_storage_cbw;
 8002ef4:	f100 021c 	add.w	r2, r0, #28
{
 8002ef8:	4607      	mov	r7, r0
 8002efa:	4688      	mov	r8, r1
    transfer_request -> ux_transfer_request_requested_length =  UX_HOST_CLASS_STORAGE_CBW_LENGTH;
 8002efc:	f04f 0a02 	mov.w	sl, #2
    transfer_request =  &storage -> ux_host_class_storage_bulk_out_endpoint -> ux_endpoint_transfer_request;
 8002f00:	f106 0430 	add.w	r4, r6, #48	; 0x30
           the bulk transport is non blocking).  */
        if (status != UX_SUCCESS)
            return(status);

        /* Wait for the completion of the transfer request.  */
        status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_HOST_CLASS_STORAGE_TRANSFER_TIMEOUT));
 8002f04:	f106 0958 	add.w	r9, r6, #88	; 0x58
    transfer_request -> ux_transfer_request_data_pointer =      cbw;
 8002f08:	63b2      	str	r2, [r6, #56]	; 0x38
    transfer_request -> ux_transfer_request_requested_length =  UX_HOST_CLASS_STORAGE_CBW_LENGTH;
 8002f0a:	63f3      	str	r3, [r6, #60]	; 0x3c
        status =  _ux_host_stack_transfer_request(transfer_request);
 8002f0c:	4620      	mov	r0, r4
 8002f0e:	f001 fa6f 	bl	80043f0 <_ux_host_stack_transfer_request>
        status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_HOST_CLASS_STORAGE_TRANSFER_TIMEOUT));
 8002f12:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
        if (status != UX_SUCCESS)
 8002f16:	4605      	mov	r5, r0
 8002f18:	bb70      	cbnz	r0, 8002f78 <_ux_host_class_storage_transport_bo+0x8c>
        status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_HOST_CLASS_STORAGE_TRANSFER_TIMEOUT));
 8002f1a:	4648      	mov	r0, r9
 8002f1c:	f7ff f8b8 	bl	8002090 <_ux_utility_semaphore_get>

        /* If the semaphore did not succeed we probably have a time out.  */
        if (status != UX_SUCCESS)
 8002f20:	2800      	cmp	r0, #0
 8002f22:	d174      	bne.n	800300e <_ux_host_class_storage_transport_bo+0x122>
            /* There was an error, return to the caller.  */
            return(UX_TRANSFER_TIMEOUT);
        }

        /* Did we successfully send the CBW?  */
        if (transfer_request -> ux_transfer_request_completion_code == UX_SUCCESS)
 8002f24:	f8d6 5084 	ldr.w	r5, [r6, #132]	; 0x84
 8002f28:	2d00      	cmp	r5, #0
 8002f2a:	d167      	bne.n	8002ffc <_ux_host_class_storage_transport_bo+0x110>
            return(transfer_request -> ux_transfer_request_completion_code);
        }
    }

    /* Get the length of the data payload.  */
    data_phase_requested_length =  _ux_utility_long_get(cbw + UX_HOST_CLASS_STORAGE_CBW_DATA_LENGTH);
 8002f2c:	f107 0924 	add.w	r9, r7, #36	; 0x24
 8002f30:	4648      	mov	r0, r9
 8002f32:	f001 faf7 	bl	8004524 <_ux_utility_long_get>

    /* Reset the data phase memory size.  */
    storage -> ux_host_class_storage_data_phase_length =  0;
 8002f36:	f8c7 5174 	str.w	r5, [r7, #372]	; 0x174

    /* Perform the data stage - if there is any.  */
    while (data_phase_requested_length != 0)
 8002f3a:	4606      	mov	r6, r0
 8002f3c:	b360      	cbz	r0, 8002f98 <_ux_host_class_storage_transport_bo+0xac>
 8002f3e:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400

            /* The transfer size can be the requested length.  */
            data_phase_transfer_size =  data_phase_requested_length;

        /* Check the direction and determine which endpoint to use.  */
        if (*(cbw + UX_HOST_CLASS_STORAGE_CBW_FLAGS) == UX_HOST_CLASS_STORAGE_DATA_IN)
 8002f42:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8002f46:	4635      	mov	r5, r6
 8002f48:	bf28      	it	cs
 8002f4a:	f44f 6580 	movcs.w	r5, #1024	; 0x400
 8002f4e:	2b80      	cmp	r3, #128	; 0x80
 8002f50:	d101      	bne.n	8002f56 <_ux_host_class_storage_transport_bo+0x6a>
            transfer_request =  &storage -> ux_host_class_storage_bulk_in_endpoint -> ux_endpoint_transfer_request;
 8002f52:	697c      	ldr	r4, [r7, #20]
 8002f54:	3430      	adds	r4, #48	; 0x30

        /* Fill in the transfer request data payload buffer.  */
        transfer_request -> ux_transfer_request_data_pointer =  data_pointer;
 8002f56:	f8c4 8008 	str.w	r8, [r4, #8]

        /* Store the requested length in the transfer request.  */
        transfer_request -> ux_transfer_request_requested_length =  data_phase_transfer_size;

        /* Perform data payload transfer (in or out).  */
        status =  _ux_host_stack_transfer_request(transfer_request);
 8002f5a:	4620      	mov	r0, r4
        transfer_request -> ux_transfer_request_requested_length =  data_phase_transfer_size;
 8002f5c:	60e5      	str	r5, [r4, #12]
        status =  _ux_host_stack_transfer_request(transfer_request);
 8002f5e:	f001 fa47 	bl	80043f0 <_ux_host_stack_transfer_request>

        /* Check the status of the data payload.  */
        if (status == UX_SUCCESS)
 8002f62:	b160      	cbz	r0, 8002f7e <_ux_host_class_storage_transport_bo+0x92>

            /* All transfers pending need to abort. There may have been a partial transfer.  */
            _ux_host_stack_transfer_request_abort(transfer_request);

            /* Set the completion code.  */
            transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_TIMEOUT;
 8002f64:	255c      	movs	r5, #92	; 0x5c
            _ux_host_stack_transfer_request_abort(transfer_request);
 8002f66:	4620      	mov	r0, r4
 8002f68:	f001 fa90 	bl	800448c <_ux_host_stack_transfer_request_abort>

            /* Error trap. */
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_TRANSFER_TIMEOUT);
 8002f6c:	2107      	movs	r1, #7
            transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_TIMEOUT;
 8002f6e:	6565      	str	r5, [r4, #84]	; 0x54
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_TRANSFER_TIMEOUT);
 8002f70:	462a      	mov	r2, r5
 8002f72:	2002      	movs	r0, #2
 8002f74:	f7fe fe44 	bl	8001c00 <_ux_system_error_handler>
    /* If we get here, the CSW transfer stalled twice. We must reset the device.  */
    _ux_host_class_storage_device_reset(storage);

    /* Return the error.  */
    return(transfer_request -> ux_transfer_request_completion_code);
}
 8002f78:	4628      	mov	r0, r5
 8002f7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_HOST_CLASS_STORAGE_TRANSFER_TIMEOUT));
 8002f7e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8002f82:	f104 0028 	add.w	r0, r4, #40	; 0x28
        data_pointer +=  data_phase_transfer_size;
 8002f86:	44a8      	add	r8, r5
            status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_HOST_CLASS_STORAGE_TRANSFER_TIMEOUT));
 8002f88:	f7ff f882 	bl	8002090 <_ux_utility_semaphore_get>
        if (status != UX_SUCCESS)
 8002f8c:	2800      	cmp	r0, #0
 8002f8e:	d1e9      	bne.n	8002f64 <_ux_host_class_storage_transport_bo+0x78>
        if (transfer_request -> ux_transfer_request_completion_code != UX_SUCCESS)
 8002f90:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002f92:	bb53      	cbnz	r3, 8002fea <_ux_host_class_storage_transport_bo+0xfe>
    while (data_phase_requested_length != 0)
 8002f94:	1b76      	subs	r6, r6, r5
 8002f96:	d1d2      	bne.n	8002f3e <_ux_host_class_storage_transport_bo+0x52>
    transfer_request =  &storage -> ux_host_class_storage_bulk_in_endpoint -> ux_endpoint_transfer_request;
 8002f98:	697c      	ldr	r4, [r7, #20]
    transfer_request -> ux_transfer_request_data_pointer =      (UCHAR *) &storage -> ux_host_class_storage_csw;
 8002f9a:	f107 029c 	add.w	r2, r7, #156	; 0x9c
    transfer_request -> ux_transfer_request_requested_length =  UX_HOST_CLASS_STORAGE_CSW_LENGTH;
 8002f9e:	230d      	movs	r3, #13
 8002fa0:	2602      	movs	r6, #2
    transfer_request =  &storage -> ux_host_class_storage_bulk_in_endpoint -> ux_endpoint_transfer_request;
 8002fa2:	f104 0830 	add.w	r8, r4, #48	; 0x30
        status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_HOST_CLASS_STORAGE_TRANSFER_TIMEOUT));
 8002fa6:	f104 0a58 	add.w	sl, r4, #88	; 0x58
    transfer_request -> ux_transfer_request_data_pointer =      (UCHAR *) &storage -> ux_host_class_storage_csw;
 8002faa:	63a2      	str	r2, [r4, #56]	; 0x38
    transfer_request -> ux_transfer_request_requested_length =  UX_HOST_CLASS_STORAGE_CSW_LENGTH;
 8002fac:	63e3      	str	r3, [r4, #60]	; 0x3c
        status =  _ux_host_stack_transfer_request(transfer_request);
 8002fae:	4640      	mov	r0, r8
 8002fb0:	f001 fa1e 	bl	80043f0 <_ux_host_stack_transfer_request>
        status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_HOST_CLASS_STORAGE_TRANSFER_TIMEOUT));
 8002fb4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
        if (status != UX_SUCCESS)
 8002fb8:	4605      	mov	r5, r0
 8002fba:	2800      	cmp	r0, #0
 8002fbc:	d1dc      	bne.n	8002f78 <_ux_host_class_storage_transport_bo+0x8c>
        status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_HOST_CLASS_STORAGE_TRANSFER_TIMEOUT));
 8002fbe:	4650      	mov	r0, sl
 8002fc0:	f7ff f866 	bl	8002090 <_ux_utility_semaphore_get>
        if (status != UX_SUCCESS)
 8002fc4:	bb78      	cbnz	r0, 8003026 <_ux_host_class_storage_transport_bo+0x13a>
        if (transfer_request -> ux_transfer_request_completion_code == UX_SUCCESS)
 8002fc6:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
 8002fca:	b3c5      	cbz	r5, 800303e <_ux_host_class_storage_transport_bo+0x152>
        _ux_host_stack_endpoint_reset(storage -> ux_host_class_storage_bulk_in_endpoint);
 8002fcc:	6978      	ldr	r0, [r7, #20]
 8002fce:	f001 f8a3 	bl	8004118 <_ux_host_stack_endpoint_reset>
    for (retry =  0; retry < 2; retry++)
 8002fd2:	2e01      	cmp	r6, #1
 8002fd4:	f04f 0601 	mov.w	r6, #1
 8002fd8:	d1e9      	bne.n	8002fae <_ux_host_class_storage_transport_bo+0xc2>
    _ux_host_class_storage_device_reset(storage);
 8002fda:	4638      	mov	r0, r7
 8002fdc:	f7ff fcd8 	bl	8002990 <_ux_host_class_storage_device_reset>
    return(transfer_request -> ux_transfer_request_completion_code);
 8002fe0:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
}
 8002fe4:	4628      	mov	r0, r5
 8002fe6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if (*(cbw + UX_HOST_CLASS_STORAGE_CBW_FLAGS) == UX_HOST_CLASS_STORAGE_DATA_IN)
 8002fea:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8002fee:	2b80      	cmp	r3, #128	; 0x80
                _ux_host_stack_endpoint_reset(storage -> ux_host_class_storage_bulk_in_endpoint);
 8002ff0:	bf0c      	ite	eq
 8002ff2:	6978      	ldreq	r0, [r7, #20]
                _ux_host_stack_endpoint_reset(storage -> ux_host_class_storage_bulk_out_endpoint);
 8002ff4:	6938      	ldrne	r0, [r7, #16]
 8002ff6:	f001 f88f 	bl	8004118 <_ux_host_stack_endpoint_reset>
 8002ffa:	e7cd      	b.n	8002f98 <_ux_host_class_storage_transport_bo+0xac>
        if (retry == 0)
 8002ffc:	f1ba 0f01 	cmp.w	sl, #1
            _ux_host_class_storage_device_reset(storage);
 8003000:	4638      	mov	r0, r7
 8003002:	f04f 0a01 	mov.w	sl, #1
        if (retry == 0)
 8003006:	d0b7      	beq.n	8002f78 <_ux_host_class_storage_transport_bo+0x8c>
            _ux_host_class_storage_device_reset(storage);
 8003008:	f7ff fcc2 	bl	8002990 <_ux_host_class_storage_device_reset>
        status =  _ux_host_stack_transfer_request(transfer_request);
 800300c:	e77e      	b.n	8002f0c <_ux_host_class_storage_transport_bo+0x20>
            transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_TIMEOUT;
 800300e:	255c      	movs	r5, #92	; 0x5c
            _ux_host_stack_transfer_request_abort(transfer_request);
 8003010:	4620      	mov	r0, r4
 8003012:	f001 fa3b 	bl	800448c <_ux_host_stack_transfer_request_abort>
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_TRANSFER_TIMEOUT);
 8003016:	2107      	movs	r1, #7
            transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_TIMEOUT;
 8003018:	f8c6 5084 	str.w	r5, [r6, #132]	; 0x84
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_TRANSFER_TIMEOUT);
 800301c:	462a      	mov	r2, r5
 800301e:	2002      	movs	r0, #2
 8003020:	f7fe fdee 	bl	8001c00 <_ux_system_error_handler>
            return(UX_TRANSFER_TIMEOUT);
 8003024:	e7a8      	b.n	8002f78 <_ux_host_class_storage_transport_bo+0x8c>
            transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_TIMEOUT;
 8003026:	255c      	movs	r5, #92	; 0x5c
            _ux_host_stack_transfer_request_abort(transfer_request);
 8003028:	4640      	mov	r0, r8
 800302a:	f001 fa2f 	bl	800448c <_ux_host_stack_transfer_request_abort>
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_TRANSFER_TIMEOUT);
 800302e:	2107      	movs	r1, #7
            transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_TIMEOUT;
 8003030:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_CLASS, UX_TRANSFER_TIMEOUT);
 8003034:	462a      	mov	r2, r5
 8003036:	2002      	movs	r0, #2
 8003038:	f7fe fde2 	bl	8001c00 <_ux_system_error_handler>
            return(UX_TRANSFER_TIMEOUT);
 800303c:	e79c      	b.n	8002f78 <_ux_host_class_storage_transport_bo+0x8c>
            if (storage -> ux_host_class_storage_csw[UX_HOST_CLASS_STORAGE_CSW_STATUS] == UX_HOST_CLASS_STORAGE_CSW_PASSED ||
 800303e:	f897 30a8 	ldrb.w	r3, [r7, #168]	; 0xa8
 8003042:	2b01      	cmp	r3, #1
 8003044:	d83b      	bhi.n	80030be <_ux_host_class_storage_transport_bo+0x1d2>
                if (*(cbw + UX_HOST_CLASS_STORAGE_CBW_FLAGS) == UX_HOST_CLASS_STORAGE_DATA_OUT)
 8003046:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
 800304a:	2a00      	cmp	r2, #0
 800304c:	d13b      	bne.n	80030c6 <_ux_host_class_storage_transport_bo+0x1da>
                    if (storage -> ux_host_class_storage_csw[UX_HOST_CLASS_STORAGE_CSW_STATUS] == UX_HOST_CLASS_STORAGE_CSW_FAILED ||
 800304e:	2b01      	cmp	r3, #1
 8003050:	d005      	beq.n	800305e <_ux_host_class_storage_transport_bo+0x172>
                        _ux_utility_long_get(storage -> ux_host_class_storage_csw + UX_HOST_CLASS_STORAGE_CSW_DATA_RESIDUE) != 0)
 8003052:	f107 04a4 	add.w	r4, r7, #164	; 0xa4
 8003056:	4620      	mov	r0, r4
 8003058:	f001 fa64 	bl	8004524 <_ux_utility_long_get>
                    if (storage -> ux_host_class_storage_csw[UX_HOST_CLASS_STORAGE_CSW_STATUS] == UX_HOST_CLASS_STORAGE_CSW_FAILED ||
 800305c:	b320      	cbz	r0, 80030a8 <_ux_host_class_storage_transport_bo+0x1bc>
                        get_status_response =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, 2);
 800305e:	2202      	movs	r2, #2
 8003060:	2101      	movs	r1, #1
 8003062:	f04f 30ff 	mov.w	r0, #4294967295
 8003066:	f7fe fe41 	bl	8001cec <_ux_utility_memory_allocate>
                        if (get_status_response == UX_NULL)
 800306a:	4604      	mov	r4, r0
 800306c:	b398      	cbz	r0, 80030d6 <_ux_host_class_storage_transport_bo+0x1ea>
                        transfer_request -> ux_transfer_request_index =             storage -> ux_host_class_storage_bulk_out_endpoint-> ux_endpoint_descriptor.bEndpointAddress;
 800306e:	693a      	ldr	r2, [r7, #16]
                        transfer_request -> ux_transfer_request_requested_length =  0x02;
 8003070:	2602      	movs	r6, #2
                        transfer_request =  &storage -> ux_host_class_storage_device -> ux_device_control_endpoint.ux_endpoint_transfer_request;
 8003072:	68bb      	ldr	r3, [r7, #8]
                        transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_ENDPOINT;
 8003074:	2182      	movs	r1, #130	; 0x82
                        transfer_request -> ux_transfer_request_index =             storage -> ux_host_class_storage_bulk_out_endpoint-> ux_endpoint_descriptor.bEndpointAddress;
 8003076:	6950      	ldr	r0, [r2, #20]
                        transfer_request -> ux_transfer_request_function =          UX_GET_STATUS;
 8003078:	2200      	movs	r2, #0
                        transfer_request -> ux_transfer_request_data_pointer =      get_status_response;
 800307a:	f8c3 40cc 	str.w	r4, [r3, #204]	; 0xcc
                        transfer_request -> ux_transfer_request_index =             storage -> ux_host_class_storage_bulk_out_endpoint-> ux_endpoint_descriptor.bEndpointAddress;
 800307e:	f8c3 00e4 	str.w	r0, [r3, #228]	; 0xe4
                        status =  _ux_host_stack_transfer_request(transfer_request);
 8003082:	f103 00c4 	add.w	r0, r3, #196	; 0xc4
                        transfer_request -> ux_transfer_request_requested_length =  0x02;
 8003086:	f8c3 60d0 	str.w	r6, [r3, #208]	; 0xd0
                        transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_ENDPOINT;
 800308a:	f8c3 10d8 	str.w	r1, [r3, #216]	; 0xd8
                        transfer_request -> ux_transfer_request_value =             0;
 800308e:	e9c3 2237 	strd	r2, r2, [r3, #220]	; 0xdc
                        status =  _ux_host_stack_transfer_request(transfer_request);
 8003092:	f001 f9ad 	bl	80043f0 <_ux_host_stack_transfer_request>
                        if (status == UX_SUCCESS)
 8003096:	b9c8      	cbnz	r0, 80030cc <_ux_host_class_storage_transport_bo+0x1e0>
                            if (get_status_response[0] & 0x01)
 8003098:	7823      	ldrb	r3, [r4, #0]
 800309a:	07db      	lsls	r3, r3, #31
 800309c:	d41d      	bmi.n	80030da <_ux_host_class_storage_transport_bo+0x1ee>
                        _ux_utility_memory_free(get_status_response);
 800309e:	4620      	mov	r0, r4
 80030a0:	f107 04a4 	add.w	r4, r7, #164	; 0xa4
 80030a4:	f7fe ff36 	bl	8001f14 <_ux_utility_memory_free>
                storage -> ux_host_class_storage_data_phase_length =  _ux_utility_long_get(cbw + UX_HOST_CLASS_STORAGE_CBW_DATA_LENGTH) -
 80030a8:	4648      	mov	r0, r9
 80030aa:	f001 fa3b 	bl	8004524 <_ux_utility_long_get>
 80030ae:	4606      	mov	r6, r0
                    _ux_utility_long_get(storage -> ux_host_class_storage_csw + UX_HOST_CLASS_STORAGE_CSW_DATA_RESIDUE);
 80030b0:	4620      	mov	r0, r4
 80030b2:	f001 fa37 	bl	8004524 <_ux_utility_long_get>
                storage -> ux_host_class_storage_data_phase_length =  _ux_utility_long_get(cbw + UX_HOST_CLASS_STORAGE_CBW_DATA_LENGTH) -
 80030b6:	1a30      	subs	r0, r6, r0
 80030b8:	f8c7 0174 	str.w	r0, [r7, #372]	; 0x174
 80030bc:	e75c      	b.n	8002f78 <_ux_host_class_storage_transport_bo+0x8c>
                _ux_host_class_storage_device_reset(storage);
 80030be:	4638      	mov	r0, r7
 80030c0:	f7ff fc66 	bl	8002990 <_ux_host_class_storage_device_reset>
 80030c4:	e758      	b.n	8002f78 <_ux_host_class_storage_transport_bo+0x8c>
 80030c6:	f107 04a4 	add.w	r4, r7, #164	; 0xa4
 80030ca:	e7ed      	b.n	80030a8 <_ux_host_class_storage_transport_bo+0x1bc>
                        _ux_utility_memory_free(get_status_response);
 80030cc:	4605      	mov	r5, r0
 80030ce:	4620      	mov	r0, r4
 80030d0:	f7fe ff20 	bl	8001f14 <_ux_utility_memory_free>
 80030d4:	e750      	b.n	8002f78 <_ux_host_class_storage_transport_bo+0x8c>
                            return(UX_MEMORY_INSUFFICIENT);
 80030d6:	2512      	movs	r5, #18
 80030d8:	e74e      	b.n	8002f78 <_ux_host_class_storage_transport_bo+0x8c>
                                status =  _ux_host_stack_endpoint_reset(storage -> ux_host_class_storage_bulk_out_endpoint);
 80030da:	6938      	ldr	r0, [r7, #16]
 80030dc:	f001 f81c 	bl	8004118 <_ux_host_stack_endpoint_reset>
 80030e0:	4606      	mov	r6, r0
                        _ux_utility_memory_free(get_status_response);
 80030e2:	4620      	mov	r0, r4
 80030e4:	f7fe ff16 	bl	8001f14 <_ux_utility_memory_free>
                        if (status != UX_SUCCESS)
 80030e8:	2e00      	cmp	r6, #0
 80030ea:	d0ec      	beq.n	80030c6 <_ux_host_class_storage_transport_bo+0x1da>
 80030ec:	4635      	mov	r5, r6
 80030ee:	e743      	b.n	8002f78 <_ux_host_class_storage_transport_bo+0x8c>

080030f0 <_ux_hcd_stm32_asynch_queue_process>:
ULONG                transfer_size;
ULONG                hctsiz_register;
ULONG                hcintmsk_register;
        
    /* Load the ED for the channel.  */
    ed =  hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index];
 80030f0:	3128      	adds	r1, #40	; 0x28
{
 80030f2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ed =  hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index];
 80030f6:	f850 5021 	ldr.w	r5, [r0, r1, lsl #2]
{
 80030fa:	b083      	sub	sp, #12
    
    /* Do a sanity test. The ED should be legal and non zero.  */
    if (ed == UX_NULL)
 80030fc:	2d00      	cmp	r5, #0
 80030fe:	f000 8096 	beq.w	800322e <_ux_hcd_stm32_asynch_queue_process+0x13e>
    /* Get the transfer request associated with the TD.  */                          
    transfer_request =  td -> ux_stm32_td_transfer_request;

    /* Unmask the Chanel Halt interrupt.  */
    hcintmsk_register = _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINT + 
                       (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE));                    
 8003102:	6a29      	ldr	r1, [r5, #32]
 8003104:	4616      	mov	r6, r2
    td = ed -> ux_stm32_ed_head_td;
 8003106:	686c      	ldr	r4, [r5, #4]
 8003108:	4607      	mov	r7, r0
                       (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE));                    
 800310a:	0149      	lsls	r1, r1, #5
    endpoint =  ed -> ux_stm32_ed_endpoint;
 800310c:	f8d5 9014 	ldr.w	r9, [r5, #20]
    transfer_request =  td -> ux_stm32_td_transfer_request;
 8003110:	f8d4 800c 	ldr.w	r8, [r4, #12]
    hcintmsk_register = _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINT + 
 8003114:	f501 61a1 	add.w	r1, r1, #1288	; 0x508
 8003118:	f7fe fbc8 	bl	80018ac <_ux_hcd_stm32_register_read>
    /* Set the Halt bit to unmask.  */
    hcintmsk_register |=  UX_HCD_STM32_OTG_FS_HCINT_CHHM;

    /* Save the channel register.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINT + 
                            (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), hcintmsk_register);                    
 800311c:	6a29      	ldr	r1, [r5, #32]
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINT + 
 800311e:	f040 0202 	orr.w	r2, r0, #2
 8003122:	4638      	mov	r0, r7
                            (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), hcintmsk_register);                    
 8003124:	0149      	lsls	r1, r1, #5
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINT + 
 8003126:	f501 61a1 	add.w	r1, r1, #1288	; 0x508
 800312a:	f7fe fbc9 	bl	80018c0 <_ux_hcd_stm32_register_write>

    /* Look at the content of the interrupt register and determine the reason for completion of the transaction.  */
    /* Was it a RXFLVL interrupt ? */
    if (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_RXFLVL)
 800312e:	00f1      	lsls	r1, r6, #3
 8003130:	f100 80a5 	bmi.w	800327e <_ux_hcd_stm32_asynch_queue_process+0x18e>
        }
    }

    /* Look at the content of the interrupt register and determine the reason for completion of the transaction.  */
    /* Was the transaction completed successfully ? */
    if (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_XFRC)
 8003134:	07f2      	lsls	r2, r6, #31
 8003136:	d56f      	bpl.n	8003218 <_ux_hcd_stm32_asynch_queue_process+0x128>
    {
    
        /* The XFRC bit is raised. We have a completion with no errors.  
           Get the transfer length for that transaction. For IN packet,
           we take the field from the actual size. */
        if (td -> ux_stm32_td_direction ==  UX_HCD_STM32_TD_IN)
 8003138:	6a23      	ldr	r3, [r4, #32]
 800313a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
            /* Transfer is out. Length is in td_length.  */
            actual_length = td -> ux_stm32_td_length;
    
    
        /* The toggle bit expected for the next transfer.  */
        if (td -> ux_stm32_td_toggle ==  UX_HCD_STM32_TD_TOGGLE_FROM_ED)
 800313e:	6a63      	ldr	r3, [r4, #36]	; 0x24
            actual_length = td -> ux_stm32_td_actual_length;
 8003140:	bf0c      	ite	eq
 8003142:	f8d4 a018 	ldreq.w	sl, [r4, #24]
            actual_length = td -> ux_stm32_td_length;
 8003146:	f8d4 a004 	ldrne.w	sl, [r4, #4]
        if (td -> ux_stm32_td_toggle ==  UX_HCD_STM32_TD_TOGGLE_FROM_ED)
 800314a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800314e:	f000 8108 	beq.w	8003362 <_ux_hcd_stm32_asynch_queue_process+0x272>

            }
        }
                            
        /* Decide if this is a short packet or not.  */
        if (((actual_length % ed -> ux_stm32_ed_endpoint -> ux_endpoint_descriptor.wMaxPacketSize) != 0) || actual_length == 0)
 8003152:	696b      	ldr	r3, [r5, #20]
 8003154:	faba f28a 	clz	r2, sl
            /* This is not a short packet.  */
            short_packet = UX_FALSE;            
        
        /* If this a data phase either on a control endpoint or any transfer on a bulk endpoint,
           the transfer request actual length must be updated.  */
        if (td -> ux_stm32_td_status & UX_HCD_STM32_TD_DATA_PHASE)
 8003158:	69e0      	ldr	r0, [r4, #28]
        if (((actual_length % ed -> ux_stm32_ed_endpoint -> ux_endpoint_descriptor.wMaxPacketSize) != 0) || actual_length == 0)
 800315a:	69db      	ldr	r3, [r3, #28]
 800315c:	0952      	lsrs	r2, r2, #5
 800315e:	f8d8 c010 	ldr.w	ip, [r8, #16]
 8003162:	fbba f1f3 	udiv	r1, sl, r3
 8003166:	fb03 a111 	mls	r1, r3, r1, sl
 800316a:	2900      	cmp	r1, #0
 800316c:	bf0c      	ite	eq
 800316e:	4611      	moveq	r1, r2
 8003170:	2101      	movne	r1, #1
        if (td -> ux_stm32_td_status & UX_HCD_STM32_TD_DATA_PHASE)
 8003172:	0383      	lsls	r3, r0, #14
 8003174:	d502      	bpl.n	800317c <_ux_hcd_stm32_asynch_queue_process+0x8c>
            transfer_request -> ux_transfer_request_actual_length +=  actual_length;
 8003176:	44d4      	add	ip, sl
 8003178:	f8c8 c010 	str.w	ip, [r8, #16]
    
        /* Get the TD status and isolate the Phase.  */
        td_phase =    td -> ux_stm32_td_status & UX_HCD_STM32_TD_PHASE_MASK;
    
        /* Check for control endpoint.  */
        if ((endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) == UX_CONTROL_ENDPOINT) 
 800317c:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8003180:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8003184:	f012 0203 	ands.w	r2, r2, #3
 8003188:	d128      	bne.n	80031dc <_ux_hcd_stm32_asynch_queue_process+0xec>
        td_phase =    td -> ux_stm32_td_status & UX_HCD_STM32_TD_PHASE_MASK;
 800318a:	f400 20e0 	and.w	r0, r0, #458752	; 0x70000
            /* Check if we have received too much data.  */
            if (transfer_request -> ux_transfer_request_actual_length > transfer_request -> ux_transfer_request_requested_length)
            {

                /* Set the completion code to error.  */
                transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_ERROR;
 800318e:	4563      	cmp	r3, ip
 8003190:	bf34      	ite	cc
 8003192:	f04f 0c23 	movcc.w	ip, #35	; 0x23
 8003196:	f04f 0c00 	movcs.w	ip, #0
                /* Set the completion code to SUCCESS.  */
                transfer_request -> ux_transfer_request_completion_code =  UX_SUCCESS;
            }

            /* Take the TD out of the Endpoint.  */
            ed -> ux_stm32_ed_head_td =  td -> ux_stm32_td_next_td;
 800319a:	68a3      	ldr	r3, [r4, #8]
        
            /* We can now free the TD used in this PTD.  */
            td -> ux_stm32_td_status =  UX_UNUSED;
    
            /* Check for phase.  */
            switch (td_phase)
 800319c:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 80031a0:	f8c8 c054 	str.w	ip, [r8, #84]	; 0x54
            ed -> ux_stm32_ed_head_td =  td -> ux_stm32_td_next_td;
 80031a4:	606b      	str	r3, [r5, #4]
            td -> ux_stm32_td_status =  UX_UNUSED;
 80031a6:	61e2      	str	r2, [r4, #28]
            switch (td_phase)
 80031a8:	d036      	beq.n	8003218 <_ux_hcd_stm32_asynch_queue_process+0x128>
 80031aa:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
 80031ae:	d10f      	bne.n	80031d0 <_ux_hcd_stm32_asynch_queue_process+0xe0>
            
                case UX_HCD_STM32_TD_DATA_PHASE  :
    
                    /* If there is a short packet, we need to take out all the pending DATA phases
                          linked to the ED. We leave the STATUS phase.  If transfer error occurred, we take out all the pending TDs.  */
                    if (short_packet == UX_TRUE || transfer_request -> ux_transfer_request_completion_code != UX_SUCCESS)
 80031b0:	2900      	cmp	r1, #0
 80031b2:	f040 8127 	bne.w	8003404 <_ux_hcd_stm32_asynch_queue_process+0x314>
 80031b6:	f1bc 0f00 	cmp.w	ip, #0
 80031ba:	d02d      	beq.n	8003218 <_ux_hcd_stm32_asynch_queue_process+0x128>
    
                        /* Get the TD attached to the head and traverse the linked list.  */
                        td =  ed -> ux_stm32_ed_head_td;
    
                        /* Check if we have reached the end.  */
                        while (td != ed -> ux_stm32_ed_tail_td)
 80031bc:	6828      	ldr	r0, [r5, #0]
                transfer_request -> ux_transfer_request_completion_code =  UX_SUCCESS;
 80031be:	461c      	mov	r4, r3
        
                                /* This is a DATA phase, take it out of the chain.  */
                                ed -> ux_stm32_ed_head_td =  next_td;                     
        
                                /* We can now free the TD.  */
                                td -> ux_stm32_td_status =  UX_UNUSED;
 80031c0:	2200      	movs	r2, #0
 80031c2:	e003      	b.n	80031cc <_ux_hcd_stm32_asynch_queue_process+0xdc>
 80031c4:	68a3      	ldr	r3, [r4, #8]
                                ed -> ux_stm32_ed_head_td =  next_td;                     
 80031c6:	606b      	str	r3, [r5, #4]
                                td -> ux_stm32_td_status =  UX_UNUSED;
 80031c8:	61e2      	str	r2, [r4, #28]
 80031ca:	461c      	mov	r4, r3
                        while (td != ed -> ux_stm32_ed_tail_td)
 80031cc:	4284      	cmp	r4, r0
 80031ce:	d1f9      	bne.n	80031c4 <_ux_hcd_stm32_asynch_queue_process+0xd4>
                    }
    
                default :
    
                    /* Status Phase or error occurred.  Wake up the transfer request. */
                    if (transfer_request -> ux_transfer_request_completion_function != UX_NULL)
 80031d0:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 80031d4:	b1e3      	cbz	r3, 8003210 <_ux_hcd_stm32_asynch_queue_process+0x120>
                        transfer_request -> ux_transfer_request_completion_function(transfer_request);
 80031d6:	4640      	mov	r0, r8
 80031d8:	4798      	blx	r3
 80031da:	e019      	b.n	8003210 <_ux_hcd_stm32_asynch_queue_process+0x120>
        {
        

            /* We come here when this is a non control endpoint,
            Check the transmitted length and see if we have a short packet or if we are finished with this transfer.  */
            if ((transfer_request -> ux_transfer_request_actual_length >= transfer_request -> ux_transfer_request_requested_length) ||
 80031dc:	4563      	cmp	r3, ip
 80031de:	d902      	bls.n	80031e6 <_ux_hcd_stm32_asynch_queue_process+0xf6>
 80031e0:	2900      	cmp	r1, #0
 80031e2:	f000 80d2 	beq.w	800338a <_ux_hcd_stm32_asynch_queue_process+0x29a>
                (short_packet == UX_TRUE))
            {
        
                /* Remove all the TDs attached.  */
                while (td != ed -> ux_stm32_ed_tail_td)
 80031e6:	6829      	ldr	r1, [r5, #0]
 80031e8:	428c      	cmp	r4, r1
 80031ea:	d006      	beq.n	80031fa <_ux_hcd_stm32_asynch_queue_process+0x10a>
        
                    /* Take it out of the chain.  */
                    ed -> ux_stm32_ed_head_td =  next_td;                     
        
                    /* We can now free the TD.  */
                    td -> ux_stm32_td_status =  UX_UNUSED;
 80031ec:	2000      	movs	r0, #0
                    next_td =  td -> ux_stm32_td_next_td;                     
 80031ee:	68a2      	ldr	r2, [r4, #8]
                    td -> ux_stm32_td_status =  UX_UNUSED;
 80031f0:	61e0      	str	r0, [r4, #28]
                while (td != ed -> ux_stm32_ed_tail_td)
 80031f2:	428a      	cmp	r2, r1
 80031f4:	4614      	mov	r4, r2
 80031f6:	d1fa      	bne.n	80031ee <_ux_hcd_stm32_asynch_queue_process+0xfe>
 80031f8:	606a      	str	r2, [r5, #4]
                /* Check if we received more data than expected.  */
                if (transfer_request -> ux_transfer_request_actual_length > transfer_request -> ux_transfer_request_requested_length)
                {

                    /* Set the completion code to error.  */                                
                    transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_ERROR;
 80031fa:	4563      	cmp	r3, ip
 80031fc:	bf34      	ite	cc
 80031fe:	2323      	movcc	r3, #35	; 0x23
 8003200:	2300      	movcs	r3, #0
                    /* Set the completion code to SUCCESS.  */
                    transfer_request -> ux_transfer_request_completion_code =  UX_SUCCESS;
                }
                
                /* All transfer completion default to this section. */
                if (transfer_request -> ux_transfer_request_completion_function != UX_NULL)
 8003202:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 8003206:	f8c8 3054 	str.w	r3, [r8, #84]	; 0x54
 800320a:	b10a      	cbz	r2, 8003210 <_ux_hcd_stm32_asynch_queue_process+0x120>
                    transfer_request -> ux_transfer_request_completion_function(transfer_request);
 800320c:	4640      	mov	r0, r8
 800320e:	4790      	blx	r2
        
                /* Wake up the transfer request thread.  */
                _ux_utility_semaphore_put(&transfer_request -> ux_transfer_request_semaphore);
 8003210:	f108 0028 	add.w	r0, r8, #40	; 0x28
 8003214:	f7fe ff60 	bl	80020d8 <_ux_utility_semaphore_put>
        }
    
    }

    /* Check for ACK reception. We ignore this interrupt.  But reset the error count.  */
    if (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_ACK)
 8003218:	06b1      	lsls	r1, r6, #26
 800321a:	d501      	bpl.n	8003220 <_ux_hcd_stm32_asynch_queue_process+0x130>
    {

        /* Reset the error count.  */
        ed -> ux_stm32_ed_command_retry    = 0;
 800321c:	2300      	movs	r3, #0
 800321e:	626b      	str	r3, [r5, #36]	; 0x24

    }
    
    /* Check for NAK reception. Differentiate the IN/OUT and Bulk/Control and Interrupt pipes. Reset the error count.  */
    if (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_NAK)
 8003220:	06f2      	lsls	r2, r6, #27
 8003222:	d457      	bmi.n	80032d4 <_ux_hcd_stm32_asynch_queue_process+0x1e4>
                
        }
    }
    
    /* Check for halted channel.  */
    if (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_CHH)    
 8003224:	07b1      	lsls	r1, r6, #30
 8003226:	d475      	bmi.n	8003314 <_ux_hcd_stm32_asynch_queue_process+0x224>
        ed -> ux_stm32_ed_channel_status = UX_HCD_STM32_ED_CHANNEL_RESET;

    }
    
    /* Check for errors in the transmission.  */
    if ((channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_STALL) || (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_TXERR)    
 8003228:	f416 6ff1 	tst.w	r6, #1928	; 0x788
 800322c:	d102      	bne.n	8003234 <_ux_hcd_stm32_asynch_queue_process+0x144>
        _ux_utility_semaphore_put(&transfer_request -> ux_transfer_request_semaphore);
    }    
    
    /* Return to caller.  */
    return;
}
 800322e:	b003      	add	sp, #12
 8003230:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003234:	6a29      	ldr	r1, [r5, #32]
 8003236:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800323a:	4638      	mov	r0, r7
 800323c:	3128      	adds	r1, #40	; 0x28
 800323e:	0149      	lsls	r1, r1, #5
 8003240:	f7fe fb38 	bl	80018b4 <_ux_hcd_stm32_register_set>
        ed -> ux_stm32_ed_channel_status = UX_HCD_STM32_ED_CHANNEL_HALTED;
 8003244:	2301      	movs	r3, #1
        if (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_STALL)
 8003246:	0732      	lsls	r2, r6, #28
        ed -> ux_stm32_ed_channel_status = UX_HCD_STM32_ED_CHANNEL_HALTED;
 8003248:	62ab      	str	r3, [r5, #40]	; 0x28
        if (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_STALL)
 800324a:	d56f      	bpl.n	800332c <_ux_hcd_stm32_asynch_queue_process+0x23c>
            transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_STALLED;
 800324c:	2321      	movs	r3, #33	; 0x21
 800324e:	f8c8 3054 	str.w	r3, [r8, #84]	; 0x54
        while (td != ed -> ux_stm32_ed_tail_td)
 8003252:	682a      	ldr	r2, [r5, #0]
 8003254:	4294      	cmp	r4, r2
 8003256:	d006      	beq.n	8003266 <_ux_hcd_stm32_asynch_queue_process+0x176>
            td -> ux_stm32_td_status =  UX_UNUSED;
 8003258:	2100      	movs	r1, #0
            next_td =  td -> ux_stm32_td_next_td;                     
 800325a:	68a3      	ldr	r3, [r4, #8]
            td -> ux_stm32_td_status =  UX_UNUSED;
 800325c:	61e1      	str	r1, [r4, #28]
        while (td != ed -> ux_stm32_ed_tail_td)
 800325e:	4293      	cmp	r3, r2
 8003260:	461c      	mov	r4, r3
 8003262:	d1fa      	bne.n	800325a <_ux_hcd_stm32_asynch_queue_process+0x16a>
 8003264:	606b      	str	r3, [r5, #4]
        if (transfer_request -> ux_transfer_request_completion_function != UX_NULL)
 8003266:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800326a:	b10b      	cbz	r3, 8003270 <_ux_hcd_stm32_asynch_queue_process+0x180>
            transfer_request -> ux_transfer_request_completion_function(transfer_request);
 800326c:	4640      	mov	r0, r8
 800326e:	4798      	blx	r3
        _ux_utility_semaphore_put(&transfer_request -> ux_transfer_request_semaphore);
 8003270:	f108 0028 	add.w	r0, r8, #40	; 0x28
}
 8003274:	b003      	add	sp, #12
 8003276:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        _ux_utility_semaphore_put(&transfer_request -> ux_transfer_request_semaphore);
 800327a:	f7fe bf2d 	b.w	80020d8 <_ux_utility_semaphore_put>
        stm32_grxstp_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GRXSTSP);
 800327e:	2120      	movs	r1, #32
 8003280:	4638      	mov	r0, r7
 8003282:	f7fe fb13 	bl	80018ac <_ux_hcd_stm32_register_read>
        transfer_status = (stm32_grxstp_register & UX_HCD_STM32_OTG_FS_GRXSTSP_PKTSTS_MASK) >> UX_HCD_STM32_OTG_FS_GRXSTSP_PKTSTS_SHIFT;  
 8003286:	f3c0 4343 	ubfx	r3, r0, #17, #4
        if (transfer_status == UX_HCD_STM32_OTG_FS_GRXSTSP_PKTSTS_IN_RCVD)
 800328a:	2b02      	cmp	r3, #2
 800328c:	f47f af52 	bne.w	8003134 <_ux_hcd_stm32_asynch_queue_process+0x44>
        transfer_size =  (stm32_grxstp_register & UX_HCD_STM32_OTG_FS_GRXSTSP_BCNT_MASK) >> UX_HCD_STM32_OTG_FS_GRXSTSP_BCNT_SHIFT;
 8003290:	0900      	lsrs	r0, r0, #4
            td -> ux_stm32_td_actual_length += transfer_size;
 8003292:	69a2      	ldr	r2, [r4, #24]
            if (transfer_size > td -> ux_stm32_td_length)
 8003294:	6863      	ldr	r3, [r4, #4]
        transfer_size =  (stm32_grxstp_register & UX_HCD_STM32_OTG_FS_GRXSTSP_BCNT_MASK) >> UX_HCD_STM32_OTG_FS_GRXSTSP_BCNT_SHIFT;
 8003296:	f3c0 010a 	ubfx	r1, r0, #0, #11
            byte_count =  transfer_size % sizeof(ULONG);
 800329a:	f000 0003 	and.w	r0, r0, #3
            td -> ux_stm32_td_actual_length += transfer_size;
 800329e:	440a      	add	r2, r1
            if (transfer_size > td -> ux_stm32_td_length)
 80032a0:	428b      	cmp	r3, r1
            byte_count =  transfer_size % sizeof(ULONG);
 80032a2:	9000      	str	r0, [sp, #0]
            dword_count =  transfer_size / sizeof(ULONG);
 80032a4:	ea4f 0a91 	mov.w	sl, r1, lsr #2
            td -> ux_stm32_td_actual_length += transfer_size;
 80032a8:	61a2      	str	r2, [r4, #24]
            if (transfer_size > td -> ux_stm32_td_length)
 80032aa:	d272      	bcs.n	8003392 <_ux_hcd_stm32_asynch_queue_process+0x2a2>
                if (byte_count != 0)
 80032ac:	b930      	cbnz	r0, 80032bc <_ux_hcd_stm32_asynch_queue_process+0x1cc>
                while (dword_count-- != 0)
 80032ae:	f10a 33ff 	add.w	r3, sl, #4294967295
 80032b2:	f1ba 0f00 	cmp.w	sl, #0
 80032b6:	f43f af3d 	beq.w	8003134 <_ux_hcd_stm32_asynch_queue_process+0x44>
 80032ba:	469a      	mov	sl, r3
                    _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_FIFO + 
 80032bc:	6a29      	ldr	r1, [r5, #32]
                while (dword_count-- != 0)
 80032be:	f10a 3aff 	add.w	sl, sl, #4294967295
                    _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_FIFO + 
 80032c2:	4638      	mov	r0, r7
 80032c4:	3101      	adds	r1, #1
 80032c6:	0309      	lsls	r1, r1, #12
 80032c8:	f7fe faf0 	bl	80018ac <_ux_hcd_stm32_register_read>
                while (dword_count-- != 0)
 80032cc:	f1ba 3fff 	cmp.w	sl, #4294967295
 80032d0:	d1f4      	bne.n	80032bc <_ux_hcd_stm32_asynch_queue_process+0x1cc>
 80032d2:	e72f      	b.n	8003134 <_ux_hcd_stm32_asynch_queue_process+0x44>
        channel_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 80032d4:	6a29      	ldr	r1, [r5, #32]
        ed -> ux_stm32_ed_command_retry    = 0;
 80032d6:	2300      	movs	r3, #0
        channel_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 80032d8:	4638      	mov	r0, r7
 80032da:	3128      	adds	r1, #40	; 0x28
        ed -> ux_stm32_ed_command_retry    = 0;
 80032dc:	626b      	str	r3, [r5, #36]	; 0x24
        channel_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 80032de:	0149      	lsls	r1, r1, #5
 80032e0:	f7fe fae4 	bl	80018ac <_ux_hcd_stm32_register_read>
        if (channel_register & UX_HCD_STM32_OTG_FS_HCCHAR_EPDIR_IN)
 80032e4:	0403      	lsls	r3, r0, #16
 80032e6:	d530      	bpl.n	800334a <_ux_hcd_stm32_asynch_queue_process+0x25a>
            if ((endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) == UX_INTERRUPT_ENDPOINT)
 80032e8:	f8d9 3018 	ldr.w	r3, [r9, #24]
 80032ec:	f003 0303 	and.w	r3, r3, #3
 80032f0:	2b03      	cmp	r3, #3
 80032f2:	d02a      	beq.n	800334a <_ux_hcd_stm32_asynch_queue_process+0x25a>
                if (ed -> ux_stm32_ed_nak_counter == UX_HCD_STM32_ASYNCH_NAK_COUNTER)
 80032f4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80032f6:	2b01      	cmp	r3, #1
 80032f8:	d027      	beq.n	800334a <_ux_hcd_stm32_asynch_queue_process+0x25a>
                    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 80032fa:	6a29      	ldr	r1, [r5, #32]
                    ed -> ux_stm32_ed_nak_counter++;
 80032fc:	3301      	adds	r3, #1
                    channel_register &=  ~UX_HCD_STM32_OTG_FS_HCCHAR_CHDIS;
 80032fe:	f020 4280 	bic.w	r2, r0, #1073741824	; 0x40000000
                    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003302:	4638      	mov	r0, r7
 8003304:	3128      	adds	r1, #40	; 0x28
                    ed -> ux_stm32_ed_nak_counter++;
 8003306:	62eb      	str	r3, [r5, #44]	; 0x2c
                    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003308:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 800330c:	0149      	lsls	r1, r1, #5
 800330e:	f7fe fad7 	bl	80018c0 <_ux_hcd_stm32_register_write>
 8003312:	e787      	b.n	8003224 <_ux_hcd_stm32_asynch_queue_process+0x134>
        channel_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003314:	6a29      	ldr	r1, [r5, #32]
 8003316:	4638      	mov	r0, r7
 8003318:	3128      	adds	r1, #40	; 0x28
 800331a:	0149      	lsls	r1, r1, #5
 800331c:	f7fe fac6 	bl	80018ac <_ux_hcd_stm32_register_read>
        ed -> ux_stm32_ed_channel_status = UX_HCD_STM32_ED_CHANNEL_RESET;
 8003320:	2300      	movs	r3, #0
    if ((channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_STALL) || (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_TXERR)    
 8003322:	f416 6ff1 	tst.w	r6, #1928	; 0x788
        ed -> ux_stm32_ed_channel_status = UX_HCD_STM32_ED_CHANNEL_RESET;
 8003326:	62ab      	str	r3, [r5, #40]	; 0x28
    if ((channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_STALL) || (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_TXERR)    
 8003328:	d081      	beq.n	800322e <_ux_hcd_stm32_asynch_queue_process+0x13e>
 800332a:	e783      	b.n	8003234 <_ux_hcd_stm32_asynch_queue_process+0x144>
            if (ed -> ux_stm32_ed_command_retry++ !=  UX_HCD_STM32_COMMAND_RETRY)
 800332c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
            transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_ERROR;
 800332e:	2023      	movs	r0, #35	; 0x23
            if (ed -> ux_stm32_ed_command_retry++ !=  UX_HCD_STM32_COMMAND_RETRY)
 8003330:	1c51      	adds	r1, r2, #1
 8003332:	2a03      	cmp	r2, #3
            transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_ERROR;
 8003334:	f8c8 0054 	str.w	r0, [r8, #84]	; 0x54
            if (ed -> ux_stm32_ed_command_retry++ !=  UX_HCD_STM32_COMMAND_RETRY)
 8003338:	6269      	str	r1, [r5, #36]	; 0x24
 800333a:	d08a      	beq.n	8003252 <_ux_hcd_stm32_asynch_queue_process+0x162>
                td -> ux_stm32_td_status &=  ~UX_HCD_STM32_TD_ACK_PENDING;
 800333c:	69e2      	ldr	r2, [r4, #28]
                transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_STATUS_PENDING;
 800333e:	f8c8 3054 	str.w	r3, [r8, #84]	; 0x54
                td -> ux_stm32_td_status &=  ~UX_HCD_STM32_TD_ACK_PENDING;
 8003342:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 8003346:	61e2      	str	r2, [r4, #28]
                return;                  
 8003348:	e771      	b.n	800322e <_ux_hcd_stm32_asynch_queue_process+0x13e>
            td -> ux_stm32_td_status &=  ~UX_HCD_STM32_TD_ACK_PENDING;
 800334a:	69e3      	ldr	r3, [r4, #28]
            _ux_hcd_stm32_channel_halt(hcd_stm32, ed);
 800334c:	4629      	mov	r1, r5
 800334e:	4638      	mov	r0, r7
            td -> ux_stm32_td_status &=  ~UX_HCD_STM32_TD_ACK_PENDING;
 8003350:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8003354:	61e3      	str	r3, [r4, #28]
            _ux_hcd_stm32_channel_halt(hcd_stm32, ed);
 8003356:	f000 f887 	bl	8003468 <_ux_hcd_stm32_channel_halt>
    if (channel_interrupt_source & UX_HCD_STM32_OTG_FS_HCINT_CHH)    
 800335a:	07b1      	lsls	r1, r6, #30
 800335c:	f57f af64 	bpl.w	8003228 <_ux_hcd_stm32_asynch_queue_process+0x138>
 8003360:	e7d8      	b.n	8003314 <_ux_hcd_stm32_asynch_queue_process+0x224>
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE));                    
 8003362:	6a29      	ldr	r1, [r5, #32]
            hctsiz_register = _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCTSIZ + 
 8003364:	4638      	mov	r0, r7
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE));                    
 8003366:	0149      	lsls	r1, r1, #5
            hctsiz_register = _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCTSIZ + 
 8003368:	f501 61a2 	add.w	r1, r1, #1296	; 0x510
 800336c:	f7fe fa9e 	bl	80018ac <_ux_hcd_stm32_register_read>
            hctsiz_register &= UX_HCD_STM32_OTG_FS_HCTSIZ_DPID_MASK;
 8003370:	f000 40c0 	and.w	r0, r0, #1610612736	; 0x60000000
            switch (hctsiz_register)
 8003374:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
 8003378:	d041      	beq.n	80033fe <_ux_hcd_stm32_asynch_queue_process+0x30e>
 800337a:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 800337e:	d053      	beq.n	8003428 <_ux_hcd_stm32_asynch_queue_process+0x338>
 8003380:	2800      	cmp	r0, #0
 8003382:	f47f aee6 	bne.w	8003152 <_ux_hcd_stm32_asynch_queue_process+0x62>
                       ed -> ux_stm32_ed_toggle = 0;
 8003386:	61a8      	str	r0, [r5, #24]
                    break;
 8003388:	e6e3      	b.n	8003152 <_ux_hcd_stm32_asynch_queue_process+0x62>
                ed -> ux_stm32_ed_head_td =  td -> ux_stm32_td_next_td;                     
 800338a:	68a3      	ldr	r3, [r4, #8]
 800338c:	606b      	str	r3, [r5, #4]
                td -> ux_stm32_td_status =  UX_UNUSED;
 800338e:	61e1      	str	r1, [r4, #28]
 8003390:	e742      	b.n	8003218 <_ux_hcd_stm32_asynch_queue_process+0x128>
                buffer =  td -> ux_stm32_td_buffer;
 8003392:	f8d4 b000 	ldr.w	fp, [r4]
                td -> ux_stm32_td_buffer += transfer_size;
 8003396:	4459      	add	r1, fp
 8003398:	6021      	str	r1, [r4, #0]
                while (dword_count-- != 0)
 800339a:	f1ba 0f00 	cmp.w	sl, #0
 800339e:	d060      	beq.n	8003462 <_ux_hcd_stm32_asynch_queue_process+0x372>
 80033a0:	eb0b 0a8a 	add.w	sl, fp, sl, lsl #2
                    fifo_value =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_FIFO + 
 80033a4:	6a29      	ldr	r1, [r5, #32]
 80033a6:	4638      	mov	r0, r7
 80033a8:	3101      	adds	r1, #1
 80033aa:	0309      	lsls	r1, r1, #12
 80033ac:	f7fe fa7e 	bl	80018ac <_ux_hcd_stm32_register_read>
                    _ux_utility_long_put(buffer, fifo_value);
 80033b0:	4601      	mov	r1, r0
 80033b2:	4658      	mov	r0, fp
                    buffer += sizeof(ULONG);
 80033b4:	f10b 0b04 	add.w	fp, fp, #4
                    _ux_utility_long_put(buffer, fifo_value);
 80033b8:	f001 f8b6 	bl	8004528 <_ux_utility_long_put>
                while (dword_count-- != 0)
 80033bc:	45d3      	cmp	fp, sl
 80033be:	d1f1      	bne.n	80033a4 <_ux_hcd_stm32_asynch_queue_process+0x2b4>
 80033c0:	9b00      	ldr	r3, [sp, #0]
 80033c2:	6a29      	ldr	r1, [r5, #32]
                if (byte_count != 0)
 80033c4:	bb9b      	cbnz	r3, 800342e <_ux_hcd_stm32_asynch_queue_process+0x33e>
                                   (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE));                    
 80033c6:	0149      	lsls	r1, r1, #5
                hctsiz_register = _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCTSIZ + 
 80033c8:	4638      	mov	r0, r7
 80033ca:	f501 61a2 	add.w	r1, r1, #1296	; 0x510
 80033ce:	f7fe fa6d 	bl	80018ac <_ux_hcd_stm32_register_read>
                if (((hctsiz_register & UX_HCD_STM32_OTG_FS_HCTSIZ_PKTCNT_MASK) >> UX_HCD_STM32_OTG_FS_HCTSIZ_PKTCNT_SHIFT) != 0)
 80033d2:	f3c0 40c9 	ubfx	r0, r0, #19, #10
 80033d6:	2800      	cmp	r0, #0
 80033d8:	f43f aeac 	beq.w	8003134 <_ux_hcd_stm32_asynch_queue_process+0x44>
                    channel_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 80033dc:	6a2b      	ldr	r3, [r5, #32]
 80033de:	4638      	mov	r0, r7
 80033e0:	3328      	adds	r3, #40	; 0x28
 80033e2:	0159      	lsls	r1, r3, #5
 80033e4:	f7fe fa62 	bl	80018ac <_ux_hcd_stm32_register_read>
                    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 80033e8:	6a2b      	ldr	r3, [r5, #32]
                    channel_register &=  ~UX_HCD_STM32_OTG_FS_HCCHAR_CHDIS;
 80033ea:	f020 4280 	bic.w	r2, r0, #1073741824	; 0x40000000
                    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 80033ee:	4638      	mov	r0, r7
 80033f0:	3328      	adds	r3, #40	; 0x28
 80033f2:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80033f6:	0159      	lsls	r1, r3, #5
 80033f8:	f7fe fa62 	bl	80018c0 <_ux_hcd_stm32_register_write>
 80033fc:	e69a      	b.n	8003134 <_ux_hcd_stm32_asynch_queue_process+0x44>
                       ed -> ux_stm32_ed_toggle = 2;
 80033fe:	2302      	movs	r3, #2
 8003400:	61ab      	str	r3, [r5, #24]
                    break;
 8003402:	e6a6      	b.n	8003152 <_ux_hcd_stm32_asynch_queue_process+0x62>
                        while (td != ed -> ux_stm32_ed_tail_td)
 8003404:	6828      	ldr	r0, [r5, #0]
 8003406:	f1bc 0f00 	cmp.w	ip, #0
 800340a:	f47f aed8 	bne.w	80031be <_ux_hcd_stm32_asynch_queue_process+0xce>
                                td -> ux_stm32_td_status =  UX_UNUSED;
 800340e:	4662      	mov	r2, ip
                        while (td != ed -> ux_stm32_ed_tail_td)
 8003410:	4298      	cmp	r0, r3
 8003412:	d007      	beq.n	8003424 <_ux_hcd_stm32_asynch_queue_process+0x334>
                            if ((td -> ux_stm32_td_status & UX_HCD_STM32_TD_DATA_PHASE) || 
 8003414:	69d9      	ldr	r1, [r3, #28]
 8003416:	689c      	ldr	r4, [r3, #8]
 8003418:	0389      	lsls	r1, r1, #14
 800341a:	d501      	bpl.n	8003420 <_ux_hcd_stm32_asynch_queue_process+0x330>
                                ed -> ux_stm32_ed_head_td =  next_td;                     
 800341c:	606c      	str	r4, [r5, #4]
                                td -> ux_stm32_td_status =  UX_UNUSED;
 800341e:	61da      	str	r2, [r3, #28]
 8003420:	4623      	mov	r3, r4
 8003422:	e7f5      	b.n	8003410 <_ux_hcd_stm32_asynch_queue_process+0x320>
                        while (td != ed -> ux_stm32_ed_tail_td)
 8003424:	4604      	mov	r4, r0
 8003426:	e6f7      	b.n	8003218 <_ux_hcd_stm32_asynch_queue_process+0x128>
                       ed -> ux_stm32_ed_toggle = 1;
 8003428:	2301      	movs	r3, #1
 800342a:	61ab      	str	r3, [r5, #24]
                    break;
 800342c:	e691      	b.n	8003152 <_ux_hcd_stm32_asynch_queue_process+0x62>
                    fifo_value =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_FIFO + 
 800342e:	3101      	adds	r1, #1
 8003430:	4638      	mov	r0, r7
 8003432:	0309      	lsls	r1, r1, #12
 8003434:	f7fe fa3a 	bl	80018ac <_ux_hcd_stm32_register_read>
                    if (byte_count >= sizeof(USHORT))
 8003438:	9a00      	ldr	r2, [sp, #0]
                    fifo_value =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_FIFO + 
 800343a:	4603      	mov	r3, r0
                    if (byte_count >= sizeof(USHORT))
 800343c:	2a01      	cmp	r2, #1
 800343e:	d103      	bne.n	8003448 <_ux_hcd_stm32_asynch_queue_process+0x358>
                        *buffer = (UCHAR) fifo_value;
 8003440:	f88a 3000 	strb.w	r3, [sl]
 8003444:	6a29      	ldr	r1, [r5, #32]
 8003446:	e7be      	b.n	80033c6 <_ux_hcd_stm32_asynch_queue_process+0x2d6>
                        _ux_utility_short_put(buffer, fifo_value);
 8003448:	b281      	uxth	r1, r0
 800344a:	9001      	str	r0, [sp, #4]
 800344c:	4650      	mov	r0, sl
 800344e:	f001 f889 	bl	8004564 <_ux_utility_short_put>
                    if (byte_count != 0)
 8003452:	9a00      	ldr	r2, [sp, #0]
 8003454:	9b01      	ldr	r3, [sp, #4]
 8003456:	2a02      	cmp	r2, #2
 8003458:	d0f4      	beq.n	8003444 <_ux_hcd_stm32_asynch_queue_process+0x354>
                        fifo_value = fifo_value >> (sizeof(USHORT) * 8);
 800345a:	0c1b      	lsrs	r3, r3, #16
                        buffer += sizeof(USHORT);
 800345c:	f10a 0a02 	add.w	sl, sl, #2
 8003460:	e7ee      	b.n	8003440 <_ux_hcd_stm32_asynch_queue_process+0x350>
                buffer =  td -> ux_stm32_td_buffer;
 8003462:	46da      	mov	sl, fp
 8003464:	4603      	mov	r3, r0
 8003466:	e7ac      	b.n	80033c2 <_ux_hcd_stm32_asynch_queue_process+0x2d2>

08003468 <_ux_hcd_stm32_channel_halt>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_hcd_stm32_channel_halt(UX_HCD_STM32 *hcd_stm32, UX_HCD_STM32_ED *ed)
{
 8003468:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800346a:	460c      	mov	r4, r1
        
    /* Get the endpoint container.  */
    endpoint =  ed -> ux_stm32_ed_endpoint;
    
    /* Read the channel register. */
    channel_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 800346c:	6a09      	ldr	r1, [r1, #32]
{
 800346e:	4606      	mov	r6, r0
    channel_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003470:	3128      	adds	r1, #40	; 0x28
    endpoint =  ed -> ux_stm32_ed_endpoint;
 8003472:	6967      	ldr	r7, [r4, #20]
    channel_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003474:	0149      	lsls	r1, r1, #5
 8003476:	f7fe fa19 	bl	80018ac <_ux_hcd_stm32_register_read>
    /* Set Channel enabled bit to restart the transfer.  */
    channel_register |=  UX_HCD_STM32_OTG_FS_HCCHAR_CHENA;
                
    /* Check for space in the request queue to issue the halt. */
    /* Check the type of endpoint. Interrupt and Bulk/Control are treated differently.  */
    switch (endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE)
 800347a:	69bb      	ldr	r3, [r7, #24]
    channel_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 800347c:	4605      	mov	r5, r0
    channel_register |=  UX_HCD_STM32_OTG_FS_HCCHAR_CHENA;
 800347e:	f040 4740 	orr.w	r7, r0, #3221225472	; 0xc0000000
    switch (endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE)
 8003482:	f003 0303 	and.w	r3, r3, #3
 8003486:	2b02      	cmp	r3, #2
 8003488:	d00c      	beq.n	80034a4 <_ux_hcd_stm32_channel_halt+0x3c>
 800348a:	2b03      	cmp	r3, #3
 800348c:	d016      	beq.n	80034bc <_ux_hcd_stm32_channel_halt+0x54>
 800348e:	b14b      	cbz	r3, 80034a4 <_ux_hcd_stm32_channel_halt+0x3c>

    
    }

    /* Save the channel register.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003490:	6a21      	ldr	r1, [r4, #32]
 8003492:	463a      	mov	r2, r7
 8003494:	4630      	mov	r0, r6
 8003496:	3128      	adds	r1, #40	; 0x28
 8003498:	0149      	lsls	r1, r1, #5
 800349a:	f7fe fa11 	bl	80018c0 <_ux_hcd_stm32_register_write>
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), channel_register);                    
    
    /* Set the channel to halted.  */
    ed -> ux_stm32_ed_channel_status = UX_HCD_STM32_ED_CHANNEL_HALTED;
 800349e:	2301      	movs	r3, #1
 80034a0:	62a3      	str	r3, [r4, #40]	; 0x28
    
    /* Return to caller.  */
    return;
}
 80034a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            gnptxsts_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GNPTXSTS);
 80034a4:	212c      	movs	r1, #44	; 0x2c
 80034a6:	4630      	mov	r0, r6
 80034a8:	f7fe fa00 	bl	80018ac <_ux_hcd_stm32_register_read>
            if ((gnptxsts_register & UX_HCD_STM32_OTG_FS_GNPTXSTS_NPTQFSAV_MASK) == 0)
 80034ac:	f410 0f7f 	tst.w	r0, #16711680	; 0xff0000
 80034b0:	d1ee      	bne.n	8003490 <_ux_hcd_stm32_channel_halt+0x28>
 80034b2:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
                channel_register &=  ~UX_HCD_STM32_OTG_FS_HCCHAR_CHENA;
 80034b6:	f045 4780 	orr.w	r7, r5, #1073741824	; 0x40000000
 80034ba:	e7e9      	b.n	8003490 <_ux_hcd_stm32_channel_halt+0x28>
            hptxsts_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HPTXSTS);
 80034bc:	f44f 6182 	mov.w	r1, #1040	; 0x410
 80034c0:	4630      	mov	r0, r6
 80034c2:	f7fe f9f3 	bl	80018ac <_ux_hcd_stm32_register_read>
            if ((hptxsts_register & UX_HCD_STM32_OTG_FS_HPTXSTS_PTQFSAV_MASK) == 0)
 80034c6:	f410 0f7f 	tst.w	r0, #16711680	; 0xff0000
 80034ca:	d1e1      	bne.n	8003490 <_ux_hcd_stm32_channel_halt+0x28>
 80034cc:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
                channel_register &=  ~UX_HCD_STM32_OTG_FS_HCCHAR_CHENA;
 80034d0:	f045 4780 	orr.w	r7, r5, #1073741824	; 0x40000000
 80034d4:	e7dc      	b.n	8003490 <_ux_hcd_stm32_channel_halt+0x28>
 80034d6:	bf00      	nop

080034d8 <_ux_hcd_stm32_delay>:
volatile ULONG     ucount = 0;
ULONG              ucount_local;
ULONG              utime_local;

    /* Calculate the time to wait in cycles.  */
    utime = UX_HCD_STM32_CONTROLLER_DELAY * usec;
 80034d8:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
{
 80034dc:	b082      	sub	sp, #8
volatile ULONG     ucount = 0;
 80034de:	2300      	movs	r3, #0
    utime = UX_HCD_STM32_CONTROLLER_DELAY * usec;
 80034e0:	00c0      	lsls	r0, r0, #3
volatile ULONG     ucount = 0;
 80034e2:	9301      	str	r3, [sp, #4]
    utime = UX_HCD_STM32_CONTROLLER_DELAY * usec;
 80034e4:	9000      	str	r0, [sp, #0]
    do
    {
        /* Check the count.  Place volatile variables in non-volatile to 
           avoid compiler confusion regarding the order of volatile 
           comparisons.  */
        ucount_local =  ++ucount;
 80034e6:	9b01      	ldr	r3, [sp, #4]
 80034e8:	3301      	adds	r3, #1
 80034ea:	9301      	str	r3, [sp, #4]
        utime_local =  utime;
 80034ec:	9a00      	ldr	r2, [sp, #0]
        if (ucount_local > utime_local)
 80034ee:	4293      	cmp	r3, r2
 80034f0:	d9f9      	bls.n	80034e6 <_ux_hcd_stm32_delay+0xe>
            
            /* Done.  */
            return;

    } while(1);
}
 80034f2:	b002      	add	sp, #8
 80034f4:	4770      	bx	lr
 80034f6:	bf00      	nop

080034f8 <_ux_hcd_stm32_ed_obtain>:
ULONG                 ed_index;


    /* Start the search from the beginning of the list.  */
    ed =  hcd_stm32 -> ux_hcd_stm32_ed_list;
    for (ed_index = 0; ed_index < _ux_system_host -> ux_system_host_max_ed; ed_index++)
 80034f8:	4b10      	ldr	r3, [pc, #64]	; (800353c <_ux_hcd_stm32_ed_obtain+0x44>)
 80034fa:	681b      	ldr	r3, [r3, #0]
 80034fc:	6a19      	ldr	r1, [r3, #32]
{
 80034fe:	b510      	push	{r4, lr}
    ed =  hcd_stm32 -> ux_hcd_stm32_ed_list;
 8003500:	6844      	ldr	r4, [r0, #4]
    for (ed_index = 0; ed_index < _ux_system_host -> ux_system_host_max_ed; ed_index++)
 8003502:	b1c1      	cbz	r1, 8003536 <_ux_hcd_stm32_ed_obtain+0x3e>
    {

        /* Check the ED status, a free ED is marked with the UNUSED flag.  */
        if (ed -> ux_stm32_ed_status == UX_UNUSED)
 8003504:	6923      	ldr	r3, [r4, #16]
 8003506:	b153      	cbz	r3, 800351e <_ux_hcd_stm32_ed_obtain+0x26>
    for (ed_index = 0; ed_index < _ux_system_host -> ux_system_host_max_ed; ed_index++)
 8003508:	2300      	movs	r3, #0
 800350a:	e001      	b.n	8003510 <_ux_hcd_stm32_ed_obtain+0x18>
        if (ed -> ux_stm32_ed_status == UX_UNUSED)
 800350c:	6922      	ldr	r2, [r4, #16]
 800350e:	b132      	cbz	r2, 800351e <_ux_hcd_stm32_ed_obtain+0x26>
    for (ed_index = 0; ed_index < _ux_system_host -> ux_system_host_max_ed; ed_index++)
 8003510:	3301      	adds	r3, #1
            /* Return ED pointer.  */
            return(ed);
        }

        /* Point to the next ED.  */
        ed++;
 8003512:	3430      	adds	r4, #48	; 0x30
    for (ed_index = 0; ed_index < _ux_system_host -> ux_system_host_max_ed; ed_index++)
 8003514:	428b      	cmp	r3, r1
 8003516:	d1f9      	bne.n	800350c <_ux_hcd_stm32_ed_obtain+0x14>
    }

    /* There is no available ED in the ED list.  */
    return(UX_NULL);
 8003518:	2400      	movs	r4, #0
}
 800351a:	4620      	mov	r0, r4
 800351c:	bd10      	pop	{r4, pc}
            _ux_utility_memory_set(ed, 0, sizeof(UX_HCD_STM32_ED));
 800351e:	4620      	mov	r0, r4
 8003520:	2230      	movs	r2, #48	; 0x30
 8003522:	2100      	movs	r1, #0
 8003524:	f7fe fd82 	bl	800202c <_ux_utility_memory_set>
            ed -> ux_stm32_ed_status =  UX_USED;
 8003528:	2201      	movs	r2, #1
            ed -> ux_stm32_ed_channel =  UX_HCD_STM32_NO_CHANNEL_ASSIGNED;
 800352a:	f04f 33ff 	mov.w	r3, #4294967295
}
 800352e:	4620      	mov	r0, r4
            ed -> ux_stm32_ed_status =  UX_USED;
 8003530:	6122      	str	r2, [r4, #16]
            ed -> ux_stm32_ed_channel =  UX_HCD_STM32_NO_CHANNEL_ASSIGNED;
 8003532:	6223      	str	r3, [r4, #32]
}
 8003534:	bd10      	pop	{r4, pc}
    return(UX_NULL);
 8003536:	460c      	mov	r4, r1
 8003538:	e7ef      	b.n	800351a <_ux_hcd_stm32_ed_obtain+0x22>
 800353a:	bf00      	nop
 800353c:	20000db8 	.word	0x20000db8

08003540 <_ux_hcd_stm32_entry>:
UX_HCD_STM32          *hcd_stm32;
UX_INT_SAVE_AREA
    

    /* Check the status of the controller.  */
    if (hcd -> ux_hcd_status == UX_UNUSED)
 8003540:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
 8003542:	b510      	push	{r4, lr}
    if (hcd -> ux_hcd_status == UX_UNUSED)
 8003544:	b183      	cbz	r3, 8003568 <_ux_hcd_stm32_entry+0x28>
            
    /* Get the pointer to the STM32 HCD.  */
    hcd_stm32 =  (UX_HCD_STM32 *) hcd -> ux_hcd_controller_hardware;

    /* look at the function and route it.  */
    switch(function)
 8003546:	1e4b      	subs	r3, r1, #1
    hcd_stm32 =  (UX_HCD_STM32 *) hcd -> ux_hcd_controller_hardware;
 8003548:	f8d0 40c8 	ldr.w	r4, [r0, #200]	; 0xc8
    switch(function)
 800354c:	2b10      	cmp	r3, #16
 800354e:	f200 8095 	bhi.w	800367c <_ux_hcd_stm32_entry+0x13c>
 8003552:	e8df f003 	tbb	[pc, r3]
 8003556:	888e      	.short	0x888e
 8003558:	70767c82 	.word	0x70767c82
 800355c:	585e646a 	.word	0x585e646a
 8003560:	39464c52 	.word	0x39464c52
 8003564:	262c      	.short	0x262c
 8003566:	10          	.byte	0x10
 8003567:	00          	.byte	0x00
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HCD, UX_CONTROLLER_UNKNOWN);
 8003568:	2255      	movs	r2, #85	; 0x55
 800356a:	2101      	movs	r1, #1
 800356c:	2002      	movs	r0, #2
 800356e:	f7fe fb47 	bl	8001c00 <_ux_system_error_handler>
        return(UX_CONTROLLER_UNKNOWN);
 8003572:	2055      	movs	r0, #85	; 0x55
        
    }        
    
    /* Return completion status.  */
    return(status);
}
 8003574:	bd10      	pop	{r4, pc}
        _ux_hcd_stm32_iso_schedule(hcd_stm32);
 8003576:	4620      	mov	r0, r4
 8003578:	f000 f9ce 	bl	8003918 <_ux_hcd_stm32_iso_schedule>
        _ux_hcd_stm32_periodic_schedule(hcd_stm32);
 800357c:	4620      	mov	r0, r4
 800357e:	f000 fa5b 	bl	8003a38 <_ux_hcd_stm32_periodic_schedule>
        _ux_hcd_stm32_asynch_schedule(hcd_stm32);
 8003582:	4620      	mov	r0, r4
 8003584:	f001 fa28 	bl	80049d8 <_ux_hcd_stm32_asynch_schedule>
        UX_DISABLE_INTS
 8003588:	2001      	movs	r0, #1
 800358a:	f7fc fea9 	bl	80002e0 <_tx_thread_interrupt_control>
        hcd_stm32 -> ux_hcd_stm32_controller_flag &= ~UX_HCD_STM32_CONTROLLER_FLAG_SOF;
 800358e:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
 8003592:	f023 0304 	bic.w	r3, r3, #4
 8003596:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
        UX_RESTORE_INTS
 800359a:	f7fc fea1 	bl	80002e0 <_tx_thread_interrupt_control>
        status =  UX_SUCCESS;
 800359e:	2000      	movs	r0, #0
}
 80035a0:	bd10      	pop	{r4, pc}
        status =  _ux_hcd_stm32_endpoint_reset(hcd_stm32, (UX_ENDPOINT*) parameter);
 80035a2:	4620      	mov	r0, r4
 80035a4:	4611      	mov	r1, r2
}
 80035a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_endpoint_reset(hcd_stm32, (UX_ENDPOINT*) parameter);
 80035aa:	f001 bb6d 	b.w	8004c88 <_ux_hcd_stm32_endpoint_reset>
        switch ((((UX_ENDPOINT*) parameter) -> ux_endpoint_descriptor.bmAttributes) & UX_MASK_ENDPOINT_TYPE)
 80035ae:	6993      	ldr	r3, [r2, #24]
            status =  _ux_hcd_stm32_periodic_endpoint_destroy(hcd_stm32, (UX_ENDPOINT*) parameter);
 80035b0:	4611      	mov	r1, r2
 80035b2:	4620      	mov	r0, r4
        switch ((((UX_ENDPOINT*) parameter) -> ux_endpoint_descriptor.bmAttributes) & UX_MASK_ENDPOINT_TYPE)
 80035b4:	f003 0303 	and.w	r3, r3, #3
 80035b8:	2b01      	cmp	r3, #1
 80035ba:	d066      	beq.n	800368a <_ux_hcd_stm32_entry+0x14a>
 80035bc:	2b03      	cmp	r3, #3
 80035be:	d064      	beq.n	800368a <_ux_hcd_stm32_entry+0x14a>
}
 80035c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            status =  _ux_hcd_stm32_asynchronous_endpoint_destroy(hcd_stm32, (UX_ENDPOINT*) parameter);
 80035c4:	f001 bb2c 	b.w	8004c20 <_ux_hcd_stm32_asynchronous_endpoint_destroy>
        switch ((((UX_ENDPOINT*) parameter) -> ux_endpoint_descriptor.bmAttributes) & UX_MASK_ENDPOINT_TYPE)
 80035c8:	6993      	ldr	r3, [r2, #24]
            status =  _ux_hcd_stm32_isochronous_endpoint_create(hcd_stm32, (UX_ENDPOINT*) parameter);
 80035ca:	4611      	mov	r1, r2
 80035cc:	4620      	mov	r0, r4
        switch ((((UX_ENDPOINT*) parameter) -> ux_endpoint_descriptor.bmAttributes) & UX_MASK_ENDPOINT_TYPE)
 80035ce:	f003 0303 	and.w	r3, r3, #3
 80035d2:	2b01      	cmp	r3, #1
 80035d4:	d061      	beq.n	800369a <_ux_hcd_stm32_entry+0x15a>
 80035d6:	2b03      	cmp	r3, #3
 80035d8:	d15b      	bne.n	8003692 <_ux_hcd_stm32_entry+0x152>
}
 80035da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            status =  _ux_hcd_stm32_interrupt_endpoint_create(hcd_stm32, (UX_ENDPOINT*) parameter);
 80035de:	f000 b883 	b.w	80036e8 <_ux_hcd_stm32_interrupt_endpoint_create>
        status =  _ux_hcd_stm32_transfer_abort(hcd_stm32, (UX_TRANSFER *) parameter);
 80035e2:	4620      	mov	r0, r4
 80035e4:	4611      	mov	r1, r2
}
 80035e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_transfer_abort(hcd_stm32, (UX_TRANSFER *) parameter);
 80035ea:	f000 bbad 	b.w	8003d48 <_ux_hcd_stm32_transfer_abort>
        status =  _ux_hcd_stm32_request_transfer(hcd_stm32, (UX_TRANSFER *) parameter);
 80035ee:	4620      	mov	r0, r4
 80035f0:	4611      	mov	r1, r2
}
 80035f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_request_transfer(hcd_stm32, (UX_TRANSFER *) parameter);
 80035f6:	f000 baf7 	b.w	8003be8 <_ux_hcd_stm32_request_transfer>
        _ux_hcd_stm32_frame_number_set(hcd_stm32, (ULONG) parameter);
 80035fa:	4620      	mov	r0, r4
 80035fc:	4611      	mov	r1, r2
 80035fe:	f000 f871 	bl	80036e4 <_ux_hcd_stm32_frame_number_set>
        status =  UX_SUCCESS;
 8003602:	2000      	movs	r0, #0
}
 8003604:	bd10      	pop	{r4, pc}
        status =  _ux_hcd_stm32_frame_number_get(hcd_stm32, (ULONG *) parameter);
 8003606:	4620      	mov	r0, r4
 8003608:	4611      	mov	r1, r2
}
 800360a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_frame_number_get(hcd_stm32, (ULONG *) parameter);
 800360e:	f000 b849 	b.w	80036a4 <_ux_hcd_stm32_frame_number_get>
        status =  _ux_hcd_stm32_port_reset(hcd_stm32, (ULONG) parameter);
 8003612:	4620      	mov	r0, r4
 8003614:	4611      	mov	r1, r2
}
 8003616:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_port_reset(hcd_stm32, (ULONG) parameter);
 800361a:	f000 ba35 	b.w	8003a88 <_ux_hcd_stm32_port_reset>
        status =  _ux_hcd_stm32_port_resume(hcd_stm32, (UINT) parameter);
 800361e:	4620      	mov	r0, r4
 8003620:	4611      	mov	r1, r2
}
 8003622:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_port_resume(hcd_stm32, (UINT) parameter);
 8003626:	f000 ba91 	b.w	8003b4c <_ux_hcd_stm32_port_resume>
        status =  _ux_hcd_stm32_port_suspend(hcd_stm32, (ULONG) parameter);
 800362a:	4620      	mov	r0, r4
 800362c:	4611      	mov	r1, r2
}
 800362e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_port_suspend(hcd_stm32, (ULONG) parameter);
 8003632:	f000 baa7 	b.w	8003b84 <_ux_hcd_stm32_port_suspend>
        status =  _ux_hcd_stm32_power_down_port(hcd_stm32, (ULONG) parameter);
 8003636:	4620      	mov	r0, r4
 8003638:	4611      	mov	r1, r2
}
 800363a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_power_down_port(hcd_stm32, (ULONG) parameter);
 800363e:	f000 baa3 	b.w	8003b88 <_ux_hcd_stm32_power_down_port>
        status =  _ux_hcd_stm32_power_on_port(hcd_stm32, (ULONG) parameter);
 8003642:	4620      	mov	r0, r4
 8003644:	4611      	mov	r1, r2
}
 8003646:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_power_on_port(hcd_stm32, (ULONG) parameter);
 800364a:	f7fe b915 	b.w	8001878 <_ux_hcd_stm32_power_on_port>
        status =  _ux_hcd_stm32_port_disable(hcd_stm32, (ULONG) parameter);
 800364e:	4620      	mov	r0, r4
 8003650:	4611      	mov	r1, r2
}
 8003652:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_port_disable(hcd_stm32, (ULONG) parameter);
 8003656:	f000 ba13 	b.w	8003a80 <_ux_hcd_stm32_port_disable>
        status =  _ux_hcd_stm32_port_enable(hcd_stm32, (ULONG) parameter);
 800365a:	4620      	mov	r0, r4
 800365c:	4611      	mov	r1, r2
}
 800365e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_port_enable(hcd_stm32, (ULONG) parameter);
 8003662:	f000 ba0f 	b.w	8003a84 <_ux_hcd_stm32_port_enable>
        status =  _ux_hcd_stm32_port_status_get(hcd_stm32, (ULONG) parameter);
 8003666:	4620      	mov	r0, r4
 8003668:	4611      	mov	r1, r2
}
 800366a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_port_status_get(hcd_stm32, (ULONG) parameter);
 800366e:	f000 ba6f 	b.w	8003b50 <_ux_hcd_stm32_port_status_get>
        status =  _ux_hcd_stm32_controller_disable(hcd_stm32);
 8003672:	4620      	mov	r0, r4
}
 8003674:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        status =  _ux_hcd_stm32_controller_disable(hcd_stm32);
 8003678:	f001 bb02 	b.w	8004c80 <_ux_hcd_stm32_controller_disable>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HCD, UX_FUNCTION_NOT_SUPPORTED);
 800367c:	2254      	movs	r2, #84	; 0x54
 800367e:	2101      	movs	r1, #1
 8003680:	2002      	movs	r0, #2
 8003682:	f7fe fabd 	bl	8001c00 <_ux_system_error_handler>
        status =  UX_FUNCTION_NOT_SUPPORTED;
 8003686:	2054      	movs	r0, #84	; 0x54
}
 8003688:	bd10      	pop	{r4, pc}
 800368a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            status =  _ux_hcd_stm32_periodic_endpoint_destroy(hcd_stm32, (UX_ENDPOINT*) parameter);
 800368e:	f000 b9a3 	b.w	80039d8 <_ux_hcd_stm32_periodic_endpoint_destroy>
}
 8003692:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            status =  _ux_hcd_stm32_asynchronous_endpoint_create(hcd_stm32, (UX_ENDPOINT*) parameter);
 8003696:	f001 b9d1 	b.w	8004a3c <_ux_hcd_stm32_asynchronous_endpoint_create>
}
 800369a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            status =  _ux_hcd_stm32_isochronous_endpoint_create(hcd_stm32, (UX_ENDPOINT*) parameter);
 800369e:	f000 b93d 	b.w	800391c <_ux_hcd_stm32_isochronous_endpoint_create>
 80036a2:	bf00      	nop

080036a4 <_ux_hcd_stm32_frame_number_get>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_frame_number_get(UX_HCD_STM32 *hcd_stm32, ULONG *frame_number)
{
 80036a4:	b538      	push	{r3, r4, r5, lr}
 80036a6:	460d      	mov	r5, r1
    
ULONG    port_status;

    /* Check the port status. If the port is not enabled, the SOF value is meaningless.  */
    port_status =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT);
 80036a8:	f44f 6188 	mov.w	r1, #1088	; 0x440
{
 80036ac:	4604      	mov	r4, r0
    port_status =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT);
 80036ae:	f7fe f8fd 	bl	80018ac <_ux_hcd_stm32_register_read>

    /* Check Port status enabled bit.  */
    if (port_status & UX_HCD_STM32_OTG_FS_HPRT_PENA)    
 80036b2:	0743      	lsls	r3, r0, #29
 80036b4:	d40a      	bmi.n	80036cc <_ux_hcd_stm32_frame_number_get+0x28>
    else
    {

        /* We come here when the port is not enabled and the frame # is not incrementing every ms.
           So we wait for 1ms with the delay function.  */
        _ux_utility_delay_ms(1);
 80036b6:	2001      	movs	r0, #1
 80036b8:	f7fe fb0c 	bl	8001cd4 <_ux_utility_delay_ms>
           
        /* Save the frame # in the controller structure.  */
        hcd_stm32 -> ux_hcd_stm32_frame_number++;
 80036bc:	f8d4 30fc 	ldr.w	r3, [r4, #252]	; 0xfc
        *frame_number =  hcd_stm32 -> ux_hcd_stm32_frame_number;

    }
    
    return(UX_SUCCESS);
}
 80036c0:	2000      	movs	r0, #0
        hcd_stm32 -> ux_hcd_stm32_frame_number++;
 80036c2:	3301      	adds	r3, #1
 80036c4:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
        *frame_number =  hcd_stm32 -> ux_hcd_stm32_frame_number;
 80036c8:	602b      	str	r3, [r5, #0]
}
 80036ca:	bd38      	pop	{r3, r4, r5, pc}
        hcd_stm32 -> ux_hcd_stm32_frame_number = _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HFNUM) & UX_HCD_STM32_OTG_FS_HFNUM_FRNUM_MASK; 
 80036cc:	f44f 6181 	mov.w	r1, #1032	; 0x408
 80036d0:	4620      	mov	r0, r4
 80036d2:	f7fe f8eb 	bl	80018ac <_ux_hcd_stm32_register_read>
 80036d6:	b280      	uxth	r0, r0
 80036d8:	f8c4 00fc 	str.w	r0, [r4, #252]	; 0xfc
        *frame_number =  hcd_stm32 -> ux_hcd_stm32_frame_number;
 80036dc:	6028      	str	r0, [r5, #0]
}
 80036de:	2000      	movs	r0, #0
 80036e0:	bd38      	pop	{r3, r4, r5, pc}
 80036e2:	bf00      	nop

080036e4 <_ux_hcd_stm32_frame_number_set>:
VOID  _ux_hcd_stm32_frame_number_set(UX_HCD_STM32 *hcd_stm32, ULONG frame_number)
{

    /* Return to caller.  */
    return;
}
 80036e4:	4770      	bx	lr
 80036e6:	bf00      	nop

080036e8 <_ux_hcd_stm32_interrupt_endpoint_create>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_interrupt_endpoint_create(UX_HCD_STM32 *hcd_stm32, UX_ENDPOINT *endpoint)
{
 80036e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80036ec:	4688      	mov	r8, r1
 80036ee:	4605      	mov	r5, r0
UINT                interval_stm32;
ULONG                channel_index;
ULONG                stm32_channel_register;

    /* Get the pointer to the device.  */
    device =  endpoint -> ux_endpoint_device;
 80036f0:	6acf      	ldr	r7, [r1, #44]	; 0x2c

    /* Obtain a ED for this new endpoint. This ED will live as long as
       the endpoint is active and will be the container for the tds.  */
    ed =  _ux_hcd_stm32_ed_obtain(hcd_stm32);
 80036f2:	f7ff ff01 	bl	80034f8 <_ux_hcd_stm32_ed_obtain>
    if (ed == UX_NULL)
 80036f6:	2800      	cmp	r0, #0
 80036f8:	d05e      	beq.n	80037b8 <_ux_hcd_stm32_interrupt_endpoint_create+0xd0>
 80036fa:	4606      	mov	r6, r0
        return(UX_NO_ED_AVAILABLE);

    /* Obtain a dummy TD for terminating the ED transfer chain.  */
    td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 80036fc:	4628      	mov	r0, r5
 80036fe:	f000 fa45 	bl	8003b8c <_ux_hcd_stm32_regular_td_obtain>
    if (td == UX_NULL)
 8003702:	4602      	mov	r2, r0
 8003704:	2800      	cmp	r0, #0
 8003706:	f000 80c4 	beq.w	8003892 <_ux_hcd_stm32_interrupt_endpoint_create+0x1aa>
        ed -> ux_stm32_ed_status =  UX_UNUSED;
        return(UX_NO_TD_AVAILABLE);
    }

    /* And get a channel. */
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 800370a:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 800370e:	2b00      	cmp	r3, #0
 8003710:	d04f      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
    {

        /* Check if that Channel is free.  */
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8003712:	f8d5 10a0 	ldr.w	r1, [r5, #160]	; 0xa0
 8003716:	2900      	cmp	r1, #0
 8003718:	f000 80c4 	beq.w	80038a4 <_ux_hcd_stm32_interrupt_endpoint_create+0x1bc>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 800371c:	2b01      	cmp	r3, #1
 800371e:	d948      	bls.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8003720:	f8d5 10a4 	ldr.w	r1, [r5, #164]	; 0xa4
 8003724:	2900      	cmp	r1, #0
 8003726:	d04a      	beq.n	80037be <_ux_hcd_stm32_interrupt_endpoint_create+0xd6>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8003728:	2b02      	cmp	r3, #2
 800372a:	d042      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 800372c:	f8d5 10a8 	ldr.w	r1, [r5, #168]	; 0xa8
 8003730:	2900      	cmp	r1, #0
 8003732:	f000 80bb 	beq.w	80038ac <_ux_hcd_stm32_interrupt_endpoint_create+0x1c4>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8003736:	2b03      	cmp	r3, #3
 8003738:	d03b      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 800373a:	f8d5 10ac 	ldr.w	r1, [r5, #172]	; 0xac
 800373e:	2900      	cmp	r1, #0
 8003740:	f000 80b9 	beq.w	80038b6 <_ux_hcd_stm32_interrupt_endpoint_create+0x1ce>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8003744:	2b04      	cmp	r3, #4
 8003746:	d034      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8003748:	f8d5 10b0 	ldr.w	r1, [r5, #176]	; 0xb0
 800374c:	2900      	cmp	r1, #0
 800374e:	f000 80b9 	beq.w	80038c4 <_ux_hcd_stm32_interrupt_endpoint_create+0x1dc>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8003752:	2b05      	cmp	r3, #5
 8003754:	d02d      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8003756:	f8d5 10b4 	ldr.w	r1, [r5, #180]	; 0xb4
 800375a:	2900      	cmp	r1, #0
 800375c:	f000 80b9 	beq.w	80038d2 <_ux_hcd_stm32_interrupt_endpoint_create+0x1ea>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8003760:	2b06      	cmp	r3, #6
 8003762:	d026      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8003764:	f8d5 10b8 	ldr.w	r1, [r5, #184]	; 0xb8
 8003768:	2900      	cmp	r1, #0
 800376a:	f000 80b9 	beq.w	80038e0 <_ux_hcd_stm32_interrupt_endpoint_create+0x1f8>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 800376e:	2b07      	cmp	r3, #7
 8003770:	d01f      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8003772:	f8d5 10bc 	ldr.w	r1, [r5, #188]	; 0xbc
 8003776:	2900      	cmp	r1, #0
 8003778:	f000 80b7 	beq.w	80038ea <_ux_hcd_stm32_interrupt_endpoint_create+0x202>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 800377c:	2b08      	cmp	r3, #8
 800377e:	d018      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8003780:	f8d5 10c0 	ldr.w	r1, [r5, #192]	; 0xc0
 8003784:	2900      	cmp	r1, #0
 8003786:	f000 80b5 	beq.w	80038f4 <_ux_hcd_stm32_interrupt_endpoint_create+0x20c>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 800378a:	2b09      	cmp	r3, #9
 800378c:	d011      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 800378e:	f8d5 10c4 	ldr.w	r1, [r5, #196]	; 0xc4
 8003792:	2900      	cmp	r1, #0
 8003794:	f000 80b3 	beq.w	80038fe <_ux_hcd_stm32_interrupt_endpoint_create+0x216>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8003798:	2b0a      	cmp	r3, #10
 800379a:	d00a      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 800379c:	f8d5 10c8 	ldr.w	r1, [r5, #200]	; 0xc8
 80037a0:	2900      	cmp	r1, #0
 80037a2:	f000 80b1 	beq.w	8003908 <_ux_hcd_stm32_interrupt_endpoint_create+0x220>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 80037a6:	2b0b      	cmp	r3, #11
 80037a8:	d003      	beq.n	80037b2 <_ux_hcd_stm32_interrupt_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 80037aa:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
 80037ae:	2b00      	cmp	r3, #0
 80037b0:	d073      	beq.n	800389a <_ux_hcd_stm32_interrupt_endpoint_create+0x1b2>
 80037b2:	6a33      	ldr	r3, [r6, #32]
            break;
        }
    }

    /* Check for channel assignment.  */
    if (ed -> ux_stm32_ed_channel ==  UX_HCD_STM32_NO_CHANNEL_ASSIGNED)
 80037b4:	3301      	adds	r3, #1
 80037b6:	d106      	bne.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
        return(UX_NO_ED_AVAILABLE);
 80037b8:	2014      	movs	r0, #20
    /* There is activity in the periodic tree, the scheduler has to be active all the time.  */
    hcd_stm32 -> ux_hcd_stm32_periodic_scheduler_active++;

    /* Return successful completion.  */
    return(UX_SUCCESS);         
}
 80037ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            ed -> ux_stm32_ed_channel = channel_index;
 80037be:	2301      	movs	r3, #1
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 80037c0:	f8c5 60a4 	str.w	r6, [r5, #164]	; 0xa4
            ed -> ux_stm32_ed_channel = channel_index;
 80037c4:	6233      	str	r3, [r6, #32]
    endpoint -> ux_endpoint_ed =  (VOID *)ed;
 80037c6:	f8c8 6008 	str.w	r6, [r8, #8]
    ed_list =  _ux_hcd_stm32_least_traffic_list_get(hcd_stm32);
 80037ca:	4628      	mov	r0, r5
    ed -> ux_stm32_ed_endpoint =  endpoint;
 80037cc:	f8c6 8014 	str.w	r8, [r6, #20]
    ed -> ux_stm32_ed_head_td =  td;
 80037d0:	e9c6 2200 	strd	r2, r2, [r6]
    ed_list =  _ux_hcd_stm32_least_traffic_list_get(hcd_stm32);
 80037d4:	f000 f8de 	bl	8003994 <_ux_hcd_stm32_least_traffic_list_get>
    interval =          endpoint -> ux_endpoint_descriptor.bInterval;
 80037d8:	f8d8 2020 	ldr.w	r2, [r8, #32]
 80037dc:	6883      	ldr	r3, [r0, #8]
    if (interval == 0)
 80037de:	2a00      	cmp	r2, #0
 80037e0:	d03c      	beq.n	800385c <_ux_hcd_stm32_interrupt_endpoint_create+0x174>
    if (interval >= 32)
 80037e2:	2a1f      	cmp	r2, #31
 80037e4:	d94f      	bls.n	8003886 <_ux_hcd_stm32_interrupt_endpoint_create+0x19e>
    if (next_ed != UX_NULL)
 80037e6:	b103      	cbz	r3, 80037ea <_ux_hcd_stm32_interrupt_endpoint_create+0x102>
        next_ed -> ux_stm32_ed_previous_ed =  ed;
 80037e8:	60de      	str	r6, [r3, #12]
    stm32_channel_register |=  (endpoint -> ux_endpoint_descriptor.bEndpointAddress & ~UX_ENDPOINT_DIRECTION) << UX_HCD_STM32_OTG_FS_HCCHAR_EPNUM_SHIFT;
 80037ea:	f8d8 1014 	ldr.w	r1, [r8, #20]
 80037ee:	4a49      	ldr	r2, [pc, #292]	; (8003914 <_ux_hcd_stm32_interrupt_endpoint_create+0x22c>)
    stm32_channel_register |=  endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 80037f0:	f8d8 401c 	ldr.w	r4, [r8, #28]
    stm32_channel_register |=  (endpoint -> ux_endpoint_descriptor.bEndpointAddress & ~UX_ENDPOINT_DIRECTION) << UX_HCD_STM32_OTG_FS_HCCHAR_EPNUM_SHIFT;
 80037f4:	ea02 22c1 	and.w	r2, r2, r1, lsl #11
    if (device -> ux_device_speed == UX_LOW_SPEED_DEVICE)
 80037f8:	e9d7 c703 	ldrd	ip, r7, [r7, #12]
    ed -> ux_stm32_ed_next_ed =           next_ed;
 80037fc:	60b3      	str	r3, [r6, #8]
    stm32_channel_register |=  endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 80037fe:	ea42 528c 	orr.w	r2, r2, ip, lsl #22
    stm32_channel_register |=  UX_HCD_STM32_OTG_FS_HCCHAR_EPTYP_INTERRUPT;
 8003802:	2f00      	cmp	r7, #0
    ed -> ux_stm32_ed_previous_ed =       ed_list;
 8003804:	60f0      	str	r0, [r6, #12]
    stm32_channel_register |=  UX_HCD_STM32_OTG_FS_HCCHAR_EPTYP_INTERRUPT;
 8003806:	bf0c      	ite	eq
 8003808:	f44f 2360 	moveq.w	r3, #917504	; 0xe0000
 800380c:	f44f 2340 	movne.w	r3, #786432	; 0xc0000
    stm32_channel_register |=  endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8003810:	4322      	orrs	r2, r4
    ed_list -> ux_stm32_ed_next_ed =      ed;
 8003812:	6086      	str	r6, [r0, #8]
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003814:	4628      	mov	r0, r5
    stm32_channel_register |=  endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8003816:	431a      	orrs	r2, r3
    if ((endpoint -> ux_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_IN)
 8003818:	060b      	lsls	r3, r1, #24
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 800381a:	6a31      	ldr	r1, [r6, #32]
        stm32_channel_register |=  UX_HCD_STM32_OTG_FS_HCCHAR_EPDIR_IN;  
 800381c:	bf48      	it	mi
 800381e:	f442 4200 	orrmi.w	r2, r2, #32768	; 0x8000
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003822:	3128      	adds	r1, #40	; 0x28
 8003824:	0149      	lsls	r1, r1, #5
 8003826:	f7fe f84b 	bl	80018c0 <_ux_hcd_stm32_register_write>
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), UX_HCD_STM32_OTG_FS_HCINT_DEFAULT);                    
 800382a:	6a31      	ldr	r1, [r6, #32]
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
 800382c:	4628      	mov	r0, r5
 800382e:	f240 72fb 	movw	r2, #2043	; 0x7fb
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), UX_HCD_STM32_OTG_FS_HCINT_DEFAULT);                    
 8003832:	0149      	lsls	r1, r1, #5
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
 8003834:	f201 510c 	addw	r1, r1, #1292	; 0x50c
 8003838:	f7fe f842 	bl	80018c0 <_ux_hcd_stm32_register_write>
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_HAINTMSK, 1 << ed -> ux_stm32_ed_channel);                    
 800383c:	6a33      	ldr	r3, [r6, #32]
 800383e:	2201      	movs	r2, #1
 8003840:	4628      	mov	r0, r5
 8003842:	f44f 6183 	mov.w	r1, #1048	; 0x418
 8003846:	409a      	lsls	r2, r3
 8003848:	f7fe f834 	bl	80018b4 <_ux_hcd_stm32_register_set>
    hcd_stm32 -> ux_hcd_stm32_periodic_scheduler_active++;
 800384c:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
    return(UX_SUCCESS);         
 8003850:	2000      	movs	r0, #0
    hcd_stm32 -> ux_hcd_stm32_periodic_scheduler_active++;
 8003852:	3301      	adds	r3, #1
 8003854:	f8c5 30d8 	str.w	r3, [r5, #216]	; 0xd8
}
 8003858:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        interval =  1;
 800385c:	2201      	movs	r2, #1
            if (interval & interval_index)
 800385e:	0751      	lsls	r1, r2, #29
 8003860:	d435      	bmi.n	80038ce <_ux_hcd_stm32_interrupt_endpoint_create+0x1e6>
 8003862:	0791      	lsls	r1, r2, #30
 8003864:	d43a      	bmi.n	80038dc <_ux_hcd_stm32_interrupt_endpoint_create+0x1f4>
            interval_stm32++;
 8003866:	f012 0f01 	tst.w	r2, #1
 800386a:	bf0c      	ite	eq
 800386c:	2406      	moveq	r4, #6
 800386e:	2405      	movne	r4, #5
    while (interval_stm32--)
 8003870:	f114 34ff 	adds.w	r4, r4, #4294967295
 8003874:	d201      	bcs.n	800387a <_ux_hcd_stm32_interrupt_endpoint_create+0x192>
 8003876:	e7b6      	b.n	80037e6 <_ux_hcd_stm32_interrupt_endpoint_create+0xfe>
            ed_list =  ed_list -> ux_stm32_ed_next_ed;
 8003878:	689b      	ldr	r3, [r3, #8]
        while (!(ed_list -> ux_stm32_ed_status & UX_HCD_STM32_ED_STATIC))
 800387a:	691a      	ldr	r2, [r3, #16]
 800387c:	2a00      	cmp	r2, #0
 800387e:	dafb      	bge.n	8003878 <_ux_hcd_stm32_interrupt_endpoint_create+0x190>
            interval_stm32++;
 8003880:	4618      	mov	r0, r3
 8003882:	689b      	ldr	r3, [r3, #8]
 8003884:	e7f4      	b.n	8003870 <_ux_hcd_stm32_interrupt_endpoint_create+0x188>
            if (interval & interval_index)
 8003886:	06d1      	lsls	r1, r2, #27
 8003888:	d41a      	bmi.n	80038c0 <_ux_hcd_stm32_interrupt_endpoint_create+0x1d8>
 800388a:	0711      	lsls	r1, r2, #28
 800388c:	d5e7      	bpl.n	800385e <_ux_hcd_stm32_interrupt_endpoint_create+0x176>
            interval_stm32++;
 800388e:	2402      	movs	r4, #2
 8003890:	e7ee      	b.n	8003870 <_ux_hcd_stm32_interrupt_endpoint_create+0x188>
        ed -> ux_stm32_ed_status =  UX_UNUSED;
 8003892:	6130      	str	r0, [r6, #16]
        return(UX_NO_TD_AVAILABLE);
 8003894:	2013      	movs	r0, #19
}
 8003896:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            ed -> ux_stm32_ed_channel = channel_index;
 800389a:	230b      	movs	r3, #11
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 800389c:	f8c5 60cc 	str.w	r6, [r5, #204]	; 0xcc
            ed -> ux_stm32_ed_channel = channel_index;
 80038a0:	6233      	str	r3, [r6, #32]
 80038a2:	e790      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 80038a4:	f8c5 60a0 	str.w	r6, [r5, #160]	; 0xa0
            ed -> ux_stm32_ed_channel = channel_index;
 80038a8:	6231      	str	r1, [r6, #32]
 80038aa:	e78c      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
 80038ac:	2302      	movs	r3, #2
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 80038ae:	f8c5 60a8 	str.w	r6, [r5, #168]	; 0xa8
            ed -> ux_stm32_ed_channel = channel_index;
 80038b2:	6233      	str	r3, [r6, #32]
 80038b4:	e787      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
 80038b6:	2303      	movs	r3, #3
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 80038b8:	f8c5 60ac 	str.w	r6, [r5, #172]	; 0xac
            ed -> ux_stm32_ed_channel = channel_index;
 80038bc:	6233      	str	r3, [r6, #32]
 80038be:	e782      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
            if (interval & interval_index)
 80038c0:	2401      	movs	r4, #1
 80038c2:	e7d5      	b.n	8003870 <_ux_hcd_stm32_interrupt_endpoint_create+0x188>
            ed -> ux_stm32_ed_channel = channel_index;
 80038c4:	2304      	movs	r3, #4
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 80038c6:	f8c5 60b0 	str.w	r6, [r5, #176]	; 0xb0
            ed -> ux_stm32_ed_channel = channel_index;
 80038ca:	6233      	str	r3, [r6, #32]
 80038cc:	e77b      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
            interval_stm32++;
 80038ce:	2403      	movs	r4, #3
 80038d0:	e7ce      	b.n	8003870 <_ux_hcd_stm32_interrupt_endpoint_create+0x188>
            ed -> ux_stm32_ed_channel = channel_index;
 80038d2:	2305      	movs	r3, #5
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 80038d4:	f8c5 60b4 	str.w	r6, [r5, #180]	; 0xb4
            ed -> ux_stm32_ed_channel = channel_index;
 80038d8:	6233      	str	r3, [r6, #32]
 80038da:	e774      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
            interval_stm32++;
 80038dc:	2404      	movs	r4, #4
 80038de:	e7c7      	b.n	8003870 <_ux_hcd_stm32_interrupt_endpoint_create+0x188>
            ed -> ux_stm32_ed_channel = channel_index;
 80038e0:	2306      	movs	r3, #6
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 80038e2:	f8c5 60b8 	str.w	r6, [r5, #184]	; 0xb8
            ed -> ux_stm32_ed_channel = channel_index;
 80038e6:	6233      	str	r3, [r6, #32]
 80038e8:	e76d      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
 80038ea:	2307      	movs	r3, #7
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 80038ec:	f8c5 60bc 	str.w	r6, [r5, #188]	; 0xbc
            ed -> ux_stm32_ed_channel = channel_index;
 80038f0:	6233      	str	r3, [r6, #32]
 80038f2:	e768      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
 80038f4:	2308      	movs	r3, #8
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 80038f6:	f8c5 60c0 	str.w	r6, [r5, #192]	; 0xc0
            ed -> ux_stm32_ed_channel = channel_index;
 80038fa:	6233      	str	r3, [r6, #32]
 80038fc:	e763      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
 80038fe:	2309      	movs	r3, #9
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8003900:	f8c5 60c4 	str.w	r6, [r5, #196]	; 0xc4
            ed -> ux_stm32_ed_channel = channel_index;
 8003904:	6233      	str	r3, [r6, #32]
 8003906:	e75e      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
 8003908:	230a      	movs	r3, #10
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 800390a:	f8c5 60c8 	str.w	r6, [r5, #200]	; 0xc8
            ed -> ux_stm32_ed_channel = channel_index;
 800390e:	6233      	str	r3, [r6, #32]
 8003910:	e759      	b.n	80037c6 <_ux_hcd_stm32_interrupt_endpoint_create+0xde>
 8003912:	bf00      	nop
 8003914:	fffbf800 	.word	0xfffbf800

08003918 <_ux_hcd_stm32_iso_schedule>:
UINT  _ux_hcd_stm32_iso_schedule(UX_HCD_STM32 *hcd_stm32)
{

    /* Not currently implemented - just return FALSE.  */
    return(UX_FALSE);
}
 8003918:	2000      	movs	r0, #0
 800391a:	4770      	bx	lr

0800391c <_ux_hcd_stm32_isochronous_endpoint_create>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_isochronous_endpoint_create(UX_HCD_STM32 *hcd_stm32, UX_ENDPOINT *endpoint)
{
 800391c:	b570      	push	{r4, r5, r6, lr}
 800391e:	460e      	mov	r6, r1
 8003920:	4605      	mov	r5, r0
UX_HCD_STM32_ISO_TD       *td;


    /* Obtain a ED for this new endpoint. This ED will live as long as the endpoint is 
       active and will be the container for the TDs.  */
    ed =  _ux_hcd_stm32_ed_obtain(hcd_stm32);
 8003922:	f7ff fde9 	bl	80034f8 <_ux_hcd_stm32_ed_obtain>
    if (ed == UX_NULL)
 8003926:	b170      	cbz	r0, 8003946 <_ux_hcd_stm32_isochronous_endpoint_create+0x2a>
 8003928:	4604      	mov	r4, r0
        return(UX_NO_ED_AVAILABLE);

    /* Obtain a dummy isoch TD for terminating the ED transfer chain.  */
    td =  _ux_hcd_stm32_isochronous_td_obtain(hcd_stm32);
 800392a:	4628      	mov	r0, r5
 800392c:	f000 f812 	bl	8003954 <_ux_hcd_stm32_isochronous_td_obtain>
    if (td == UX_NULL)
 8003930:	b168      	cbz	r0, 800394e <_ux_hcd_stm32_isochronous_endpoint_create+0x32>
    /* Hook the TD to both the tail and head of the ED.  */
    ed -> ux_stm32_ed_tail_td =  (UX_HCD_STM32_TD *) ((void *) td);
    ed -> ux_stm32_ed_head_td =  (UX_HCD_STM32_TD *) ((void *) td);

    /* Attach this ED to the iso list.  */
    head_ed =  hcd_stm32 -> ux_hcd_stm32_iso_head_ed;
 8003932:	69eb      	ldr	r3, [r5, #28]
    endpoint -> ux_endpoint_ed =  (VOID *) ed;
 8003934:	60b4      	str	r4, [r6, #8]
    ed -> ux_stm32_ed_next_ed =  head_ed;
 8003936:	60a3      	str	r3, [r4, #8]
    ed -> ux_stm32_ed_head_td =  (UX_HCD_STM32_TD *) ((void *) td);
 8003938:	e9c4 0000 	strd	r0, r0, [r4]
    hcd_stm32 -> ux_hcd_stm32_iso_head_ed =  ed;
 800393c:	61ec      	str	r4, [r5, #28]

    /* Build the back chaining pointer. The previous head ED needs to know about the
       inserted ED. */
    if (head_ed != UX_NULL)
 800393e:	b123      	cbz	r3, 800394a <_ux_hcd_stm32_isochronous_endpoint_create+0x2e>
        head_ed -> ux_stm32_ed_previous_ed =  ed;
 8003940:	60dc      	str	r4, [r3, #12]
    
    /* Return successful completion.  */
    return(UX_SUCCESS);         
 8003942:	2000      	movs	r0, #0
}
 8003944:	bd70      	pop	{r4, r5, r6, pc}
        return(UX_NO_ED_AVAILABLE);
 8003946:	2014      	movs	r0, #20
}
 8003948:	bd70      	pop	{r4, r5, r6, pc}
    return(UX_SUCCESS);         
 800394a:	4618      	mov	r0, r3
}
 800394c:	bd70      	pop	{r4, r5, r6, pc}
        ed -> ux_stm32_ed_status =  UX_UNUSED;
 800394e:	6120      	str	r0, [r4, #16]
        return(UX_NO_TD_AVAILABLE);
 8003950:	2013      	movs	r0, #19
}
 8003952:	bd70      	pop	{r4, r5, r6, pc}

08003954 <_ux_hcd_stm32_isochronous_td_obtain>:
ULONG                     td_index;


    /* Start the search from the beginning of the list.  */
    td =  hcd_stm32 -> ux_hcd_stm32_iso_td_list;
    for (td_index = 0; td_index < _ux_system_host -> ux_system_host_max_iso_td; td_index++)
 8003954:	4b0e      	ldr	r3, [pc, #56]	; (8003990 <_ux_hcd_stm32_isochronous_td_obtain+0x3c>)
 8003956:	681b      	ldr	r3, [r3, #0]
 8003958:	6a99      	ldr	r1, [r3, #40]	; 0x28
{
 800395a:	b510      	push	{r4, lr}
    td =  hcd_stm32 -> ux_hcd_stm32_iso_td_list;
 800395c:	68c4      	ldr	r4, [r0, #12]
    for (td_index = 0; td_index < _ux_system_host -> ux_system_host_max_iso_td; td_index++)
 800395e:	b1a9      	cbz	r1, 800398c <_ux_hcd_stm32_isochronous_td_obtain+0x38>
    {

        /* Check the TD status, a free TD is marked with the UX_USED flag.  */
        if (td -> ux_stm32_iso_td_status == UX_UNUSED)
 8003960:	69e3      	ldr	r3, [r4, #28]
 8003962:	b153      	cbz	r3, 800397a <_ux_hcd_stm32_isochronous_td_obtain+0x26>
    for (td_index = 0; td_index < _ux_system_host -> ux_system_host_max_iso_td; td_index++)
 8003964:	2300      	movs	r3, #0
 8003966:	e001      	b.n	800396c <_ux_hcd_stm32_isochronous_td_obtain+0x18>
        if (td -> ux_stm32_iso_td_status == UX_UNUSED)
 8003968:	69e2      	ldr	r2, [r4, #28]
 800396a:	b132      	cbz	r2, 800397a <_ux_hcd_stm32_isochronous_td_obtain+0x26>
    for (td_index = 0; td_index < _ux_system_host -> ux_system_host_max_iso_td; td_index++)
 800396c:	3301      	adds	r3, #1
            /* Success, return pointer to TD.  */
            return(td);
        }

        /* Move to next TD.  */
        td++;
 800396e:	3424      	adds	r4, #36	; 0x24
    for (td_index = 0; td_index < _ux_system_host -> ux_system_host_max_iso_td; td_index++)
 8003970:	428b      	cmp	r3, r1
 8003972:	d1f9      	bne.n	8003968 <_ux_hcd_stm32_isochronous_td_obtain+0x14>
    }

    /* There is no available TD in the TD list, return a NULL.  */
    return(UX_NULL);
 8003974:	2400      	movs	r4, #0
}
 8003976:	4620      	mov	r0, r4
 8003978:	bd10      	pop	{r4, pc}
            _ux_utility_memory_set(td, 0, sizeof(UX_HCD_STM32_ISO_TD));
 800397a:	4620      	mov	r0, r4
 800397c:	2224      	movs	r2, #36	; 0x24
 800397e:	2100      	movs	r1, #0
 8003980:	f7fe fb54 	bl	800202c <_ux_utility_memory_set>
            td -> ux_stm32_iso_td_status = UX_USED;
 8003984:	2301      	movs	r3, #1
}
 8003986:	4620      	mov	r0, r4
            td -> ux_stm32_iso_td_status = UX_USED;
 8003988:	61e3      	str	r3, [r4, #28]
}
 800398a:	bd10      	pop	{r4, pc}
    return(UX_NULL);
 800398c:	460c      	mov	r4, r1
 800398e:	e7f2      	b.n	8003976 <_ux_hcd_stm32_isochronous_td_obtain+0x22>
 8003990:	20000db8 	.word	0x20000db8

08003994 <_ux_hcd_stm32_least_traffic_list_get>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UX_HCD_STM32_ED  *_ux_hcd_stm32_least_traffic_list_get(UX_HCD_STM32 *hcd_stm32)
{
 8003994:	4684      	mov	ip, r0

    /* Set the min bandwidth used to a arbitrary maximum value.  */
    min_bandwidth_used =  0xffffffff;

    /* The first ED is the list candidate for now.  */
    min_bandwidth_ed =  hcd_stm32 -> ux_hcd_stm32_interrupt_ed_list[0];
 8003996:	6a00      	ldr	r0, [r0, #32]
{
 8003998:	b4f0      	push	{r4, r5, r6, r7}
 800399a:	f10c 051c 	add.w	r5, ip, #28
    min_bandwidth_used =  0xffffffff;
 800399e:	f04f 37ff 	mov.w	r7, #4294967295
 80039a2:	f10c 0c9c 	add.w	ip, ip, #156	; 0x9c

        /* Reset the bandwidth for this list.  */
        bandwidth_used =  0;

        /* Get the ED of the beginning of the list we parse now.  */
        ed =  hcd_stm32 -> ux_hcd_stm32_interrupt_ed_list[list_index];
 80039a6:	f855 6f04 	ldr.w	r6, [r5, #4]!
        bandwidth_used =  0;
 80039aa:	2400      	movs	r4, #0
        ed =  hcd_stm32 -> ux_hcd_stm32_interrupt_ed_list[list_index];
 80039ac:	4633      	mov	r3, r6

        /* We keep track of the first ED for the current list.  */
        begin_ed =  ed;

        /* Parse the eds in the list.  */
        while (ed -> ux_stm32_ed_next_ed != UX_NULL)
 80039ae:	689a      	ldr	r2, [r3, #8]
 80039b0:	b14a      	cbz	r2, 80039c6 <_ux_hcd_stm32_least_traffic_list_get+0x32>
        {

            /* Check if this is a valid endpoint or an anchor only.  */
            if ((ed -> ux_stm32_ed_status & UX_HCD_STM32_ED_STATIC) == 0)
 80039b2:	6919      	ldr	r1, [r3, #16]
 80039b4:	2900      	cmp	r1, #0
 80039b6:	db02      	blt.n	80039be <_ux_hcd_stm32_least_traffic_list_get+0x2a>

                /* Get the endpoint pointer from the physical ED.  */
                endpoint =  ed -> ux_stm32_ed_endpoint;

                /* Add to the bandwidth used the max packet size pointed by this ED.  */
                bandwidth_used +=  (ULONG) endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 80039b8:	695b      	ldr	r3, [r3, #20]
 80039ba:	69db      	ldr	r3, [r3, #28]
 80039bc:	441c      	add	r4, r3
    min_bandwidth_used =  0xffffffff;
 80039be:	4613      	mov	r3, r2
        while (ed -> ux_stm32_ed_next_ed != UX_NULL)
 80039c0:	689a      	ldr	r2, [r3, #8]
 80039c2:	2a00      	cmp	r2, #0
 80039c4:	d1f5      	bne.n	80039b2 <_ux_hcd_stm32_least_traffic_list_get+0x1e>
            ed =  ed -> ux_stm32_ed_next_ed;
        }

        /* We have processed a list, check the bandwidth used by this list.
           If this bandwidth is the minimum, we memorize the ED.  */        
        if (bandwidth_used < min_bandwidth_used)
 80039c6:	42bc      	cmp	r4, r7
 80039c8:	d201      	bcs.n	80039ce <_ux_hcd_stm32_least_traffic_list_get+0x3a>
 80039ca:	4627      	mov	r7, r4
            /* We have found a better list with a lower used bandwidth, memorize the bandwidth 
               for this list.  */
            min_bandwidth_used =  bandwidth_used;
            
            /* Memorize the begin ED for this list.  */
            min_bandwidth_ed =  begin_ed;
 80039cc:	4630      	mov	r0, r6
    for (list_index = 0; list_index < 32; list_index++)
 80039ce:	4565      	cmp	r5, ip
 80039d0:	d1e9      	bne.n	80039a6 <_ux_hcd_stm32_least_traffic_list_get+0x12>
        }
    }
    
    /* Return the ED list with the lowest bandwidth.  */
    return(min_bandwidth_ed);   
}
 80039d2:	bcf0      	pop	{r4, r5, r6, r7}
 80039d4:	4770      	bx	lr
 80039d6:	bf00      	nop

080039d8 <_ux_hcd_stm32_periodic_endpoint_destroy>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_periodic_endpoint_destroy(UX_HCD_STM32 *hcd_stm32, UX_ENDPOINT *endpoint)
{
 80039d8:	b570      	push	{r4, r5, r6, lr}
UX_HCD_STM32_TD      *tail_td;
UX_HCD_STM32_TD      *head_td;

    
    /* From the endpoint container fetch the stm32 ED descriptor.  */
    ed =  (UX_HCD_STM32_ED*) endpoint -> ux_endpoint_ed;
 80039da:	688c      	ldr	r4, [r1, #8]

    /* Check if this physical endpoint has been initialized properly!  */
    if (ed == UX_NULL)
 80039dc:	b32c      	cbz	r4, 8003a2a <_ux_hcd_stm32_periodic_endpoint_destroy+0x52>

        return(UX_ENDPOINT_HANDLE_UNKNOWN);
    }

    /* The endpoint may be active. If so, set the skip bit.  */
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 80039de:	6923      	ldr	r3, [r4, #16]
 80039e0:	4605      	mov	r5, r0
    
    /* Wait for the controller to finish the current frame processing.  */
    _ux_utility_delay_ms(1);
 80039e2:	2001      	movs	r0, #1
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 80039e4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80039e8:	6123      	str	r3, [r4, #16]
    _ux_utility_delay_ms(1);
 80039ea:	f7fe f973 	bl	8001cd4 <_ux_utility_delay_ms>

    /* Get the previous ED in the list for this ED.  */
    previous_ed =  ed -> ux_stm32_ed_previous_ed;

    /* Get the next ED in the list for this ED.  */
    next_ed =  ed -> ux_stm32_ed_next_ed;
 80039ee:	e9d4 3202 	ldrd	r3, r2, [r4, #8]

    /* The previous ED points now to the ED after the ED we are removing.  */
    previous_ed -> ux_stm32_ed_next_ed =  next_ed;
 80039f2:	6093      	str	r3, [r2, #8]

    /* There may not be any next endpoint.  But if there is one, link it
       to the previous ED. */
    if (next_ed != UX_NULL)
 80039f4:	b103      	cbz	r3, 80039f8 <_ux_hcd_stm32_periodic_endpoint_destroy+0x20>
    
        /* Update the previous ED pointer in the next ED.  */
        next_ed -> ux_stm32_ed_previous_ed =  previous_ed;
 80039f6:	60da      	str	r2, [r3, #12]

    /* Remove all the tds from this ED and leave the head and tail pointing to the dummy TD.  */
    head_td =  ed -> ux_stm32_ed_head_td;
    tail_td =  ed -> ux_stm32_ed_tail_td;
 80039f8:	e9d4 2300 	ldrd	r2, r3, [r4]

    /* Free all tds attached to the ED.  */
    while (head_td != tail_td)
 80039fc:	4293      	cmp	r3, r2
 80039fe:	d005      	beq.n	8003a0c <_ux_hcd_stm32_periodic_endpoint_destroy+0x34>
    {

        /* Mark the current head TD as free. */
        head_td -> ux_stm32_td_status =  UX_UNUSED;
 8003a00:	2100      	movs	r1, #0
 8003a02:	61d9      	str	r1, [r3, #28]

        /* Update the head TD with the next TD.  */
        ed -> ux_stm32_ed_head_td =  head_td -> ux_stm32_td_next_td;
 8003a04:	689b      	ldr	r3, [r3, #8]
    while (head_td != tail_td)
 8003a06:	4293      	cmp	r3, r2
 8003a08:	d1fb      	bne.n	8003a02 <_ux_hcd_stm32_periodic_endpoint_destroy+0x2a>
 8003a0a:	6062      	str	r2, [r4, #4]

    /* We need to free the dummy TD that was attached to the ED.  */
    tail_td -> ux_stm32_td_status =  UX_UNUSED;

    /* We need to free the channel.  */
    hcd_stm32 -> ux_hcd_stm32_channels_ed[ed -> ux_stm32_ed_channel] =  UX_NULL;
 8003a0c:	6a20      	ldr	r0, [r4, #32]
    tail_td -> ux_stm32_td_status =  UX_UNUSED;
 8003a0e:	2300      	movs	r3, #0
    /* Now we can safely make the ED free.  */
    ed -> ux_stm32_ed_status =  UX_UNUSED;

    /* Decrement the number of interrupt endpoints active. When the counter
       reaches 0, the periodic scheduler will be turned off.  */
    hcd_stm32 -> ux_hcd_stm32_periodic_scheduler_active--;
 8003a10:	f8d5 10d8 	ldr.w	r1, [r5, #216]	; 0xd8
    hcd_stm32 -> ux_hcd_stm32_channels_ed[ed -> ux_stm32_ed_channel] =  UX_NULL;
 8003a14:	f100 0628 	add.w	r6, r0, #40	; 0x28
    tail_td -> ux_stm32_td_status =  UX_UNUSED;
 8003a18:	61d3      	str	r3, [r2, #28]
    hcd_stm32 -> ux_hcd_stm32_periodic_scheduler_active--;
 8003a1a:	3901      	subs	r1, #1

    /* Return successful completion.  */
    return(UX_SUCCESS);         
 8003a1c:	4618      	mov	r0, r3
    hcd_stm32 -> ux_hcd_stm32_channels_ed[ed -> ux_stm32_ed_channel] =  UX_NULL;
 8003a1e:	f845 3026 	str.w	r3, [r5, r6, lsl #2]
    ed -> ux_stm32_ed_status =  UX_UNUSED;
 8003a22:	6123      	str	r3, [r4, #16]
    hcd_stm32 -> ux_hcd_stm32_periodic_scheduler_active--;
 8003a24:	f8c5 10d8 	str.w	r1, [r5, #216]	; 0xd8
}
 8003a28:	bd70      	pop	{r4, r5, r6, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HCD, UX_ENDPOINT_HANDLE_UNKNOWN);
 8003a2a:	2253      	movs	r2, #83	; 0x53
 8003a2c:	2101      	movs	r1, #1
 8003a2e:	2002      	movs	r0, #2
 8003a30:	f7fe f8e6 	bl	8001c00 <_ux_system_error_handler>
        return(UX_ENDPOINT_HANDLE_UNKNOWN);
 8003a34:	2053      	movs	r0, #83	; 0x53
}
 8003a36:	bd70      	pop	{r4, r5, r6, pc}

08003a38 <_ux_hcd_stm32_periodic_schedule>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_periodic_schedule(UX_HCD_STM32 *hcd_stm32)
{
 8003a38:	b530      	push	{r4, r5, lr}
 8003a3a:	b083      	sub	sp, #12
 8003a3c:	4605      	mov	r5, r0

UX_HCD_STM32_ED     *ed;
ULONG               frame_number;

    /* Get the current frame number.  */
    _ux_hcd_stm32_frame_number_get(hcd_stm32, &frame_number);
 8003a3e:	a901      	add	r1, sp, #4
 8003a40:	f7ff fe30 	bl	80036a4 <_ux_hcd_stm32_frame_number_get>
    
    /* Isolate the low bits to match an entry in the upper periodic entry list.  */
    frame_number &=  UX_HCD_STM32_PERIODIC_ENTRY_MASK;
 8003a44:	9b01      	ldr	r3, [sp, #4]
 8003a46:	f003 031f 	and.w	r3, r3, #31

    /* Get the first ED in the periodic list.  */
    ed =  hcd_stm32 -> ux_hcd_stm32_interrupt_ed_list[frame_number];
 8003a4a:	f103 0208 	add.w	r2, r3, #8
    frame_number &=  UX_HCD_STM32_PERIODIC_ENTRY_MASK;
 8003a4e:	9301      	str	r3, [sp, #4]
    ed =  hcd_stm32 -> ux_hcd_stm32_interrupt_ed_list[frame_number];
 8003a50:	f855 4022 	ldr.w	r4, [r5, r2, lsl #2]

    /* Search for an entry in the periodic tree.  */
    while (ed != UX_NULL) 
 8003a54:	b18c      	cbz	r4, 8003a7a <_ux_hcd_stm32_periodic_schedule+0x42>
    {

        /* Ensure this ED does not have the SKIP bit set and no TD are in progress. */
        if ((ed -> ux_stm32_ed_head_td -> ux_stm32_td_status & UX_HCD_STM32_TD_ACK_PENDING) == 0)
 8003a56:	6863      	ldr	r3, [r4, #4]
 8003a58:	69da      	ldr	r2, [r3, #28]
 8003a5a:	0312      	lsls	r2, r2, #12
 8003a5c:	d40a      	bmi.n	8003a74 <_ux_hcd_stm32_periodic_schedule+0x3c>
        {

            /* The ED has to be a real ED (not static) and has to have a different tail and head TD.  */
            if ((ed -> ux_stm32_ed_status != UX_HCD_STM32_ED_STATIC) && (ed -> ux_stm32_ed_tail_td != ed -> ux_stm32_ed_head_td))
 8003a5e:	6922      	ldr	r2, [r4, #16]
 8003a60:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8003a64:	d006      	beq.n	8003a74 <_ux_hcd_stm32_periodic_schedule+0x3c>
 8003a66:	6822      	ldr	r2, [r4, #0]
            {

                    /* Insert this transfer in the list of scheduled TDs if possible.  */
                    _ux_hcd_stm32_td_schedule(hcd_stm32, ed);
 8003a68:	4621      	mov	r1, r4
 8003a6a:	4628      	mov	r0, r5
            if ((ed -> ux_stm32_ed_status != UX_HCD_STM32_ED_STATIC) && (ed -> ux_stm32_ed_tail_td != ed -> ux_stm32_ed_head_td))
 8003a6c:	4293      	cmp	r3, r2
 8003a6e:	d001      	beq.n	8003a74 <_ux_hcd_stm32_periodic_schedule+0x3c>
                    _ux_hcd_stm32_td_schedule(hcd_stm32, ed);
 8003a70:	f000 f8de 	bl	8003c30 <_ux_hcd_stm32_td_schedule>
            }
        }

        /* Point to the next ED in the list.  */
        ed =  ed -> ux_stm32_ed_next_ed;
 8003a74:	68a4      	ldr	r4, [r4, #8]
    while (ed != UX_NULL) 
 8003a76:	2c00      	cmp	r4, #0
 8003a78:	d1ed      	bne.n	8003a56 <_ux_hcd_stm32_periodic_schedule+0x1e>
    }

    /* Return to caller.  */
    return(UX_FALSE);
}
 8003a7a:	2000      	movs	r0, #0
 8003a7c:	b003      	add	sp, #12
 8003a7e:	bd30      	pop	{r4, r5, pc}

08003a80 <_ux_hcd_stm32_port_disable>:
UINT  _ux_hcd_stm32_port_disable(UX_HCD_STM32 *hcd_stm32, ULONG port_index)
{

    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 8003a80:	2000      	movs	r0, #0
 8003a82:	4770      	bx	lr

08003a84 <_ux_hcd_stm32_port_enable>:
UINT  _ux_hcd_stm32_port_enable(UX_HCD_STM32 *hcd_stm32, ULONG port_index)
{

    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 8003a84:	2000      	movs	r0, #0
 8003a86:	4770      	bx	lr

08003a88 <_ux_hcd_stm32_port_reset>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_port_reset(UX_HCD_STM32 *hcd_stm32, ULONG port_index)
{
 8003a88:	b570      	push	{r4, r5, r6, lr}
ULONG    stm32_register;
ULONG    port_enable_timeout;
ULONG   port_reset_loop;

    /* Check to see if this port is valid on this controller.  On STM32, there is only one. */
    if (port_index != 0)
 8003a8a:	2900      	cmp	r1, #0
 8003a8c:	d149      	bne.n	8003b22 <_ux_hcd_stm32_port_reset+0x9a>
        return(UX_PORT_INDEX_UNKNOWN);
    }
    
    /* Ensure that the downstream port has a device attached. It is unnatural
       to perform a port reset if there is no device.  */
    if ((hcd_stm32 -> ux_hcd_stm32_controller_flag & UX_HCD_STM32_CONTROLLER_FLAG_DEVICE_ATTACHED) == 0)
 8003a8e:	f8d0 30e4 	ldr.w	r3, [r0, #228]	; 0xe4
 8003a92:	4605      	mov	r5, r0
 8003a94:	07db      	lsls	r3, r3, #31
 8003a96:	d54b      	bpl.n	8003b30 <_ux_hcd_stm32_port_reset+0xa8>
 8003a98:	2603      	movs	r6, #3
    /* Perform the reset 3 times.  */
    while (port_reset_loop++ < 3)
    {
    
        /* Arm the Reset signal.  */
        _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT, UX_HCD_STM32_OTG_FS_HPRT_PRST);    
 8003a9a:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003a9e:	f44f 6188 	mov.w	r1, #1088	; 0x440
 8003aa2:	4628      	mov	r0, r5
    
        /* Perform the necessary delay for resetting the port.  More than 10ms.  */
        _ux_utility_delay_ms(50);
    
        /* Complete the Reset signal.  */
        _ux_hcd_stm32_register_clear(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT, UX_HCD_STM32_OTG_FS_HPRT_PRST);    
 8003aa4:	2405      	movs	r4, #5
        _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT, UX_HCD_STM32_OTG_FS_HPRT_PRST);    
 8003aa6:	f7fd ff05 	bl	80018b4 <_ux_hcd_stm32_register_set>
        _ux_utility_delay_ms(50);
 8003aaa:	2032      	movs	r0, #50	; 0x32
 8003aac:	f7fe f912 	bl	8001cd4 <_ux_utility_delay_ms>
        _ux_hcd_stm32_register_clear(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT, UX_HCD_STM32_OTG_FS_HPRT_PRST);    
 8003ab0:	f44f 7280 	mov.w	r2, #256	; 0x100
 8003ab4:	f44f 6188 	mov.w	r1, #1088	; 0x440
 8003ab8:	4628      	mov	r0, r5
 8003aba:	f7fd feef 	bl	800189c <_ux_hcd_stm32_register_clear>
        /* Wait for the port to be enabled.  */
        while (port_enable_timeout < UX_HCD_STM32_PORT_ENABLE_TIMEOUT)
        {
    
            /* Read the port status.  */
            stm32_register = _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT);
 8003abe:	f44f 6188 	mov.w	r1, #1088	; 0x440
 8003ac2:	4628      	mov	r0, r5
 8003ac4:	f7fd fef2 	bl	80018ac <_ux_hcd_stm32_register_read>
            
            /* Is it enabled ? */
            if (stm32_register & UX_HCD_STM32_OTG_FS_HPRT_PENA)
 8003ac8:	f010 0f04 	tst.w	r0, #4
                return(UX_SUCCESS);

            }            
    
            /* We need to wait a bit.  */
            _ux_utility_delay_ms(1);
 8003acc:	f04f 0001 	mov.w	r0, #1
            if (stm32_register & UX_HCD_STM32_OTG_FS_HPRT_PENA)
 8003ad0:	d107      	bne.n	8003ae2 <_ux_hcd_stm32_port_reset+0x5a>
            _ux_utility_delay_ms(1);
 8003ad2:	f7fe f8ff 	bl	8001cd4 <_ux_utility_delay_ms>
        while (port_enable_timeout < UX_HCD_STM32_PORT_ENABLE_TIMEOUT)
 8003ad6:	3c01      	subs	r4, #1
 8003ad8:	d1f1      	bne.n	8003abe <_ux_hcd_stm32_port_reset+0x36>
    while (port_reset_loop++ < 3)
 8003ada:	3e01      	subs	r6, #1
 8003adc:	d1dd      	bne.n	8003a9a <_ux_hcd_stm32_port_reset+0x12>
    
        }                        
    }

       /* Port reset failed.  */
    return(UX_PORT_RESET_FAILED);
 8003ade:	2031      	movs	r0, #49	; 0x31
    
    
}
 8003ae0:	bd70      	pop	{r4, r5, r6, pc}
                stm32_register = _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HPRT) & UX_HCD_STM32_OTG_FS_HPRT_PSPD_SPEED_MASK;
 8003ae2:	f44f 6188 	mov.w	r1, #1088	; 0x440
 8003ae6:	4628      	mov	r0, r5
 8003ae8:	f7fd fee0 	bl	80018ac <_ux_hcd_stm32_register_read>
 8003aec:	f400 20c0 	and.w	r0, r0, #393216	; 0x60000
                switch (stm32_register)
 8003af0:	f5b0 3f00 	cmp.w	r0, #131072	; 0x20000
 8003af4:	d023      	beq.n	8003b3e <_ux_hcd_stm32_port_reset+0xb6>
 8003af6:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 8003afa:	d00b      	beq.n	8003b14 <_ux_hcd_stm32_port_reset+0x8c>
 8003afc:	b928      	cbnz	r0, 8003b0a <_ux_hcd_stm32_port_reset+0x82>
                        hcd_stm32 -> ux_hcd_stm32_controller_flag |= UX_HCD_STM32_CONTROLLER_HIGH_SPEED_DEVICE;
 8003afe:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
 8003b02:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003b06:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
                _ux_utility_delay_ms(UX_HCD_STM32_PORT_RESET_DELAY);
 8003b0a:	2032      	movs	r0, #50	; 0x32
 8003b0c:	f7fe f8e2 	bl	8001cd4 <_ux_utility_delay_ms>
                return(UX_SUCCESS);
 8003b10:	2000      	movs	r0, #0
}
 8003b12:	bd70      	pop	{r4, r5, r6, pc}
                        hcd_stm32 -> ux_hcd_stm32_controller_flag |= UX_HCD_STM32_CONTROLLER_LOW_SPEED_DEVICE;
 8003b14:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
 8003b18:	f043 0320 	orr.w	r3, r3, #32
 8003b1c:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
                        break;
 8003b20:	e7f3      	b.n	8003b0a <_ux_hcd_stm32_port_reset+0x82>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HCD, UX_PORT_INDEX_UNKNOWN);
 8003b22:	2256      	movs	r2, #86	; 0x56
 8003b24:	2101      	movs	r1, #1
 8003b26:	2002      	movs	r0, #2
 8003b28:	f7fe f86a 	bl	8001c00 <_ux_system_error_handler>
        return(UX_PORT_INDEX_UNKNOWN);
 8003b2c:	2056      	movs	r0, #86	; 0x56
}
 8003b2e:	bd70      	pop	{r4, r5, r6, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HCD, UX_NO_DEVICE_CONNECTED);
 8003b30:	225f      	movs	r2, #95	; 0x5f
 8003b32:	2101      	movs	r1, #1
 8003b34:	2002      	movs	r0, #2
 8003b36:	f7fe f863 	bl	8001c00 <_ux_system_error_handler>
        return(UX_NO_DEVICE_CONNECTED);
 8003b3a:	205f      	movs	r0, #95	; 0x5f
}
 8003b3c:	bd70      	pop	{r4, r5, r6, pc}
                        hcd_stm32 -> ux_hcd_stm32_controller_flag |= UX_HCD_STM32_CONTROLLER_FULL_SPEED_DEVICE;
 8003b3e:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
 8003b42:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003b46:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
                        break;
 8003b4a:	e7de      	b.n	8003b0a <_ux_hcd_stm32_port_reset+0x82>

08003b4c <_ux_hcd_stm32_port_resume>:
UINT  _ux_hcd_stm32_port_resume(UX_HCD_STM32 *hcd_stm32, UINT port_index)
{

    /* Return error status.  */
    return(UX_FUNCTION_NOT_SUPPORTED);  
}
 8003b4c:	2054      	movs	r0, #84	; 0x54
 8003b4e:	4770      	bx	lr

08003b50 <_ux_hcd_stm32_port_status_get>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
ULONG  _ux_hcd_stm32_port_status_get(UX_HCD_STM32 *hcd_stm32, ULONG port_index)
{
 8003b50:	b508      	push	{r3, lr}

ULONG       port_status;


    /* Check to see if this port is valid on this controller.  */
    if (hcd_stm32 -> ux_hcd_stm32_nb_root_hubs < port_index)
 8003b52:	f8d0 30e8 	ldr.w	r3, [r0, #232]	; 0xe8
 8003b56:	428b      	cmp	r3, r1
 8003b58:	d30c      	bcc.n	8003b74 <_ux_hcd_stm32_port_status_get+0x24>
    /* The port is valid, build the status mask for this port. This function
       returns a controller agnostic bit field.  */ 
    port_status =  0;
                                    
    /* Device Connection Status.  */
    if (hcd_stm32 -> ux_hcd_stm32_controller_flag & UX_HCD_STM32_CONTROLLER_FLAG_DEVICE_ATTACHED)
 8003b5a:	f8d0 30e4 	ldr.w	r3, [r0, #228]	; 0xe4
        port_status |=  UX_PS_CCS;
                                    
    /* Port Device Attached speed. Report Full speed or Low speed.  */
    if (hcd_stm32 -> ux_hcd_stm32_controller_flag & UX_HCD_STM32_CONTROLLER_LOW_SPEED_DEVICE)
 8003b5e:	069a      	lsls	r2, r3, #26
    if (hcd_stm32 -> ux_hcd_stm32_controller_flag & UX_HCD_STM32_CONTROLLER_FLAG_DEVICE_ATTACHED)
 8003b60:	f003 0001 	and.w	r0, r3, #1
    if (hcd_stm32 -> ux_hcd_stm32_controller_flag & UX_HCD_STM32_CONTROLLER_LOW_SPEED_DEVICE)
 8003b64:	d405      	bmi.n	8003b72 <_ux_hcd_stm32_port_status_get+0x22>
        port_status |=  UX_PS_DS_LS;
    else
    {
        
        /* Check if Full Speed now.  */
        if (hcd_stm32 -> ux_hcd_stm32_controller_flag & UX_HCD_STM32_CONTROLLER_FULL_SPEED_DEVICE)
 8003b66:	065b      	lsls	r3, r3, #25

            /* Full Speed.  */
            port_status |=  UX_PS_DS_FS;
 8003b68:	bf4c      	ite	mi
 8003b6a:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40

        else

            /* High Speed.  */
            port_status |=  UX_PS_DS_HS;
 8003b6e:	f040 0080 	orrpl.w	r0, r0, #128	; 0x80
                    
    }

    /* Return port status.  */
    return(port_status);            
}
 8003b72:	bd08      	pop	{r3, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HCD, UX_PORT_INDEX_UNKNOWN);
 8003b74:	2256      	movs	r2, #86	; 0x56
 8003b76:	2101      	movs	r1, #1
 8003b78:	2002      	movs	r0, #2
 8003b7a:	f7fe f841 	bl	8001c00 <_ux_system_error_handler>
        return(UX_PORT_INDEX_UNKNOWN);
 8003b7e:	2056      	movs	r0, #86	; 0x56
}
 8003b80:	bd08      	pop	{r3, pc}
 8003b82:	bf00      	nop

08003b84 <_ux_hcd_stm32_port_suspend>:
UINT  _ux_hcd_stm32_port_suspend(UX_HCD_STM32 *hcd_stm32, ULONG port_index)
{

    /* Return error status.  */
    return(UX_FUNCTION_NOT_SUPPORTED);  
}
 8003b84:	2054      	movs	r0, #84	; 0x54
 8003b86:	4770      	bx	lr

08003b88 <_ux_hcd_stm32_power_down_port>:
UINT  _ux_hcd_stm32_power_down_port(UX_HCD_STM32 *hcd_stm32, ULONG port_index)
{

    /* Return error status.  */
    return(UX_FUNCTION_NOT_SUPPORTED);  
}
 8003b88:	2054      	movs	r0, #84	; 0x54
 8003b8a:	4770      	bx	lr

08003b8c <_ux_hcd_stm32_regular_td_obtain>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UX_HCD_STM32_TD  *_ux_hcd_stm32_regular_td_obtain(UX_HCD_STM32 *hcd_stm32)
{
 8003b8c:	b538      	push	{r3, r4, r5, lr}
UX_HCD_STM32_TD       *td;
ULONG             td_index;


    /* Get the mutex as this is a critical section.  */
    _ux_utility_mutex_on(&_ux_system -> ux_system_mutex);
 8003b8e:	4d14      	ldr	r5, [pc, #80]	; (8003be0 <_ux_hcd_stm32_regular_td_obtain+0x54>)
{
 8003b90:	4604      	mov	r4, r0
    _ux_utility_mutex_on(&_ux_system -> ux_system_mutex);
 8003b92:	6828      	ldr	r0, [r5, #0]
 8003b94:	301c      	adds	r0, #28
 8003b96:	f7fe fa5d 	bl	8002054 <_ux_utility_mutex_on>

    /* Start the search from the beginning of the list.  */
    td =  hcd_stm32 -> ux_hcd_stm32_td_list;

    for (td_index = 0; td_index < _ux_system_host -> ux_system_host_max_td; td_index++)
 8003b9a:	4b12      	ldr	r3, [pc, #72]	; (8003be4 <_ux_hcd_stm32_regular_td_obtain+0x58>)
    td =  hcd_stm32 -> ux_hcd_stm32_td_list;
 8003b9c:	68a4      	ldr	r4, [r4, #8]
    for (td_index = 0; td_index < _ux_system_host -> ux_system_host_max_td; td_index++)
 8003b9e:	681b      	ldr	r3, [r3, #0]
 8003ba0:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8003ba2:	b149      	cbz	r1, 8003bb8 <_ux_hcd_stm32_regular_td_obtain+0x2c>
    {

        /* Check the TD status, a free TD is marked with the UNUSED flag.  */
        if (td -> ux_stm32_td_status == UX_UNUSED)
 8003ba4:	69e3      	ldr	r3, [r4, #28]
 8003ba6:	b173      	cbz	r3, 8003bc6 <_ux_hcd_stm32_regular_td_obtain+0x3a>
    for (td_index = 0; td_index < _ux_system_host -> ux_system_host_max_td; td_index++)
 8003ba8:	2300      	movs	r3, #0
 8003baa:	e001      	b.n	8003bb0 <_ux_hcd_stm32_regular_td_obtain+0x24>
        if (td -> ux_stm32_td_status == UX_UNUSED)
 8003bac:	69e2      	ldr	r2, [r4, #28]
 8003bae:	b152      	cbz	r2, 8003bc6 <_ux_hcd_stm32_regular_td_obtain+0x3a>
    for (td_index = 0; td_index < _ux_system_host -> ux_system_host_max_td; td_index++)
 8003bb0:	3301      	adds	r3, #1
            /* Return the TD pointer.  */
            return(td);
        }

        /* Move to next TD.  */
        td++;
 8003bb2:	3428      	adds	r4, #40	; 0x28
    for (td_index = 0; td_index < _ux_system_host -> ux_system_host_max_td; td_index++)
 8003bb4:	428b      	cmp	r3, r1
 8003bb6:	d1f9      	bne.n	8003bac <_ux_hcd_stm32_regular_td_obtain+0x20>
    }

    /* There is no available TD in the TD list. */

    /* Release the mutex protection.  */
    _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8003bb8:	6828      	ldr	r0, [r5, #0]

    /* Return a NULL pointer.  */
    return(UX_NULL);
 8003bba:	2400      	movs	r4, #0
    _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8003bbc:	301c      	adds	r0, #28
 8003bbe:	f7fe fa47 	bl	8002050 <_ux_utility_mutex_off>
}
 8003bc2:	4620      	mov	r0, r4
 8003bc4:	bd38      	pop	{r3, r4, r5, pc}
            _ux_utility_memory_set(td, 0, sizeof(UX_HCD_STM32_TD));
 8003bc6:	2228      	movs	r2, #40	; 0x28
 8003bc8:	2100      	movs	r1, #0
 8003bca:	4620      	mov	r0, r4
 8003bcc:	f7fe fa2e 	bl	800202c <_ux_utility_memory_set>
            _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8003bd0:	6828      	ldr	r0, [r5, #0]
            td -> ux_stm32_td_status =  UX_USED;
 8003bd2:	2301      	movs	r3, #1
            _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8003bd4:	301c      	adds	r0, #28
            td -> ux_stm32_td_status =  UX_USED;
 8003bd6:	61e3      	str	r3, [r4, #28]
            _ux_utility_mutex_off(&_ux_system -> ux_system_mutex);
 8003bd8:	f7fe fa3a 	bl	8002050 <_ux_utility_mutex_off>
}
 8003bdc:	4620      	mov	r0, r4
 8003bde:	bd38      	pop	{r3, r4, r5, pc}
 8003be0:	20000dc0 	.word	0x20000dc0
 8003be4:	20000db8 	.word	0x20000db8

08003be8 <_ux_hcd_stm32_request_transfer>:

UX_ENDPOINT     *endpoint;
UINT            status;
    
    /* Device Connection Status.  */
    if (hcd_stm32 -> ux_hcd_stm32_controller_flag & UX_HCD_STM32_CONTROLLER_FLAG_DEVICE_ATTACHED)
 8003be8:	f8d0 30e4 	ldr.w	r3, [r0, #228]	; 0xe4
 8003bec:	07db      	lsls	r3, r3, #31
 8003bee:	d511      	bpl.n	8003c14 <_ux_hcd_stm32_request_transfer+0x2c>
    {
    
        /* Get the pointer to the Endpoint.  */
        endpoint =  (UX_ENDPOINT *) transfer_request -> ux_transfer_request_endpoint;
 8003bf0:	684b      	ldr	r3, [r1, #4]
    
        /* We reset the actual length field of the transfer request as a safety measure.  */
        transfer_request -> ux_transfer_request_actual_length =  0;
        
        /* Isolate the endpoint type and route the transfer request.  */
        switch ((endpoint -> ux_endpoint_descriptor.bmAttributes) & UX_MASK_ENDPOINT_TYPE)
 8003bf2:	699b      	ldr	r3, [r3, #24]
 8003bf4:	f003 0303 	and.w	r3, r3, #3
{
 8003bf8:	b410      	push	{r4}
        switch ((endpoint -> ux_endpoint_descriptor.bmAttributes) & UX_MASK_ENDPOINT_TYPE)
 8003bfa:	2b02      	cmp	r3, #2
        transfer_request -> ux_transfer_request_actual_length =  0;
 8003bfc:	f04f 0400 	mov.w	r4, #0
 8003c00:	610c      	str	r4, [r1, #16]
        switch ((endpoint -> ux_endpoint_descriptor.bmAttributes) & UX_MASK_ENDPOINT_TYPE)
 8003c02:	d011      	beq.n	8003c28 <_ux_hcd_stm32_request_transfer+0x40>
 8003c04:	2b03      	cmp	r3, #3
 8003c06:	d007      	beq.n	8003c18 <_ux_hcd_stm32_request_transfer+0x30>
 8003c08:	2b01      	cmp	r3, #1
 8003c0a:	d009      	beq.n	8003c20 <_ux_hcd_stm32_request_transfer+0x38>
        status = UX_NO_DEVICE_CONNECTED;

    }        

    return(status);         
}
 8003c0c:	f85d 4b04 	ldr.w	r4, [sp], #4
            status =  _ux_hcd_stm32_request_control_transfer(hcd_stm32, transfer_request);
 8003c10:	f001 b8b4 	b.w	8004d7c <_ux_hcd_stm32_request_control_transfer>
}
 8003c14:	205f      	movs	r0, #95	; 0x5f
 8003c16:	4770      	bx	lr
 8003c18:	f85d 4b04 	ldr.w	r4, [sp], #4
            status =  _ux_hcd_stm32_request_interrupt_transfer(hcd_stm32, transfer_request);
 8003c1c:	f001 b9a0 	b.w	8004f60 <_ux_hcd_stm32_request_interrupt_transfer>
}
 8003c20:	f85d 4b04 	ldr.w	r4, [sp], #4
            status =  _ux_hcd_stm32_request_isochronous_transfer(hcd_stm32, transfer_request);
 8003c24:	f001 b9d2 	b.w	8004fcc <_ux_hcd_stm32_request_isochronous_transfer>
}
 8003c28:	f85d 4b04 	ldr.w	r4, [sp], #4
            status =  _ux_hcd_stm32_request_bulk_transfer(hcd_stm32, transfer_request);
 8003c2c:	f001 b830 	b.w	8004c90 <_ux_hcd_stm32_request_bulk_transfer>

08003c30 <_ux_hcd_stm32_td_schedule>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_td_schedule(UX_HCD_STM32 *hcd_stm32, UX_HCD_STM32_ED *ed)
{
 8003c30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

    /* Get the pointer to the device.  */
    device =  endpoint -> ux_endpoint_device;

    /* Get the pointer to the candidate TD.  */
    td =  ed -> ux_stm32_ed_head_td;
 8003c34:	684c      	ldr	r4, [r1, #4]
{
 8003c36:	4606      	mov	r6, r0
    endpoint =  ed -> ux_stm32_ed_endpoint;
 8003c38:	f8d1 8014 	ldr.w	r8, [r1, #20]
    
    /* Set TD into response pending state. */
    UX_DISABLE_INTS
 8003c3c:	2001      	movs	r0, #1
{
 8003c3e:	460d      	mov	r5, r1
    device =  endpoint -> ux_endpoint_device;
 8003c40:	f8d8 702c 	ldr.w	r7, [r8, #44]	; 0x2c
    UX_DISABLE_INTS
 8003c44:	f7fc fb4c 	bl	80002e0 <_tx_thread_interrupt_control>
    td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_ACK_PENDING;
 8003c48:	69e3      	ldr	r3, [r4, #28]

    /* Reset NAK count.  */
    ed -> ux_stm32_ed_nak_counter = 0;
 8003c4a:	2200      	movs	r2, #0
    td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_ACK_PENDING;
 8003c4c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8003c50:	61e3      	str	r3, [r4, #28]
    ed -> ux_stm32_ed_nak_counter = 0;
 8003c52:	62ea      	str	r2, [r5, #44]	; 0x2c

    /* Reset the actual length.  */
    td -> ux_stm32_td_actual_length = 0;
 8003c54:	61a2      	str	r2, [r4, #24]
    UX_RESTORE_INTS
 8003c56:	f7fc fb43 	bl	80002e0 <_tx_thread_interrupt_control>

    /* Set the transfer size for the transaction.  */
    stm32_hctsiz_register = td -> ux_stm32_td_length;
 8003c5a:	6862      	ldr	r2, [r4, #4]

    /* Calculate the number of packets.  Isolate for ZLP. */
    if (td -> ux_stm32_td_length != 0)
 8003c5c:	2a00      	cmp	r2, #0
 8003c5e:	d049      	beq.n	8003cf4 <_ux_hcd_stm32_td_schedule+0xc4>

        /* Number of packets = transfer length / max packet count rounded to the
           next pack if necessary.  */
        number_packets =  (td -> ux_stm32_td_length + endpoint -> ux_endpoint_descriptor.wMaxPacketSize - 1) / endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8003c60:	f8d8 101c 	ldr.w	r1, [r8, #28]
 8003c64:	188b      	adds	r3, r1, r2
 8003c66:	3b01      	subs	r3, #1
 8003c68:	fbb3 f3f1 	udiv	r3, r3, r1
 8003c6c:	04d8      	lsls	r0, r3, #19
    
        /* ZLP transfer. Make it one packet only.  */
        number_packets =  1;

    /* Check the transfer direction. For IN transfers, we program the maximum transfer.  */    
    if (td -> ux_stm32_td_direction == UX_HCD_STM32_TD_IN)
 8003c6e:	6a21      	ldr	r1, [r4, #32]
 8003c70:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8003c74:	d103      	bne.n	8003c7e <_ux_hcd_stm32_td_schedule+0x4e>

        /* Transfer is IN.  */
        stm32_hctsiz_register = number_packets * endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8003c76:	f8d8 201c 	ldr.w	r2, [r8, #28]
 8003c7a:	fb02 f203 	mul.w	r2, r2, r3

    /* Add the Number of packets.  */
    stm32_hctsiz_register |=  (number_packets << UX_HCD_STM32_OTG_FS_HCTSIZ_PKTCNT_SHIFT);

    /* Identify the PID for this transaction.  */
    if (td -> ux_stm32_td_status & UX_HCD_STM32_TD_SETUP_PHASE)
 8003c7e:	69e3      	ldr	r3, [r4, #28]
    stm32_hctsiz_register |=  (number_packets << UX_HCD_STM32_OTG_FS_HCTSIZ_PKTCNT_SHIFT);
 8003c80:	4302      	orrs	r2, r0
    if (td -> ux_stm32_td_status & UX_HCD_STM32_TD_SETUP_PHASE)
 8003c82:	03db      	lsls	r3, r3, #15
        
        /* PID is SETUP.  */
        stm32_hctsiz_register |=  UX_HCD_STM32_OTG_FS_HCTSIZ_DPID_SETUP ;
            
    /* Find the toggle, the toggle may be coming from the ED.  */
    if (td -> ux_stm32_td_toggle & UX_HCD_STM32_TD_TOGGLE_FROM_ED)
 8003c84:	6a63      	ldr	r3, [r4, #36]	; 0x24
        stm32_hctsiz_register |=  UX_HCD_STM32_OTG_FS_HCTSIZ_DPID_SETUP ;
 8003c86:	bf48      	it	mi
 8003c88:	f042 42c0 	orrmi.w	r2, r2, #1610612736	; 0x60000000
    if (td -> ux_stm32_td_toggle & UX_HCD_STM32_TD_TOGGLE_FROM_ED)
 8003c8c:	2b00      	cmp	r3, #0

        toggle =  ed -> ux_stm32_ed_toggle & 1;
 8003c8e:	bfb8      	it	lt
 8003c90:	69ab      	ldrlt	r3, [r5, #24]
    else

        toggle =  td -> ux_stm32_td_toggle & 1;
 8003c92:	f003 0301 	and.w	r3, r3, #1


    /* Check value of Data Toggle : DATA0 or DATA1. */
    if (toggle != 0)
 8003c96:	b10b      	cbz	r3, 8003c9c <_ux_hcd_stm32_td_schedule+0x6c>

        /* Set the PID to DATA1.  */
        stm32_hctsiz_register |=  UX_HCD_STM32_OTG_FS_HCTSIZ_DPID_DATA1;
 8003c98:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000

    /* Store the HCTSIZ register.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCTSIZ + 
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), stm32_hctsiz_register);                    
 8003c9c:	6a29      	ldr	r1, [r5, #32]
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCTSIZ + 
 8003c9e:	4630      	mov	r0, r6
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), stm32_hctsiz_register);                    
 8003ca0:	0149      	lsls	r1, r1, #5
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCTSIZ + 
 8003ca2:	f501 61a2 	add.w	r1, r1, #1296	; 0x510
 8003ca6:	f7fd fe0b 	bl	80018c0 <_ux_hcd_stm32_register_write>
    
    /* Read the Channel register.  */
    stm32_channel_register =  _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003caa:	6a29      	ldr	r1, [r5, #32]
 8003cac:	4630      	mov	r0, r6
 8003cae:	3128      	adds	r1, #40	; 0x28
 8003cb0:	0149      	lsls	r1, r1, #5
 8003cb2:	f7fd fdfb 	bl	80018ac <_ux_hcd_stm32_register_read>
    
    /* Clear the Channel disable flag.  */
    stm32_channel_register &=  ~UX_HCD_STM32_OTG_FS_HCCHAR_CHDIS;
                
    /* Check the transfer direction. For IN transfers, we program the direction bit.  */    
    if (td -> ux_stm32_td_direction == UX_HCD_STM32_TD_IN)
 8003cb6:	6a23      	ldr	r3, [r4, #32]
 8003cb8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003cbc:	d03a      	beq.n	8003d34 <_ux_hcd_stm32_td_schedule+0x104>
 8003cbe:	4b20      	ldr	r3, [pc, #128]	; (8003d40 <_ux_hcd_stm32_td_schedule+0x110>)
 8003cc0:	4003      	ands	r3, r0
        stm32_channel_register |=  UX_HCD_STM32_OTG_FS_HCCHAR_EPDIR_IN;

    else
    
        /* Reset the DIR bit for out, it could have been set during the previous transaction.  */
        stm32_channel_register &=  ~UX_HCD_STM32_OTG_FS_HCCHAR_EPDIR_IN;
 8003cc2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000

    /* Set the device address which can change after the SET_ADDRESS command for control endpoint.  */
    stm32_channel_register |=  device -> ux_device_address << UX_HCD_STM32_OTG_FS_HCCHAR_DAD_SHIFT;
 8003cc6:	68fa      	ldr	r2, [r7, #12]
    /* Set the Max Packet Size which can also change when the Device descriptor is read the first time.  */
    stm32_channel_register &=  ~UX_HCD_STM32_OTG_FS_HCCHAR_MPSIZ_MASK;
    stm32_channel_register |=  endpoint -> ux_endpoint_descriptor.wMaxPacketSize;

    /* Set the host channel characteristics register to enable the channel. */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003cc8:	4630      	mov	r0, r6
 8003cca:	6a29      	ldr	r1, [r5, #32]
    stm32_channel_register |=  device -> ux_device_address << UX_HCD_STM32_OTG_FS_HCCHAR_DAD_SHIFT;
 8003ccc:	ea43 5382 	orr.w	r3, r3, r2, lsl #22
    stm32_channel_register &=  ~UX_HCD_STM32_OTG_FS_HCCHAR_MPSIZ_MASK;
 8003cd0:	4a1c      	ldr	r2, [pc, #112]	; (8003d44 <_ux_hcd_stm32_td_schedule+0x114>)
    stm32_channel_register |=  endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8003cd2:	f8d8 701c 	ldr.w	r7, [r8, #28]
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003cd6:	3128      	adds	r1, #40	; 0x28
    stm32_channel_register &=  ~UX_HCD_STM32_OTG_FS_HCCHAR_MPSIZ_MASK;
 8003cd8:	401a      	ands	r2, r3
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003cda:	0149      	lsls	r1, r1, #5
 8003cdc:	433a      	orrs	r2, r7
 8003cde:	f7fd fdef 	bl	80018c0 <_ux_hcd_stm32_register_write>
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), stm32_channel_register);                    

    /* If the transfer is OUT and not a ZLP, push the buffer into the appropriate FIFO.  */
    if ((td -> ux_stm32_td_direction == UX_HCD_STM32_TD_OUT) &&
 8003ce2:	6a23      	ldr	r3, [r4, #32]
 8003ce4:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8003ce8:	d008      	beq.n	8003cfc <_ux_hcd_stm32_td_schedule+0xcc>
        }
    }        

    /* Save the ed being scheduled now.  We will need it when the transaction
       is completed.  */
    hcd_stm32 -> ux_hcd_stm32_scheduled_ed =  ed;
 8003cea:	f8c6 5100 	str.w	r5, [r6, #256]	; 0x100
    
    /* We have completed the schedule.  */
    return(UX_SUCCESS);
}
 8003cee:	2000      	movs	r0, #0
 8003cf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003cf4:	f44f 2000 	mov.w	r0, #524288	; 0x80000
        number_packets =  1;
 8003cf8:	2301      	movs	r3, #1
 8003cfa:	e7b8      	b.n	8003c6e <_ux_hcd_stm32_td_schedule+0x3e>
        (td -> ux_stm32_td_length != 0))
 8003cfc:	6863      	ldr	r3, [r4, #4]
    if ((td -> ux_stm32_td_direction == UX_HCD_STM32_TD_OUT) &&
 8003cfe:	2b00      	cmp	r3, #0
 8003d00:	d0f3      	beq.n	8003cea <_ux_hcd_stm32_td_schedule+0xba>
        dword_count =  (td -> ux_stm32_td_length + 3) / sizeof(ULONG);
 8003d02:	3303      	adds	r3, #3
        buffer =  td -> ux_stm32_td_buffer;
 8003d04:	6827      	ldr	r7, [r4, #0]
        while (dword_count-- != 0)
 8003d06:	089b      	lsrs	r3, r3, #2
 8003d08:	d0ef      	beq.n	8003cea <_ux_hcd_stm32_td_schedule+0xba>
 8003d0a:	eb07 0883 	add.w	r8, r7, r3, lsl #2
            _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_FIFO + 
 8003d0e:	6a29      	ldr	r1, [r5, #32]
 8003d10:	4638      	mov	r0, r7
            buffer += sizeof(ULONG);
 8003d12:	3704      	adds	r7, #4
            _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_FIFO + 
 8003d14:	3101      	adds	r1, #1
 8003d16:	030c      	lsls	r4, r1, #12
 8003d18:	f000 fc04 	bl	8004524 <_ux_utility_long_get>
 8003d1c:	4602      	mov	r2, r0
 8003d1e:	4621      	mov	r1, r4
 8003d20:	4630      	mov	r0, r6
 8003d22:	f7fd fdcd 	bl	80018c0 <_ux_hcd_stm32_register_write>
        while (dword_count-- != 0)
 8003d26:	4547      	cmp	r7, r8
 8003d28:	d1f1      	bne.n	8003d0e <_ux_hcd_stm32_td_schedule+0xde>
    hcd_stm32 -> ux_hcd_stm32_scheduled_ed =  ed;
 8003d2a:	f8c6 5100 	str.w	r5, [r6, #256]	; 0x100
}
 8003d2e:	2000      	movs	r0, #0
 8003d30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003d34:	f020 4380 	bic.w	r3, r0, #1073741824	; 0x40000000
        stm32_channel_register |=  UX_HCD_STM32_OTG_FS_HCCHAR_EPDIR_IN;
 8003d38:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8003d3c:	e7c3      	b.n	8003cc6 <_ux_hcd_stm32_td_schedule+0x96>
 8003d3e:	bf00      	nop
 8003d40:	bfff7fff 	.word	0xbfff7fff
 8003d44:	fffff800 	.word	0xfffff800

08003d48 <_ux_hcd_stm32_transfer_abort>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_transfer_abort(UX_HCD_STM32 *hcd_stm32, UX_TRANSFER *transfer_request)
{
 8003d48:	b570      	push	{r4, r5, r6, lr}
UX_HCD_STM32_ED     *ed;
ULONG               endpoint_type;
ULONG               stm32_channel_register;

    /* Get the pointer to the endpoint associated with the transfer request.  */
    endpoint =  (UX_ENDPOINT *) transfer_request -> ux_transfer_request_endpoint;
 8003d4a:	684e      	ldr	r6, [r1, #4]
    
    /* From the endpoint container, get the address of the physical endpoint.  */
    ed =  (UX_HCD_STM32_ED *) endpoint -> ux_endpoint_ed;
 8003d4c:	68b4      	ldr	r4, [r6, #8]
    
    /* Check if this physical endpoint has been initialized properly!  */
    if (ed == UX_NULL)
 8003d4e:	2c00      	cmp	r4, #0
 8003d50:	d05a      	beq.n	8003e08 <_ux_hcd_stm32_transfer_abort+0xc0>

        return(UX_ENDPOINT_HANDLE_UNKNOWN);
    }

    /* The endpoint may be active. If so, set the skip bit.  */
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8003d52:	6923      	ldr	r3, [r4, #16]
 8003d54:	4605      	mov	r5, r0

    /* Wait for the controller to finish the current frame processing.  */
    _ux_utility_delay_ms(1);
 8003d56:	2001      	movs	r0, #1
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8003d58:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8003d5c:	6123      	str	r3, [r4, #16]
    _ux_utility_delay_ms(1);
 8003d5e:	f7fd ffb9 	bl	8001cd4 <_ux_utility_delay_ms>

    /* Only allow the Channel Halt bit interrupt.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), UX_HCD_STM32_OTG_FS_HCINT_CHHM);                    
 8003d62:	6a21      	ldr	r1, [r4, #32]
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
 8003d64:	2202      	movs	r2, #2
 8003d66:	4628      	mov	r0, r5
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), UX_HCD_STM32_OTG_FS_HCINT_CHHM);                    
 8003d68:	0149      	lsls	r1, r1, #5
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
 8003d6a:	f201 510c 	addw	r1, r1, #1292	; 0x50c
 8003d6e:	f7fd fda7 	bl	80018c0 <_ux_hcd_stm32_register_write>

    /* Read the channel characteristic register.  */
    stm32_channel_register = _ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003d72:	6a21      	ldr	r1, [r4, #32]
 8003d74:	4628      	mov	r0, r5
 8003d76:	3128      	adds	r1, #40	; 0x28
 8003d78:	0149      	lsls	r1, r1, #5
 8003d7a:	f7fd fd97 	bl	80018ac <_ux_hcd_stm32_register_read>
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE));

    /* We only Halt the channel on an endpoint which has a pending transfer.  */
    if (stm32_channel_register & UX_HCD_STM32_OTG_FS_HCCHAR_CHENA)
 8003d7e:	2800      	cmp	r0, #0
 8003d80:	db39      	blt.n	8003df6 <_ux_hcd_stm32_transfer_abort+0xae>
                                    (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), (stm32_channel_register | UX_HCD_STM32_OTG_FS_HCCHAR_CHDIS));                    

    }

    /* Wait for the controller to finish halting the channel. */
    _ux_utility_delay_ms(1);
 8003d82:	2001      	movs	r0, #1
 8003d84:	f7fd ffa6 	bl	8001cd4 <_ux_utility_delay_ms>

    /* Flush FIFOs.  */
    if ((endpoint -> ux_endpoint_descriptor.bEndpointAddress & 0x80) == 0)
 8003d88:	6973      	ldr	r3, [r6, #20]
 8003d8a:	0619      	lsls	r1, r3, #24
 8003d8c:	d51d      	bpl.n	8003dca <_ux_hcd_stm32_transfer_abort+0x82>
        while (_ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL) & UX_HCD_STM32_OTG_FS_GRSTCTL_TXFFLSH);
    }

    /* Re-enable the Host channel interrupt mask register.  */
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), UX_HCD_STM32_OTG_FS_HCINT_DEFAULT);
 8003d8e:	6a21      	ldr	r1, [r4, #32]
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
 8003d90:	4628      	mov	r0, r5
 8003d92:	f240 72fb 	movw	r2, #2043	; 0x7fb
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), UX_HCD_STM32_OTG_FS_HCINT_DEFAULT);
 8003d96:	0149      	lsls	r1, r1, #5
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
 8003d98:	f201 510c 	addw	r1, r1, #1292	; 0x50c
 8003d9c:	f7fd fd90 	bl	80018c0 <_ux_hcd_stm32_register_write>

    /* Reset TDs (until there is dummy one created on endpoint creation).  */
    while (ed -> ux_stm32_ed_head_td != ed -> ux_stm32_ed_tail_td)
 8003da0:	e9d4 0100 	ldrd	r0, r1, [r4]
 8003da4:	4288      	cmp	r0, r1
 8003da6:	d00b      	beq.n	8003dc0 <_ux_hcd_stm32_transfer_abort+0x78>
    {

        /* Double confirm, last TD's next is NULL.  */
        if (ed -> ux_stm32_ed_head_td -> ux_stm32_td_next_td == UX_NULL)
 8003da8:	688b      	ldr	r3, [r1, #8]
 8003daa:	b14b      	cbz	r3, 8003dc0 <_ux_hcd_stm32_transfer_abort+0x78>
            break;

        /* Discard the TD in header.  */
        ed -> ux_stm32_ed_head_td -> ux_stm32_td_status = UX_UNUSED;
 8003dac:	2500      	movs	r5, #0
 8003dae:	e002      	b.n	8003db6 <_ux_hcd_stm32_transfer_abort+0x6e>
        if (ed -> ux_stm32_ed_head_td -> ux_stm32_td_next_td == UX_NULL)
 8003db0:	689a      	ldr	r2, [r3, #8]
 8003db2:	b1d2      	cbz	r2, 8003dea <_ux_hcd_stm32_transfer_abort+0xa2>
 8003db4:	4613      	mov	r3, r2
    while (ed -> ux_stm32_ed_head_td != ed -> ux_stm32_ed_tail_td)
 8003db6:	4298      	cmp	r0, r3
        ed -> ux_stm32_ed_head_td -> ux_stm32_td_status = UX_UNUSED;
 8003db8:	61cd      	str	r5, [r1, #28]
 8003dba:	4619      	mov	r1, r3
    while (ed -> ux_stm32_ed_head_td != ed -> ux_stm32_ed_tail_td)
 8003dbc:	d1f8      	bne.n	8003db0 <_ux_hcd_stm32_transfer_abort+0x68>
 8003dbe:	6060      	str	r0, [r4, #4]
        ed -> ux_stm32_ed_head_td = ed -> ux_stm32_ed_head_td -> ux_stm32_td_next_td;
    }

    /* Remove the reset bit in the ED.  */
    ed -> ux_stm32_ed_status =  ~UX_HCD_STM32_ED_SKIP;
 8003dc0:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000

    /* Return successful completion.  */
    return(UX_SUCCESS);         
 8003dc4:	2000      	movs	r0, #0
    ed -> ux_stm32_ed_status =  ~UX_HCD_STM32_ED_SKIP;
 8003dc6:	6123      	str	r3, [r4, #16]
}
 8003dc8:	bd70      	pop	{r4, r5, r6, pc}
        if (endpoint_type == 0 || endpoint_type == 2)
 8003dca:	69b3      	ldr	r3, [r6, #24]
            _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL, (1|UX_HCD_STM32_OTG_FS_GRSTCTL_TXFFLSH));
 8003dcc:	2110      	movs	r1, #16
 8003dce:	4628      	mov	r0, r5
        if (endpoint_type == 0 || endpoint_type == 2)
 8003dd0:	07da      	lsls	r2, r3, #31
            _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL, (0|UX_HCD_STM32_OTG_FS_GRSTCTL_TXFFLSH));
 8003dd2:	bf54      	ite	pl
 8003dd4:	2220      	movpl	r2, #32
            _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL, (1|UX_HCD_STM32_OTG_FS_GRSTCTL_TXFFLSH));
 8003dd6:	2221      	movmi	r2, #33	; 0x21
 8003dd8:	f7fd fd72 	bl	80018c0 <_ux_hcd_stm32_register_write>
        while (_ux_hcd_stm32_register_read(hcd_stm32, UX_HCD_STM32_OTG_FS_GRSTCTL) & UX_HCD_STM32_OTG_FS_GRSTCTL_TXFFLSH);
 8003ddc:	2110      	movs	r1, #16
 8003dde:	4628      	mov	r0, r5
 8003de0:	f7fd fd64 	bl	80018ac <_ux_hcd_stm32_register_read>
 8003de4:	0683      	lsls	r3, r0, #26
 8003de6:	d4f9      	bmi.n	8003ddc <_ux_hcd_stm32_transfer_abort+0x94>
 8003de8:	e7d1      	b.n	8003d8e <_ux_hcd_stm32_transfer_abort+0x46>
 8003dea:	6063      	str	r3, [r4, #4]
    ed -> ux_stm32_ed_status =  ~UX_HCD_STM32_ED_SKIP;
 8003dec:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
    return(UX_SUCCESS);         
 8003df0:	2000      	movs	r0, #0
    ed -> ux_stm32_ed_status =  ~UX_HCD_STM32_ED_SKIP;
 8003df2:	6123      	str	r3, [r4, #16]
 8003df4:	e7e8      	b.n	8003dc8 <_ux_hcd_stm32_transfer_abort+0x80>
        _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8003df6:	6a21      	ldr	r1, [r4, #32]
 8003df8:	f040 4280 	orr.w	r2, r0, #1073741824	; 0x40000000
 8003dfc:	4628      	mov	r0, r5
 8003dfe:	3128      	adds	r1, #40	; 0x28
 8003e00:	0149      	lsls	r1, r1, #5
 8003e02:	f7fd fd5d 	bl	80018c0 <_ux_hcd_stm32_register_write>
 8003e06:	e7bc      	b.n	8003d82 <_ux_hcd_stm32_transfer_abort+0x3a>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HCD, UX_ENDPOINT_HANDLE_UNKNOWN);
 8003e08:	2253      	movs	r2, #83	; 0x53
 8003e0a:	2101      	movs	r1, #1
 8003e0c:	2002      	movs	r0, #2
 8003e0e:	f7fd fef7 	bl	8001c00 <_ux_system_error_handler>
        return(UX_ENDPOINT_HANDLE_UNKNOWN);
 8003e12:	2053      	movs	r0, #83	; 0x53
}
 8003e14:	bd70      	pop	{r4, r5, r6, pc}
 8003e16:	bf00      	nop

08003e18 <_ux_host_stack_class_instance_create>:

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_REGISTER(UX_TRACE_HOST_OBJECT_TYPE_CLASS_INSTANCE, class_instance, 0, 0, 0)

    /* Start with the first class instance attached to the class container.  */
    current_class_instance =  host_class -> ux_host_class_first_instance;
 8003e18:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
    
    /* Check if there are any instances attached.  */
    if (current_class_instance == UX_NULL)
 8003e1a:	b90a      	cbnz	r2, 8003e20 <_ux_host_stack_class_instance_create+0x8>
 8003e1c:	e006      	b.n	8003e2c <_ux_host_stack_class_instance_create+0x14>
 8003e1e:	461a      	mov	r2, r3
        /* Return successful completion.  */
        return(UX_SUCCESS);
    }

    /* Traverse the list of the class instances until we find the last class.  */        
    while (*current_class_instance != UX_NULL)
 8003e20:	6813      	ldr	r3, [r2, #0]
 8003e22:	2b00      	cmp	r3, #0
 8003e24:	d1fb      	bne.n	8003e1e <_ux_host_stack_class_instance_create+0x6>
        current_class_instance =  *current_class_instance;
    }

    /* We have reached the last class, hook the new class to the end. This way, we preserve
       the chronological order of the class instances.  */
    *current_class_instance =  class_instance;
 8003e26:	6011      	str	r1, [r2, #0]
    
    /* Return successful completion to caller.  */
    return(UX_SUCCESS);
}
 8003e28:	2000      	movs	r0, #0
 8003e2a:	4770      	bx	lr
        host_class -> ux_host_class_first_instance =  class_instance;
 8003e2c:	64c1      	str	r1, [r0, #76]	; 0x4c
}
 8003e2e:	2000      	movs	r0, #0
 8003e30:	4770      	bx	lr
 8003e32:	bf00      	nop

08003e34 <_ux_host_stack_class_instance_destroy>:
    /* Get the pointer to the instance pointed by the instance to destroy.  */
    next_class_instance =  class_instance;
    next_class_instance =  *next_class_instance;
    
    /* Start with the first class instance attached to the class container.  */
    current_class_instance =  host_class -> ux_host_class_first_instance;
 8003e34:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
{
 8003e36:	b510      	push	{r4, lr}
    next_class_instance =  *next_class_instance;
 8003e38:	680c      	ldr	r4, [r1, #0]
    
    /* Check if there are any instances attached.  */
    if (current_class_instance == UX_NULL)
 8003e3a:	b142      	cbz	r2, 8003e4e <_ux_host_stack_class_instance_destroy+0x1a>
        return(UX_HOST_CLASS_INSTANCE_UNKNOWN);
    }

    /* The first instance is a special case because it is attached to the class
       container.  */
    if (current_class_instance == class_instance)
 8003e3c:	4291      	cmp	r1, r2
 8003e3e:	d103      	bne.n	8003e48 <_ux_host_stack_class_instance_destroy+0x14>
 8003e40:	e00f      	b.n	8003e62 <_ux_host_stack_class_instance_destroy+0x2e>
    /* Traverse the list of the class instances until we found the right one.  */        
    while (*current_class_instance != UX_NULL)
    {

        /* Check to see if this class is the one we need to destroy.  */
        if(*current_class_instance == class_instance)
 8003e42:	428b      	cmp	r3, r1
 8003e44:	d00a      	beq.n	8003e5c <_ux_host_stack_class_instance_destroy+0x28>
 8003e46:	461a      	mov	r2, r3
    while (*current_class_instance != UX_NULL)
 8003e48:	6813      	ldr	r3, [r2, #0]
 8003e4a:	2b00      	cmp	r3, #0
 8003e4c:	d1f9      	bne.n	8003e42 <_ux_host_stack_class_instance_destroy+0xe>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_HOST_CLASS_INSTANCE_UNKNOWN);
 8003e4e:	225b      	movs	r2, #91	; 0x5b
 8003e50:	2104      	movs	r1, #4
 8003e52:	2002      	movs	r0, #2
 8003e54:	f7fd fed4 	bl	8001c00 <_ux_system_error_handler>
        return(UX_HOST_CLASS_INSTANCE_UNKNOWN);
 8003e58:	205b      	movs	r0, #91	; 0x5b
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_HOST_CLASS_INSTANCE_UNKNOWN, class_instance, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* Return error to caller.  */
    return(UX_HOST_CLASS_INSTANCE_UNKNOWN);
}
 8003e5a:	bd10      	pop	{r4, pc}
            *current_class_instance =  next_class_instance;
 8003e5c:	6014      	str	r4, [r2, #0]
            return(UX_SUCCESS);
 8003e5e:	2000      	movs	r0, #0
}
 8003e60:	bd10      	pop	{r4, pc}
        host_class -> ux_host_class_first_instance = next_class_instance;
 8003e62:	64c4      	str	r4, [r0, #76]	; 0x4c
        return(UX_SUCCESS);
 8003e64:	2000      	movs	r0, #0
}
 8003e66:	bd10      	pop	{r4, pc}

08003e68 <_ux_host_stack_configuration_interface_get>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_configuration_interface_get(UX_CONFIGURATION *configuration, 
                                                UINT interface_index, UINT alternate_setting_index,
                                                UX_INTERFACE **interface)
{
 8003e68:	b538      	push	{r3, r4, r5, lr}
UINT                container_index;
UX_INTERFACE        *current_interface;


    /* Do a sanity check on the configuration handle.  */
    if (configuration -> ux_configuration_handle != (ULONG) (ALIGN_TYPE) configuration)
 8003e6a:	6804      	ldr	r4, [r0, #0]
 8003e6c:	42a0      	cmp	r0, r4
 8003e6e:	d11c      	bne.n	8003eaa <_ux_host_stack_configuration_interface_get+0x42>
    
        return(UX_CONFIGURATION_HANDLE_UNKNOWN);
    }
            
    /* Start with the interface attached to the configuration.  */
    current_interface =  configuration -> ux_configuration_first_interface;
 8003e70:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
    
    /* Reset the interface number */
    current_interface_number =  0;
    
    /* Traverse the list of the interfaces until we found the right one */        
    while (current_interface != UX_NULL)
 8003e72:	b198      	cbz	r0, 8003e9c <_ux_host_stack_configuration_interface_get+0x34>
    {

        /* Check if the interface index matches the current one.  */
        if (interface_index == container_index)
 8003e74:	b129      	cbz	r1, 8003e82 <_ux_host_stack_configuration_interface_get+0x1a>
    container_index =  0;
 8003e76:	2400      	movs	r4, #0
        /* Check the current interface, we may already be at the end ... */
        if (current_interface != UX_NULL)
        {
        
            /* Move to the next interface.  */
            current_interface =  current_interface -> ux_interface_next_interface;
 8003e78:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
        
            /* Move to the next interface index. */
            container_index++;
 8003e7a:	3401      	adds	r4, #1
    while (current_interface != UX_NULL)
 8003e7c:	b170      	cbz	r0, 8003e9c <_ux_host_stack_configuration_interface_get+0x34>
        if (interface_index == container_index)
 8003e7e:	42a1      	cmp	r1, r4
 8003e80:	d1fa      	bne.n	8003e78 <_ux_host_stack_configuration_interface_get+0x10>
            current_interface_number =  current_interface -> ux_interface_descriptor.bInterfaceNumber;
 8003e82:	6945      	ldr	r5, [r0, #20]
                if (alternate_setting_index == container_index)
 8003e84:	b19a      	cbz	r2, 8003eae <_ux_host_stack_configuration_interface_get+0x46>
            container_index =  0;
 8003e86:	2100      	movs	r1, #0
 8003e88:	e004      	b.n	8003e94 <_ux_host_stack_configuration_interface_get+0x2c>
                    if (current_interface -> ux_interface_descriptor.bInterfaceNumber != current_interface_number)
 8003e8a:	6944      	ldr	r4, [r0, #20]
 8003e8c:	42ac      	cmp	r4, r5
 8003e8e:	d105      	bne.n	8003e9c <_ux_host_stack_configuration_interface_get+0x34>
                if (alternate_setting_index == container_index)
 8003e90:	428a      	cmp	r2, r1
 8003e92:	d00c      	beq.n	8003eae <_ux_host_stack_configuration_interface_get+0x46>
                current_interface =  current_interface -> ux_interface_next_interface;
 8003e94:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
                container_index++;
 8003e96:	3101      	adds	r1, #1
                if (current_interface != UX_NULL)
 8003e98:	2800      	cmp	r0, #0
 8003e9a:	d1f6      	bne.n	8003e8a <_ux_host_stack_configuration_interface_get+0x22>
                        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_INTERFACE_HANDLE_UNKNOWN);
 8003e9c:	2252      	movs	r2, #82	; 0x52
 8003e9e:	2104      	movs	r1, #4
 8003ea0:	2002      	movs	r0, #2
 8003ea2:	f7fd fead 	bl	8001c00 <_ux_system_error_handler>
                        return(UX_INTERFACE_HANDLE_UNKNOWN);
 8003ea6:	2052      	movs	r0, #82	; 0x52
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_INTERFACE_HANDLE_UNKNOWN, interface, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* Didn't find the right interface/alternate setting, return an error!  */
    return(UX_INTERFACE_HANDLE_UNKNOWN);
}
 8003ea8:	bd38      	pop	{r3, r4, r5, pc}
        return(UX_CONFIGURATION_HANDLE_UNKNOWN);
 8003eaa:	2051      	movs	r0, #81	; 0x51
}
 8003eac:	bd38      	pop	{r3, r4, r5, pc}
                    *interface =  current_interface;
 8003eae:	6018      	str	r0, [r3, #0]
                    return(UX_SUCCESS);
 8003eb0:	2000      	movs	r0, #0
}
 8003eb2:	bd38      	pop	{r3, r4, r5, pc}

08003eb4 <_ux_host_stack_device_configuration_get>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_device_configuration_get(UX_DEVICE *device, UINT configuration_index,
                                                        UX_CONFIGURATION **configuration)
{
 8003eb4:	b508      	push	{r3, lr}

UINT                    current_configuration_index;
UX_CONFIGURATION        *current_configuration;

    /* Do a sanity check on the device handle.  */
    if (device -> ux_device_handle != (ULONG) (ALIGN_TYPE) device)
 8003eb6:	6803      	ldr	r3, [r0, #0]
 8003eb8:	4298      	cmp	r0, r3
 8003eba:	d114      	bne.n	8003ee6 <_ux_host_stack_device_configuration_get+0x32>

        return(UX_DEVICE_HANDLE_UNKNOWN);
    }
        
    /* Start with the configuration attached to the device.  */
    current_configuration =  device -> ux_device_first_configuration;
 8003ebc:	6d43      	ldr	r3, [r0, #84]	; 0x54

    /* The first configuration has the index 0.  */    
    current_configuration_index =  0;
    
    /* Traverse the list of the configurations until we found the right one.  */        
    while (current_configuration != UX_NULL)
 8003ebe:	b143      	cbz	r3, 8003ed2 <_ux_host_stack_device_configuration_get+0x1e>
    {

        /* Check if the configuration index matches the current one.  */
        if (configuration_index == current_configuration_index)
 8003ec0:	b171      	cbz	r1, 8003ee0 <_ux_host_stack_device_configuration_get+0x2c>
    current_configuration_index =  0;
 8003ec2:	2000      	movs	r0, #0
 8003ec4:	e001      	b.n	8003eca <_ux_host_stack_device_configuration_get+0x16>
        if (configuration_index == current_configuration_index)
 8003ec6:	4281      	cmp	r1, r0
 8003ec8:	d00a      	beq.n	8003ee0 <_ux_host_stack_device_configuration_get+0x2c>
            /* Return successful completion.  */
            return(UX_SUCCESS);
        }
        
        /* Move to the next configuration.  */
        current_configuration =  current_configuration -> ux_configuration_next_configuration;
 8003eca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
        
        /* Move to the next index.  */
        current_configuration_index++;
 8003ecc:	3001      	adds	r0, #1
    while (current_configuration != UX_NULL)
 8003ece:	2b00      	cmp	r3, #0
 8003ed0:	d1f9      	bne.n	8003ec6 <_ux_host_stack_device_configuration_get+0x12>
    }
    
    /* Error trap. */
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_CONFIGURATION_HANDLE_UNKNOWN);
 8003ed2:	2251      	movs	r2, #81	; 0x51
 8003ed4:	2104      	movs	r1, #4
 8003ed6:	2002      	movs	r0, #2
 8003ed8:	f7fd fe92 	bl	8001c00 <_ux_system_error_handler>

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_CONFIGURATION_HANDLE_UNKNOWN, configuration, 0, 0, UX_TRACE_ERRORS, 0, 0)
    
    /* Return an error.  */
    return(UX_CONFIGURATION_HANDLE_UNKNOWN);
 8003edc:	2051      	movs	r0, #81	; 0x51
}
 8003ede:	bd08      	pop	{r3, pc}
            *configuration =  current_configuration;
 8003ee0:	6013      	str	r3, [r2, #0]
            return(UX_SUCCESS);
 8003ee2:	2000      	movs	r0, #0
}
 8003ee4:	bd08      	pop	{r3, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_DEVICE_HANDLE_UNKNOWN);
 8003ee6:	2250      	movs	r2, #80	; 0x50
 8003ee8:	2104      	movs	r1, #4
 8003eea:	2002      	movs	r0, #2
 8003eec:	f7fd fe88 	bl	8001c00 <_ux_system_error_handler>
        return(UX_DEVICE_HANDLE_UNKNOWN);
 8003ef0:	2050      	movs	r0, #80	; 0x50
}
 8003ef2:	bd08      	pop	{r3, pc}

08003ef4 <_ux_host_stack_device_configuration_select>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_device_configuration_select(UX_CONFIGURATION *configuration)
{
 8003ef4:	b538      	push	{r3, r4, r5, lr}
UX_DEVICE               *device;
UX_CONFIGURATION        *current_configuration;
UINT                    status;
    
    /* Check for validity of the configuration handle.  */
    if (configuration -> ux_configuration_handle != (ULONG) (ALIGN_TYPE) configuration)
 8003ef6:	6803      	ldr	r3, [r0, #0]
 8003ef8:	4298      	cmp	r0, r3
 8003efa:	d123      	bne.n	8003f44 <_ux_host_stack_device_configuration_select+0x50>
    
        return(UX_CONFIGURATION_HANDLE_UNKNOWN);
    }

    /* Get the device container for this configuration.  */       
    device =  configuration -> ux_configuration_device;
 8003efc:	6b45      	ldr	r5, [r0, #52]	; 0x34
 8003efe:	4604      	mov	r4, r0
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_DEVICE_CONFIGURATION_SELECT, device, configuration, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    /* Check for the state of the device . If the device is already configured, 
       we need to cancel the existing configuration before enabling this one.   */
    if (device -> ux_device_state == UX_DEVICE_CONFIGURED)
 8003f00:	68ab      	ldr	r3, [r5, #8]
 8003f02:	2b03      	cmp	r3, #3
 8003f04:	d008      	beq.n	8003f18 <_ux_host_stack_device_configuration_select+0x24>

    /* The device is now in the unconfigured state. We need to deal
       with the amount of power the device is consuming before allowing
       it to be configured. Otherwise we may run the risk of an over
       current fault. */        
    if (configuration -> ux_configuration_descriptor.MaxPower > device -> ux_device_max_power)
 8003f06:	69ab      	ldr	r3, [r5, #24]
 8003f08:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8003f0a:	429a      	cmp	r2, r3
 8003f0c:	d813      	bhi.n	8003f36 <_ux_host_stack_device_configuration_select+0x42>
    
        return(UX_OVER_CURRENT_CONDITION);
    }
        
    /* The device can now be configured.  */
    status =  _ux_host_stack_configuration_set(configuration);
 8003f0e:	4620      	mov	r0, r4
 8003f10:	f001 f9ac 	bl	800526c <_ux_host_stack_configuration_set>
    if (status != UX_SUCCESS)
 8003f14:	b1e8      	cbz	r0, 8003f52 <_ux_host_stack_device_configuration_select+0x5e>
    /* Create the configuration instance.  */
    status =  _ux_host_stack_configuration_instance_create(configuration);

    /* Return completion status.  */
    return(status);
}
 8003f16:	bd38      	pop	{r3, r4, r5, pc}
        current_configuration =  device -> ux_device_first_configuration;
 8003f18:	6d68      	ldr	r0, [r5, #84]	; 0x54
                device -> ux_device_current_configuration)
 8003f1a:	6a2a      	ldr	r2, [r5, #32]
        while (current_configuration -> ux_configuration_descriptor.bConfigurationValue !=
 8003f1c:	69c3      	ldr	r3, [r0, #28]
 8003f1e:	4293      	cmp	r3, r2
 8003f20:	d003      	beq.n	8003f2a <_ux_host_stack_device_configuration_select+0x36>
            current_configuration =  current_configuration -> ux_configuration_next_configuration;
 8003f22:	6b00      	ldr	r0, [r0, #48]	; 0x30
        while (current_configuration -> ux_configuration_descriptor.bConfigurationValue !=
 8003f24:	69c3      	ldr	r3, [r0, #28]
 8003f26:	4293      	cmp	r3, r2
 8003f28:	d1fb      	bne.n	8003f22 <_ux_host_stack_device_configuration_select+0x2e>
        _ux_host_stack_configuration_instance_delete(current_configuration);
 8003f2a:	f001 f98b 	bl	8005244 <_ux_host_stack_configuration_instance_delete>
    if (configuration -> ux_configuration_descriptor.MaxPower > device -> ux_device_max_power)
 8003f2e:	69ab      	ldr	r3, [r5, #24]
 8003f30:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8003f32:	429a      	cmp	r2, r3
 8003f34:	d9eb      	bls.n	8003f0e <_ux_host_stack_device_configuration_select+0x1a>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_OVER_CURRENT_CONDITION);
 8003f36:	2243      	movs	r2, #67	; 0x43
 8003f38:	2104      	movs	r1, #4
 8003f3a:	2002      	movs	r0, #2
 8003f3c:	f7fd fe60 	bl	8001c00 <_ux_system_error_handler>
        return(UX_OVER_CURRENT_CONDITION);
 8003f40:	2043      	movs	r0, #67	; 0x43
}
 8003f42:	bd38      	pop	{r3, r4, r5, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_CONFIGURATION_HANDLE_UNKNOWN);
 8003f44:	2251      	movs	r2, #81	; 0x51
 8003f46:	2104      	movs	r1, #4
 8003f48:	2002      	movs	r0, #2
 8003f4a:	f7fd fe59 	bl	8001c00 <_ux_system_error_handler>
        return(UX_CONFIGURATION_HANDLE_UNKNOWN);
 8003f4e:	2051      	movs	r0, #81	; 0x51
}
 8003f50:	bd38      	pop	{r3, r4, r5, pc}
    status =  _ux_host_stack_configuration_instance_create(configuration);
 8003f52:	4620      	mov	r0, r4
}
 8003f54:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    status =  _ux_host_stack_configuration_instance_create(configuration);
 8003f58:	f001 b962 	b.w	8005220 <_ux_host_stack_configuration_instance_create>

08003f5c <_ux_host_stack_device_remove>:
UX_INTERFACE                *interface;
UX_HOST_CLASS_COMMAND       command;

    /* We need to find the device descriptor for the removed device. We can find it 
       with the parent device and the port it was attached to. Start with the first device.  */
    device =  _ux_system_host -> ux_system_host_device_array;    
 8003f5c:	4b29      	ldr	r3, [pc, #164]	; (8004004 <_ux_host_stack_device_remove+0xa8>)
 8003f5e:	681b      	ldr	r3, [r3, #0]
{
 8003f60:	b5f0      	push	{r4, r5, r6, r7, lr}
    device =  _ux_system_host -> ux_system_host_device_array;    
 8003f62:	e9d3 4606 	ldrd	r4, r6, [r3, #24]
{
 8003f66:	b08f      	sub	sp, #60	; 0x3c

    /* Start at the beginning of the list.  */
    container_index =  0;

    /* Search the list until the end.  */
    while (container_index++ < _ux_system_host -> ux_system_host_max_devices)
 8003f68:	b346      	cbz	r6, 8003fbc <_ux_host_stack_device_remove+0x60>
 8003f6a:	3601      	adds	r6, #1
 8003f6c:	2301      	movs	r3, #1
 8003f6e:	e003      	b.n	8003f78 <_ux_host_stack_device_remove+0x1c>
 8003f70:	429e      	cmp	r6, r3
                return(UX_SUCCESS);
            }                
        }   

        /* Move to the next device entry.  */
        device++;
 8003f72:	f504 74b6 	add.w	r4, r4, #364	; 0x16c
    while (container_index++ < _ux_system_host -> ux_system_host_max_devices)
 8003f76:	d021      	beq.n	8003fbc <_ux_host_stack_device_remove+0x60>
        if (device -> ux_device_handle != UX_UNUSED)
 8003f78:	6825      	ldr	r5, [r4, #0]
    while (container_index++ < _ux_system_host -> ux_system_host_max_devices)
 8003f7a:	3301      	adds	r3, #1
        if (device -> ux_device_handle != UX_UNUSED)
 8003f7c:	2d00      	cmp	r5, #0
 8003f7e:	d0f7      	beq.n	8003f70 <_ux_host_stack_device_remove+0x14>
            if((device -> ux_device_parent == parent) && (device -> ux_device_port_location == port_index) &&
 8003f80:	6c65      	ldr	r5, [r4, #68]	; 0x44
 8003f82:	428d      	cmp	r5, r1
 8003f84:	d1f4      	bne.n	8003f70 <_ux_host_stack_device_remove+0x14>
 8003f86:	6965      	ldr	r5, [r4, #20]
 8003f88:	4295      	cmp	r5, r2
 8003f8a:	d1f1      	bne.n	8003f70 <_ux_host_stack_device_remove+0x14>
               (device -> ux_device_hcd == hcd))
 8003f8c:	6d25      	ldr	r5, [r4, #80]	; 0x50
            if((device -> ux_device_parent == parent) && (device -> ux_device_port_location == port_index) &&
 8003f8e:	4285      	cmp	r5, r0
 8003f90:	d1ee      	bne.n	8003f70 <_ux_host_stack_device_remove+0x14>
                device -> ux_device_state = UX_DEVICE_REMOVED;
 8003f92:	210a      	movs	r1, #10
                command.ux_host_class_command_request =  UX_HOST_CLASS_COMMAND_DEACTIVATE;
 8003f94:	2203      	movs	r2, #3
                if (device -> ux_device_class_instance != UX_NULL)
 8003f96:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
                device -> ux_device_state = UX_DEVICE_REMOVED;
 8003f98:	60a1      	str	r1, [r4, #8]
                command.ux_host_class_command_request =  UX_HOST_CLASS_COMMAND_DEACTIVATE;
 8003f9a:	9201      	str	r2, [sp, #4]
                if (device -> ux_device_class_instance != UX_NULL)
 8003f9c:	b1b3      	cbz	r3, 8003fcc <_ux_host_stack_device_remove+0x70>
                    device -> ux_device_class -> ux_host_class_entry_function(&command);
 8003f9e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8003fa0:	a801      	add	r0, sp, #4
                    command.ux_host_class_command_instance =  device -> ux_device_class_instance;
 8003fa2:	9303      	str	r3, [sp, #12]
                    device -> ux_device_class -> ux_host_class_entry_function(&command);
 8003fa4:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8003fa6:	4798      	blx	r3
                _ux_host_stack_device_resources_free(device);                
 8003fa8:	4620      	mov	r0, r4
 8003faa:	f000 f82d 	bl	8004008 <_ux_host_stack_device_resources_free>
                hcd -> ux_hcd_nb_devices--;
 8003fae:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
                return(UX_SUCCESS);
 8003fb2:	2000      	movs	r0, #0
                hcd -> ux_hcd_nb_devices--;
 8003fb4:	3b01      	subs	r3, #1
 8003fb6:	f8c5 30a4 	str.w	r3, [r5, #164]	; 0xa4
                return(UX_SUCCESS);
 8003fba:	e005      	b.n	8003fc8 <_ux_host_stack_device_remove+0x6c>
    }

    /* Error trap. */
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_DEVICE_HANDLE_UNKNOWN);
 8003fbc:	2002      	movs	r0, #2
 8003fbe:	2250      	movs	r2, #80	; 0x50
 8003fc0:	2104      	movs	r1, #4
 8003fc2:	f7fd fe1d 	bl	8001c00 <_ux_system_error_handler>

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_DEVICE_HANDLE_UNKNOWN, device, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* We get here when we could not find the device.  */
    return(UX_DEVICE_HANDLE_UNKNOWN);
 8003fc6:	2050      	movs	r0, #80	; 0x50
}
 8003fc8:	b00f      	add	sp, #60	; 0x3c
 8003fca:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    configuration =  device -> ux_device_first_configuration;
 8003fcc:	6d67      	ldr	r7, [r4, #84]	; 0x54
                    while (configuration != UX_NULL)
 8003fce:	b91f      	cbnz	r7, 8003fd8 <_ux_host_stack_device_remove+0x7c>
 8003fd0:	e7ea      	b.n	8003fa8 <_ux_host_stack_device_remove+0x4c>
                        configuration =  configuration -> ux_configuration_next_configuration;                                
 8003fd2:	6b3f      	ldr	r7, [r7, #48]	; 0x30
                    while (configuration != UX_NULL)
 8003fd4:	2f00      	cmp	r7, #0
 8003fd6:	d0e7      	beq.n	8003fa8 <_ux_host_stack_device_remove+0x4c>
                        if (configuration -> ux_configuration_descriptor.bConfigurationValue ==
 8003fd8:	69fa      	ldr	r2, [r7, #28]
 8003fda:	6a23      	ldr	r3, [r4, #32]
 8003fdc:	429a      	cmp	r2, r3
 8003fde:	d1f8      	bne.n	8003fd2 <_ux_host_stack_device_remove+0x76>
                            interface =  configuration -> ux_configuration_first_interface;
 8003fe0:	6afe      	ldr	r6, [r7, #44]	; 0x2c
                            while (interface != UX_NULL)
 8003fe2:	b93e      	cbnz	r6, 8003ff4 <_ux_host_stack_device_remove+0x98>
 8003fe4:	e7f5      	b.n	8003fd2 <_ux_host_stack_device_remove+0x76>
                                    interface -> ux_interface_class -> ux_host_class_entry_function(&command);
 8003fe6:	6b32      	ldr	r2, [r6, #48]	; 0x30
                                    command.ux_host_class_command_instance =  interface -> ux_interface_class_instance;
 8003fe8:	9303      	str	r3, [sp, #12]
                                    interface -> ux_interface_class -> ux_host_class_entry_function(&command);
 8003fea:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8003fec:	4798      	blx	r3
                                interface =  interface -> ux_interface_next_interface;
 8003fee:	6bf6      	ldr	r6, [r6, #60]	; 0x3c
                            while (interface != UX_NULL)
 8003ff0:	2e00      	cmp	r6, #0
 8003ff2:	d0ee      	beq.n	8003fd2 <_ux_host_stack_device_remove+0x76>
                                if (interface -> ux_interface_class_instance != UX_NULL)
 8003ff4:	6b73      	ldr	r3, [r6, #52]	; 0x34
                                    interface -> ux_interface_class -> ux_host_class_entry_function(&command);
 8003ff6:	a801      	add	r0, sp, #4
                                if (interface -> ux_interface_class_instance != UX_NULL)
 8003ff8:	2b00      	cmp	r3, #0
 8003ffa:	d1f4      	bne.n	8003fe6 <_ux_host_stack_device_remove+0x8a>
                                interface =  interface -> ux_interface_next_interface;
 8003ffc:	6bf6      	ldr	r6, [r6, #60]	; 0x3c
                            while (interface != UX_NULL)
 8003ffe:	2e00      	cmp	r6, #0
 8004000:	d1f8      	bne.n	8003ff4 <_ux_host_stack_device_remove+0x98>
 8004002:	e7e6      	b.n	8003fd2 <_ux_host_stack_device_remove+0x76>
 8004004:	20000db8 	.word	0x20000db8

08004008 <_ux_host_stack_device_resources_free>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_device_resources_free(UX_DEVICE *device)
{
 8004008:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

    /* Set the alternate setting to zero.  */
    current_alternate_setting = 0;

    /* Get the first configuration registered to the device.  */
    configuration =  device -> ux_device_first_configuration;
 800400c:	f8d0 8054 	ldr.w	r8, [r0, #84]	; 0x54
{
 8004010:	4681      	mov	r9, r0

    /* Parse all the configurations, remove all resources for the possible configuration.  */
    while (configuration != UX_NULL)
 8004012:	f1b8 0f00 	cmp.w	r8, #0
 8004016:	d029      	beq.n	800406c <_ux_host_stack_device_resources_free+0x64>
    current_alternate_setting = 0;
 8004018:	2700      	movs	r7, #0
    {
        
        /* We have the correct configuration, search the interface(s).  */
        interface =  configuration -> ux_configuration_first_interface;
 800401a:	f8d8 602c 	ldr.w	r6, [r8, #44]	; 0x2c

        /* Parse all the interfaces.  */
        while (interface != UX_NULL)
 800401e:	b1ee      	cbz	r6, 800405c <_ux_host_stack_device_resources_free+0x54>
        {

            /* The alternate setting 0 has the selected alternate setting value.  */
            if (interface -> ux_interface_descriptor.bAlternateSetting == 0)
 8004020:	69b3      	ldr	r3, [r6, #24]
 8004022:	b903      	cbnz	r3, 8004026 <_ux_host_stack_device_resources_free+0x1e>
                current_alternate_setting = interface -> ux_interface_current_alternate_setting;
 8004024:	68b7      	ldr	r7, [r6, #8]

            /* If this is the selected interface, we need to free all the endpoints 
            attached to the alternate setting for this interface.  */
            endpoint =  interface -> ux_interface_first_endpoint;
 8004026:	6bb4      	ldr	r4, [r6, #56]	; 0x38
            
            /* Parse all the endpoints.  */
            while (endpoint != UX_NULL)
 8004028:	b934      	cbnz	r4, 8004038 <_ux_host_stack_device_resources_free+0x30>
 800402a:	e010      	b.n	800404e <_ux_host_stack_device_resources_free+0x46>

                /* Memorize the endpoint container address.  */
                container =  (VOID *) endpoint;                  
                
                /* Get the next endpoint.  */      
                endpoint =  endpoint -> ux_endpoint_next_endpoint;
 800402c:	6a65      	ldr	r5, [r4, #36]	; 0x24
                
                /* Delete the endpoint container.  */
                _ux_utility_memory_free(container);
 800402e:	f7fd ff71 	bl	8001f14 <_ux_utility_memory_free>
            while (endpoint != UX_NULL)
 8004032:	b165      	cbz	r5, 800404e <_ux_host_stack_device_resources_free+0x46>
 8004034:	462c      	mov	r4, r5
 8004036:	69b3      	ldr	r3, [r6, #24]
                if (interface -> ux_interface_descriptor.bAlternateSetting == current_alternate_setting)
 8004038:	42bb      	cmp	r3, r7
                _ux_utility_memory_free(container);
 800403a:	4620      	mov	r0, r4
                if (interface -> ux_interface_descriptor.bAlternateSetting == current_alternate_setting)
 800403c:	d1f6      	bne.n	800402c <_ux_host_stack_device_resources_free+0x24>
                    _ux_host_stack_endpoint_instance_delete(endpoint);
 800403e:	f000 f84d 	bl	80040dc <_ux_host_stack_endpoint_instance_delete>
                endpoint =  endpoint -> ux_endpoint_next_endpoint;
 8004042:	6a65      	ldr	r5, [r4, #36]	; 0x24
                _ux_utility_memory_free(container);
 8004044:	4620      	mov	r0, r4
 8004046:	f7fd ff65 	bl	8001f14 <_ux_utility_memory_free>
            while (endpoint != UX_NULL)
 800404a:	2d00      	cmp	r5, #0
 800404c:	d1f2      	bne.n	8004034 <_ux_host_stack_device_resources_free+0x2c>
            
            /* Memorize the interface container address.  */
            container =  (VOID *) interface;                  
                
            /* Get the next interface.  */      
            interface =  interface -> ux_interface_next_interface;
 800404e:	6bf4      	ldr	r4, [r6, #60]	; 0x3c

            /* Delete the interface container.  */
            _ux_utility_memory_free(container);
 8004050:	4630      	mov	r0, r6
 8004052:	f7fd ff5f 	bl	8001f14 <_ux_utility_memory_free>
        while (interface != UX_NULL)
 8004056:	b10c      	cbz	r4, 800405c <_ux_host_stack_device_resources_free+0x54>
 8004058:	4626      	mov	r6, r4
 800405a:	e7e1      	b.n	8004020 <_ux_host_stack_device_resources_free+0x18>

        /* Memorize this configuration address before we free it.  */
        container =  (VOID *) configuration;

        /* Move to the next configuration in the list.  */
        configuration =  configuration -> ux_configuration_next_configuration;                                
 800405c:	f8d8 4030 	ldr.w	r4, [r8, #48]	; 0x30

        /* Free the configuration.  */
        _ux_utility_memory_free(container);
 8004060:	4640      	mov	r0, r8
 8004062:	f7fd ff57 	bl	8001f14 <_ux_utility_memory_free>
    while (configuration != UX_NULL)
 8004066:	b10c      	cbz	r4, 800406c <_ux_host_stack_device_resources_free+0x64>
 8004068:	46a0      	mov	r8, r4
 800406a:	e7d6      	b.n	800401a <_ux_host_stack_device_resources_free+0x12>
    /* We need the HCD address for the control endpoint removal and to free
       the device address.  */
    hcd =  device -> ux_device_hcd;

    /* Was the control endpoint already created ? */
    if (device -> ux_device_control_endpoint.ux_endpoint_state != 0)
 800406c:	f8d9 3098 	ldr.w	r3, [r9, #152]	; 0x98
    hcd =  device -> ux_device_hcd;
 8004070:	f8d9 4050 	ldr.w	r4, [r9, #80]	; 0x50
    if (device -> ux_device_control_endpoint.ux_endpoint_state != 0)
 8004074:	bb1b      	cbnz	r3, 80040be <_ux_host_stack_device_resources_free+0xb6>
        /* The control endpoint should be destroyed at the HCD level.  */
        hcd -> ux_hcd_entry_function(hcd, UX_HCD_DESTROY_ENDPOINT, (VOID *) &device -> ux_device_control_endpoint);
    }

    /* The semaphore attached to the control endpoint must be destroyed.  */
    _ux_utility_semaphore_delete(&device -> ux_device_control_endpoint.ux_endpoint_transfer_request.ux_transfer_request_semaphore);
 8004076:	f109 00ec 	add.w	r0, r9, #236	; 0xec
 800407a:	f7fe f807 	bl	800208c <_ux_utility_semaphore_delete>

    /* Check if the device had an assigned address.  */
    if (device -> ux_device_address != 0)    
 800407e:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8004082:	b16b      	cbz	r3, 80040a0 <_ux_host_stack_device_resources_free+0x98>

        /* The USB address of this device can now be returned to the pool
           We need the HCD pointer for this operation.  */

        /* Calculate in which byte index the device address belongs.  */
        device_address_byte_index =  (UINT) (device -> ux_device_address-1)/8;        
 8004084:	3b01      	subs	r3, #1

        /* Now calculate the amount left in the byte index in bit.  */
        device_address_bit_index =  (UINT) (device -> ux_device_address-1)%8;     

        /* Build the mask for the address.  */
        device_address_byte =  (UCHAR)(1 << device_address_bit_index);
 8004086:	2101      	movs	r1, #1

        /* Free the address.  */
        hcd -> ux_hcd_address[device_address_byte_index] &=  (UCHAR)~device_address_byte;
 8004088:	eb04 04d3 	add.w	r4, r4, r3, lsr #3
        device_address_bit_index =  (UINT) (device -> ux_device_address-1)%8;     
 800408c:	f003 0307 	and.w	r3, r3, #7
        hcd -> ux_hcd_address[device_address_byte_index] &=  (UCHAR)~device_address_byte;
 8004090:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
        device_address_byte =  (UCHAR)(1 << device_address_bit_index);
 8004094:	fa01 f303 	lsl.w	r3, r1, r3
        hcd -> ux_hcd_address[device_address_byte_index] &=  (UCHAR)~device_address_byte;
 8004098:	ea22 0303 	bic.w	r3, r2, r3
 800409c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    }        

    /* The semaphore for endpoint 0 protection must be destroyed.  */
    _ux_utility_semaphore_delete(&device -> ux_device_protection_semaphore);
 80040a0:	f109 0024 	add.w	r0, r9, #36	; 0x24
 80040a4:	f7fd fff2 	bl	800208c <_ux_utility_semaphore_delete>

    /* Now this device can be free and its container return to the pool.  */
    _ux_utility_memory_set(device, 0, sizeof(UX_DEVICE));
 80040a8:	4648      	mov	r0, r9
 80040aa:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 80040ae:	2100      	movs	r1, #0
 80040b0:	f7fd ffbc 	bl	800202c <_ux_utility_memory_set>

    /* Mark the device handle as unused.  */
    device -> ux_device_handle =  UX_UNUSED;
 80040b4:	2000      	movs	r0, #0
 80040b6:	f8c9 0000 	str.w	r0, [r9]

    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 80040ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        _ux_host_stack_endpoint_transfer_abort(&device -> ux_device_control_endpoint);
 80040be:	f109 0594 	add.w	r5, r9, #148	; 0x94
 80040c2:	4628      	mov	r0, r5
 80040c4:	f000 f848 	bl	8004158 <_ux_host_stack_endpoint_transfer_abort>
        _ux_utility_thread_schedule_other(UX_THREAD_PRIORITY_ENUM); 
 80040c8:	2014      	movs	r0, #20
 80040ca:	f000 fa61 	bl	8004590 <_ux_utility_thread_schedule_other>
        hcd -> ux_hcd_entry_function(hcd, UX_HCD_DESTROY_ENDPOINT, (VOID *) &device -> ux_device_control_endpoint);
 80040ce:	462a      	mov	r2, r5
 80040d0:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 80040d4:	210f      	movs	r1, #15
 80040d6:	4620      	mov	r0, r4
 80040d8:	4798      	blx	r3
 80040da:	e7cc      	b.n	8004076 <_ux_host_stack_device_resources_free+0x6e>

080040dc <_ux_host_stack_endpoint_instance_delete>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_stack_endpoint_instance_delete(UX_ENDPOINT *endpoint)
{
 80040dc:	b538      	push	{r3, r4, r5, lr}
UX_DEVICE       *device;

    
    /* Obtain the HCD for this endpoint.  */
    device =  endpoint -> ux_endpoint_device;
    hcd =  device -> ux_device_hcd;
 80040de:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
{
 80040e0:	4604      	mov	r4, r0

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_ENDPOINT_INSTANCE_DELETE, device, endpoint, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)
    
    /* Ensure the endpoint had its physical ED allocated.  */
    if (endpoint -> ux_endpoint_ed != UX_NULL)
 80040e2:	6883      	ldr	r3, [r0, #8]
    hcd =  device -> ux_device_hcd;
 80040e4:	6d15      	ldr	r5, [r2, #80]	; 0x50
    if (endpoint -> ux_endpoint_ed != UX_NULL)
 80040e6:	b14b      	cbz	r3, 80040fc <_ux_host_stack_endpoint_instance_delete+0x20>
    {    

        /* Destroy this endpoint.  */
        hcd -> ux_hcd_entry_function(hcd, UX_HCD_DESTROY_ENDPOINT, (VOID *) endpoint);
 80040e8:	4602      	mov	r2, r0
 80040ea:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
 80040ee:	210f      	movs	r1, #15
 80040f0:	4628      	mov	r0, r5
 80040f2:	4798      	blx	r3
    
        /* Free the semaphore previously attached to the transfer_request of this endpoint.  */
        _ux_utility_semaphore_delete(&endpoint -> ux_endpoint_transfer_request.ux_transfer_request_semaphore);
 80040f4:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80040f8:	f7fd ffc8 	bl	800208c <_ux_utility_semaphore_delete>
    }

    /* If the endpoint requested guaranteed bandwidth, free it now.  */
    switch ((endpoint -> ux_endpoint_descriptor.bmAttributes) & UX_MASK_ENDPOINT_TYPE)
 80040fc:	69a3      	ldr	r3, [r4, #24]
 80040fe:	f013 0303 	ands.w	r3, r3, #3
 8004102:	d007      	beq.n	8004114 <_ux_host_stack_endpoint_instance_delete+0x38>
 8004104:	2b02      	cmp	r3, #2
 8004106:	d005      	beq.n	8004114 <_ux_host_stack_endpoint_instance_delete+0x38>
        break;

    default:

        /* Reclaim its bandwidth.  */
        _ux_host_stack_bandwidth_release(hcd, endpoint);
 8004108:	4621      	mov	r1, r4
 800410a:	4628      	mov	r0, r5
    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_UNREGISTER(endpoint);

    /* Return to caller.  */
    return;    
}
 800410c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        _ux_host_stack_bandwidth_release(hcd, endpoint);
 8004110:	f000 bfda 	b.w	80050c8 <_ux_host_stack_bandwidth_release>
}
 8004114:	bd38      	pop	{r3, r4, r5, pc}
 8004116:	bf00      	nop

08004118 <_ux_host_stack_endpoint_reset>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_endpoint_reset(UX_ENDPOINT *endpoint)
{
 8004118:	b570      	push	{r4, r5, r6, lr}
 800411a:	4605      	mov	r5, r0

    /* Retrieve the transfer_request pointer.  */
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    /* Create a transfer_request for the CLEAR_FEATURE request.  */
    transfer_request -> ux_transfer_request_data_pointer =      UX_NULL;
 800411c:	2300      	movs	r3, #0
    transfer_request -> ux_transfer_request_requested_length =  0;
    transfer_request -> ux_transfer_request_function =          UX_CLEAR_FEATURE;
 800411e:	2001      	movs	r0, #1
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_OUT| UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_ENDPOINT;
 8004120:	2102      	movs	r1, #2
    device =  endpoint -> ux_endpoint_device;
 8004122:	6aec      	ldr	r4, [r5, #44]	; 0x2c
    transfer_request -> ux_transfer_request_value =             UX_ENDPOINT_HALT;
    transfer_request -> ux_transfer_request_index =             endpoint -> ux_endpoint_descriptor.bEndpointAddress;
 8004124:	696a      	ldr	r2, [r5, #20]
    transfer_request -> ux_transfer_request_function =          UX_CLEAR_FEATURE;
 8004126:	f8c4 00dc 	str.w	r0, [r4, #220]	; 0xdc

    /* Send request to HCD layer.  */
    status =  _ux_host_stack_transfer_request(transfer_request);
 800412a:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_OUT| UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_ENDPOINT;
 800412e:	f8c4 10d8 	str.w	r1, [r4, #216]	; 0xd8
    transfer_request -> ux_transfer_request_index =             endpoint -> ux_endpoint_descriptor.bEndpointAddress;
 8004132:	f8c4 20e4 	str.w	r2, [r4, #228]	; 0xe4
    transfer_request -> ux_transfer_request_value =             UX_ENDPOINT_HALT;
 8004136:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
    transfer_request -> ux_transfer_request_requested_length =  0;
 800413a:	e9c4 3333 	strd	r3, r3, [r4, #204]	; 0xcc
    status =  _ux_host_stack_transfer_request(transfer_request);
 800413e:	f000 f957 	bl	80043f0 <_ux_host_stack_transfer_request>

    /* Reset the endpoint at the HCD level.  */
    if (status == UX_SUCCESS)
 8004142:	b938      	cbnz	r0, 8004154 <_ux_host_stack_endpoint_reset+0x3c>
    {

        /* Pickup HCD pointer.  */
        hcd =  device -> ux_device_hcd;
 8004144:	6d20      	ldr	r0, [r4, #80]	; 0x50

        /* Call HCD entry function.  */
        status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_RESET_ENDPOINT, endpoint);
 8004146:	462a      	mov	r2, r5
 8004148:	2110      	movs	r1, #16
 800414a:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
    }

    /* And return the completion status.  */
    return(status);
}
 800414e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_RESET_ENDPOINT, endpoint);
 8004152:	4718      	bx	r3
}
 8004154:	bd70      	pop	{r4, r5, r6, pc}
 8004156:	bf00      	nop

08004158 <_ux_host_stack_endpoint_transfer_abort>:
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_ENDPOINT_TRANSFER_ABORT, endpoint, 0, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    /* Since we only have one transfer_request per endpoint, use the regular 
       abort transfer request function.  */
    status =  _ux_host_stack_transfer_request_abort(&endpoint -> ux_endpoint_transfer_request);
 8004158:	3030      	adds	r0, #48	; 0x30
 800415a:	f000 b997 	b.w	800448c <_ux_host_stack_transfer_request_abort>
 800415e:	bf00      	nop

08004160 <_ux_host_stack_enum_thread_entry>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_stack_enum_thread_entry(ULONG input)
{
 8004160:	4c08      	ldr	r4, [pc, #32]	; (8004184 <_ux_host_stack_enum_thread_entry+0x24>)
 8004162:	b508      	push	{r3, lr}
    /* Loop forever waiting for changes signaled through the semaphore. */     
    while (1)
    {   

        /* Wait for the semaphore to be put by the root hub or a regular hub.  */
        _ux_utility_semaphore_get(&_ux_system_host -> ux_system_host_enum_semaphore, UX_WAIT_FOREVER);
 8004164:	6820      	ldr	r0, [r4, #0]
 8004166:	f04f 31ff 	mov.w	r1, #4294967295
 800416a:	f500 7080 	add.w	r0, r0, #256	; 0x100
 800416e:	f7fd ff8f 	bl	8002090 <_ux_utility_semaphore_get>

        /* We try the hub first. For this we look into the USBX project
           structure to see if there is at least one hub.  */
        if (_ux_system_host -> ux_system_host_enum_hub_function != UX_NULL)
 8004172:	6823      	ldr	r3, [r4, #0]
 8004174:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 8004178:	b103      	cbz	r3, 800417c <_ux_host_stack_enum_thread_entry+0x1c>
        {

            /* Yes, there is a HUB function, call it!  */
            _ux_system_host -> ux_system_host_enum_hub_function();
 800417a:	4798      	blx	r3
        }

        /* The signal may be also coming from the root hub, call the root hub handler.  */
        _ux_host_stack_rh_change_process();
 800417c:	f000 f860 	bl	8004240 <_ux_host_stack_rh_change_process>
        _ux_utility_semaphore_get(&_ux_system_host -> ux_system_host_enum_semaphore, UX_WAIT_FOREVER);
 8004180:	e7f0      	b.n	8004164 <_ux_host_stack_enum_thread_entry+0x4>
 8004182:	bf00      	nop
 8004184:	20000db8 	.word	0x20000db8

08004188 <_ux_host_stack_hcd_thread_entry>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_stack_hcd_thread_entry(ULONG input)
{
 8004188:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800418c:	f8df 806c 	ldr.w	r8, [pc, #108]	; 80041fc <_ux_host_stack_hcd_thread_entry+0x74>
           to see who posted work to do. */  
        for(hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_registered_hcd; hcd_index++)
        {

            /* Pickup HCD pointer.  */
            hcd =  &_ux_system_host -> ux_system_host_hcd_array[hcd_index];
 8004190:	f04f 09cc 	mov.w	r9, #204	; 0xcc
        _ux_utility_semaphore_get(&_ux_system_host -> ux_system_host_hcd_semaphore, UX_WAIT_FOREVER);
 8004194:	f8d8 0000 	ldr.w	r0, [r8]
 8004198:	f04f 31ff 	mov.w	r1, #4294967295
 800419c:	f500 7030 	add.w	r0, r0, #704	; 0x2c0
 80041a0:	f7fd ff76 	bl	8002090 <_ux_utility_semaphore_get>
        for(hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_registered_hcd; hcd_index++)
 80041a4:	f8d8 3000 	ldr.w	r3, [r8]
 80041a8:	f8d3 c014 	ldr.w	ip, [r3, #20]
 80041ac:	f1bc 0f00 	cmp.w	ip, #0
 80041b0:	d0f0      	beq.n	8004194 <_ux_host_stack_hcd_thread_entry+0xc>
 80041b2:	2600      	movs	r6, #0
 80041b4:	e001      	b.n	80041ba <_ux_host_stack_hcd_thread_entry+0x32>
 80041b6:	4566      	cmp	r6, ip
 80041b8:	d2ec      	bcs.n	8004194 <_ux_host_stack_hcd_thread_entry+0xc>
            hcd =  &_ux_system_host -> ux_system_host_hcd_array[hcd_index];
 80041ba:	691c      	ldr	r4, [r3, #16]
 80041bc:	fb09 4406 	mla	r4, r9, r6, r4
        for(hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_registered_hcd; hcd_index++)
 80041c0:	3601      	adds	r6, #1

            /* Is there work to do for this HCD?  */
            if((hcd -> ux_hcd_status == UX_HCD_STATUS_OPERATIONAL) && (hcd -> ux_hcd_thread_signal !=0))
 80041c2:	6d25      	ldr	r5, [r4, #80]	; 0x50
 80041c4:	2d01      	cmp	r5, #1
 80041c6:	d1f6      	bne.n	80041b6 <_ux_host_stack_hcd_thread_entry+0x2e>
 80041c8:	f8d4 70ac 	ldr.w	r7, [r4, #172]	; 0xac
            {

                /* Yes, call the HCD function to process the work.  */
                hcd -> ux_hcd_entry_function(hcd, UX_HCD_PROCESS_DONE_QUEUE, UX_NULL);
 80041cc:	2200      	movs	r2, #0
 80041ce:	2111      	movs	r1, #17
 80041d0:	4620      	mov	r0, r4
            if((hcd -> ux_hcd_status == UX_HCD_STATUS_OPERATIONAL) && (hcd -> ux_hcd_thread_signal !=0))
 80041d2:	2f00      	cmp	r7, #0
 80041d4:	d0ef      	beq.n	80041b6 <_ux_host_stack_hcd_thread_entry+0x2e>
                hcd -> ux_hcd_entry_function(hcd, UX_HCD_PROCESS_DONE_QUEUE, UX_NULL);
 80041d6:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 80041da:	4798      	blx	r3
                UX_DISABLE_INTS
 80041dc:	4628      	mov	r0, r5
 80041de:	f7fc f87f 	bl	80002e0 <_tx_thread_interrupt_control>
                hcd -> ux_hcd_thread_signal--;
 80041e2:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 80041e6:	3b01      	subs	r3, #1
 80041e8:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
                UX_RESTORE_INTS
 80041ec:	f7fc f878 	bl	80002e0 <_tx_thread_interrupt_control>
 80041f0:	f8d8 3000 	ldr.w	r3, [r8]
 80041f4:	f8d3 c014 	ldr.w	ip, [r3, #20]
 80041f8:	e7dd      	b.n	80041b6 <_ux_host_stack_hcd_thread_entry+0x2e>
 80041fa:	bf00      	nop
 80041fc:	20000db8 	.word	0x20000db8

08004200 <_ux_host_stack_interface_endpoint_get>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_interface_endpoint_get(UX_INTERFACE *interface, UINT endpoint_index, UX_ENDPOINT **endpoint)
{
 8004200:	b508      	push	{r3, lr}

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_INTERFACE_ENDPOINT_GET, interface, endpoint_index, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    /* Do a sanity check on the interface handle.  */
    if (interface -> ux_interface_handle != (ULONG) (ALIGN_TYPE) interface)
 8004202:	6803      	ldr	r3, [r0, #0]
 8004204:	4298      	cmp	r0, r3
 8004206:	d114      	bne.n	8004232 <_ux_host_stack_interface_endpoint_get+0x32>

        return(UX_INTERFACE_HANDLE_UNKNOWN);
    }
            
    /* Start with the endpoint attached to the interface.  */
    current_endpoint =  interface -> ux_interface_first_endpoint;
 8004208:	6b83      	ldr	r3, [r0, #56]	; 0x38

    /* The first endpoint has the index 0.  */    
    current_endpoint_index =  0;
    
    /* Traverse the list of the endpoints until we found the right one.  */        
    while (current_endpoint != UX_NULL)
 800420a:	b143      	cbz	r3, 800421e <_ux_host_stack_interface_endpoint_get+0x1e>
    {

        /* Check if the endpoint index matches the current one.  */
        if (endpoint_index == current_endpoint_index)
 800420c:	b171      	cbz	r1, 800422c <_ux_host_stack_interface_endpoint_get+0x2c>
    current_endpoint_index =  0;
 800420e:	2000      	movs	r0, #0
 8004210:	e001      	b.n	8004216 <_ux_host_stack_interface_endpoint_get+0x16>
        if (endpoint_index == current_endpoint_index)
 8004212:	4281      	cmp	r1, r0
 8004214:	d00a      	beq.n	800422c <_ux_host_stack_interface_endpoint_get+0x2c>
            /* Return success to the caller.  */
            return(UX_SUCCESS);
        }
        
        /* Move to the next endpoint.  */
        current_endpoint =  current_endpoint -> ux_endpoint_next_endpoint;
 8004216:	6a5b      	ldr	r3, [r3, #36]	; 0x24
        
        /* Move to the next index.  */
        current_endpoint_index++;
 8004218:	3001      	adds	r0, #1
    while (current_endpoint != UX_NULL)
 800421a:	2b00      	cmp	r3, #0
 800421c:	d1f9      	bne.n	8004212 <_ux_host_stack_interface_endpoint_get+0x12>
    }

    /* Error trap. */
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_ENDPOINT_HANDLE_UNKNOWN);
 800421e:	2253      	movs	r2, #83	; 0x53
 8004220:	2104      	movs	r1, #4
 8004222:	2002      	movs	r0, #2
 8004224:	f7fd fcec 	bl	8001c00 <_ux_system_error_handler>

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_ENDPOINT_HANDLE_UNKNOWN, endpoint, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* Return an error!  */
    return(UX_ENDPOINT_HANDLE_UNKNOWN);
 8004228:	2053      	movs	r0, #83	; 0x53
}
 800422a:	bd08      	pop	{r3, pc}
            *endpoint=current_endpoint;
 800422c:	6013      	str	r3, [r2, #0]
            return(UX_SUCCESS);
 800422e:	2000      	movs	r0, #0
}
 8004230:	bd08      	pop	{r3, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_INTERFACE_HANDLE_UNKNOWN);
 8004232:	2252      	movs	r2, #82	; 0x52
 8004234:	2104      	movs	r1, #4
 8004236:	2002      	movs	r0, #2
 8004238:	f7fd fce2 	bl	8001c00 <_ux_system_error_handler>
        return(UX_INTERFACE_HANDLE_UNKNOWN);
 800423c:	2052      	movs	r0, #82	; 0x52
}
 800423e:	bd08      	pop	{r3, pc}

08004240 <_ux_host_stack_rh_change_process>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_stack_rh_change_process(VOID)
{
 8004240:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
UINT        port_index;
UX_INT_SAVE_AREA

    /* This thread was maybe awaken by one or more HCD controllers. Check each 
       of the HCD to see where there has been a change of topology.  */
    for(hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_registered_hcd; hcd_index++)
 8004244:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 800430c <_ux_host_stack_rh_change_process+0xcc>
 8004248:	f8d9 1000 	ldr.w	r1, [r9]
 800424c:	6948      	ldr	r0, [r1, #20]
 800424e:	2800      	cmp	r0, #0
 8004250:	d041      	beq.n	80042d6 <_ux_host_stack_rh_change_process+0x96>
 8004252:	2700      	movs	r7, #0
    {

        /* Pickup HCD pointer.  */
        hcd =  &_ux_system_host -> ux_system_host_hcd_array[hcd_index];
 8004254:	f04f 0bcc 	mov.w	fp, #204	; 0xcc
                                if (hcd -> ux_hcd_root_hub_signal[port_index] != 0)
                                {

                                    /* We need to get back in synch now.  */
                                    UX_DISABLE_INTS
                                    hcd -> ux_hcd_root_hub_signal[port_index] = 0;
 8004258:	46ba      	mov	sl, r7
 800425a:	e002      	b.n	8004262 <_ux_host_stack_rh_change_process+0x22>
    for(hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_registered_hcd; hcd_index++)
 800425c:	3701      	adds	r7, #1
 800425e:	4287      	cmp	r7, r0
 8004260:	d239      	bcs.n	80042d6 <_ux_host_stack_rh_change_process+0x96>
        hcd =  &_ux_system_host -> ux_system_host_hcd_array[hcd_index];
 8004262:	690c      	ldr	r4, [r1, #16]
 8004264:	fb0b 4407 	mla	r4, fp, r7, r4
        if (hcd -> ux_hcd_status == UX_HCD_STATUS_OPERATIONAL)
 8004268:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800426a:	2b01      	cmp	r3, #1
 800426c:	d1f6      	bne.n	800425c <_ux_host_stack_rh_change_process+0x1c>
            for (port_index = 0; port_index < hcd -> ux_hcd_nb_root_hubs; port_index++)
 800426e:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8004270:	2a00      	cmp	r2, #0
 8004272:	d0f3      	beq.n	800425c <_ux_host_stack_rh_change_process+0x1c>
                    UX_DISABLE_INTS
 8004274:	4698      	mov	r8, r3
 8004276:	f104 0564 	add.w	r5, r4, #100	; 0x64
            for (port_index = 0; port_index < hcd -> ux_hcd_nb_root_hubs; port_index++)
 800427a:	2600      	movs	r6, #0
 800427c:	e003      	b.n	8004286 <_ux_host_stack_rh_change_process+0x46>
 800427e:	3601      	adds	r6, #1
 8004280:	3504      	adds	r5, #4
 8004282:	4296      	cmp	r6, r2
 8004284:	d221      	bcs.n	80042ca <_ux_host_stack_rh_change_process+0x8a>
                if (hcd -> ux_hcd_root_hub_signal[port_index] != 0)
 8004286:	682b      	ldr	r3, [r5, #0]
 8004288:	2b00      	cmp	r3, #0
 800428a:	d0f8      	beq.n	800427e <_ux_host_stack_rh_change_process+0x3e>
                    UX_DISABLE_INTS
 800428c:	2001      	movs	r0, #1
 800428e:	f7fc f827 	bl	80002e0 <_tx_thread_interrupt_control>
                    hcd -> ux_hcd_root_hub_signal[port_index]--;
 8004292:	682b      	ldr	r3, [r5, #0]
 8004294:	3b01      	subs	r3, #1
 8004296:	602b      	str	r3, [r5, #0]
                    UX_RESTORE_INTS
 8004298:	f7fc f822 	bl	80002e0 <_tx_thread_interrupt_control>
                    port_status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_GET_PORT_STATUS, (VOID *)((ALIGN_TYPE)port_index));
 800429c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 80042a0:	4632      	mov	r2, r6
 80042a2:	2102      	movs	r1, #2
 80042a4:	4620      	mov	r0, r4
 80042a6:	4798      	blx	r3
                    if (port_status != UX_PORT_INDEX_UNKNOWN)
 80042a8:	2856      	cmp	r0, #86	; 0x56
 80042aa:	d009      	beq.n	80042c0 <_ux_host_stack_rh_change_process+0x80>
 80042ac:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 80042b0:	fa08 f306 	lsl.w	r3, r8, r6
 80042b4:	4013      	ands	r3, r2
                        if (port_status & UX_PS_CCS)
 80042b6:	07c2      	lsls	r2, r0, #31
 80042b8:	d50f      	bpl.n	80042da <_ux_host_stack_rh_change_process+0x9a>
                            if ((hcd -> ux_hcd_rh_device_connection & (ULONG)(1 << port_index)) == 0)
 80042ba:	b30b      	cbz	r3, 8004300 <_ux_host_stack_rh_change_process+0xc0>
                                if (hcd -> ux_hcd_root_hub_signal[port_index] != 0)
 80042bc:	682b      	ldr	r3, [r5, #0]
 80042be:	b9a3      	cbnz	r3, 80042ea <_ux_host_stack_rh_change_process+0xaa>
 80042c0:	6e22      	ldr	r2, [r4, #96]	; 0x60
            for (port_index = 0; port_index < hcd -> ux_hcd_nb_root_hubs; port_index++)
 80042c2:	3601      	adds	r6, #1
 80042c4:	3504      	adds	r5, #4
 80042c6:	4296      	cmp	r6, r2
 80042c8:	d3dd      	bcc.n	8004286 <_ux_host_stack_rh_change_process+0x46>
 80042ca:	f8d9 1000 	ldr.w	r1, [r9]
    for(hcd_index = 0; hcd_index < _ux_system_host -> ux_system_host_registered_hcd; hcd_index++)
 80042ce:	3701      	adds	r7, #1
 80042d0:	6948      	ldr	r0, [r1, #20]
 80042d2:	4287      	cmp	r7, r0
 80042d4:	d3c5      	bcc.n	8004262 <_ux_host_stack_rh_change_process+0x22>
                    }
                }
            }
        }               
    }
}
 80042d6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                            if ((hcd -> ux_hcd_rh_device_connection & (ULONG)(1 << port_index)) !=0)
 80042da:	2b00      	cmp	r3, #0
 80042dc:	d0f0      	beq.n	80042c0 <_ux_host_stack_rh_change_process+0x80>
                                _ux_host_stack_rh_device_extraction(hcd,port_index);
 80042de:	4631      	mov	r1, r6
 80042e0:	4620      	mov	r0, r4
 80042e2:	f000 f815 	bl	8004310 <_ux_host_stack_rh_device_extraction>
 80042e6:	6e22      	ldr	r2, [r4, #96]	; 0x60
 80042e8:	e7eb      	b.n	80042c2 <_ux_host_stack_rh_change_process+0x82>
                                    UX_DISABLE_INTS
 80042ea:	2001      	movs	r0, #1
 80042ec:	f7fb fff8 	bl	80002e0 <_tx_thread_interrupt_control>
                                    hcd -> ux_hcd_root_hub_signal[port_index] = 0;
 80042f0:	f8c5 a000 	str.w	sl, [r5]
                                    UX_RESTORE_INTS
 80042f4:	f7fb fff4 	bl	80002e0 <_tx_thread_interrupt_control>
                                    _ux_host_stack_rh_device_extraction(hcd,port_index);
 80042f8:	4631      	mov	r1, r6
 80042fa:	4620      	mov	r0, r4
 80042fc:	f000 f808 	bl	8004310 <_ux_host_stack_rh_device_extraction>
                                    _ux_host_stack_rh_device_insertion(hcd,port_index);
 8004300:	4631      	mov	r1, r6
 8004302:	4620      	mov	r0, r4
 8004304:	f000 f816 	bl	8004334 <_ux_host_stack_rh_device_insertion>
 8004308:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800430a:	e7b8      	b.n	800427e <_ux_host_stack_rh_change_process+0x3e>
 800430c:	20000db8 	.word	0x20000db8

08004310 <_ux_host_stack_rh_device_extraction>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_rh_device_extraction(UX_HCD *hcd, UINT port_index)
{
 8004310:	b538      	push	{r3, r4, r5, lr}
 8004312:	460d      	mov	r5, r1

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_RH_DEVICE_EXTRACTION, hcd, port_index, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    /* Ask the stack to remove the device, pass the value 0 as the parent root hub.  */
    _ux_host_stack_device_remove(hcd, 0, port_index);
 8004314:	2100      	movs	r1, #0
{
 8004316:	4604      	mov	r4, r0
    _ux_host_stack_device_remove(hcd, 0, port_index);
 8004318:	462a      	mov	r2, r5
 800431a:	f7ff fe1f 	bl	8003f5c <_ux_host_stack_device_remove>

    /* The device has been removed, so the port is free again.  */
    hcd -> ux_hcd_rh_device_connection &= (ULONG)~(1 << port_index);
 800431e:	2101      	movs	r1, #1
 8004320:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0

    /* That command should never fail!  */
    return(UX_SUCCESS);
}
 8004324:	2000      	movs	r0, #0
    hcd -> ux_hcd_rh_device_connection &= (ULONG)~(1 << port_index);
 8004326:	40a9      	lsls	r1, r5
 8004328:	ea23 0301 	bic.w	r3, r3, r1
 800432c:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
}
 8004330:	bd38      	pop	{r3, r4, r5, pc}
 8004332:	bf00      	nop

08004334 <_ux_host_stack_rh_device_insertion>:
/*                                                                        */
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_rh_device_insertion(UX_HCD *hcd, UINT port_index)
{
 8004334:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004338:	460d      	mov	r5, r1
 800433a:	b082      	sub	sp, #8

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_RH_DEVICE_INSERTION, hcd, port_index, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    /* Perform a PORT_ENABLE command.  */
    port_status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_ENABLE_PORT, (VOID *)((ALIGN_TYPE)port_index));
 800433c:	2103      	movs	r1, #3
 800433e:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
 8004342:	462a      	mov	r2, r5
{
 8004344:	4604      	mov	r4, r0
    port_status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_ENABLE_PORT, (VOID *)((ALIGN_TYPE)port_index));
 8004346:	4798      	blx	r3

    /* Check return status.  */
    if (port_status == UX_PORT_INDEX_UNKNOWN)
 8004348:	2856      	cmp	r0, #86	; 0x56
 800434a:	d03a      	beq.n	80043c2 <_ux_host_stack_rh_device_insertion+0x8e>
        return(port_status);

    /* A debounce interval with a minimum duration of 100 ms on attach.  */
    _ux_utility_delay_ms(100);
 800434c:	2064      	movs	r0, #100	; 0x64

    /* The first attempts to do a device enumeration may fail.
       Typically, after the port is reset and the first command is sent to
       the device, there is no answer. In this case, we reset the port again
       and retry. Usually that does the trick!  */
    for (index_loop = 0; index_loop < UX_RH_ENUMERATION_RETRY; index_loop++)
 800434e:	2700      	movs	r7, #0
            /* Set the device speed.  */
            device_speed =  port_status >> UX_PS_DS;

            /* Ask the USB stack to enumerate this device. A root hub is considered self
               powered. */
            status =  _ux_host_stack_new_device_create(hcd, UX_NULL, port_index, device_speed, UX_MAX_SELF_POWER);
 8004350:	f04f 08fa 	mov.w	r8, #250	; 0xfa
    _ux_utility_delay_ms(100);
 8004354:	f7fd fcbe 	bl	8001cd4 <_ux_utility_delay_ms>
        port_status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_RESET_PORT, (VOID *)((ALIGN_TYPE)port_index));
 8004358:	462a      	mov	r2, r5
 800435a:	2109      	movs	r1, #9
 800435c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 8004360:	4620      	mov	r0, r4
 8004362:	4798      	blx	r3
            port_status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_GET_PORT_STATUS, (VOID *)((ALIGN_TYPE)port_index));
 8004364:	462a      	mov	r2, r5
        if (port_status == UX_SUCCESS)
 8004366:	4606      	mov	r6, r0
            port_status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_GET_PORT_STATUS, (VOID *)((ALIGN_TYPE)port_index));
 8004368:	2102      	movs	r1, #2
        if (port_status == UX_SUCCESS)
 800436a:	b9b0      	cbnz	r0, 800439a <_ux_host_stack_rh_device_insertion+0x66>
            port_status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_GET_PORT_STATUS, (VOID *)((ALIGN_TYPE)port_index));
 800436c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 8004370:	4620      	mov	r0, r4
 8004372:	4798      	blx	r3
            if (port_status == UX_PORT_INDEX_UNKNOWN)
 8004374:	2856      	cmp	r0, #86	; 0x56
            status =  _ux_host_stack_new_device_create(hcd, UX_NULL, port_index, device_speed, UX_MAX_SELF_POWER);
 8004376:	ea4f 1390 	mov.w	r3, r0, lsr #6
 800437a:	462a      	mov	r2, r5
 800437c:	4631      	mov	r1, r6
 800437e:	4620      	mov	r0, r4
            if (port_status == UX_PORT_INDEX_UNKNOWN)
 8004380:	d026      	beq.n	80043d0 <_ux_host_stack_rh_device_insertion+0x9c>
            status =  _ux_host_stack_new_device_create(hcd, UX_NULL, port_index, device_speed, UX_MAX_SELF_POWER);
 8004382:	f8cd 8000 	str.w	r8, [sp]
 8004386:	f000 ffa3 	bl	80052d0 <_ux_host_stack_new_device_create>
                return(UX_SUCCESS);
            }
            else if (index_loop < UX_RH_ENUMERATION_RETRY - 1)

                /* Simulate remove to free allocated resources before retry.  */
                _ux_host_stack_device_remove(hcd, UX_NULL, port_index);
 800438a:	462a      	mov	r2, r5
 800438c:	4631      	mov	r1, r6
            if (status == UX_SUCCESS)
 800438e:	b330      	cbz	r0, 80043de <_ux_host_stack_rh_device_insertion+0xaa>
            else if (index_loop < UX_RH_ENUMERATION_RETRY - 1)
 8004390:	2f02      	cmp	r7, #2
                _ux_host_stack_device_remove(hcd, UX_NULL, port_index);
 8004392:	4620      	mov	r0, r4
            else if (index_loop < UX_RH_ENUMERATION_RETRY - 1)
 8004394:	d018      	beq.n	80043c8 <_ux_host_stack_rh_device_insertion+0x94>
                _ux_host_stack_device_remove(hcd, UX_NULL, port_index);
 8004396:	f7ff fde1 	bl	8003f5c <_ux_host_stack_device_remove>
    for (index_loop = 0; index_loop < UX_RH_ENUMERATION_RETRY; index_loop++)
 800439a:	3701      	adds	r7, #1
        }

        /* We get here if something did not go well. Either the port did not respond
           well to the ENABLE\RESET phases or the device did not enumerate well
           so we try again ! */
        _ux_utility_delay_ms(UX_RH_ENUMERATION_RETRY_DELAY);
 800439c:	2064      	movs	r0, #100	; 0x64
 800439e:	f7fd fc99 	bl	8001cd4 <_ux_utility_delay_ms>
    for (index_loop = 0; index_loop < UX_RH_ENUMERATION_RETRY; index_loop++)
 80043a2:	2f03      	cmp	r7, #3
 80043a4:	d1d8      	bne.n	8004358 <_ux_host_stack_rh_device_insertion+0x24>
    }

    /* If we get here, the device did not enumerate completely. The device is still attached to the root
       hub and therefore there is a physical connection with a unenumerated device. */
    hcd -> ux_hcd_rh_device_connection |= (ULONG)(1 << port_index);
 80043a6:	2001      	movs	r0, #1
 80043a8:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0

    /* Error trap. */
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ROOT_HUB, UX_DEVICE_ENUMERATION_FAILURE);
 80043ac:	2244      	movs	r2, #68	; 0x44
 80043ae:	2105      	movs	r1, #5
    hcd -> ux_hcd_rh_device_connection |= (ULONG)(1 << port_index);
 80043b0:	fa00 f505 	lsl.w	r5, r0, r5
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ROOT_HUB, UX_DEVICE_ENUMERATION_FAILURE);
 80043b4:	2002      	movs	r0, #2
    hcd -> ux_hcd_rh_device_connection |= (ULONG)(1 << port_index);
 80043b6:	432b      	orrs	r3, r5
 80043b8:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ROOT_HUB, UX_DEVICE_ENUMERATION_FAILURE);
 80043bc:	f7fd fc20 	bl	8001c00 <_ux_system_error_handler>

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_DEVICE_ENUMERATION_FAILURE, port_index, 0, 0, UX_TRACE_ERRORS, 0, 0)

    /* Return a failed enumeration.  */
    return(UX_DEVICE_ENUMERATION_FAILURE);
 80043c0:	2044      	movs	r0, #68	; 0x44
}
 80043c2:	b002      	add	sp, #8
 80043c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        _ux_utility_delay_ms(UX_RH_ENUMERATION_RETRY_DELAY);
 80043c8:	2064      	movs	r0, #100	; 0x64
 80043ca:	f7fd fc83 	bl	8001cd4 <_ux_utility_delay_ms>
 80043ce:	e7ea      	b.n	80043a6 <_ux_host_stack_rh_device_insertion+0x72>
                _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ROOT_HUB, UX_DEVICE_ENUMERATION_FAILURE);
 80043d0:	2002      	movs	r0, #2
 80043d2:	2244      	movs	r2, #68	; 0x44
 80043d4:	2105      	movs	r1, #5
 80043d6:	f7fd fc13 	bl	8001c00 <_ux_system_error_handler>
                return(UX_DEVICE_ENUMERATION_FAILURE);
 80043da:	2044      	movs	r0, #68	; 0x44
 80043dc:	e7f1      	b.n	80043c2 <_ux_host_stack_rh_device_insertion+0x8e>
                hcd -> ux_hcd_rh_device_connection |= (ULONG)(1 << port_index);
 80043de:	2201      	movs	r2, #1
 80043e0:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 80043e4:	fa02 f505 	lsl.w	r5, r2, r5
 80043e8:	432b      	orrs	r3, r5
 80043ea:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
                return(UX_SUCCESS);
 80043ee:	e7e8      	b.n	80043c2 <_ux_host_stack_rh_device_insertion+0x8e>

080043f0 <_ux_host_stack_transfer_request>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_transfer_request(UX_TRANSFER *transfer_request)
{
 80043f0:	b5f0      	push	{r4, r5, r6, r7, lr}
UX_HCD          *hcd;
UINT            status;
    

    /* Get the endpoint container from the transfer_request */
    endpoint =  transfer_request -> ux_transfer_request_endpoint;
 80043f2:	6844      	ldr	r4, [r0, #4]
{
 80043f4:	b083      	sub	sp, #12

    /* Get the device container from the endpoint.  */
    device =  endpoint -> ux_endpoint_device;
 80043f6:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
__attribute__( ( always_inline ) ) static inline unsigned int __disable_interrupts(void)
{

unsigned int  primask_value;

    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 80043f8:	f3ef 8710 	mrs	r7, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 80043fc:	b672      	cpsid	i
       state and set the transfer status.  */
    TX_DISABLE

    /* We can only transfer when the device is ATTACHED, ADDRESSED OR CONFIGURED.  */
    if ((device -> ux_device_state == UX_DEVICE_ATTACHED) || (device -> ux_device_state == UX_DEVICE_ADDRESSED)
            || (device -> ux_device_state == UX_DEVICE_CONFIGURED))
 80043fe:	68ab      	ldr	r3, [r5, #8]
 8004400:	3b01      	subs	r3, #1
    if ((device -> ux_device_state == UX_DEVICE_ATTACHED) || (device -> ux_device_state == UX_DEVICE_ADDRESSED)
 8004402:	2b02      	cmp	r3, #2
 8004404:	d90b      	bls.n	800441e <_ux_host_stack_transfer_request+0x2e>
}

__attribute__( ( always_inline ) ) static inline void __restore_interrupts(unsigned int primask_value)
{

    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 8004406:	f387 8810 	msr	PRIMASK, r7

        /* The device is in an invalid state. Restore interrupts and return error.  */
        TX_RESTORE

        /* Check if this is endpoint 0.  */
        if ((endpoint -> ux_endpoint_descriptor.bEndpointAddress & (UINT)~UX_ENDPOINT_DIRECTION) == 0)
 800440a:	6963      	ldr	r3, [r4, #20]
 800440c:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 8004410:	d101      	bne.n	8004416 <_ux_host_stack_transfer_request+0x26>
        {

            /* Check if the class has already protected it.  */
            if (device -> ux_device_protection_semaphore.tx_semaphore_count == 0)
 8004412:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8004414:	b313      	cbz	r3, 800445c <_ux_host_stack_transfer_request+0x6c>
                /* Class is using endpoint 0. Unprotect semaphore.  */
                _ux_utility_semaphore_put(&device -> ux_device_protection_semaphore);
            }
        }

        return(UX_TRANSFER_NOT_READY);
 8004416:	2725      	movs	r7, #37	; 0x25
        /* We are using endpoint 0. Unprotect with semaphore.  */
        _ux_utility_semaphore_put(&device -> ux_device_protection_semaphore);

    /* And return the status.  */
    return(status);
}
 8004418:	4638      	mov	r0, r7
 800441a:	b003      	add	sp, #12
 800441c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_STATUS_PENDING;
 800441e:	2301      	movs	r3, #1
 8004420:	4606      	mov	r6, r0
 8004422:	6543      	str	r3, [r0, #84]	; 0x54
        transfer_request -> ux_transfer_request_thread_pending =  _ux_utility_thread_identify();
 8004424:	f000 f8a8 	bl	8004578 <_ux_utility_thread_identify>
 8004428:	6670      	str	r0, [r6, #100]	; 0x64
 800442a:	f387 8810 	msr	PRIMASK, r7
    if ((endpoint -> ux_endpoint_descriptor.bEndpointAddress & (UINT)~UX_ENDPOINT_DIRECTION) == 0)
 800442e:	6962      	ldr	r2, [r4, #20]
    hcd =  device -> ux_device_hcd;
 8004430:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    if ((endpoint -> ux_endpoint_descriptor.bEndpointAddress & (UINT)~UX_ENDPOINT_DIRECTION) == 0)
 8004432:	f032 0280 	bics.w	r2, r2, #128	; 0x80
 8004436:	d019      	beq.n	800446c <_ux_host_stack_transfer_request+0x7c>
    status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_TRANSFER_REQUEST, transfer_request);
 8004438:	4632      	mov	r2, r6
 800443a:	4618      	mov	r0, r3
 800443c:	f8d3 60c4 	ldr.w	r6, [r3, #196]	; 0xc4
 8004440:	210c      	movs	r1, #12
 8004442:	47b0      	blx	r6
    if ((endpoint -> ux_endpoint_descriptor.bEndpointAddress & (UINT)~UX_ENDPOINT_DIRECTION) == 0)
 8004444:	6963      	ldr	r3, [r4, #20]
    status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_TRANSFER_REQUEST, transfer_request);
 8004446:	4607      	mov	r7, r0
    if ((endpoint -> ux_endpoint_descriptor.bEndpointAddress & (UINT)~UX_ENDPOINT_DIRECTION) == 0)
 8004448:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800444c:	d1e4      	bne.n	8004418 <_ux_host_stack_transfer_request+0x28>
        _ux_utility_semaphore_put(&device -> ux_device_protection_semaphore);
 800444e:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8004452:	f7fd fe41 	bl	80020d8 <_ux_utility_semaphore_put>
}
 8004456:	4638      	mov	r0, r7
 8004458:	b003      	add	sp, #12
 800445a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return(UX_TRANSFER_NOT_READY);
 800445c:	2725      	movs	r7, #37	; 0x25
                _ux_utility_semaphore_put(&device -> ux_device_protection_semaphore);
 800445e:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8004462:	f7fd fe39 	bl	80020d8 <_ux_utility_semaphore_put>
}
 8004466:	4638      	mov	r0, r7
 8004468:	b003      	add	sp, #12
 800446a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (device -> ux_device_protection_semaphore.tx_semaphore_count != 0)        
 800446c:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800446e:	2a00      	cmp	r2, #0
 8004470:	d0e2      	beq.n	8004438 <_ux_host_stack_transfer_request+0x48>
            status =  _ux_utility_semaphore_get(&device -> ux_device_protection_semaphore, UX_WAIT_FOREVER);
 8004472:	f04f 31ff 	mov.w	r1, #4294967295
 8004476:	f105 0024 	add.w	r0, r5, #36	; 0x24
 800447a:	9301      	str	r3, [sp, #4]
 800447c:	f7fd fe08 	bl	8002090 <_ux_utility_semaphore_get>
            if (status != UX_SUCCESS)
 8004480:	9b01      	ldr	r3, [sp, #4]
 8004482:	4607      	mov	r7, r0
 8004484:	2800      	cmp	r0, #0
 8004486:	d0d7      	beq.n	8004438 <_ux_host_stack_transfer_request+0x48>
 8004488:	e7c6      	b.n	8004418 <_ux_host_stack_transfer_request+0x28>
 800448a:	bf00      	nop

0800448c <_ux_host_stack_transfer_request_abort>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_transfer_request_abort(UX_TRANSFER *transfer_request)
{
 800448c:	b538      	push	{r3, r4, r5, lr}
    
    /* With the device we have the pointer to the HCD.  */
    hcd = device -> ux_device_hcd;

    /* Check pending transaction.  */
    if (transfer_request -> ux_transfer_request_completion_code == UX_TRANSFER_STATUS_PENDING)
 800448e:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8004490:	2b01      	cmp	r3, #1
 8004492:	d111      	bne.n	80044b8 <_ux_host_stack_transfer_request_abort+0x2c>
    device =  endpoint -> ux_endpoint_device;
 8004494:	6843      	ldr	r3, [r0, #4]
 8004496:	4604      	mov	r4, r0
    {
    
        /* Send the abort command to the controller.  */    
        hcd -> ux_hcd_entry_function(hcd, UX_HCD_TRANSFER_ABORT, transfer_request);
 8004498:	4602      	mov	r2, r0
 800449a:	210d      	movs	r1, #13
    hcd = device -> ux_device_hcd;
 800449c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800449e:	6d18      	ldr	r0, [r3, #80]	; 0x50
        hcd -> ux_hcd_entry_function(hcd, UX_HCD_TRANSFER_ABORT, transfer_request);
 80044a0:	f8d0 30c4 	ldr.w	r3, [r0, #196]	; 0xc4
 80044a4:	4798      	blx	r3
           Such a case is valid, and we want to make sure we don't put() the
           transfer request's semaphore again.  */
        completion_code =  transfer_request -> ux_transfer_request_completion_code;

        /* Set the transfer_request status to abort.  */
        transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_STATUS_ABORT;
 80044a6:	2204      	movs	r2, #4

        /* We need to inform the class that owns this transfer_request of the 
           abort if there is a call back mechanism.  */
        if (transfer_request -> ux_transfer_request_completion_function != UX_NULL)
 80044a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
        completion_code =  transfer_request -> ux_transfer_request_completion_code;
 80044aa:	6d65      	ldr	r5, [r4, #84]	; 0x54
        transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_STATUS_ABORT;
 80044ac:	6562      	str	r2, [r4, #84]	; 0x54
        if (transfer_request -> ux_transfer_request_completion_function != UX_NULL)
 80044ae:	b10b      	cbz	r3, 80044b4 <_ux_host_stack_transfer_request_abort+0x28>
            transfer_request -> ux_transfer_request_completion_function(transfer_request);
 80044b0:	4620      	mov	r0, r4
 80044b2:	4798      	blx	r3
       
        /* Is a thread waiting on the semaphore?  */
        if (/* Is the transfer pending?  */
 80044b4:	2d01      	cmp	r5, #1
 80044b6:	d001      	beq.n	80044bc <_ux_host_stack_transfer_request_abort+0x30>
            _ux_utility_semaphore_put(&transfer_request -> ux_transfer_request_semaphore);
    }
    
    /* This function never fails!  */
    return(UX_SUCCESS);       
}
 80044b8:	2000      	movs	r0, #0
 80044ba:	bd38      	pop	{r3, r4, r5, pc}
            transfer_request -> ux_transfer_request_thread_pending != _ux_utility_thread_identify() && 
 80044bc:	6e65      	ldr	r5, [r4, #100]	; 0x64
 80044be:	f000 f85b 	bl	8004578 <_ux_utility_thread_identify>
            completion_code == UX_TRANSFER_STATUS_PENDING &&
 80044c2:	4285      	cmp	r5, r0
 80044c4:	d0f8      	beq.n	80044b8 <_ux_host_stack_transfer_request_abort+0x2c>
            transfer_request -> ux_transfer_request_thread_pending != _ux_utility_thread_identify() && 
 80044c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80044c8:	2b00      	cmp	r3, #0
 80044ca:	d1f5      	bne.n	80044b8 <_ux_host_stack_transfer_request_abort+0x2c>
            _ux_utility_semaphore_put(&transfer_request -> ux_transfer_request_semaphore);
 80044cc:	f104 0028 	add.w	r0, r4, #40	; 0x28
 80044d0:	f7fd fe02 	bl	80020d8 <_ux_utility_semaphore_put>
 80044d4:	e7f0      	b.n	80044b8 <_ux_host_stack_transfer_request_abort+0x2c>
 80044d6:	bf00      	nop

080044d8 <_ux_utility_descriptor_parse>:
VOID  _ux_utility_descriptor_parse(UCHAR * raw_descriptor, UCHAR * descriptor_structure,
                        UINT descriptor_entries, UCHAR * descriptor)
{

    /* Loop on all the entries in this descriptor.  */
    while(descriptor_entries--)
 80044d8:	b31a      	cbz	r2, 8004522 <_ux_utility_descriptor_parse+0x4a>
{
 80044da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80044dc:	4606      	mov	r6, r0
 80044de:	460c      	mov	r4, r1
 80044e0:	461d      	mov	r5, r3
 80044e2:	188f      	adds	r7, r1, r2
 80044e4:	e007      	b.n	80044f6 <_ux_utility_descriptor_parse+0x1e>
        /* Check the size then build the component from the source and
           insert it into the target descriptor.  */
        case 4:

            *((ULONG *) descriptor) =  _ux_utility_long_get(raw_descriptor);
            raw_descriptor +=  4;
 80044e6:	3604      	adds	r6, #4
            *((ULONG *) descriptor) =  _ux_utility_long_get(raw_descriptor);
 80044e8:	f000 f81c 	bl	8004524 <_ux_utility_long_get>
 80044ec:	6028      	str	r0, [r5, #0]
    while(descriptor_entries--)
 80044ee:	42bc      	cmp	r4, r7
            *((ULONG *) descriptor) =  (ULONG) *raw_descriptor;
            raw_descriptor++;
        }

        /* Add the size of the component to the destination.  */
        descriptor +=  4;
 80044f0:	f105 0504 	add.w	r5, r5, #4
    while(descriptor_entries--)
 80044f4:	d00e      	beq.n	8004514 <_ux_utility_descriptor_parse+0x3c>
        switch(*descriptor_structure++)
 80044f6:	f814 3b01 	ldrb.w	r3, [r4], #1
 80044fa:	2b02      	cmp	r3, #2
 80044fc:	d00b      	beq.n	8004516 <_ux_utility_descriptor_parse+0x3e>
 80044fe:	2b04      	cmp	r3, #4
            *((ULONG *) descriptor) =  _ux_utility_long_get(raw_descriptor);
 8004500:	4630      	mov	r0, r6
        switch(*descriptor_structure++)
 8004502:	d0f0      	beq.n	80044e6 <_ux_utility_descriptor_parse+0xe>
            *((ULONG *) descriptor) =  (ULONG) *raw_descriptor;
 8004504:	f816 3b01 	ldrb.w	r3, [r6], #1
    while(descriptor_entries--)
 8004508:	42bc      	cmp	r4, r7
        descriptor +=  4;
 800450a:	f105 0504 	add.w	r5, r5, #4
            *((ULONG *) descriptor) =  (ULONG) *raw_descriptor;
 800450e:	f845 3c04 	str.w	r3, [r5, #-4]
    while(descriptor_entries--)
 8004512:	d1f0      	bne.n	80044f6 <_ux_utility_descriptor_parse+0x1e>
    }

    /* Return to caller.  */
    return;
}
 8004514:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            *((ULONG *) descriptor) = (ULONG) _ux_utility_short_get(raw_descriptor);
 8004516:	4630      	mov	r0, r6
            raw_descriptor += 2;
 8004518:	3602      	adds	r6, #2
            *((ULONG *) descriptor) = (ULONG) _ux_utility_short_get(raw_descriptor);
 800451a:	f000 f821 	bl	8004560 <_ux_utility_short_get>
 800451e:	6028      	str	r0, [r5, #0]
            break;                   
 8004520:	e7e5      	b.n	80044ee <_ux_utility_descriptor_parse+0x16>
 8004522:	4770      	bx	lr

08004524 <_ux_utility_long_get>:
    value |=  (ULONG)*address++ << 16;
    value |=  (ULONG)*address << 24;

    /* Return 32-bit value.  */
    return(value);
}
 8004524:	6800      	ldr	r0, [r0, #0]
 8004526:	4770      	bx	lr

08004528 <_ux_utility_long_put>:
{

    /* In order to make this function endian agnostic and memory alignment
       independent, we write a byte at a time from the address.  */
    *address++ =  (UCHAR) (value & 0xff);
    *address++ =  (UCHAR) ((value >> 8) & 0xff);
 8004528:	0a0a      	lsrs	r2, r1, #8
    *address++ =  (UCHAR) (value & 0xff);
 800452a:	7001      	strb	r1, [r0, #0]
    *address++ =  (UCHAR) ((value >> 16) & 0xff);
 800452c:	0c0b      	lsrs	r3, r1, #16
    *address =    (UCHAR) ((value >> 24) & 0xff);
 800452e:	0e09      	lsrs	r1, r1, #24
    *address++ =  (UCHAR) ((value >> 8) & 0xff);
 8004530:	7042      	strb	r2, [r0, #1]
    *address++ =  (UCHAR) ((value >> 16) & 0xff);
 8004532:	7083      	strb	r3, [r0, #2]
    *address =    (UCHAR) ((value >> 24) & 0xff);
 8004534:	70c1      	strb	r1, [r0, #3]

    /* Return to caller.  */
    return;
}
 8004536:	4770      	bx	lr

08004538 <_ux_utility_long_put_big_endian>:
ULONG   high_word_value;

    /* First we swap the value words.  */
    low_word_value =  value >> 16;
    high_word_value =  value << 16;
    value =  high_word_value | low_word_value;
 8004538:	ea4f 4131 	mov.w	r1, r1, ror #16

    /* In order to make this function endian agnostic and memory alignment
       independent, we write a byte at a time from the address.  */
    *address++ =  (UCHAR) ((value >> 8) & 0xff);
 800453c:	2300      	movs	r3, #0
 800453e:	0a0a      	lsrs	r2, r1, #8
 8004540:	f362 0307 	bfi	r3, r2, #0, #8
    *address++ =  (UCHAR) (value & 0xff);
    *address++ =  (UCHAR) ((value >> 24 ) & 0xff);
    *address   =  (UCHAR) ((value >> 16) & 0xff);
 8004544:	0c0a      	lsrs	r2, r1, #16
{
 8004546:	b410      	push	{r4}
    *address++ =  (UCHAR) ((value >> 8) & 0xff);
 8004548:	f361 230f 	bfi	r3, r1, #8, #8
    *address++ =  (UCHAR) ((value >> 24 ) & 0xff);
 800454c:	0e0c      	lsrs	r4, r1, #24
    *address++ =  (UCHAR) ((value >> 8) & 0xff);
 800454e:	f364 4317 	bfi	r3, r4, #16, #8

    /* Return to caller.  */
    return;
}
 8004552:	f85d 4b04 	ldr.w	r4, [sp], #4
    *address++ =  (UCHAR) ((value >> 8) & 0xff);
 8004556:	f362 631f 	bfi	r3, r2, #24, #8
 800455a:	6003      	str	r3, [r0, #0]
}
 800455c:	4770      	bx	lr
 800455e:	bf00      	nop

08004560 <_ux_utility_short_get>:
    value =  (USHORT) *address++;
    value |=  (USHORT)(*address << 8);

    /* Return to caller.  */
    return((ULONG) value);
}
 8004560:	8800      	ldrh	r0, [r0, #0]
 8004562:	4770      	bx	lr

08004564 <_ux_utility_short_put>:
{

    /* In order to make this function endian agnostic and memory alignment
       independent, we write a byte at a time from the address */
    *address++ =  (UCHAR) (value & 0xff);
    *address = (UCHAR) ((value >> 8) & 0xff);
 8004564:	0a0b      	lsrs	r3, r1, #8
    *address++ =  (UCHAR) (value & 0xff);
 8004566:	7001      	strb	r1, [r0, #0]
    *address = (UCHAR) ((value >> 8) & 0xff);
 8004568:	7043      	strb	r3, [r0, #1]

    /* Return to caller.  */
    return;
}
 800456a:	4770      	bx	lr

0800456c <_ux_utility_short_put_big_endian>:

    
    /* First we swap the value bytes. */
    low_byte_value =  value >> 8;
    high_byte_value =  (USHORT)(value<< 8);
    value =  high_byte_value | low_byte_value;
 800456c:	ba49      	rev16	r1, r1
 800456e:	b289      	uxth	r1, r1

    /* In order to make this function endian agnostic and memory alignment
       independent, we write a byte at a time from the address.  */
    *address++ =  (UCHAR) (value & 0xff);
    *address=     (UCHAR) ((value >> 8) & 0xff);
 8004570:	0a0b      	lsrs	r3, r1, #8
    *address++ =  (UCHAR) (value & 0xff);
 8004572:	7001      	strb	r1, [r0, #0]
    *address=     (UCHAR) ((value >> 8) & 0xff);
 8004574:	7043      	strb	r3, [r0, #1]

    /* Return to caller. */
    return;
}
 8004576:	4770      	bx	lr

08004578 <_ux_utility_thread_identify>:
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8004578:	f3ef 8305 	mrs	r3, IPSR
{


    /* If we're under interrupt, the thread returned by tx_thread_identify
        is the thread running prior to the ISR. Instead, we set it to null.  */
    return(TX_THREAD_GET_SYSTEM_STATE() ? UX_NULL : tx_thread_identify());
 800457c:	4a03      	ldr	r2, [pc, #12]	; (800458c <_ux_utility_thread_identify+0x14>)
 800457e:	6812      	ldr	r2, [r2, #0]
 8004580:	4313      	orrs	r3, r2
 8004582:	d101      	bne.n	8004588 <_ux_utility_thread_identify+0x10>
 8004584:	f008 b83c 	b.w	800c600 <_tx_thread_identify>
}
 8004588:	2000      	movs	r0, #0
 800458a:	4770      	bx	lr
 800458c:	20000164 	.word	0x20000164

08004590 <_ux_utility_thread_schedule_other>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_utility_thread_schedule_other(UINT caller_priority)
{
 8004590:	b510      	push	{r4, lr}
 8004592:	b082      	sub	sp, #8
TX_THREAD   *my_thread;

    UX_PARAMETER_NOT_USED(caller_priority);

    /* Call TX to know my own tread.  */
    my_thread = tx_thread_identify();
 8004594:	f008 f834 	bl	800c600 <_tx_thread_identify>

    /* Call ThreadX to change thread priority .  */
    status =  tx_thread_priority_change(my_thread, _ux_system -> ux_system_thread_lowest_priority, &old_priority);
 8004598:	4b08      	ldr	r3, [pc, #32]	; (80045bc <_ux_utility_thread_schedule_other+0x2c>)
 800459a:	aa01      	add	r2, sp, #4
    my_thread = tx_thread_identify();
 800459c:	4604      	mov	r4, r0
    status =  tx_thread_priority_change(my_thread, _ux_system -> ux_system_thread_lowest_priority, &old_priority);
 800459e:	681b      	ldr	r3, [r3, #0]
 80045a0:	6999      	ldr	r1, [r3, #24]
 80045a2:	f008 fe27 	bl	800d1f4 <_txe_thread_priority_change>
    
    /* Check for error.  */
    if (status == TX_SUCCESS)
 80045a6:	b930      	cbnz	r0, 80045b6 <_ux_utility_thread_schedule_other+0x26>
    {
    
        /* Wait until all other threads passed into the scheduler. */
        _ux_utility_thread_relinquish();
 80045a8:	f000 ff26 	bl	80053f8 <_ux_utility_thread_relinquish>
    
        /* And now return the priority of the thread to normal.  */
        status =  tx_thread_priority_change(my_thread, old_priority, &old_priority);
 80045ac:	aa01      	add	r2, sp, #4
 80045ae:	4620      	mov	r0, r4
 80045b0:	9901      	ldr	r1, [sp, #4]
 80045b2:	f008 fe1f 	bl	800d1f4 <_txe_thread_priority_change>
        
    }

    /* Return completion status.  */
    return(status);
}
 80045b6:	b002      	add	sp, #8
 80045b8:	bd10      	pop	{r4, pc}
 80045ba:	bf00      	nop
 80045bc:	20000dc0 	.word	0x20000dc0

080045c0 <_ux_host_class_hub_feature>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_feature(UX_HOST_CLASS_HUB *hub, UINT port, UINT command, UINT function)
{
 80045c0:	b470      	push	{r4, r5, r6}
UINT            target;
UINT            status;


    /* We need to get the default control endpoint transfer request pointer.  */
    control_endpoint =  &hub -> ux_host_class_hub_device -> ux_device_control_endpoint;
 80045c2:	6884      	ldr	r4, [r0, #8]
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    /* The target is DEVICE for the HUB and OTHER for the downstream ports.  */
    if (port == 0)
 80045c4:	2900      	cmp	r1, #0
 80045c6:	bf14      	ite	ne
 80045c8:	2623      	movne	r6, #35	; 0x23
 80045ca:	2620      	moveq	r6, #32
    else
        target =  UX_REQUEST_TARGET_OTHER;

    /* Create a transfer request for the SET_FEATURE or CLEAR_FEATURE request.  */
    transfer_request -> ux_transfer_request_function =          command;
    transfer_request -> ux_transfer_request_requested_length =  0;
 80045cc:	2500      	movs	r5, #0
    transfer_request -> ux_transfer_request_function =          command;
 80045ce:	f8c4 20dc 	str.w	r2, [r4, #220]	; 0xdc
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_OUT | UX_REQUEST_TYPE_CLASS | target;
    transfer_request -> ux_transfer_request_value =             function;
    transfer_request -> ux_transfer_request_index =             port;

    /* Send request to HCD layer.  */
    status =  _ux_host_stack_transfer_request(transfer_request);
 80045d2:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_OUT | UX_REQUEST_TYPE_CLASS | target;
 80045d6:	f8c4 60d8 	str.w	r6, [r4, #216]	; 0xd8
    transfer_request -> ux_transfer_request_requested_length =  0;
 80045da:	f8c4 50d0 	str.w	r5, [r4, #208]	; 0xd0
    transfer_request -> ux_transfer_request_index =             port;
 80045de:	e9c4 3138 	strd	r3, r1, [r4, #224]	; 0xe0
    
    /* Return completion status.  */
    return(status);
}
 80045e2:	bc70      	pop	{r4, r5, r6}
    status =  _ux_host_stack_transfer_request(transfer_request);
 80045e4:	f7ff bf04 	b.w	80043f0 <_ux_host_stack_transfer_request>

080045e8 <_ux_host_class_hub_port_change_connection_process>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_class_hub_port_change_connection_process(UX_HOST_CLASS_HUB *hub, UINT port, UINT port_status)
{
 80045e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80045ec:	2301      	movs	r3, #1
 80045ee:	460d      	mov	r5, r1
 80045f0:	4604      	mov	r4, r0
    
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_HUB_PORT_CHANGE_CONNECTION_PROCESS, hub, port, port_status, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

    /* Get the HCD used by this instance.  */
    hcd =  hub -> ux_host_class_hub_device -> ux_device_hcd;
 80045f2:	6881      	ldr	r1, [r0, #8]
 80045f4:	40ab      	lsls	r3, r5
 80045f6:	6c40      	ldr	r0, [r0, #68]	; 0x44

    /* If there is a device attached on this HUB, there is a new device and it should 
       be enumerated.  */
    if (port_status & UX_HOST_CLASS_HUB_PORT_STATUS_CONNECTION)
 80045f8:	07d7      	lsls	r7, r2, #31
{
 80045fa:	b085      	sub	sp, #20
    hcd =  hub -> ux_host_class_hub_device -> ux_device_hcd;
 80045fc:	f8d1 8050 	ldr.w	r8, [r1, #80]	; 0x50
 8004600:	ea03 0600 	and.w	r6, r3, r0
    if (port_status & UX_HOST_CLASS_HUB_PORT_STATUS_CONNECTION)
 8004604:	d548      	bpl.n	8004698 <_ux_host_class_hub_port_change_connection_process+0xb0>
    {

        /* Check if there was a previous device already attached on this port. This may happen when a device
           disconnects and reconnect very quickly before the hub has a chance to poll the port state. In this
           case we do a device removal before doing a device connection.  */
        if (hub -> ux_host_class_hub_port_state & (UINT)(1 << port))
 8004606:	2e00      	cmp	r6, #0
 8004608:	d164      	bne.n	80046d4 <_ux_host_class_hub_port_change_connection_process+0xec>
            
        }
        else
            
            /* Mark device connection.  */
            hub -> ux_host_class_hub_port_state |= (UINT)(1 << port);
 800460a:	4303      	orrs	r3, r0
 800460c:	6463      	str	r3, [r4, #68]	; 0x44
          
        /* Tell the hub to clear the change bit for this port so that we do 
           not process the same change event again.  */
        _ux_host_class_hub_feature(hub, port, UX_CLEAR_FEATURE, UX_HOST_CLASS_HUB_C_PORT_CONNECTION);
 800460e:	2310      	movs	r3, #16
 8004610:	2201      	movs	r2, #1
 8004612:	4629      	mov	r1, r5
 8004614:	4620      	mov	r0, r4
 8004616:	2703      	movs	r7, #3
 8004618:	f7ff ffd2 	bl	80045c0 <_ux_host_class_hub_feature>
        /* Some devices are known to fail on the first try.  */
        for (device_enumeration_retry = 0; device_enumeration_retry < UX_HOST_CLASS_HUB_ENUMERATION_RETRY; device_enumeration_retry++)
        {

            /* Wait for debounce.  */
            _ux_utility_delay_ms(UX_HOST_CLASS_HUB_ENUMERATION_DEBOUNCE_DELAY);
 800461c:	2064      	movs	r0, #100	; 0x64
 800461e:	f7fd fb59 	bl	8001cd4 <_ux_utility_delay_ms>

            /* The port must be reset.  */
            status =  _ux_host_class_hub_port_reset(hub, port);
 8004622:	4629      	mov	r1, r5
 8004624:	4620      	mov	r0, r4
 8004626:	f000 f873 	bl	8004710 <_ux_host_class_hub_port_reset>
            if (status != UX_SUCCESS)
                return;
                
            /* Reset succeeded, so perform a new port status after reset to force speed reevaluation.  */
            status =  _ux_host_class_hub_status_get(hub, port, &local_port_status, &local_port_change);
 800462a:	f10d 030e 	add.w	r3, sp, #14
 800462e:	aa03      	add	r2, sp, #12
 8004630:	4629      	mov	r1, r5
            if (status != UX_SUCCESS)
 8004632:	2800      	cmp	r0, #0
 8004634:	d143      	bne.n	80046be <_ux_host_class_hub_port_change_connection_process+0xd6>
            status =  _ux_host_class_hub_status_get(hub, port, &local_port_status, &local_port_change);
 8004636:	4620      	mov	r0, r4
 8004638:	f7fe f81c 	bl	8002674 <_ux_host_class_hub_status_get>
            if (status != UX_SUCCESS)
 800463c:	4606      	mov	r6, r0
 800463e:	2800      	cmp	r0, #0
 8004640:	d13d      	bne.n	80046be <_ux_host_class_hub_port_change_connection_process+0xd6>
                return;

            /* Device connected. Get the device speed.  */
            if (local_port_status & UX_HOST_CLASS_HUB_PORT_STATUS_LOW_SPEED)
 8004642:	f8bd 300c 	ldrh.w	r3, [sp, #12]
            
                /* Hub is self powered.  */
                port_power =  UX_MAX_SELF_POWER;

            /* Wait for reset recovery.  */
            _ux_utility_delay_ms(UX_HOST_CLASS_HUB_ENUMERATION_RESET_RECOVERY_DELAY);
 8004646:	200a      	movs	r0, #10
            if (local_port_status & UX_HOST_CLASS_HUB_PORT_STATUS_LOW_SPEED)
 8004648:	059a      	lsls	r2, r3, #22
 800464a:	d404      	bmi.n	8004656 <_ux_host_class_hub_port_change_connection_process+0x6e>
                    device_speed =  UX_HIGH_SPEED_DEVICE;
 800464c:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8004650:	bf0c      	ite	eq
 8004652:	2601      	moveq	r6, #1
 8004654:	2602      	movne	r6, #2
            if (hub -> ux_host_class_hub_device -> ux_device_power_source == UX_DEVICE_BUS_POWERED)
 8004656:	68a3      	ldr	r3, [r4, #8]
 8004658:	69db      	ldr	r3, [r3, #28]
 800465a:	2b01      	cmp	r3, #1
 800465c:	bf14      	ite	ne
 800465e:	f04f 09fa 	movne.w	r9, #250	; 0xfa
 8004662:	f04f 0932 	moveq.w	r9, #50	; 0x32
            _ux_utility_delay_ms(UX_HOST_CLASS_HUB_ENUMERATION_RESET_RECOVERY_DELAY);
 8004666:	f7fd fb35 	bl	8001cd4 <_ux_utility_delay_ms>

            /* Perform the device creation.  */
            status =  _ux_host_stack_new_device_create(hub -> ux_host_class_hub_device -> ux_device_hcd,
 800466a:	68a1      	ldr	r1, [r4, #8]
 800466c:	462a      	mov	r2, r5
 800466e:	4633      	mov	r3, r6
 8004670:	6d08      	ldr	r0, [r1, #80]	; 0x50
 8004672:	f8cd 9000 	str.w	r9, [sp]
 8004676:	f000 fe2b 	bl	80052d0 <_ux_host_stack_new_device_create>
            }
            else if (device_enumeration_retry < UX_HOST_CLASS_HUB_ENUMERATION_RETRY - 1)
            {

                /* Simulate remove to free allocated resources before retry.  */
                _ux_host_stack_device_remove(hcd, hub -> ux_host_class_hub_device, port);
 800467a:	462a      	mov	r2, r5
            if (status == UX_SUCCESS)
 800467c:	b1f8      	cbz	r0, 80046be <_ux_host_class_hub_port_change_connection_process+0xd6>
            else if (device_enumeration_retry < UX_HOST_CLASS_HUB_ENUMERATION_RETRY - 1)
 800467e:	2f01      	cmp	r7, #1
                _ux_host_stack_device_remove(hcd, hub -> ux_host_class_hub_device, port);
 8004680:	4640      	mov	r0, r8
 8004682:	f107 37ff 	add.w	r7, r7, #4294967295
            else if (device_enumeration_retry < UX_HOST_CLASS_HUB_ENUMERATION_RETRY - 1)
 8004686:	d01d      	beq.n	80046c4 <_ux_host_class_hub_port_change_connection_process+0xdc>
                _ux_host_stack_device_remove(hcd, hub -> ux_host_class_hub_device, port);
 8004688:	68a1      	ldr	r1, [r4, #8]
 800468a:	f7ff fc67 	bl	8003f5c <_ux_host_stack_device_remove>

                /* Wait for a while.  */
                _ux_utility_delay_ms(UX_HOST_CLASS_HUB_ENUMERATION_RETRY_DELAY);
 800468e:	f44f 7096 	mov.w	r0, #300	; 0x12c
 8004692:	f7fd fb1f 	bl	8001cd4 <_ux_utility_delay_ms>
 8004696:	e7c1      	b.n	800461c <_ux_host_class_hub_port_change_connection_process+0x34>
    }           
    else
    {

        /* Check if there was a no previous device attached on this port. */
        if ((hub -> ux_host_class_hub_port_state & (UINT)(1 << port)))
 8004698:	bb0e      	cbnz	r6, 80046de <_ux_host_class_hub_port_change_connection_process+0xf6>
            /* We get here when there is a device extraction.  */
            status =  _ux_host_stack_device_remove(hcd, hub -> ux_host_class_hub_device, port);
        }

        /* The port should be disabled now. Power is still applied.  */
        status =  _ux_host_class_hub_feature(hub, port, UX_CLEAR_FEATURE, UX_HOST_CLASS_HUB_PORT_ENABLE);
 800469a:	2301      	movs	r3, #1
 800469c:	4629      	mov	r1, r5
 800469e:	4620      	mov	r0, r4
 80046a0:	461a      	mov	r2, r3
 80046a2:	f7ff ff8d 	bl	80045c0 <_ux_host_class_hub_feature>

        /* We must clear the enable change condition so that we don't get awaken again.  */
        _ux_host_class_hub_feature(hub, port, UX_CLEAR_FEATURE, UX_HOST_CLASS_HUB_C_PORT_ENABLE);
 80046a6:	2311      	movs	r3, #17
 80046a8:	2201      	movs	r2, #1
 80046aa:	4629      	mov	r1, r5
 80046ac:	4620      	mov	r0, r4
 80046ae:	f7ff ff87 	bl	80045c0 <_ux_host_class_hub_feature>

        /* We must clear the connection change condition so that we don't get awaken again.  */
        _ux_host_class_hub_feature(hub, port, UX_CLEAR_FEATURE, UX_HOST_CLASS_HUB_C_PORT_CONNECTION);
 80046b2:	4629      	mov	r1, r5
 80046b4:	4620      	mov	r0, r4
 80046b6:	2310      	movs	r3, #16
 80046b8:	2201      	movs	r2, #1
 80046ba:	f7ff ff81 	bl	80045c0 <_ux_host_class_hub_feature>
    }        

    /* Return to caller.  */
    return;
}
 80046be:	b005      	add	sp, #20
 80046c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ROOT_HUB, UX_DEVICE_ENUMERATION_FAILURE);
 80046c4:	2244      	movs	r2, #68	; 0x44
 80046c6:	2105      	movs	r1, #5
 80046c8:	2002      	movs	r0, #2
 80046ca:	f7fd fa99 	bl	8001c00 <_ux_system_error_handler>
}
 80046ce:	b005      	add	sp, #20
 80046d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            status =  _ux_host_stack_device_remove(hcd, hub -> ux_host_class_hub_device, port);
 80046d4:	462a      	mov	r2, r5
 80046d6:	4640      	mov	r0, r8
 80046d8:	f7ff fc40 	bl	8003f5c <_ux_host_stack_device_remove>
 80046dc:	e797      	b.n	800460e <_ux_host_class_hub_port_change_connection_process+0x26>
            hub -> ux_host_class_hub_port_state &= (UINT)~(1 << port);
 80046de:	ea20 0303 	bic.w	r3, r0, r3
            status =  _ux_host_stack_device_remove(hcd, hub -> ux_host_class_hub_device, port);
 80046e2:	462a      	mov	r2, r5
 80046e4:	4640      	mov	r0, r8
            hub -> ux_host_class_hub_port_state &= (UINT)~(1 << port);
 80046e6:	6463      	str	r3, [r4, #68]	; 0x44
            status =  _ux_host_stack_device_remove(hcd, hub -> ux_host_class_hub_device, port);
 80046e8:	f7ff fc38 	bl	8003f5c <_ux_host_stack_device_remove>
 80046ec:	e7d5      	b.n	800469a <_ux_host_class_hub_port_change_connection_process+0xb2>
 80046ee:	bf00      	nop

080046f0 <_ux_host_class_hub_port_change_enable_process>:

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_HUB_PORT_CHANGE_ENABLE_PROCESS, hub, port, port_status, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

    /* Here we simply clear the condition so that we don't get awaken again.  */
    _ux_host_class_hub_feature(hub, port, UX_CLEAR_FEATURE, UX_HOST_CLASS_HUB_C_PORT_ENABLE);
 80046f0:	2311      	movs	r3, #17
 80046f2:	2201      	movs	r2, #1
 80046f4:	f7ff bf64 	b.w	80045c0 <_ux_host_class_hub_feature>

080046f8 <_ux_host_class_hub_port_change_over_current_process>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_class_hub_port_change_over_current_process(UX_HOST_CLASS_HUB *hub, UINT port, UINT port_status)
{
 80046f8:	b508      	push	{r3, lr}

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_HUB_PORT_CHANGE_OVER_CURRENT_PROCESS, hub, port, port_status, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

    /* Here we simply clear the condition so that we don't get awaken again.  */
    _ux_host_class_hub_feature(hub, port, UX_CLEAR_FEATURE, UX_HOST_CLASS_HUB_C_PORT_OVER_CURRENT);
 80046fa:	2201      	movs	r2, #1
 80046fc:	2313      	movs	r3, #19
 80046fe:	f7ff ff5f 	bl	80045c0 <_ux_host_class_hub_feature>

    /* Error trap. */
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HUB, UX_OVER_CURRENT_CONDITION);
 8004702:	2243      	movs	r2, #67	; 0x43
 8004704:	2106      	movs	r1, #6
 8004706:	2002      	movs	r0, #2

    /* Return to caller.  */
    return;
}   
 8004708:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HUB, UX_OVER_CURRENT_CONDITION);
 800470c:	f7fd ba78 	b.w	8001c00 <_ux_system_error_handler>

08004710 <_ux_host_class_hub_port_reset>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_hub_port_reset(UX_HOST_CLASS_HUB *hub, UINT port)
{
 8004710:	b5f0      	push	{r4, r5, r6, r7, lr}
USHORT      port_status;
USHORT      port_change;


    /* Send the PORT_RESET command.  */
    status =  _ux_host_class_hub_feature(hub, port, UX_SET_FEATURE, UX_HOST_CLASS_HUB_PORT_RESET);
 8004712:	2304      	movs	r3, #4
{
 8004714:	b083      	sub	sp, #12
    status =  _ux_host_class_hub_feature(hub, port, UX_SET_FEATURE, UX_HOST_CLASS_HUB_PORT_RESET);
 8004716:	2203      	movs	r2, #3
{
 8004718:	4606      	mov	r6, r0
 800471a:	460f      	mov	r7, r1
    status =  _ux_host_class_hub_feature(hub, port, UX_SET_FEATURE, UX_HOST_CLASS_HUB_PORT_RESET);
 800471c:	f7ff ff50 	bl	80045c0 <_ux_host_class_hub_feature>

    /* Check the function result and update HUB status if there was a problem.  */
    if (status != UX_SUCCESS)
 8004720:	4604      	mov	r4, r0
 8004722:	b9c0      	cbnz	r0, 8004756 <_ux_host_class_hub_port_reset+0x46>
 8004724:	2503      	movs	r5, #3
    port_enable_retry =  UX_HOST_CLASS_HUB_ENABLE_RETRY_COUNT;
    while (port_enable_retry--)
    {

        /* Now get the status until we have a port enabled.  */
        status =  _ux_host_class_hub_status_get(hub, port, &port_status, &port_change);
 8004726:	f10d 0306 	add.w	r3, sp, #6
 800472a:	aa01      	add	r2, sp, #4
 800472c:	4639      	mov	r1, r7
 800472e:	4630      	mov	r0, r6
 8004730:	f7fd ffa0 	bl	8002674 <_ux_host_class_hub_status_get>
        if (status != UX_SUCCESS)
 8004734:	4604      	mov	r4, r0
 8004736:	b970      	cbnz	r0, 8004756 <_ux_host_class_hub_port_reset+0x46>
            return(status);
            
        /* On return of the GET_STATUS, the port_change field has been updated. 
           Check for each of the bits it may contain. */
        if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_RESET)
 8004738:	f8bd 3006 	ldrh.w	r3, [sp, #6]
            /* Return success.  */
            return(UX_SUCCESS);
        }

        /* We should wait a bit before retrying this operation.  */
        _ux_utility_delay_ms(UX_HOST_CLASS_HUB_ENABLE_RETRY_DELAY);
 800473c:	2064      	movs	r0, #100	; 0x64
        if (port_change & UX_HOST_CLASS_HUB_PORT_CHANGE_RESET)
 800473e:	06db      	lsls	r3, r3, #27
 8004740:	d40c      	bmi.n	800475c <_ux_host_class_hub_port_reset+0x4c>
        _ux_utility_delay_ms(UX_HOST_CLASS_HUB_ENABLE_RETRY_DELAY);
 8004742:	f7fd fac7 	bl	8001cd4 <_ux_utility_delay_ms>
    while (port_enable_retry--)
 8004746:	3d01      	subs	r5, #1
 8004748:	d1ed      	bne.n	8004726 <_ux_host_class_hub_port_reset+0x16>

    /* Invoke error callback.  */
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HUB, UX_PORT_RESET_FAILED);

    /* Return error.  */
    return(UX_PORT_RESET_FAILED);
 800474a:	2431      	movs	r4, #49	; 0x31
    _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HUB, UX_PORT_RESET_FAILED);
 800474c:	2106      	movs	r1, #6
 800474e:	2002      	movs	r0, #2
 8004750:	4622      	mov	r2, r4
 8004752:	f7fd fa55 	bl	8001c00 <_ux_system_error_handler>
}
 8004756:	4620      	mov	r0, r4
 8004758:	b003      	add	sp, #12
 800475a:	bdf0      	pop	{r4, r5, r6, r7, pc}
            _ux_host_class_hub_port_change_reset_process(hub, port, port_status);       
 800475c:	4639      	mov	r1, r7
 800475e:	4630      	mov	r0, r6
 8004760:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 8004764:	f7fd ff52 	bl	800260c <_ux_host_class_hub_port_change_reset_process>
            return(UX_SUCCESS);
 8004768:	e7f5      	b.n	8004756 <_ux_host_class_hub_port_reset+0x46>
 800476a:	bf00      	nop

0800476c <_ux_host_class_storage_driver_entry>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_class_storage_driver_entry(FX_MEDIA *media)
{
 800476c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
UX_HOST_CLASS_STORAGE           *storage;
UX_HOST_CLASS_STORAGE_MEDIA     *storage_media;
    

    /* Get the pointer to the storage instance.  */
    storage =  (UX_HOST_CLASS_STORAGE *) media -> fx_media_driver_info;
 800476e:	f8d0 5084 	ldr.w	r5, [r0, #132]	; 0x84

    /* Get the pointer to the media instance.  */
    storage_media =  (UX_HOST_CLASS_STORAGE_MEDIA *) media -> fx_media_reserved_for_user;
    
    /* Ensure the instance is valid.  */
    if ((storage -> ux_host_class_storage_state !=  UX_HOST_CLASS_INSTANCE_LIVE) &&
 8004772:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 8004776:	f023 0302 	bic.w	r3, r3, #2
 800477a:	2b01      	cmp	r3, #1
 800477c:	d003      	beq.n	8004786 <_ux_host_class_storage_driver_entry+0x1a>
        (storage -> ux_host_class_storage_state !=  UX_HOST_CLASS_INSTANCE_MOUNTING))
    {

        /* Class instance is invalid. Return an error!  */
        media -> fx_media_driver_status =  FX_PTR_ERROR;
 800477e:	2318      	movs	r3, #24
 8004780:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
        break;
    }

    /* Unprotect thread reentry to this instance.  */
    _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
}
 8004784:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    _ux_utility_semaphore_get(&storage -> ux_host_class_storage_semaphore, UX_WAIT_FOREVER);
 8004786:	f505 77c2 	add.w	r7, r5, #388	; 0x184
    storage_media =  (UX_HOST_CLASS_STORAGE_MEDIA *) media -> fx_media_reserved_for_user;
 800478a:	f8d0 6898 	ldr.w	r6, [r0, #2200]	; 0x898
 800478e:	4604      	mov	r4, r0
    _ux_utility_semaphore_get(&storage -> ux_host_class_storage_semaphore, UX_WAIT_FOREVER);
 8004790:	f04f 31ff 	mov.w	r1, #4294967295
 8004794:	4638      	mov	r0, r7
 8004796:	f7fd fc7b 	bl	8002090 <_ux_utility_semaphore_get>
    storage -> ux_host_class_storage_lun =  storage_media -> ux_host_class_storage_media_lun;
 800479a:	f242 41bc 	movw	r1, #9404	; 0x24bc
    storage -> ux_host_class_storage_sector_size =  storage_media -> ux_host_class_storage_media_sector_size;
 800479e:	f242 42c4 	movw	r2, #9412	; 0x24c4
    switch (media -> fx_media_driver_request)
 80047a2:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
    storage -> ux_host_class_storage_lun =  storage_media -> ux_host_class_storage_media_lun;
 80047a6:	5871      	ldr	r1, [r6, r1]
    storage -> ux_host_class_storage_sector_size =  storage_media -> ux_host_class_storage_media_sector_size;
 80047a8:	58b2      	ldr	r2, [r6, r2]
    storage -> ux_host_class_storage_lun =  storage_media -> ux_host_class_storage_media_lun;
 80047aa:	f8c5 112c 	str.w	r1, [r5, #300]	; 0x12c
    storage -> ux_host_class_storage_sector_size =  storage_media -> ux_host_class_storage_media_sector_size;
 80047ae:	f8c5 2170 	str.w	r2, [r5, #368]	; 0x170
    switch (media -> fx_media_driver_request)
 80047b2:	2b08      	cmp	r3, #8
 80047b4:	d84e      	bhi.n	8004854 <_ux_host_class_storage_driver_entry+0xe8>
 80047b6:	e8df f003 	tbb	[pc, r3]
 80047ba:	3325      	.short	0x3325
 80047bc:	13050b0b 	.word	0x13050b0b
 80047c0:	414d      	.short	0x414d
 80047c2:	0b          	.byte	0x0b
 80047c3:	00          	.byte	0x00
        if (storage -> ux_host_class_storage_write_protected_media ==  UX_TRUE)
 80047c4:	f8d5 3124 	ldr.w	r3, [r5, #292]	; 0x124
 80047c8:	2b01      	cmp	r3, #1
 80047ca:	d101      	bne.n	80047d0 <_ux_host_class_storage_driver_entry+0x64>
            media -> fx_media_driver_write_protect = UX_TRUE;
 80047cc:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
        media -> fx_media_driver_status =  FX_SUCCESS;
 80047d0:	2300      	movs	r3, #0
 80047d2:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
    _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
 80047d6:	4638      	mov	r0, r7
}
 80047d8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    _ux_utility_semaphore_put(&storage -> ux_host_class_storage_semaphore);
 80047dc:	f7fd bc7c 	b.w	80020d8 <_ux_utility_semaphore_put>
        status =  _ux_host_class_storage_media_read(storage, storage_media -> ux_host_class_storage_media_partition_start, 1,
 80047e0:	f506 5613 	add.w	r6, r6, #9408	; 0x24c0
 80047e4:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80047e8:	2201      	movs	r2, #1
 80047ea:	4628      	mov	r0, r5
 80047ec:	6831      	ldr	r1, [r6, #0]
 80047ee:	f7fe fa99 	bl	8002d24 <_ux_host_class_storage_media_read>
        if (status == UX_SUCCESS)
 80047f2:	2800      	cmp	r0, #0
 80047f4:	d0ec      	beq.n	80047d0 <_ux_host_class_storage_driver_entry+0x64>
            media -> fx_media_driver_status =  _ux_host_class_storage_sense_code_translate(storage, status);
 80047f6:	4601      	mov	r1, r0
 80047f8:	4628      	mov	r0, r5
 80047fa:	f000 f8eb 	bl	80049d4 <_ux_host_class_storage_sense_code_translate>
 80047fe:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
 8004802:	e7e8      	b.n	80047d6 <_ux_host_class_storage_driver_entry+0x6a>
                                        storage_media -> ux_host_class_storage_media_partition_start,
 8004804:	f506 5613 	add.w	r6, r6, #9408	; 0x24c0
        status =  _ux_host_class_storage_media_read(storage, media -> fx_media_driver_logical_sector + 
 8004808:	4628      	mov	r0, r5
 800480a:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 800480e:	6836      	ldr	r6, [r6, #0]
 8004810:	e9d4 3124 	ldrd	r3, r1, [r4, #144]	; 0x90
 8004814:	4431      	add	r1, r6
 8004816:	f7fe fa85 	bl	8002d24 <_ux_host_class_storage_media_read>
        if (status == UX_SUCCESS)
 800481a:	2800      	cmp	r0, #0
 800481c:	d0d8      	beq.n	80047d0 <_ux_host_class_storage_driver_entry+0x64>
 800481e:	e7ea      	b.n	80047f6 <_ux_host_class_storage_driver_entry+0x8a>
                                            storage_media -> ux_host_class_storage_media_partition_start,
 8004820:	f506 5613 	add.w	r6, r6, #9408	; 0x24c0
        status =  _ux_host_class_storage_media_write(storage, media -> fx_media_driver_logical_sector + 
 8004824:	4628      	mov	r0, r5
 8004826:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 800482a:	6836      	ldr	r6, [r6, #0]
 800482c:	e9d4 3124 	ldrd	r3, r1, [r4, #144]	; 0x90
 8004830:	4431      	add	r1, r6
 8004832:	f000 f85f 	bl	80048f4 <_ux_host_class_storage_media_write>
        if (status == UX_SUCCESS)
 8004836:	2800      	cmp	r0, #0
 8004838:	d0ca      	beq.n	80047d0 <_ux_host_class_storage_driver_entry+0x64>
 800483a:	e7dc      	b.n	80047f6 <_ux_host_class_storage_driver_entry+0x8a>
        status =  _ux_host_class_storage_media_write(storage, storage_media -> ux_host_class_storage_media_partition_start, 1,
 800483c:	f506 5613 	add.w	r6, r6, #9408	; 0x24c0
 8004840:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8004844:	2201      	movs	r2, #1
 8004846:	4628      	mov	r0, r5
 8004848:	6831      	ldr	r1, [r6, #0]
 800484a:	f000 f853 	bl	80048f4 <_ux_host_class_storage_media_write>
        if (status == UX_SUCCESS)
 800484e:	2800      	cmp	r0, #0
 8004850:	d0be      	beq.n	80047d0 <_ux_host_class_storage_driver_entry+0x64>
 8004852:	e7d0      	b.n	80047f6 <_ux_host_class_storage_driver_entry+0x8a>
        media -> fx_media_driver_status =  FX_IO_ERROR;
 8004854:	2390      	movs	r3, #144	; 0x90
 8004856:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        break;
 800485a:	e7bc      	b.n	80047d6 <_ux_host_class_storage_driver_entry+0x6a>

0800485c <_ux_host_class_storage_media_capacity_get>:
/*                                                                        */
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_media_capacity_get(UX_HOST_CLASS_STORAGE *storage)
{
 800485c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_CLASS_STORAGE_MEDIA_CAPACITY_GET, storage, 0, 0, 0, UX_TRACE_HOST_CLASS_EVENTS, 0, 0)

    /* Set the default to either 512 or 2048 bytes.  */
    switch (storage -> ux_host_class_storage_media_type)
 800485e:	f8d0 30e0 	ldr.w	r3, [r0, #224]	; 0xe0
 8004862:	2b05      	cmp	r3, #5
 8004864:	d035      	beq.n	80048d2 <_ux_host_class_storage_media_capacity_get+0x76>
 8004866:	d92f      	bls.n	80048c8 <_ux_host_class_storage_media_capacity_get+0x6c>
 8004868:	2b07      	cmp	r3, #7
 800486a:	d032      	beq.n	80048d2 <_ux_host_class_storage_media_capacity_get+0x76>
 800486c:	2b55      	cmp	r3, #85	; 0x55
 800486e:	d12d      	bne.n	80048cc <_ux_host_class_storage_media_capacity_get+0x70>
    {

    case UX_HOST_CLASS_STORAGE_MEDIA_FAT_DISK:
    case UX_HOST_CLASS_STORAGE_MEDIA_IOMEGA_CLICK:

        storage -> ux_host_class_storage_sector_size =  UX_HOST_CLASS_STORAGE_SECTOR_SIZE_FAT;
 8004870:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004874:	f8c0 3170 	str.w	r3, [r0, #368]	; 0x170
 8004878:	4604      	mov	r4, r0
{
 800487a:	270a      	movs	r7, #10
       On floppies, this operation tends to fail a few times. So we try harder.  */
    for (command_retry = 0; command_retry < UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RETRY; command_retry++)
    {

        /* Some devices require we do this.  */
        status =  _ux_host_class_storage_media_format_capacity_get(storage);
 800487c:	4620      	mov	r0, r4
 800487e:	f7fe f987 	bl	8002b90 <_ux_host_class_storage_media_format_capacity_get>
#else
        command_length =  UX_HOST_CLASS_STORAGE_READ_CAPACITY_COMMAND_LENGTH_SBC;
#endif

        /* Initialize the CBW for this command.  */
        _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_IN, UX_HOST_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH, command_length);
 8004882:	230a      	movs	r3, #10
        if (status != UX_SUCCESS)
 8004884:	4605      	mov	r5, r0
        _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_IN, UX_HOST_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH, command_length);
 8004886:	2208      	movs	r2, #8
 8004888:	2180      	movs	r1, #128	; 0x80
        if (status != UX_SUCCESS)
 800488a:	bb00      	cbnz	r0, 80048ce <_ux_host_class_storage_media_capacity_get+0x72>
        _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_IN, UX_HOST_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH, command_length);
 800488c:	4620      	mov	r0, r4
 800488e:	f7fd ff93 	bl	80027b8 <_ux_host_class_storage_cbw_initialize>

        /* Prepare the READ_CAPACITY command block.  */
        *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_READ_CAPACITY_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_READ_CAPACITY;
 8004892:	2325      	movs	r3, #37	; 0x25

        /* Obtain a block of memory for the answer.  */
        capacity_response =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH);
 8004894:	2208      	movs	r2, #8
 8004896:	2101      	movs	r1, #1
        *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_READ_CAPACITY_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_READ_CAPACITY;
 8004898:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
        capacity_response =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_READ_CAPACITY_RESPONSE_LENGTH);
 800489c:	f04f 30ff 	mov.w	r0, #4294967295
 80048a0:	f7fd fa24 	bl	8001cec <_ux_utility_memory_allocate>
        if (capacity_response == UX_NULL)
 80048a4:	4606      	mov	r6, r0
 80048a6:	b318      	cbz	r0, 80048f0 <_ux_host_class_storage_media_capacity_get+0x94>
            return(UX_MEMORY_INSUFFICIENT);

        /* Send the command to transport layer.  */
        status =  _ux_host_class_storage_transport(storage, capacity_response);
 80048a8:	4601      	mov	r1, r0
 80048aa:	4620      	mov	r0, r4
 80048ac:	f7fe fb04 	bl	8002eb8 <_ux_host_class_storage_transport>

        /* Check for error during transfer.  */
        if (status != UX_SUCCESS)
 80048b0:	4605      	mov	r5, r0
        {

            /* Free the memory resource used for the command response.  */
            _ux_utility_memory_free(capacity_response);
 80048b2:	4630      	mov	r0, r6
        if (status != UX_SUCCESS)
 80048b4:	b9c5      	cbnz	r5, 80048e8 <_ux_host_class_storage_media_capacity_get+0x8c>
            /* We return a sad status.  */
            return(status);
        }

        /* Check the sense code */
        if (storage -> ux_host_class_storage_sense_code == UX_SUCCESS)
 80048b6:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
 80048ba:	b17b      	cbz	r3, 80048dc <_ux_host_class_storage_media_capacity_get+0x80>
            /* We return a happy status.  */
            return(UX_SUCCESS);
        }

        /* Free the memory resource used for the command response.  */
        _ux_utility_memory_free(capacity_response);
 80048bc:	f7fd fb2a 	bl	8001f14 <_ux_utility_memory_free>
    for (command_retry = 0; command_retry < UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RETRY; command_retry++)
 80048c0:	3f01      	subs	r7, #1
 80048c2:	d1db      	bne.n	800487c <_ux_host_class_storage_media_capacity_get+0x20>
    }

    /* We get here when we could not retrieve the sector size through the READ_CAPACITY command.
       It's OK, we still calculated the default based on the device type.  */
    return(UX_SUCCESS);
}
 80048c4:	4628      	mov	r0, r5
 80048c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (storage -> ux_host_class_storage_media_type)
 80048c8:	2b00      	cmp	r3, #0
 80048ca:	d0d1      	beq.n	8004870 <_ux_host_class_storage_media_capacity_get+0x14>
        return(UX_HOST_CLASS_MEDIA_NOT_SUPPORTED);
 80048cc:	2562      	movs	r5, #98	; 0x62
}
 80048ce:	4628      	mov	r0, r5
 80048d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        storage -> ux_host_class_storage_sector_size =  UX_HOST_CLASS_STORAGE_SECTOR_SIZE_OTHER;
 80048d2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80048d6:	f8c0 3170 	str.w	r3, [r0, #368]	; 0x170
        break;
 80048da:	e7cd      	b.n	8004878 <_ux_host_class_storage_media_capacity_get+0x1c>
            storage -> ux_host_class_storage_sector_size =  _ux_utility_long_get_big_endian(capacity_response + UX_HOST_CLASS_STORAGE_READ_CAPACITY_DATA_SECTOR_SIZE);
 80048dc:	1d30      	adds	r0, r6, #4
 80048de:	f000 fd87 	bl	80053f0 <_ux_utility_long_get_big_endian>
 80048e2:	f8c4 0170 	str.w	r0, [r4, #368]	; 0x170
            _ux_utility_memory_free(capacity_response);
 80048e6:	4630      	mov	r0, r6
 80048e8:	f7fd fb14 	bl	8001f14 <_ux_utility_memory_free>
}
 80048ec:	4628      	mov	r0, r5
 80048ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return(UX_MEMORY_INSUFFICIENT);
 80048f0:	2512      	movs	r5, #18
 80048f2:	e7ec      	b.n	80048ce <_ux_host_class_storage_media_capacity_get+0x72>

080048f4 <_ux_host_class_storage_media_write>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_media_write(UX_HOST_CLASS_STORAGE *storage, ULONG sector_start,
                                        ULONG sector_count, UCHAR *data_pointer)
{
 80048f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80048f8:	4617      	mov	r7, r2
#else
    command_length =  UX_HOST_CLASS_STORAGE_WRITE_COMMAND_LENGTH_SBC;
#endif

    /* Initialize the CBW for this command.  */
    _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_OUT, sector_count * storage -> ux_host_class_storage_sector_size,
 80048fa:	f8d0 2170 	ldr.w	r2, [r0, #368]	; 0x170
{
 80048fe:	461e      	mov	r6, r3
    _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_OUT, sector_count * storage -> ux_host_class_storage_sector_size,
 8004900:	230a      	movs	r3, #10
{
 8004902:	4688      	mov	r8, r1
    _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_OUT, sector_count * storage -> ux_host_class_storage_sector_size,
 8004904:	fb02 f207 	mul.w	r2, r2, r7
 8004908:	2100      	movs	r1, #0
{
 800490a:	4604      	mov	r4, r0

    /* Store the sector start (LBA field).  */
    _ux_utility_long_put_big_endian(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_WRITE_LBA, sector_start);

    /* Store the number of sectors to write.  */
    _ux_utility_short_put_big_endian(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_WRITE_TRANSFER_LENGTH, (USHORT) sector_count);
 800490c:	461d      	mov	r5, r3
    _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_OUT, sector_count * storage -> ux_host_class_storage_sector_size,
 800490e:	f7fd ff53 	bl	80027b8 <_ux_host_class_storage_cbw_initialize>
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_WRITE_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_WRITE16;
 8004912:	232a      	movs	r3, #42	; 0x2a
    _ux_utility_long_put_big_endian(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_WRITE_LBA, sector_start);
 8004914:	4641      	mov	r1, r8
 8004916:	f104 002d 	add.w	r0, r4, #45	; 0x2d
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_WRITE_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_WRITE16;
 800491a:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
    _ux_utility_long_put_big_endian(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_WRITE_LBA, sector_start);
 800491e:	f7ff fe0b 	bl	8004538 <_ux_utility_long_put_big_endian>
    _ux_utility_short_put_big_endian(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_WRITE_TRANSFER_LENGTH, (USHORT) sector_count);
 8004922:	f104 0032 	add.w	r0, r4, #50	; 0x32
 8004926:	b2b9      	uxth	r1, r7
 8004928:	f7ff fe20 	bl	800456c <_ux_utility_short_put_big_endian>
    /* We may need several attempts.  */
    while (media_retry-- != 0)
    {

        /* Send the command to transport layer.  */
        status =  _ux_host_class_storage_transport(storage, data_pointer);
 800492c:	4631      	mov	r1, r6
 800492e:	4620      	mov	r0, r4
 8004930:	f7fe fac2 	bl	8002eb8 <_ux_host_class_storage_transport>
        if (status != UX_SUCCESS)
 8004934:	b928      	cbnz	r0, 8004942 <_ux_host_class_storage_media_write+0x4e>
            return(status);

        /* Check the sense code */
        if (storage -> ux_host_class_storage_sense_code == UX_SUCCESS)
 8004936:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
 800493a:	b113      	cbz	r3, 8004942 <_ux_host_class_storage_media_write+0x4e>
    while (media_retry-- != 0)
 800493c:	3d01      	subs	r5, #1
 800493e:	d1f5      	bne.n	800492c <_ux_host_class_storage_media_write+0x38>
            return(UX_SUCCESS);
    }

    /* Return sense error.  */
    return(UX_HOST_CLASS_STORAGE_SENSE_ERROR);                                            
 8004940:	2003      	movs	r0, #3
}
 8004942:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004946:	bf00      	nop

08004948 <_ux_host_class_storage_request_sense>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_class_storage_request_sense(UX_HOST_CLASS_STORAGE *storage)
{
 8004948:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#else
    command_length =  UX_HOST_CLASS_STORAGE_REQUEST_SENSE_COMMAND_LENGTH_SBC;
#endif

    /* Check of we are reentering a REQUEST SENSE command which is illegal.  */
    if (*(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_OPERATION) == UX_HOST_CLASS_STORAGE_SCSI_REQUEST_SENSE)
 800494c:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
    storage -> ux_host_class_storage_sense_code =  0;
 8004950:	2200      	movs	r2, #0
    if (*(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_OPERATION) == UX_HOST_CLASS_STORAGE_SCSI_REQUEST_SENSE)
 8004952:	2b03      	cmp	r3, #3
    storage -> ux_host_class_storage_sense_code =  0;
 8004954:	f8c0 217c 	str.w	r2, [r0, #380]	; 0x17c
    if (*(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_OPERATION) == UX_HOST_CLASS_STORAGE_SCSI_REQUEST_SENSE)
 8004958:	d038      	beq.n	80049cc <_ux_host_class_storage_request_sense+0x84>
        return(UX_ERROR);
                                                
    /* Save the current command so that we can re-initiate it after the 
       REQUEST_SENSE command.  */
    _ux_utility_memory_copy(storage -> ux_host_class_storage_saved_cbw, storage -> ux_host_class_storage_cbw, UX_HOST_CLASS_STORAGE_CBW_LENGTH);
 800495a:	f100 071c 	add.w	r7, r0, #28
 800495e:	f100 085c 	add.w	r8, r0, #92	; 0x5c
 8004962:	4604      	mov	r4, r0
    
    /* Prepare the REQUEST SENSE command block.  */
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_REQUEST_SENSE;
    
    /* Store the length of the Request Sense Response.  */
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_ALLOCATION_LENGTH) =  UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_LENGTH;
 8004964:	2512      	movs	r5, #18
    _ux_utility_memory_copy(storage -> ux_host_class_storage_saved_cbw, storage -> ux_host_class_storage_cbw, UX_HOST_CLASS_STORAGE_CBW_LENGTH);
 8004966:	221f      	movs	r2, #31
 8004968:	4640      	mov	r0, r8
 800496a:	4639      	mov	r1, r7
 800496c:	f7fd fa68 	bl	8001e40 <_ux_utility_memory_copy>
    _ux_host_class_storage_cbw_initialize(storage, UX_HOST_CLASS_STORAGE_DATA_IN, UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_LENGTH, command_length);
 8004970:	230c      	movs	r3, #12
 8004972:	462a      	mov	r2, r5
 8004974:	2180      	movs	r1, #128	; 0x80
 8004976:	4620      	mov	r0, r4
 8004978:	f7fd ff1e 	bl	80027b8 <_ux_host_class_storage_cbw_initialize>
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_REQUEST_SENSE;
 800497c:	2303      	movs	r3, #3
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_ALLOCATION_LENGTH) =  UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_LENGTH;
 800497e:	f884 502f 	strb.w	r5, [r4, #47]	; 0x2f

    /* Obtain a block of memory for the answer.  */
    request_sense_response =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_LENGTH);
 8004982:	462a      	mov	r2, r5
    *(cbw + UX_HOST_CLASS_STORAGE_CBW_CB + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_OPERATION) =  UX_HOST_CLASS_STORAGE_SCSI_REQUEST_SENSE;
 8004984:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
    request_sense_response =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_LENGTH);
 8004988:	2101      	movs	r1, #1
 800498a:	f04f 30ff 	mov.w	r0, #4294967295
 800498e:	f7fd f9ad 	bl	8001cec <_ux_utility_memory_allocate>
    if (request_sense_response == UX_NULL)
 8004992:	4606      	mov	r6, r0
 8004994:	b1b8      	cbz	r0, 80049c6 <_ux_host_class_storage_request_sense+0x7e>
        return(UX_MEMORY_INSUFFICIENT);
    
    /* Send the command to transport layer.  */
    status =  _ux_host_class_storage_transport(storage, request_sense_response);
 8004996:	4601      	mov	r1, r0
 8004998:	4620      	mov	r0, r4
 800499a:	f7fe fa8d 	bl	8002eb8 <_ux_host_class_storage_transport>

    /* If we have a transport error, there is not much we can do, simply return the error.  */
    if (status == UX_SUCCESS)
 800499e:	4605      	mov	r5, r0
 80049a0:	b948      	cbnz	r0, 80049b6 <_ux_host_class_storage_request_sense+0x6e>
    {

        /* We have a successful transaction, even though the sense code could reflect an error. The sense code 
           will be assembled and store in the device instance.  */ 
        sense_code =  (((ULONG) *(request_sense_response + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_SENSE_KEY)) & 0x0f) << 16;
 80049a2:	78b2      	ldrb	r2, [r6, #2]
        sense_code |=  ((ULONG) *(request_sense_response + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_CODE)) << 8;
        sense_code |=  (ULONG)  *(request_sense_response + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_CODE_QUALIFIER);
 80049a4:	89b3      	ldrh	r3, [r6, #12]
        sense_code =  (((ULONG) *(request_sense_response + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_SENSE_KEY)) & 0x0f) << 16;
 80049a6:	0412      	lsls	r2, r2, #16
        sense_code |=  (ULONG)  *(request_sense_response + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_CODE_QUALIFIER);
 80049a8:	ba5b      	rev16	r3, r3
        sense_code =  (((ULONG) *(request_sense_response + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_SENSE_KEY)) & 0x0f) << 16;
 80049aa:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
        sense_code |=  (ULONG)  *(request_sense_response + UX_HOST_CLASS_STORAGE_REQUEST_SENSE_RESPONSE_CODE_QUALIFIER);
 80049ae:	b29b      	uxth	r3, r3
 80049b0:	4313      	orrs	r3, r2

        /* Store the sense code in the storage instance.  */
        storage -> ux_host_class_storage_sense_code =  sense_code;
 80049b2:	f8c4 317c 	str.w	r3, [r4, #380]	; 0x17c
    }       

    /* Free the memory resource used for the command response.  */
    _ux_utility_memory_free(request_sense_response);
 80049b6:	4630      	mov	r0, r6
 80049b8:	f7fd faac 	bl	8001f14 <_ux_utility_memory_free>

    /* Restore the current CBW command.  */
    _ux_utility_memory_copy(storage -> ux_host_class_storage_cbw, storage -> ux_host_class_storage_saved_cbw, UX_HOST_CLASS_STORAGE_CBW_LENGTH);
 80049bc:	4641      	mov	r1, r8
 80049be:	4638      	mov	r0, r7
 80049c0:	221f      	movs	r2, #31
 80049c2:	f7fd fa3d 	bl	8001e40 <_ux_utility_memory_copy>

    /* Return completion code.  */    
    return(status);                                            
}
 80049c6:	4628      	mov	r0, r5
 80049c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return(UX_ERROR);
 80049cc:	25ff      	movs	r5, #255	; 0xff
}
 80049ce:	4628      	mov	r0, r5
 80049d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080049d4 <_ux_host_class_storage_sense_code_translate>:

    UX_PARAMETER_NOT_USED(storage);

    /* Return status.  */
    return(status);
}
 80049d4:	4608      	mov	r0, r1
 80049d6:	4770      	bx	lr

080049d8 <_ux_hcd_stm32_asynch_schedule>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_asynch_schedule(UX_HCD_STM32 *hcd_stm32)
{
 80049d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
UX_HCD_STM32_ED       *ed;
UX_HCD_STM32_ED       *first_ed;
ULONG                 count_ed_scheduled;    

    /* Get the pointer to the current ED in the asynchronous list.  */
    ed =  hcd_stm32 -> ux_hcd_stm32_asynch_current_ed;
 80049da:	6945      	ldr	r5, [r0, #20]

    /* Check if there is any eds candidate in the asynch list.  */
    if (ed == UX_NULL)
 80049dc:	b355      	cbz	r5, 8004a34 <_ux_hcd_stm32_asynch_schedule+0x5c>
 80049de:	4607      	mov	r7, r0
{
 80049e0:	462c      	mov	r4, r5

    /* Remember this ED.  */
    first_ed =  ed;
    
    /*     Reset the count of scheduled EDs.  */
    count_ed_scheduled = 0;
 80049e2:	2600      	movs	r6, #0
 80049e4:	e009      	b.n	80049fa <_ux_hcd_stm32_asynch_schedule+0x22>
        /* Ensure this ED does not have the SKIP bit set and no TD are in progress. */
        if ((ed -> ux_stm32_ed_head_td -> ux_stm32_td_status & UX_HCD_STM32_TD_ACK_PENDING) == 0)
        {

            /* Check if this ED has a tail and head TD different.  */
            if ((ed -> ux_stm32_ed_tail_td != ed -> ux_stm32_ed_head_td) && (ed -> ux_stm32_ed_status &  UX_HCD_STM32_ED_SKIP) == 0)
 80049e6:	6822      	ldr	r2, [r4, #0]
 80049e8:	4293      	cmp	r3, r2
 80049ea:	d002      	beq.n	80049f2 <_ux_hcd_stm32_asynch_schedule+0x1a>
 80049ec:	6923      	ldr	r3, [r4, #16]
 80049ee:	005b      	lsls	r3, r3, #1
 80049f0:	d514      	bpl.n	8004a1c <_ux_hcd_stm32_asynch_schedule+0x44>
            /* Keep the scheduler active to check pending status.  */
            count_ed_scheduled++;
        }

        /* Point to the next ED in the list. Check if at end of list.  */
        if (ed -> ux_stm32_ed_next_ed == UX_NULL)
 80049f2:	68a4      	ldr	r4, [r4, #8]
 80049f4:	b14c      	cbz	r4, 8004a0a <_ux_hcd_stm32_asynch_schedule+0x32>
            ed =  hcd_stm32 -> ux_hcd_stm32_asynch_head_ed;
        else            
            ed =  ed -> ux_stm32_ed_next_ed;

    } while (ed != first_ed);
 80049f6:	42a5      	cmp	r5, r4
 80049f8:	d00a      	beq.n	8004a10 <_ux_hcd_stm32_asynch_schedule+0x38>
        if ((ed -> ux_stm32_ed_head_td -> ux_stm32_td_status & UX_HCD_STM32_TD_ACK_PENDING) == 0)
 80049fa:	6863      	ldr	r3, [r4, #4]
 80049fc:	69da      	ldr	r2, [r3, #28]
 80049fe:	0312      	lsls	r2, r2, #12
 8004a00:	d5f1      	bpl.n	80049e6 <_ux_hcd_stm32_asynch_schedule+0xe>
        if (ed -> ux_stm32_ed_next_ed == UX_NULL)
 8004a02:	68a4      	ldr	r4, [r4, #8]
            count_ed_scheduled++;
 8004a04:	3601      	adds	r6, #1
        if (ed -> ux_stm32_ed_next_ed == UX_NULL)
 8004a06:	2c00      	cmp	r4, #0
 8004a08:	d1f5      	bne.n	80049f6 <_ux_hcd_stm32_asynch_schedule+0x1e>
 8004a0a:	693c      	ldr	r4, [r7, #16]
    } while (ed != first_ed);
 8004a0c:	42a5      	cmp	r5, r4
 8004a0e:	d1f4      	bne.n	80049fa <_ux_hcd_stm32_asynch_schedule+0x22>
    
    /*     Any ED scheduled or do we need to keep the scheduler running ?  */
    if (count_ed_scheduled == 0)
 8004a10:	b916      	cbnz	r6, 8004a18 <_ux_hcd_stm32_asynch_schedule+0x40>
    
        /* It seems the scheduler is empty, so turn it off.  */
        hcd_stm32 -> ux_hcd_stm32_queue_empty =  UX_TRUE;
 8004a12:	2301      	movs	r3, #1
 8004a14:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4

    /* We have not found anything to do.  */
    return(UX_FALSE);
}
 8004a18:	2000      	movs	r0, #0
 8004a1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                _ux_hcd_stm32_td_schedule(hcd_stm32, ed);
 8004a1c:	4621      	mov	r1, r4
 8004a1e:	4638      	mov	r0, r7
 8004a20:	f7ff f906 	bl	8003c30 <_ux_hcd_stm32_td_schedule>
                if (ed -> ux_stm32_ed_next_ed == UX_NULL)
 8004a24:	68a4      	ldr	r4, [r4, #8]
                count_ed_scheduled++;
 8004a26:	3601      	adds	r6, #1
                if (ed -> ux_stm32_ed_next_ed == UX_NULL)
 8004a28:	b10c      	cbz	r4, 8004a2e <_ux_hcd_stm32_asynch_schedule+0x56>
                    hcd_stm32 -> ux_hcd_stm32_asynch_current_ed =  ed -> ux_stm32_ed_next_ed;
 8004a2a:	617c      	str	r4, [r7, #20]
 8004a2c:	e7e3      	b.n	80049f6 <_ux_hcd_stm32_asynch_schedule+0x1e>
                    hcd_stm32 -> ux_hcd_stm32_asynch_current_ed =  hcd_stm32 -> ux_hcd_stm32_asynch_head_ed;
 8004a2e:	693c      	ldr	r4, [r7, #16]
 8004a30:	617c      	str	r4, [r7, #20]
 8004a32:	e7e0      	b.n	80049f6 <_ux_hcd_stm32_asynch_schedule+0x1e>
        if (hcd_stm32 -> ux_hcd_stm32_asynch_head_ed == UX_NULL)
 8004a34:	6905      	ldr	r5, [r0, #16]
 8004a36:	2d00      	cmp	r5, #0
 8004a38:	d1d1      	bne.n	80049de <_ux_hcd_stm32_asynch_schedule+0x6>
 8004a3a:	e7ed      	b.n	8004a18 <_ux_hcd_stm32_asynch_schedule+0x40>

08004a3c <_ux_hcd_stm32_asynchronous_endpoint_create>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_asynchronous_endpoint_create(UX_HCD_STM32 *hcd_stm32, UX_ENDPOINT *endpoint)
{
 8004a3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    /* Get pointer to generic controller.  */
    hcd = hcd_stm32 -> ux_hcd_stm32_hcd_owner;
    
    /* We need to take into account the nature of the HCD to define the max size
       of any transfer in the transfer request.  */
    if (hcd -> ux_hcd_controller_type ==  UX_HCD_STM32_CONTROLLER_HS)
 8004a3e:	6803      	ldr	r3, [r0, #0]
{
 8004a40:	4604      	mov	r4, r0
 8004a42:	460e      	mov	r6, r1
        /* Set FS MAX PAYLOAD.  */
        endpoint -> ux_endpoint_transfer_request.ux_transfer_request_maximum_length =  UX_HCD_STM32_FS_MAX_PAYLOAD;

    
    /* Get the pointer to the device.  */
    device =  endpoint -> ux_endpoint_device;
 8004a44:	6acf      	ldr	r7, [r1, #44]	; 0x2c
    if (hcd -> ux_hcd_controller_type ==  UX_HCD_STM32_CONTROLLER_HS)
 8004a46:	6d5b      	ldr	r3, [r3, #84]	; 0x54
        endpoint -> ux_endpoint_transfer_request.ux_transfer_request_maximum_length =  UX_HCD_STM32_HS_MAX_PAYLOAD;
 8004a48:	2b07      	cmp	r3, #7
 8004a4a:	bf14      	ite	ne
 8004a4c:	2340      	movne	r3, #64	; 0x40
 8004a4e:	f44f 7300 	moveq.w	r3, #512	; 0x200
 8004a52:	67cb      	str	r3, [r1, #124]	; 0x7c

    /* Obtain a ED for this new endpoint. This ED will live as long as the endpoint is active 
       and will be the container for the tds.  */
    ed =  _ux_hcd_stm32_ed_obtain(hcd_stm32);
 8004a54:	f7fe fd50 	bl	80034f8 <_ux_hcd_stm32_ed_obtain>
    if (ed == UX_NULL)
 8004a58:	2800      	cmp	r0, #0
 8004a5a:	d057      	beq.n	8004b0c <_ux_hcd_stm32_asynchronous_endpoint_create+0xd0>
        return(UX_NO_ED_AVAILABLE);

    /* And get a channel. */
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004a5c:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
 8004a60:	4605      	mov	r5, r0
 8004a62:	2b00      	cmp	r3, #0
 8004a64:	d04f      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
    {

        /* Check if that Channel is free.  */
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004a66:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 8004a6a:	2a00      	cmp	r2, #0
 8004a6c:	f000 80a0 	beq.w	8004bb0 <_ux_hcd_stm32_asynchronous_endpoint_create+0x174>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004a70:	2b01      	cmp	r3, #1
 8004a72:	d948      	bls.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004a74:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
 8004a78:	2a00      	cmp	r2, #0
 8004a7a:	f000 809d 	beq.w	8004bb8 <_ux_hcd_stm32_asynchronous_endpoint_create+0x17c>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004a7e:	2b02      	cmp	r3, #2
 8004a80:	d041      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004a82:	f8d4 20a8 	ldr.w	r2, [r4, #168]	; 0xa8
 8004a86:	2a00      	cmp	r2, #0
 8004a88:	d042      	beq.n	8004b10 <_ux_hcd_stm32_asynchronous_endpoint_create+0xd4>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004a8a:	2b03      	cmp	r3, #3
 8004a8c:	d03b      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004a8e:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 8004a92:	2a00      	cmp	r2, #0
 8004a94:	f000 809a 	beq.w	8004bcc <_ux_hcd_stm32_asynchronous_endpoint_create+0x190>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004a98:	2b04      	cmp	r3, #4
 8004a9a:	d034      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004a9c:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 8004aa0:	2a00      	cmp	r2, #0
 8004aa2:	f000 8098 	beq.w	8004bd6 <_ux_hcd_stm32_asynchronous_endpoint_create+0x19a>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004aa6:	2b05      	cmp	r3, #5
 8004aa8:	d02d      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004aaa:	f8d4 20b4 	ldr.w	r2, [r4, #180]	; 0xb4
 8004aae:	2a00      	cmp	r2, #0
 8004ab0:	f000 8096 	beq.w	8004be0 <_ux_hcd_stm32_asynchronous_endpoint_create+0x1a4>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004ab4:	2b06      	cmp	r3, #6
 8004ab6:	d026      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004ab8:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
 8004abc:	2a00      	cmp	r2, #0
 8004abe:	f000 8094 	beq.w	8004bea <_ux_hcd_stm32_asynchronous_endpoint_create+0x1ae>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004ac2:	2b07      	cmp	r3, #7
 8004ac4:	d01f      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004ac6:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
 8004aca:	2a00      	cmp	r2, #0
 8004acc:	f000 8092 	beq.w	8004bf4 <_ux_hcd_stm32_asynchronous_endpoint_create+0x1b8>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004ad0:	2b08      	cmp	r3, #8
 8004ad2:	d018      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004ad4:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
 8004ad8:	2a00      	cmp	r2, #0
 8004ada:	f000 8090 	beq.w	8004bfe <_ux_hcd_stm32_asynchronous_endpoint_create+0x1c2>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004ade:	2b09      	cmp	r3, #9
 8004ae0:	d011      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004ae2:	f8d4 20c4 	ldr.w	r2, [r4, #196]	; 0xc4
 8004ae6:	2a00      	cmp	r2, #0
 8004ae8:	f000 808e 	beq.w	8004c08 <_ux_hcd_stm32_asynchronous_endpoint_create+0x1cc>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004aec:	2b0a      	cmp	r3, #10
 8004aee:	d00a      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004af0:	f8d4 20c8 	ldr.w	r2, [r4, #200]	; 0xc8
 8004af4:	2a00      	cmp	r2, #0
 8004af6:	f000 808c 	beq.w	8004c12 <_ux_hcd_stm32_asynchronous_endpoint_create+0x1d6>
    for (channel_index = 0; channel_index < hcd_stm32 -> ux_hcd_stm32_nb_channels; channel_index++)
 8004afa:	2b0b      	cmp	r3, #11
 8004afc:	d003      	beq.n	8004b06 <_ux_hcd_stm32_asynchronous_endpoint_create+0xca>
        if (hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index]  == UX_NULL)
 8004afe:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 8004b02:	2b00      	cmp	r3, #0
 8004b04:	d05d      	beq.n	8004bc2 <_ux_hcd_stm32_asynchronous_endpoint_create+0x186>
 8004b06:	6a2b      	ldr	r3, [r5, #32]

        }
    }
    
    /* Check for channel assignment.  */
    if (ed -> ux_stm32_ed_channel ==  UX_HCD_STM32_NO_CHANNEL_ASSIGNED)
 8004b08:	3301      	adds	r3, #1
 8004b0a:	d105      	bne.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
        return(UX_NO_ED_AVAILABLE);
 8004b0c:	2014      	movs	r0, #20
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_HAINTMSK, 1 << ed -> ux_stm32_ed_channel);                    
    

    /* Return successful completion.  */
    return(UX_SUCCESS);         
}
 8004b0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            ed -> ux_stm32_ed_channel = channel_index;
 8004b10:	2302      	movs	r3, #2
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004b12:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
            ed -> ux_stm32_ed_channel = channel_index;
 8004b16:	622b      	str	r3, [r5, #32]
    ed -> ux_stm32_ed_channel_status = UX_HCD_STM32_ED_CHANNEL_RESET;
 8004b18:	2300      	movs	r3, #0
    td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004b1a:	4620      	mov	r0, r4
    ed -> ux_stm32_ed_channel_status = UX_HCD_STM32_ED_CHANNEL_RESET;
 8004b1c:	62ab      	str	r3, [r5, #40]	; 0x28
    td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004b1e:	f7ff f835 	bl	8003b8c <_ux_hcd_stm32_regular_td_obtain>
    if (td == UX_NULL)
 8004b22:	2800      	cmp	r0, #0
 8004b24:	d041      	beq.n	8004baa <_ux_hcd_stm32_asynchronous_endpoint_create+0x16e>
    head_ed =  hcd_stm32 -> ux_hcd_stm32_asynch_head_ed;
 8004b26:	6923      	ldr	r3, [r4, #16]
    endpoint -> ux_endpoint_ed =  (VOID *) ed;
 8004b28:	60b5      	str	r5, [r6, #8]
    ed -> ux_stm32_ed_endpoint =  endpoint;
 8004b2a:	616e      	str	r6, [r5, #20]
    ed -> ux_stm32_ed_next_ed =  head_ed;
 8004b2c:	60ab      	str	r3, [r5, #8]
    ed -> ux_stm32_ed_head_td =  td;
 8004b2e:	e9c5 0000 	strd	r0, r0, [r5]
    hcd_stm32 -> ux_hcd_stm32_asynch_head_ed =  ed;
 8004b32:	6125      	str	r5, [r4, #16]
    if (head_ed != UX_NULL)
 8004b34:	b103      	cbz	r3, 8004b38 <_ux_hcd_stm32_asynchronous_endpoint_create+0xfc>
        head_ed -> ux_stm32_ed_previous_ed =  ed;
 8004b36:	60dd      	str	r5, [r3, #12]
    stm32_channel_register |=  (endpoint -> ux_endpoint_descriptor.bEndpointAddress & ~UX_ENDPOINT_DIRECTION) << UX_HCD_STM32_OTG_FS_HCCHAR_EPNUM_SHIFT;
 8004b38:	4a38      	ldr	r2, [pc, #224]	; (8004c1c <_ux_hcd_stm32_asynchronous_endpoint_create+0x1e0>)
    if (device -> ux_device_speed == UX_LOW_SPEED_DEVICE)
 8004b3a:	f8d7 c010 	ldr.w	ip, [r7, #16]
    stm32_channel_register |=  device -> ux_device_address << UX_HCD_STM32_OTG_FS_HCCHAR_DAD_SHIFT;
 8004b3e:	68ff      	ldr	r7, [r7, #12]
    stm32_channel_register |=  endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8004b40:	69f0      	ldr	r0, [r6, #28]
    stm32_channel_register |=  (endpoint -> ux_endpoint_descriptor.bEndpointAddress & ~UX_ENDPOINT_DIRECTION) << UX_HCD_STM32_OTG_FS_HCCHAR_EPNUM_SHIFT;
 8004b42:	e9d6 1305 	ldrd	r1, r3, [r6, #20]
    if ((endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) == UX_BULK_ENDPOINT)
 8004b46:	f003 0303 	and.w	r3, r3, #3
    stm32_channel_register |=  (endpoint -> ux_endpoint_descriptor.bEndpointAddress & ~UX_ENDPOINT_DIRECTION) << UX_HCD_STM32_OTG_FS_HCCHAR_EPNUM_SHIFT;
 8004b4a:	ea02 22c1 	and.w	r2, r2, r1, lsl #11
    if ((endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) == UX_BULK_ENDPOINT)
 8004b4e:	2b02      	cmp	r3, #2
    stm32_channel_register |=  endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8004b50:	ea42 5287 	orr.w	r2, r2, r7, lsl #22
    if ((endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE) == UX_BULK_ENDPOINT)
 8004b54:	bf0b      	itete	eq
 8004b56:	f44f 2320 	moveq.w	r3, #655360	; 0xa0000
 8004b5a:	f44f 3300 	movne.w	r3, #131072	; 0x20000
 8004b5e:	f44f 2600 	moveq.w	r6, #524288	; 0x80000
 8004b62:	2600      	movne	r6, #0
    stm32_channel_register |=  endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8004b64:	4302      	orrs	r2, r0
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8004b66:	4620      	mov	r0, r4
    if (device -> ux_device_speed == UX_LOW_SPEED_DEVICE)
 8004b68:	f1bc 0f00 	cmp.w	ip, #0
 8004b6c:	bf18      	it	ne
 8004b6e:	4633      	movne	r3, r6
    stm32_channel_register |=  endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8004b70:	431a      	orrs	r2, r3
    if ((endpoint -> ux_endpoint_descriptor.bEndpointAddress & UX_ENDPOINT_DIRECTION) == UX_ENDPOINT_IN)
 8004b72:	060b      	lsls	r3, r1, #24
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8004b74:	6a29      	ldr	r1, [r5, #32]
        stm32_channel_register |=  UX_HCD_STM32_OTG_FS_HCCHAR_EPDIR_IN;  
 8004b76:	bf48      	it	mi
 8004b78:	f442 4200 	orrmi.w	r2, r2, #32768	; 0x8000
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCCHAR + 
 8004b7c:	3128      	adds	r1, #40	; 0x28
 8004b7e:	0149      	lsls	r1, r1, #5
 8004b80:	f7fc fe9e 	bl	80018c0 <_ux_hcd_stm32_register_write>
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), UX_HCD_STM32_OTG_FS_HCINT_DEFAULT);                    
 8004b84:	6a29      	ldr	r1, [r5, #32]
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
 8004b86:	4620      	mov	r0, r4
 8004b88:	f240 72fb 	movw	r2, #2043	; 0x7fb
                                (ed -> ux_stm32_ed_channel * UX_HCD_STM32_ENDPOINT_CHANNEL_SIZE), UX_HCD_STM32_OTG_FS_HCINT_DEFAULT);                    
 8004b8c:	0149      	lsls	r1, r1, #5
    _ux_hcd_stm32_register_write(hcd_stm32, UX_HCD_STM32_OTG_FS_HCINTMSK + 
 8004b8e:	f201 510c 	addw	r1, r1, #1292	; 0x50c
 8004b92:	f7fc fe95 	bl	80018c0 <_ux_hcd_stm32_register_write>
    _ux_hcd_stm32_register_set(hcd_stm32, UX_HCD_STM32_OTG_FS_HAINTMSK, 1 << ed -> ux_stm32_ed_channel);                    
 8004b96:	6a2b      	ldr	r3, [r5, #32]
 8004b98:	2201      	movs	r2, #1
 8004b9a:	4620      	mov	r0, r4
 8004b9c:	f44f 6183 	mov.w	r1, #1048	; 0x418
 8004ba0:	409a      	lsls	r2, r3
 8004ba2:	f7fc fe87 	bl	80018b4 <_ux_hcd_stm32_register_set>
    return(UX_SUCCESS);         
 8004ba6:	2000      	movs	r0, #0
}
 8004ba8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ed -> ux_stm32_ed_status =  UX_UNUSED;
 8004baa:	6128      	str	r0, [r5, #16]
        return(UX_NO_TD_AVAILABLE);
 8004bac:	2013      	movs	r0, #19
}
 8004bae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004bb0:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
            ed -> ux_stm32_ed_channel = channel_index;
 8004bb4:	6202      	str	r2, [r0, #32]
 8004bb6:	e7af      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004bb8:	2301      	movs	r3, #1
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004bba:	f8c4 50a4 	str.w	r5, [r4, #164]	; 0xa4
            ed -> ux_stm32_ed_channel = channel_index;
 8004bbe:	622b      	str	r3, [r5, #32]
 8004bc0:	e7aa      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004bc2:	230b      	movs	r3, #11
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004bc4:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc
            ed -> ux_stm32_ed_channel = channel_index;
 8004bc8:	622b      	str	r3, [r5, #32]
 8004bca:	e7a5      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004bcc:	2303      	movs	r3, #3
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004bce:	f8c4 50ac 	str.w	r5, [r4, #172]	; 0xac
            ed -> ux_stm32_ed_channel = channel_index;
 8004bd2:	622b      	str	r3, [r5, #32]
 8004bd4:	e7a0      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004bd6:	2304      	movs	r3, #4
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004bd8:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
            ed -> ux_stm32_ed_channel = channel_index;
 8004bdc:	622b      	str	r3, [r5, #32]
 8004bde:	e79b      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004be0:	2305      	movs	r3, #5
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004be2:	f8c4 50b4 	str.w	r5, [r4, #180]	; 0xb4
            ed -> ux_stm32_ed_channel = channel_index;
 8004be6:	622b      	str	r3, [r5, #32]
 8004be8:	e796      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004bea:	2306      	movs	r3, #6
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004bec:	f8c4 50b8 	str.w	r5, [r4, #184]	; 0xb8
            ed -> ux_stm32_ed_channel = channel_index;
 8004bf0:	622b      	str	r3, [r5, #32]
 8004bf2:	e791      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004bf4:	2307      	movs	r3, #7
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004bf6:	f8c4 50bc 	str.w	r5, [r4, #188]	; 0xbc
            ed -> ux_stm32_ed_channel = channel_index;
 8004bfa:	622b      	str	r3, [r5, #32]
 8004bfc:	e78c      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004bfe:	2308      	movs	r3, #8
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004c00:	f8c4 50c0 	str.w	r5, [r4, #192]	; 0xc0
            ed -> ux_stm32_ed_channel = channel_index;
 8004c04:	622b      	str	r3, [r5, #32]
 8004c06:	e787      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004c08:	2309      	movs	r3, #9
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004c0a:	f8c4 50c4 	str.w	r5, [r4, #196]	; 0xc4
            ed -> ux_stm32_ed_channel = channel_index;
 8004c0e:	622b      	str	r3, [r5, #32]
 8004c10:	e782      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004c12:	230a      	movs	r3, #10
            hcd_stm32 -> ux_hcd_stm32_channels_ed[channel_index] = ed;
 8004c14:	f8c4 50c8 	str.w	r5, [r4, #200]	; 0xc8
            ed -> ux_stm32_ed_channel = channel_index;
 8004c18:	622b      	str	r3, [r5, #32]
 8004c1a:	e77d      	b.n	8004b18 <_ux_hcd_stm32_asynchronous_endpoint_create+0xdc>
 8004c1c:	fffbf800 	.word	0xfffbf800

08004c20 <_ux_hcd_stm32_asynchronous_endpoint_destroy>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_asynchronous_endpoint_destroy(UX_HCD_STM32 *hcd_stm32, UX_ENDPOINT *endpoint)
{
 8004c20:	b538      	push	{r3, r4, r5, lr}
UX_HCD_STM32_TD       *tail_td;
UX_HCD_STM32_TD       *head_td;

    
    /* From the endpoint container fetch the STM32 ED descriptor.  */
    ed =  (UX_HCD_STM32_ED *) endpoint -> ux_endpoint_ed;
 8004c22:	688c      	ldr	r4, [r1, #8]

    /* Check if this physical endpoint has been initialized properly!  */
    if (ed == UX_NULL)
 8004c24:	b324      	cbz	r4, 8004c70 <_ux_hcd_stm32_asynchronous_endpoint_destroy+0x50>
        return(UX_ENDPOINT_HANDLE_UNKNOWN);

    }
    
    /* The endpoint may be active. If so, set the skip bit.  */
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8004c26:	6923      	ldr	r3, [r4, #16]
 8004c28:	4605      	mov	r5, r0
    
    /* Wait for the controller to finish the current frame processing.  */
    _ux_utility_delay_ms(1);
 8004c2a:	2001      	movs	r0, #1
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8004c2c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004c30:	6123      	str	r3, [r4, #16]
    _ux_utility_delay_ms(1);
 8004c32:	f7fd f84f 	bl	8001cd4 <_ux_utility_delay_ms>

    /* Get the previous ED in the list for this ED.  */
    previous_ed =  ed -> ux_stm32_ed_previous_ed;

    /* Get the next ED in the list for this ED.  */
    next_ed =  ed -> ux_stm32_ed_next_ed;
 8004c36:	e9d4 3202 	ldrd	r3, r2, [r4, #8]

    /* If the previous ED is NULL, we are at trying to remove the head ED.  */
    if (previous_ed == UX_NULL)
 8004c3a:	b1ba      	cbz	r2, 8004c6c <_ux_hcd_stm32_asynchronous_endpoint_destroy+0x4c>
        /* Store the new endpoint in the Control list.  */
        hcd_stm32 -> ux_hcd_stm32_asynch_head_ed =  next_ed;
    else

        /* The previous ED points now to the ED after the ED we are removing.  */
        previous_ed -> ux_stm32_ed_next_ed =  next_ed;
 8004c3c:	6093      	str	r3, [r2, #8]

    /* Reset the current ed processed and force the scheduler to restart from the beginning
       of the list.  */
    hcd_stm32 -> ux_hcd_stm32_asynch_current_ed =  UX_NULL;       
 8004c3e:	2100      	movs	r1, #0
 8004c40:	6169      	str	r1, [r5, #20]

    /* Update the previous ED pointer in the next ED if exists.  */
    if (next_ed != UX_NULL)
 8004c42:	b103      	cbz	r3, 8004c46 <_ux_hcd_stm32_asynchronous_endpoint_destroy+0x26>
        next_ed -> ux_stm32_ed_previous_ed =  previous_ed;
 8004c44:	60da      	str	r2, [r3, #12]

    /* Remove all the tds from this ED and leave the head and tail pointing to the dummy TD.  */
    head_td =  ed -> ux_stm32_ed_head_td;
    tail_td =  ed -> ux_stm32_ed_tail_td;
 8004c46:	e9d4 2300 	ldrd	r2, r3, [r4]

    /* Free all tds attached to the ED.  */
    while (head_td != tail_td)
 8004c4a:	4293      	cmp	r3, r2
 8004c4c:	d005      	beq.n	8004c5a <_ux_hcd_stm32_asynchronous_endpoint_destroy+0x3a>
    {

        /* Mark the current head TD as free. */
        head_td -> ux_stm32_td_status =  UX_UNUSED;
 8004c4e:	2100      	movs	r1, #0
 8004c50:	61d9      	str	r1, [r3, #28]

        /* Update the head TD with the next TD.  */
        ed -> ux_stm32_ed_head_td =  head_td -> ux_stm32_td_next_td;
 8004c52:	689b      	ldr	r3, [r3, #8]
    while (head_td != tail_td)
 8004c54:	4293      	cmp	r3, r2
 8004c56:	d1fb      	bne.n	8004c50 <_ux_hcd_stm32_asynchronous_endpoint_destroy+0x30>
 8004c58:	6062      	str	r2, [r4, #4]

    /* We need to free the dummy TD that was attached to the ED.  */
    tail_td -> ux_stm32_td_status =  UX_UNUSED;

    /* We need to free the channel.  */
    hcd_stm32 -> ux_hcd_stm32_channels_ed[ed -> ux_stm32_ed_channel] =  UX_NULL;
 8004c5a:	6a21      	ldr	r1, [r4, #32]
    tail_td -> ux_stm32_td_status =  UX_UNUSED;
 8004c5c:	2300      	movs	r3, #0
    hcd_stm32 -> ux_hcd_stm32_channels_ed[ed -> ux_stm32_ed_channel] =  UX_NULL;
 8004c5e:	3128      	adds	r1, #40	; 0x28
    tail_td -> ux_stm32_td_status =  UX_UNUSED;
 8004c60:	61d3      	str	r3, [r2, #28]
    
    /* Now we can safely make the ED free.  */
    ed -> ux_stm32_ed_status =  UX_UNUSED;

    /* Return successful completion.  */
    return(UX_SUCCESS);         
 8004c62:	4618      	mov	r0, r3
    hcd_stm32 -> ux_hcd_stm32_channels_ed[ed -> ux_stm32_ed_channel] =  UX_NULL;
 8004c64:	f845 3021 	str.w	r3, [r5, r1, lsl #2]
    ed -> ux_stm32_ed_status =  UX_UNUSED;
 8004c68:	6123      	str	r3, [r4, #16]
}
 8004c6a:	bd38      	pop	{r3, r4, r5, pc}
        hcd_stm32 -> ux_hcd_stm32_asynch_head_ed =  next_ed;
 8004c6c:	612b      	str	r3, [r5, #16]
 8004c6e:	e7e6      	b.n	8004c3e <_ux_hcd_stm32_asynchronous_endpoint_destroy+0x1e>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_HCD, UX_ENDPOINT_HANDLE_UNKNOWN);
 8004c70:	2253      	movs	r2, #83	; 0x53
 8004c72:	2101      	movs	r1, #1
 8004c74:	2002      	movs	r0, #2
 8004c76:	f7fc ffc3 	bl	8001c00 <_ux_system_error_handler>
        return(UX_ENDPOINT_HANDLE_UNKNOWN);
 8004c7a:	2053      	movs	r0, #83	; 0x53
}
 8004c7c:	bd38      	pop	{r3, r4, r5, pc}
 8004c7e:	bf00      	nop

08004c80 <_ux_hcd_stm32_controller_disable>:

    /* Point to the generic portion of the host controller structure instance.  */
    hcd =  hcd_stm32 -> ux_hcd_stm32_hcd_owner;
    
    /* Reflect the state of the controller in the main structure.  */
    hcd -> ux_hcd_status =  UX_HCD_STATUS_HALTED;
 8004c80:	6803      	ldr	r3, [r0, #0]
 8004c82:	2000      	movs	r0, #0
 8004c84:	6518      	str	r0, [r3, #80]	; 0x50

    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 8004c86:	4770      	bx	lr

08004c88 <_ux_hcd_stm32_endpoint_reset>:

    /* From the endpoint container fetch the STM32 ED descriptor.  */
    ed =  (UX_HCD_STM32_ED *) endpoint -> ux_endpoint_ed;

    /* Reset the data0/data1 toggle bit in the Head TD.  */
    ed -> ux_stm32_ed_toggle =  0;
 8004c88:	688b      	ldr	r3, [r1, #8]
 8004c8a:	2000      	movs	r0, #0
 8004c8c:	6198      	str	r0, [r3, #24]

    /* This operation never fails.  */
    return(UX_SUCCESS);         
}
 8004c8e:	4770      	bx	lr

08004c90 <_ux_hcd_stm32_request_bulk_transfer>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_hcd_stm32_request_bulk_transfer(UX_HCD_STM32 *hcd_stm32, UX_TRANSFER *transfer_request)
{
 8004c90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004c94:	4688      	mov	r8, r1

    /* The endpoint may be active. If so, set the skip bit.  */
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
    
    /* Reset the error retry count.  */
    ed -> ux_stm32_ed_command_retry =  0;
 8004c96:	2100      	movs	r1, #0
{
 8004c98:	b083      	sub	sp, #12
 8004c9a:	4681      	mov	r9, r0
    ed =  endpoint -> ux_endpoint_ed;
 8004c9c:	f8d8 3004 	ldr.w	r3, [r8, #4]

        /* Mark the TD with the DATA phase.  */
        data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;

        /* The Toggle value is in the ED.  */
        data_td -> ux_stm32_td_toggle =  UX_HCD_STM32_TD_TOGGLE_FROM_ED;
 8004ca0:	f04f 4b00 	mov.w	fp, #2147483648	; 0x80000000
    transfer_request_payload_length =  transfer_request -> ux_transfer_request_requested_length;
 8004ca4:	f8d8 500c 	ldr.w	r5, [r8, #12]
 8004ca8:	468a      	mov	sl, r1
    ed =  endpoint -> ux_endpoint_ed;
 8004caa:	689f      	ldr	r7, [r3, #8]
    if (transfer_request_payload_length == 0)
 8004cac:	fab5 f285 	clz	r2, r5
    data_pointer =  transfer_request -> ux_transfer_request_data_pointer;
 8004cb0:	f8d8 6008 	ldr.w	r6, [r8, #8]
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8004cb4:	693b      	ldr	r3, [r7, #16]
    if (transfer_request_payload_length == 0)
 8004cb6:	0952      	lsrs	r2, r2, #5
    data_td =  ed -> ux_stm32_ed_tail_td;
 8004cb8:	683c      	ldr	r4, [r7, #0]
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8004cba:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    ed -> ux_stm32_ed_command_retry =  0;
 8004cbe:	6279      	str	r1, [r7, #36]	; 0x24
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8004cc0:	613b      	str	r3, [r7, #16]
    while ((transfer_request_payload_length != 0) || zlp_flag == UX_TRUE)
 8004cc2:	b90d      	cbnz	r5, 8004cc8 <_ux_hcd_stm32_request_bulk_transfer+0x38>
 8004cc4:	2a00      	cmp	r2, #0
 8004cc6:	d03c      	beq.n	8004d42 <_ux_hcd_stm32_request_bulk_transfer+0xb2>
        if (transfer_request_payload_length > ed -> ux_stm32_ed_endpoint -> ux_endpoint_descriptor.wMaxPacketSize)
 8004cc8:	697b      	ldr	r3, [r7, #20]
        if ((transfer_request -> ux_transfer_request_type & UX_REQUEST_DIRECTION) == UX_REQUEST_IN)
 8004cca:	f8d8 2014 	ldr.w	r2, [r8, #20]
 8004cce:	69d9      	ldr	r1, [r3, #28]
        data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;
 8004cd0:	69e3      	ldr	r3, [r4, #28]
 8004cd2:	42a9      	cmp	r1, r5
        data_td -> ux_stm32_td_buffer =  data_pointer;
 8004cd4:	6026      	str	r6, [r4, #0]
        data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;
 8004cd6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
        data_td -> ux_stm32_td_transfer_request =  transfer_request;
 8004cda:	f8c4 800c 	str.w	r8, [r4, #12]
 8004cde:	bf28      	it	cs
 8004ce0:	4629      	movcs	r1, r5
            data_td -> ux_stm32_td_direction =  UX_HCD_STM32_TD_OUT;
 8004ce2:	f012 0f80 	tst.w	r2, #128	; 0x80
        data_td -> ux_stm32_td_ed =  ed;
 8004ce6:	6167      	str	r7, [r4, #20]
            data_td -> ux_stm32_td_direction =  UX_HCD_STM32_TD_OUT;
 8004ce8:	bf14      	ite	ne
 8004cea:	f44f 5280 	movne.w	r2, #4096	; 0x1000
 8004cee:	f44f 6200 	moveq.w	r2, #2048	; 0x800

        /* Check if there will be another transaction.  */
        if (transfer_request_payload_length != 0)
 8004cf2:	1a6d      	subs	r5, r5, r1
        data_td -> ux_stm32_td_length =  bulk_packet_payload_length;
 8004cf4:	6061      	str	r1, [r4, #4]
        data_pointer +=  bulk_packet_payload_length;
 8004cf6:	440e      	add	r6, r1
        data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;
 8004cf8:	61e3      	str	r3, [r4, #28]
 8004cfa:	e9c4 2b08 	strd	r2, fp, [r4, #32]
        if (transfer_request_payload_length != 0)
 8004cfe:	d101      	bne.n	8004d04 <_ux_hcd_stm32_request_bulk_transfer+0x74>
 8004d00:	2200      	movs	r2, #0
 8004d02:	e7de      	b.n	8004cc2 <_ux_hcd_stm32_request_bulk_transfer+0x32>
        {

            /* Get a new TD to hook this payload.  */
            data_td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004d04:	4648      	mov	r0, r9
 8004d06:	f7fe ff41 	bl	8003b8c <_ux_hcd_stm32_regular_td_obtain>
            if (data_td == UX_NULL)
 8004d0a:	b138      	cbz	r0, 8004d1c <_ux_hcd_stm32_request_bulk_transfer+0x8c>
            /* the first obtained TD in the chain has to be remembered.  */
            if (start_data_td == UX_NULL)
                start_data_td =  data_td;

            /* Attach this new TD to the previous one.  */                                
            previous_td -> ux_stm32_td_next_td =  data_td;
 8004d0c:	60a0      	str	r0, [r4, #8]
            if (start_data_td == UX_NULL)
 8004d0e:	f1ba 0f00 	cmp.w	sl, #0
 8004d12:	bf08      	it	eq
 8004d14:	4682      	moveq	sl, r0
            previous_td -> ux_stm32_td_next_td_transfer_request =  data_td;
 8004d16:	6120      	str	r0, [r4, #16]
 8004d18:	4604      	mov	r4, r0
 8004d1a:	e7f1      	b.n	8004d00 <_ux_hcd_stm32_request_bulk_transfer+0x70>
                    while (data_td)
 8004d1c:	f1ba 0f00 	cmp.w	sl, #0
 8004d20:	d007      	beq.n	8004d32 <_ux_hcd_stm32_request_bulk_transfer+0xa2>
                        next_data_td =  data_td -> ux_stm32_td_next_td;
 8004d22:	f8da 3008 	ldr.w	r3, [sl, #8]
                        data_td -> ux_stm32_td_status =  UX_UNUSED;
 8004d26:	f8ca 001c 	str.w	r0, [sl, #28]
                    while (data_td)
 8004d2a:	469a      	mov	sl, r3
 8004d2c:	f1ba 0f00 	cmp.w	sl, #0
 8004d30:	d1f7      	bne.n	8004d22 <_ux_hcd_stm32_request_bulk_transfer+0x92>
                data_td =  next_data_td;
            }
        }

        /* Clear the skip bit.  */
        ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8004d32:	693b      	ldr	r3, [r7, #16]

        return(UX_NO_TD_AVAILABLE);
 8004d34:	2013      	movs	r0, #19
        ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8004d36:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8004d3a:	613b      	str	r3, [r7, #16]
    /* Clear the skip bit.  */
    ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;

    /* Return successful completion.  */
    return(UX_SUCCESS);           
}
 8004d3c:	b003      	add	sp, #12
 8004d3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    tail_td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004d42:	4648      	mov	r0, r9
 8004d44:	9201      	str	r2, [sp, #4]
 8004d46:	f7fe ff21 	bl	8003b8c <_ux_hcd_stm32_regular_td_obtain>
    if (tail_td == UX_NULL)
 8004d4a:	9a01      	ldr	r2, [sp, #4]
 8004d4c:	4603      	mov	r3, r0
 8004d4e:	b158      	cbz	r0, 8004d68 <_ux_hcd_stm32_request_bulk_transfer+0xd8>
    ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8004d50:	6939      	ldr	r1, [r7, #16]
    return(UX_SUCCESS);           
 8004d52:	4610      	mov	r0, r2
    data_td -> ux_stm32_td_next_td =  tail_td;
 8004d54:	60a3      	str	r3, [r4, #8]
    ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8004d56:	f021 4180 	bic.w	r1, r1, #1073741824	; 0x40000000
    ed -> ux_stm32_ed_tail_td =  tail_td;
 8004d5a:	603b      	str	r3, [r7, #0]
    hcd_stm32 -> ux_hcd_stm32_queue_empty =  UX_FALSE;
 8004d5c:	f8c9 20d4 	str.w	r2, [r9, #212]	; 0xd4
    ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8004d60:	6139      	str	r1, [r7, #16]
}
 8004d62:	b003      	add	sp, #12
 8004d64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            while (data_td)
 8004d68:	f1ba 0f00 	cmp.w	sl, #0
 8004d6c:	d0e1      	beq.n	8004d32 <_ux_hcd_stm32_request_bulk_transfer+0xa2>
                next_data_td =  data_td -> ux_stm32_td_next_td;
 8004d6e:	f8da 2008 	ldr.w	r2, [sl, #8]
                data_td -> ux_stm32_td_status =  UX_UNUSED;
 8004d72:	f8ca 301c 	str.w	r3, [sl, #28]
            while (data_td)
 8004d76:	4692      	mov	sl, r2
 8004d78:	e7f6      	b.n	8004d68 <_ux_hcd_stm32_request_bulk_transfer+0xd8>
 8004d7a:	bf00      	nop

08004d7c <_ux_hcd_stm32_request_control_transfer>:

    /* Get the pointer to the Endpoint.  */
    endpoint =  (UX_ENDPOINT *) transfer_request -> ux_transfer_request_endpoint;

    /* Now get the physical ED attached to this endpoint.  */
    ed =  endpoint -> ux_endpoint_ed;
 8004d7c:	684b      	ldr	r3, [r1, #4]

    /* Reset the error retry count.  */
    ed -> ux_stm32_ed_command_retry =  0;

    /* Build the SETUP packet (phase 1 of the control transfer).  */
    setup_request =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_SETUP_SIZE);
 8004d7e:	2208      	movs	r2, #8
{
 8004d80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ed -> ux_stm32_ed_command_retry =  0;
 8004d84:	2500      	movs	r5, #0
{
 8004d86:	b083      	sub	sp, #12
    ed =  endpoint -> ux_endpoint_ed;
 8004d88:	f8d3 8008 	ldr.w	r8, [r3, #8]
{
 8004d8c:	460f      	mov	r7, r1
 8004d8e:	9001      	str	r0, [sp, #4]
    setup_request =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_SETUP_SIZE);
 8004d90:	4629      	mov	r1, r5
 8004d92:	4628      	mov	r0, r5
    ed -> ux_stm32_ed_command_retry =  0;
 8004d94:	f8c8 5024 	str.w	r5, [r8, #36]	; 0x24
    setup_request =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, UX_SETUP_SIZE);
 8004d98:	f7fc ffa8 	bl	8001cec <_ux_utility_memory_allocate>
    if (setup_request == UX_NULL)
 8004d9c:	2800      	cmp	r0, #0
 8004d9e:	f000 80b5 	beq.w	8004f0c <_ux_hcd_stm32_request_control_transfer+0x190>
 8004da2:	4681      	mov	r9, r0
        return(UX_MEMORY_INSUFFICIENT);

    *setup_request =                            transfer_request -> ux_transfer_request_function;
 8004da4:	69bb      	ldr	r3, [r7, #24]
    *(setup_request + UX_SETUP_REQUEST_TYPE) =  transfer_request -> ux_transfer_request_type;
    *(setup_request + UX_SETUP_REQUEST) =       transfer_request -> ux_transfer_request_function;
    _ux_utility_short_put(setup_request + UX_SETUP_VALUE, transfer_request -> ux_transfer_request_value);
 8004da6:	3002      	adds	r0, #2
    _ux_utility_short_put(setup_request + UX_SETUP_LENGTH, (USHORT) transfer_request -> ux_transfer_request_requested_length);

    /* Use the TD pointer by ed -> tail for our setup TD and chain from this one on.  */
    setup_td =  ed -> ux_stm32_ed_tail_td;
    setup_td -> ux_stm32_td_buffer =  setup_request;
    setup_td -> ux_stm32_td_length =  UX_SETUP_SIZE;
 8004da8:	2408      	movs	r4, #8
    *setup_request =                            transfer_request -> ux_transfer_request_function;
 8004daa:	f889 3000 	strb.w	r3, [r9]
    *(setup_request + UX_SETUP_REQUEST_TYPE) =  transfer_request -> ux_transfer_request_type;
 8004dae:	697b      	ldr	r3, [r7, #20]
 8004db0:	f889 3000 	strb.w	r3, [r9]
    *(setup_request + UX_SETUP_REQUEST) =       transfer_request -> ux_transfer_request_function;
 8004db4:	69bb      	ldr	r3, [r7, #24]
 8004db6:	f889 3001 	strb.w	r3, [r9, #1]
    _ux_utility_short_put(setup_request + UX_SETUP_VALUE, transfer_request -> ux_transfer_request_value);
 8004dba:	8bb9      	ldrh	r1, [r7, #28]
 8004dbc:	f7ff fbd2 	bl	8004564 <_ux_utility_short_put>
    _ux_utility_short_put(setup_request + UX_SETUP_INDEX, transfer_request -> ux_transfer_request_index);
 8004dc0:	8c39      	ldrh	r1, [r7, #32]
 8004dc2:	f109 0004 	add.w	r0, r9, #4
 8004dc6:	f7ff fbcd 	bl	8004564 <_ux_utility_short_put>
    _ux_utility_short_put(setup_request + UX_SETUP_LENGTH, (USHORT) transfer_request -> ux_transfer_request_requested_length);
 8004dca:	89b9      	ldrh	r1, [r7, #12]
 8004dcc:	f109 0006 	add.w	r0, r9, #6
 8004dd0:	f7ff fbc8 	bl	8004564 <_ux_utility_short_put>
    setup_td =  ed -> ux_stm32_ed_tail_td;
 8004dd4:	f8d8 6000 	ldr.w	r6, [r8]
    /* Check if there is a data phase, if not jump to status phase.  */
    data_td =  UX_NULL;    
    start_data_td =  UX_NULL;

    /* Use local variables to manipulate data pointer and length.  */
    transfer_request_payload_length =  transfer_request -> ux_transfer_request_requested_length;
 8004dd8:	f8d7 a00c 	ldr.w	sl, [r7, #12]
    setup_td -> ux_stm32_td_direction =  UX_HCD_STM32_TD_OUT;
 8004ddc:	f44f 6100 	mov.w	r1, #2048	; 0x800
    setup_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_SETUP_PHASE;
 8004de0:	69f3      	ldr	r3, [r6, #28]
    data_pointer =  transfer_request -> ux_transfer_request_data_pointer;

    /* Data starts with DATA1. For the data phase, we use the ED to contain the toggle.  */
    ed -> ux_stm32_ed_toggle =  1;
 8004de2:	2001      	movs	r0, #1
    setup_td -> ux_stm32_td_buffer =  setup_request;
 8004de4:	f8c6 9000 	str.w	r9, [r6]
    setup_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_SETUP_PHASE;
 8004de8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    setup_td -> ux_stm32_td_transfer_request =  transfer_request;
 8004dec:	60f7      	str	r7, [r6, #12]
    setup_td -> ux_stm32_td_ed =  ed;
 8004dee:	f8c6 8014 	str.w	r8, [r6, #20]
    setup_td -> ux_stm32_td_toggle =  0;
 8004df2:	6275      	str	r5, [r6, #36]	; 0x24
    setup_td -> ux_stm32_td_length =  UX_SETUP_SIZE;
 8004df4:	6074      	str	r4, [r6, #4]
    data_pointer =  transfer_request -> ux_transfer_request_data_pointer;
 8004df6:	f8d7 b008 	ldr.w	fp, [r7, #8]
    setup_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_SETUP_PHASE;
 8004dfa:	e9c6 3107 	strd	r3, r1, [r6, #28]
    ed -> ux_stm32_ed_toggle =  1;
 8004dfe:	f8c8 0018 	str.w	r0, [r8, #24]

    /* The Control data payload may be split into several smaller blocks.  */
    while (transfer_request_payload_length != 0)
 8004e02:	f1ba 0f00 	cmp.w	sl, #0
 8004e06:	f000 808b 	beq.w	8004f20 <_ux_hcd_stm32_request_control_transfer+0x1a4>
    {

        /* Get a new TD to hook this payload.  */
        data_td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004e0a:	9801      	ldr	r0, [sp, #4]
 8004e0c:	f7fe febe 	bl	8003b8c <_ux_hcd_stm32_regular_td_obtain>
        if (data_td == UX_NULL)
 8004e10:	4604      	mov	r4, r0
 8004e12:	b368      	cbz	r0, 8004e70 <_ux_hcd_stm32_request_control_transfer+0xf4>

            return(UX_NO_TD_AVAILABLE);
        }

        /* Check the current payload requirement for the max size.  */
        if (transfer_request_payload_length > ed -> ux_stm32_ed_endpoint -> ux_endpoint_descriptor.wMaxPacketSize)
 8004e14:	f8d8 2014 	ldr.w	r2, [r8, #20]

        /* Mark the TD with the DATA phase.  */
        data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;

        /* The Toggle value is in the ED.  */
        data_td -> ux_stm32_td_toggle =  UX_HCD_STM32_TD_TOGGLE_FROM_ED;
 8004e18:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
        if ((transfer_request -> ux_transfer_request_type & UX_REQUEST_DIRECTION) == UX_REQUEST_IN)
 8004e1c:	6978      	ldr	r0, [r7, #20]
 8004e1e:	f8d2 c01c 	ldr.w	ip, [r2, #28]
        data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;
 8004e22:	69e2      	ldr	r2, [r4, #28]
 8004e24:	45d4      	cmp	ip, sl
        data_td -> ux_stm32_td_buffer =  data_pointer;
 8004e26:	f8c4 b000 	str.w	fp, [r4]
        data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;
 8004e2a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
        data_td -> ux_stm32_td_transfer_request =  transfer_request;
 8004e2e:	60e7      	str	r7, [r4, #12]
 8004e30:	bf28      	it	cs
 8004e32:	46d4      	movcs	ip, sl
            data_td -> ux_stm32_td_direction =  UX_HCD_STM32_TD_OUT;
 8004e34:	f010 0f80 	tst.w	r0, #128	; 0x80
        data_td -> ux_stm32_td_ed =  ed;
 8004e38:	f8c4 8014 	str.w	r8, [r4, #20]
            data_td -> ux_stm32_td_direction =  UX_HCD_STM32_TD_OUT;
 8004e3c:	bf14      	ite	ne
 8004e3e:	f44f 5080 	movne.w	r0, #4096	; 0x1000
 8004e42:	f44f 6000 	moveq.w	r0, #2048	; 0x800
        data_td -> ux_stm32_td_length =  control_packet_payload_length;
 8004e46:	f8c4 c004 	str.w	ip, [r4, #4]
        transfer_request_payload_length -=  control_packet_payload_length;
 8004e4a:	ebaa 0a0c 	sub.w	sl, sl, ip
        data_pointer +=  control_packet_payload_length;
 8004e4e:	44e3      	add	fp, ip
        data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;
 8004e50:	61e2      	str	r2, [r4, #28]
 8004e52:	e9c4 0308 	strd	r0, r3, [r4, #32]

        /* The first obtained TD in the chain has to be remembered.  */
        if (start_data_td == UX_NULL)
 8004e56:	b1c5      	cbz	r5, 8004e8a <_ux_hcd_stm32_request_control_transfer+0x10e>
            start_data_td =  data_td;

        /* Attach this new TD to the previous one.  */                                
        chain_td -> ux_stm32_td_next_td =  data_td;
 8004e58:	60b4      	str	r4, [r6, #8]
        chain_td -> ux_stm32_td_next_td_transfer_request =  data_td;
 8004e5a:	6134      	str	r4, [r6, #16]
    while (transfer_request_payload_length != 0)
 8004e5c:	f1ba 0f00 	cmp.w	sl, #0
 8004e60:	d019      	beq.n	8004e96 <_ux_hcd_stm32_request_control_transfer+0x11a>
        data_td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004e62:	9801      	ldr	r0, [sp, #4]
 8004e64:	4626      	mov	r6, r4
 8004e66:	f7fe fe91 	bl	8003b8c <_ux_hcd_stm32_regular_td_obtain>
        if (data_td == UX_NULL)
 8004e6a:	4604      	mov	r4, r0
 8004e6c:	2800      	cmp	r0, #0
 8004e6e:	d1d1      	bne.n	8004e14 <_ux_hcd_stm32_request_control_transfer+0x98>
            _ux_utility_memory_free(setup_request);
 8004e70:	4648      	mov	r0, r9
 8004e72:	f7fd f84f 	bl	8001f14 <_ux_utility_memory_free>
            if (start_data_td != UX_NULL)
 8004e76:	b125      	cbz	r5, 8004e82 <_ux_hcd_stm32_request_control_transfer+0x106>
                    next_data_td =  data_td -> ux_stm32_td_next_td;
 8004e78:	68ab      	ldr	r3, [r5, #8]
                    data_td -> ux_stm32_td_status =  UX_UNUSED;
 8004e7a:	61ec      	str	r4, [r5, #28]
                while (data_td)
 8004e7c:	461d      	mov	r5, r3
 8004e7e:	2b00      	cmp	r3, #0
 8004e80:	d1fa      	bne.n	8004e78 <_ux_hcd_stm32_request_control_transfer+0xfc>
                data_td -> ux_stm32_td_status =  UX_UNUSED;
                data_td =  next_data_td;
            }
        }

        return(UX_NO_TD_AVAILABLE);
 8004e82:	2013      	movs	r0, #19
    /* Free the resources.  */
    _ux_utility_memory_free(setup_request);

    /* Return completion to caller.  */
    return(transfer_request -> ux_transfer_request_completion_code);           
}
 8004e84:	b003      	add	sp, #12
 8004e86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while (transfer_request_payload_length != 0)
 8004e8a:	4625      	mov	r5, r4
        chain_td -> ux_stm32_td_next_td =  data_td;
 8004e8c:	60b4      	str	r4, [r6, #8]
        chain_td -> ux_stm32_td_next_td_transfer_request =  data_td;
 8004e8e:	6134      	str	r4, [r6, #16]
    while (transfer_request_payload_length != 0)
 8004e90:	f1ba 0f00 	cmp.w	sl, #0
 8004e94:	d1e5      	bne.n	8004e62 <_ux_hcd_stm32_request_control_transfer+0xe6>
    status_td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004e96:	9801      	ldr	r0, [sp, #4]
 8004e98:	f7fe fe78 	bl	8003b8c <_ux_hcd_stm32_regular_td_obtain>
    if (status_td == UX_NULL)
 8004e9c:	4683      	mov	fp, r0
 8004e9e:	2800      	cmp	r0, #0
 8004ea0:	d054      	beq.n	8004f4c <_ux_hcd_stm32_request_control_transfer+0x1d0>
 8004ea2:	4625      	mov	r5, r4
    if ((transfer_request -> ux_transfer_request_type&UX_REQUEST_DIRECTION) == UX_REQUEST_IN)
 8004ea4:	697a      	ldr	r2, [r7, #20]
    status_td -> ux_stm32_td_buffer =  0;
 8004ea6:	2600      	movs	r6, #0
    status_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_STATUS_PHASE;
 8004ea8:	f8db 301c 	ldr.w	r3, [fp, #28]
        status_td -> ux_stm32_td_direction =  UX_HCD_STM32_TD_IN;
 8004eac:	f012 0f80 	tst.w	r2, #128	; 0x80
    status_td -> ux_stm32_td_toggle =  1;
 8004eb0:	f04f 0201 	mov.w	r2, #1
    status_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_STATUS_PHASE;
 8004eb4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    status_td -> ux_stm32_td_transfer_request =  transfer_request;
 8004eb8:	f8cb 700c 	str.w	r7, [fp, #12]
        status_td -> ux_stm32_td_direction =  UX_HCD_STM32_TD_IN;
 8004ebc:	bf14      	ite	ne
 8004ebe:	f44f 6100 	movne.w	r1, #2048	; 0x800
 8004ec2:	f44f 5180 	moveq.w	r1, #4096	; 0x1000
    status_td -> ux_stm32_td_ed =  ed;
 8004ec6:	f8cb 8014 	str.w	r8, [fp, #20]
    status_td -> ux_stm32_td_toggle =  1;
 8004eca:	f8cb 2024 	str.w	r2, [fp, #36]	; 0x24
    tail_td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004ece:	9801      	ldr	r0, [sp, #4]
 8004ed0:	e9cb 3107 	strd	r3, r1, [fp, #28]
    status_td -> ux_stm32_td_length =  0;
 8004ed4:	e9cb 6600 	strd	r6, r6, [fp]
    chain_td -> ux_stm32_td_next_td =  status_td;
 8004ed8:	f8c4 b008 	str.w	fp, [r4, #8]
    tail_td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004edc:	f7fe fe56 	bl	8003b8c <_ux_hcd_stm32_regular_td_obtain>
    if (tail_td == UX_NULL)
 8004ee0:	4604      	mov	r4, r0
 8004ee2:	b328      	cbz	r0, 8004f30 <_ux_hcd_stm32_request_control_transfer+0x1b4>
    hcd_stm32 -> ux_hcd_stm32_queue_empty =  UX_FALSE;
 8004ee4:	9b01      	ldr	r3, [sp, #4]
    status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_CONTROL_TRANSFER_TIMEOUT));
 8004ee6:	2164      	movs	r1, #100	; 0x64
    status_td -> ux_stm32_td_next_td =  tail_td;
 8004ee8:	f8cb 0008 	str.w	r0, [fp, #8]
    ed -> ux_stm32_ed_tail_td =  tail_td;
 8004eec:	f8c8 0000 	str.w	r0, [r8]
    status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_CONTROL_TRANSFER_TIMEOUT));
 8004ef0:	f107 0028 	add.w	r0, r7, #40	; 0x28
    hcd_stm32 -> ux_hcd_stm32_queue_empty =  UX_FALSE;
 8004ef4:	f8c3 60d4 	str.w	r6, [r3, #212]	; 0xd4
    status =  _ux_utility_semaphore_get(&transfer_request -> ux_transfer_request_semaphore, MS_TO_TICK(UX_CONTROL_TRANSFER_TIMEOUT));
 8004ef8:	f7fd f8ca 	bl	8002090 <_ux_utility_semaphore_get>
    if (status != UX_SUCCESS)
 8004efc:	b950      	cbnz	r0, 8004f14 <_ux_hcd_stm32_request_control_transfer+0x198>
    _ux_utility_memory_free(setup_request);
 8004efe:	4648      	mov	r0, r9
 8004f00:	f7fd f808 	bl	8001f14 <_ux_utility_memory_free>
    return(transfer_request -> ux_transfer_request_completion_code);           
 8004f04:	6d78      	ldr	r0, [r7, #84]	; 0x54
}
 8004f06:	b003      	add	sp, #12
 8004f08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8004f0c:	2012      	movs	r0, #18
}
 8004f0e:	b003      	add	sp, #12
 8004f10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        _ux_host_stack_transfer_request_abort(transfer_request);
 8004f14:	4638      	mov	r0, r7
 8004f16:	f7ff fab9 	bl	800448c <_ux_host_stack_transfer_request_abort>
        transfer_request -> ux_transfer_request_completion_code =  UX_TRANSFER_TIMEOUT;
 8004f1a:	235c      	movs	r3, #92	; 0x5c
 8004f1c:	657b      	str	r3, [r7, #84]	; 0x54
 8004f1e:	e7ee      	b.n	8004efe <_ux_hcd_stm32_request_control_transfer+0x182>
    status_td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004f20:	9801      	ldr	r0, [sp, #4]
 8004f22:	f7fe fe33 	bl	8003b8c <_ux_hcd_stm32_regular_td_obtain>
    if (status_td == UX_NULL)
 8004f26:	4683      	mov	fp, r0
 8004f28:	b160      	cbz	r0, 8004f44 <_ux_hcd_stm32_request_control_transfer+0x1c8>
 8004f2a:	4634      	mov	r4, r6
    data_td =  UX_NULL;    
 8004f2c:	4655      	mov	r5, sl
 8004f2e:	e7b9      	b.n	8004ea4 <_ux_hcd_stm32_request_control_transfer+0x128>
        _ux_utility_memory_free(setup_request);
 8004f30:	4648      	mov	r0, r9
 8004f32:	f7fc ffef 	bl	8001f14 <_ux_utility_memory_free>
        if (data_td != UX_NULL)
 8004f36:	b105      	cbz	r5, 8004f3a <_ux_hcd_stm32_request_control_transfer+0x1be>
            data_td -> ux_stm32_td_status =  UX_UNUSED;
 8004f38:	61ec      	str	r4, [r5, #28]
        status_td -> ux_stm32_td_status =  UX_UNUSED;
 8004f3a:	2300      	movs	r3, #0
        return(UX_NO_TD_AVAILABLE);
 8004f3c:	2013      	movs	r0, #19
        status_td -> ux_stm32_td_status =  UX_UNUSED;
 8004f3e:	f8cb 301c 	str.w	r3, [fp, #28]
        return(UX_NO_TD_AVAILABLE);
 8004f42:	e7e0      	b.n	8004f06 <_ux_hcd_stm32_request_control_transfer+0x18a>
        _ux_utility_memory_free(setup_request);
 8004f44:	4648      	mov	r0, r9
 8004f46:	f7fc ffe5 	bl	8001f14 <_ux_utility_memory_free>
 8004f4a:	e79a      	b.n	8004e82 <_ux_hcd_stm32_request_control_transfer+0x106>
 8004f4c:	4648      	mov	r0, r9
 8004f4e:	f7fc ffe1 	bl	8001f14 <_ux_utility_memory_free>
                data_td -> ux_stm32_td_status =  UX_UNUSED;
 8004f52:	465a      	mov	r2, fp
                next_data_td =  data_td -> ux_stm32_td_next_td;
 8004f54:	68ab      	ldr	r3, [r5, #8]
                data_td -> ux_stm32_td_status =  UX_UNUSED;
 8004f56:	61ea      	str	r2, [r5, #28]
            while (data_td)
 8004f58:	461d      	mov	r5, r3
 8004f5a:	2b00      	cmp	r3, #0
 8004f5c:	d1fa      	bne.n	8004f54 <_ux_hcd_stm32_request_control_transfer+0x1d8>
 8004f5e:	e790      	b.n	8004e82 <_ux_hcd_stm32_request_control_transfer+0x106>

08004f60 <_ux_hcd_stm32_request_interrupt_transfer>:
    
    /* Get the pointer to the Endpoint.  */
    endpoint =  (UX_ENDPOINT *) transfer_request -> ux_transfer_request_endpoint;

    /* Now get the physical ED attached to this endpoint.  */
    ed =  endpoint -> ux_endpoint_ed;
 8004f60:	684a      	ldr	r2, [r1, #4]

    /* Mark the TD with the DATA phase.  */
    data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;

    /* The Toggle value is in the ED.  */
    data_td -> ux_stm32_td_toggle =  UX_HCD_STM32_TD_TOGGLE_FROM_ED;
 8004f62:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
{
 8004f66:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ed =  endpoint -> ux_endpoint_ed;
 8004f68:	6895      	ldr	r5, [r2, #8]
    ed -> ux_stm32_ed_command_retry =  0;
 8004f6a:	2600      	movs	r6, #0
    if ((transfer_request -> ux_transfer_request_type & UX_REQUEST_DIRECTION) == UX_REQUEST_IN)
 8004f6c:	694b      	ldr	r3, [r1, #20]
    data_td =  ed -> ux_stm32_ed_tail_td;
 8004f6e:	682c      	ldr	r4, [r5, #0]
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8004f70:	692a      	ldr	r2, [r5, #16]
        data_td -> ux_stm32_td_direction =  UX_HCD_STM32_TD_OUT;
 8004f72:	f013 0f80 	tst.w	r3, #128	; 0x80
    data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;
 8004f76:	69e3      	ldr	r3, [r4, #28]
        data_td -> ux_stm32_td_direction =  UX_HCD_STM32_TD_OUT;
 8004f78:	bf14      	ite	ne
 8004f7a:	f44f 5780 	movne.w	r7, #4096	; 0x1000
 8004f7e:	f44f 6700 	moveq.w	r7, #2048	; 0x800
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8004f82:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;
 8004f86:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    ed -> ux_stm32_ed_command_retry =  0;
 8004f8a:	626e      	str	r6, [r5, #36]	; 0x24
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8004f8c:	612a      	str	r2, [r5, #16]
    data_td -> ux_stm32_td_toggle =  UX_HCD_STM32_TD_TOGGLE_FROM_ED;
 8004f8e:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
    data_td -> ux_stm32_td_status |=  UX_HCD_STM32_TD_DATA_PHASE;
 8004f92:	e9c4 3707 	strd	r3, r7, [r4, #28]

    /* Store the beginning of the buffer address in the TD.  */
    data_td -> ux_stm32_td_buffer =  transfer_request -> ux_transfer_request_data_pointer;

    /* Update the length of the transfer for this TD.  */
    data_td -> ux_stm32_td_length =  transfer_request -> ux_transfer_request_requested_length;
 8004f96:	e9d1 2302 	ldrd	r2, r3, [r1, #8]

    /* Attach the endpoint and transfer request to the TD.  */
    data_td -> ux_stm32_td_transfer_request =  transfer_request;
 8004f9a:	60e1      	str	r1, [r4, #12]
{
 8004f9c:	4607      	mov	r7, r0
    data_td -> ux_stm32_td_ed =  ed;
 8004f9e:	6165      	str	r5, [r4, #20]
    data_td -> ux_stm32_td_length =  transfer_request -> ux_transfer_request_requested_length;
 8004fa0:	e9c4 2300 	strd	r2, r3, [r4]

    /* At this stage, the Head and Tail in the ED are still the same and
       the STM32 controller will skip this ED until we have hooked the new
       tail TD.  */
    tail_td =  _ux_hcd_stm32_regular_td_obtain(hcd_stm32);
 8004fa4:	f7fe fdf2 	bl	8003b8c <_ux_hcd_stm32_regular_td_obtain>
    if (tail_td == UX_NULL)
 8004fa8:	b150      	cbz	r0, 8004fc0 <_ux_hcd_stm32_request_interrupt_transfer+0x60>

    /* Store the new tail TD.  */
    ed -> ux_stm32_ed_tail_td =  tail_td;

    /* Clear the skip bit.  */
    ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8004faa:	692a      	ldr	r2, [r5, #16]
 8004fac:	4603      	mov	r3, r0
    hcd_stm32 -> ux_hcd_stm32_queue_empty =  UX_FALSE;

    /* There is no need to wake up the stm32 controller on this transfer
       since periodic transactions will be picked up when the interrupt
       tree is scanned.  */
    return(UX_SUCCESS);           
 8004fae:	4630      	mov	r0, r6
    ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8004fb0:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
    data_td -> ux_stm32_td_next_td =  tail_td;
 8004fb4:	60a3      	str	r3, [r4, #8]
    ed -> ux_stm32_ed_tail_td =  tail_td;
 8004fb6:	602b      	str	r3, [r5, #0]
    ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8004fb8:	612a      	str	r2, [r5, #16]
    hcd_stm32 -> ux_hcd_stm32_queue_empty =  UX_FALSE;
 8004fba:	f8c7 60d4 	str.w	r6, [r7, #212]	; 0xd4
}
 8004fbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8004fc0:	692b      	ldr	r3, [r5, #16]
        return(UX_NO_TD_AVAILABLE);
 8004fc2:	2013      	movs	r0, #19
        ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8004fc4:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8004fc8:	612b      	str	r3, [r5, #16]
}
 8004fca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08004fcc <_ux_hcd_stm32_request_isochronous_transfer>:
ULONG                   isoch_packet_payload_length;
UCHAR                   *data_pointer;
ULONG                   current_frame_number;
    
    /* Get the pointer to the Endpoint.  */
    endpoint =  (UX_ENDPOINT *) transfer_request -> ux_transfer_request_endpoint;
 8004fcc:	684a      	ldr	r2, [r1, #4]
{
 8004fce:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    /* Now get the physical ED attached to this endpoint.  */
    ed =  endpoint -> ux_endpoint_ed;
 8004fd2:	6897      	ldr	r7, [r2, #8]
{
 8004fd4:	b083      	sub	sp, #12
    /* The endpoint may be active. If so, set the skip bit.  */
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;

    /* If the transfer_request specifies a max packet length other than the endpoint
       size, we force the transfer request value into the endpoint.  */
    if (transfer_request -> ux_transfer_request_packet_length == 0)
 8004fd6:	6d8d      	ldr	r5, [r1, #88]	; 0x58
{
 8004fd8:	4688      	mov	r8, r1
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8004fda:	693b      	ldr	r3, [r7, #16]
{
 8004fdc:	4681      	mov	r9, r0
    ed -> ux_stm32_ed_status |=  UX_HCD_STM32_ED_SKIP;
 8004fde:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004fe2:	613b      	str	r3, [r7, #16]
    if (transfer_request -> ux_transfer_request_packet_length == 0)
 8004fe4:	b90d      	cbnz	r5, 8004fea <_ux_hcd_stm32_request_isochronous_transfer+0x1e>
        transfer_request -> ux_transfer_request_packet_length =  (ULONG) endpoint -> ux_endpoint_descriptor.wMaxPacketSize;
 8004fe6:	69d5      	ldr	r5, [r2, #28]
 8004fe8:	658d      	str	r5, [r1, #88]	; 0x58
    start_data_td =  UX_NULL;

    /* Calculate the frame number to be used to send this payload. If there are no current transfers, 
       we take the current frame number and add a safety value (2-5) to it. If here is pending transactions,
       we use the frame number stored in the transfer request.  */
    if (ed -> ux_stm32_ed_tail_td == ed -> ux_stm32_ed_head_td)
 8004fea:	e9d7 4300 	ldrd	r4, r3, [r7]
 8004fee:	42a3      	cmp	r3, r4
 8004ff0:	d05a      	beq.n	80050a8 <_ux_hcd_stm32_request_isochronous_transfer+0xdc>
        ed -> ux_stm32_ed_frame =  current_frame_number + UX_HCD_STM32_FRAME_DELAY;
    }
    else
    {

        current_frame_number =  ed -> ux_stm32_ed_frame;
 8004ff2:	69fb      	ldr	r3, [r7, #28]
 8004ff4:	9301      	str	r3, [sp, #4]
    }

    /* Load the start buffer address and Urb length to split the urb in multiple TD transfer.  */
    transfer_request_payload_length =  transfer_request -> ux_transfer_request_requested_length;
    data_pointer =  transfer_request -> ux_transfer_request_data_pointer;
 8004ff6:	e9d8 b602 	ldrd	fp, r6, [r8, #8]
    
    while (transfer_request_payload_length != 0)
 8004ffa:	2e00      	cmp	r6, #0
 8004ffc:	d05c      	beq.n	80050b8 <_ux_hcd_stm32_request_isochronous_transfer+0xec>
    start_data_td =  UX_NULL;
 8004ffe:	f04f 0a00 	mov.w	sl, #0
    {

        /* Set the direction of the TD.  */
        if ((transfer_request -> ux_transfer_request_type&UX_REQUEST_DIRECTION) == UX_REQUEST_IN)
 8005002:	f8d8 2014 	ldr.w	r2, [r8, #20]
        /* Adjust the data payload length and the data payload pointer.  */
        transfer_request_payload_length -=  isoch_packet_payload_length;
        data_pointer +=  isoch_packet_payload_length;

        /* Prepare the next frame for the next TD in advance.  */
        current_frame_number++;
 8005006:	1c59      	adds	r1, r3, #1
            data_td -> ux_stm32_iso_td_direction =  UX_HCD_STM32_TD_IN;
 8005008:	f012 0f80 	tst.w	r2, #128	; 0x80
 800500c:	bf0c      	ite	eq
 800500e:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 8005012:	f44f 5280 	movne.w	r2, #4096	; 0x1000

        /* Check if there will be another transaction.  */
        if (transfer_request_payload_length != 0)
 8005016:	1b76      	subs	r6, r6, r5
 8005018:	6222      	str	r2, [r4, #32]
        ed -> ux_stm32_ed_frame =  current_frame_number;
 800501a:	61fb      	str	r3, [r7, #28]
        data_td -> ux_stm32_iso_td_transfer_request =  transfer_request;
 800501c:	f8c4 800c 	str.w	r8, [r4, #12]
        data_td -> ux_stm32_iso_td_ed =  ed;
 8005020:	6167      	str	r7, [r4, #20]
        data_td -> ux_stm32_iso_td_length =  isoch_packet_payload_length;
 8005022:	e9c4 b500 	strd	fp, r5, [r4]
        current_frame_number++;
 8005026:	9101      	str	r1, [sp, #4]
        if (transfer_request_payload_length != 0)
 8005028:	d122      	bne.n	8005070 <_ux_hcd_stm32_request_isochronous_transfer+0xa4>
            previous_td =  data_td;
        }
    }
        
    /* Memorize the next frame number for this ED.  */
    ed -> ux_stm32_ed_frame =  current_frame_number;
 800502a:	61f9      	str	r1, [r7, #28]

    /* At this stage, the Head and Tail in the ED are still the same and the STM32 controller 
       will skip this ED until we have hooked the new tail TD.  */
    tail_td =  _ux_hcd_stm32_isochronous_td_obtain(hcd_stm32);
 800502c:	4648      	mov	r0, r9
 800502e:	f7fe fc91 	bl	8003954 <_ux_hcd_stm32_isochronous_td_obtain>
    if (tail_td == UX_NULL)
 8005032:	4603      	mov	r3, r0
 8005034:	b148      	cbz	r0, 800504a <_ux_hcd_stm32_request_isochronous_transfer+0x7e>
    /* Adjust the ED tail pointer, the controller can now start this transfer
       at the chosen frame number.  */
    ed -> ux_stm32_ed_tail_td =  (UX_HCD_STM32_TD *) ((void *) tail_td);

    /* Clear the skip bit.  */
    ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8005036:	693a      	ldr	r2, [r7, #16]

    /* Return successful completion.  */
    return(UX_SUCCESS);           
 8005038:	2000      	movs	r0, #0
    data_td -> ux_stm32_iso_td_next_td =  tail_td;
 800503a:	60a3      	str	r3, [r4, #8]
    ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 800503c:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
    ed -> ux_stm32_ed_tail_td =  (UX_HCD_STM32_TD *) ((void *) tail_td);
 8005040:	603b      	str	r3, [r7, #0]
    ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8005042:	613a      	str	r2, [r7, #16]
}
 8005044:	b003      	add	sp, #12
 8005046:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            while(data_td)
 800504a:	f1ba 0f00 	cmp.w	sl, #0
 800504e:	d007      	beq.n	8005060 <_ux_hcd_stm32_request_isochronous_transfer+0x94>
                next_data_td =  data_td -> ux_stm32_iso_td_next_td;
 8005050:	f8da 3008 	ldr.w	r3, [sl, #8]
                data_td -> ux_stm32_iso_td_status =  UX_UNUSED;
 8005054:	f8ca 601c 	str.w	r6, [sl, #28]
            while(data_td)
 8005058:	469a      	mov	sl, r3
 800505a:	f1ba 0f00 	cmp.w	sl, #0
 800505e:	d1f7      	bne.n	8005050 <_ux_hcd_stm32_request_isochronous_transfer+0x84>
        ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8005060:	693b      	ldr	r3, [r7, #16]
        return(UX_NO_TD_AVAILABLE);
 8005062:	2013      	movs	r0, #19
        ed -> ux_stm32_ed_status &= ~UX_HCD_STM32_ED_SKIP;
 8005064:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8005068:	613b      	str	r3, [r7, #16]
}
 800506a:	b003      	add	sp, #12
 800506c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            data_td =  _ux_hcd_stm32_isochronous_td_obtain(hcd_stm32);
 8005070:	4648      	mov	r0, r9
        data_pointer +=  isoch_packet_payload_length;
 8005072:	44ab      	add	fp, r5
            data_td =  _ux_hcd_stm32_isochronous_td_obtain(hcd_stm32);
 8005074:	f7fe fc6e 	bl	8003954 <_ux_hcd_stm32_isochronous_td_obtain>
            if (data_td == UX_NULL)
 8005078:	b138      	cbz	r0, 800508a <_ux_hcd_stm32_request_isochronous_transfer+0xbe>
            previous_td -> ux_stm32_iso_td_next_td =  data_td;
 800507a:	60a0      	str	r0, [r4, #8]
 800507c:	f1ba 0f00 	cmp.w	sl, #0
 8005080:	bf08      	it	eq
 8005082:	4682      	moveq	sl, r0
 8005084:	4604      	mov	r4, r0
 8005086:	9b01      	ldr	r3, [sp, #4]
 8005088:	e7bb      	b.n	8005002 <_ux_hcd_stm32_request_isochronous_transfer+0x36>
                    while(data_td)
 800508a:	f1ba 0f00 	cmp.w	sl, #0
 800508e:	d007      	beq.n	80050a0 <_ux_hcd_stm32_request_isochronous_transfer+0xd4>
                        next_data_td =  data_td -> ux_stm32_iso_td_next_td;
 8005090:	f8da 3008 	ldr.w	r3, [sl, #8]
                        data_td -> ux_stm32_iso_td_status =  UX_UNUSED;
 8005094:	f8ca 001c 	str.w	r0, [sl, #28]
                    while(data_td)
 8005098:	469a      	mov	sl, r3
 800509a:	f1ba 0f00 	cmp.w	sl, #0
 800509e:	d1f7      	bne.n	8005090 <_ux_hcd_stm32_request_isochronous_transfer+0xc4>
                return(UX_NO_TD_AVAILABLE);
 80050a0:	2013      	movs	r0, #19
}
 80050a2:	b003      	add	sp, #12
 80050a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        _ux_hcd_stm32_frame_number_get(hcd_stm32, &current_frame_number);
 80050a8:	a901      	add	r1, sp, #4
 80050aa:	4648      	mov	r0, r9
 80050ac:	f7fe fafa 	bl	80036a4 <_ux_hcd_stm32_frame_number_get>
        ed -> ux_stm32_ed_frame =  current_frame_number + UX_HCD_STM32_FRAME_DELAY;
 80050b0:	9b01      	ldr	r3, [sp, #4]
 80050b2:	1d1a      	adds	r2, r3, #4
 80050b4:	61fa      	str	r2, [r7, #28]
 80050b6:	e79e      	b.n	8004ff6 <_ux_hcd_stm32_request_isochronous_transfer+0x2a>
    ed -> ux_stm32_ed_frame =  current_frame_number;
 80050b8:	61fb      	str	r3, [r7, #28]
    tail_td =  _ux_hcd_stm32_isochronous_td_obtain(hcd_stm32);
 80050ba:	4648      	mov	r0, r9
 80050bc:	f7fe fc4a 	bl	8003954 <_ux_hcd_stm32_isochronous_td_obtain>
    if (tail_td == UX_NULL)
 80050c0:	4603      	mov	r3, r0
 80050c2:	2800      	cmp	r0, #0
 80050c4:	d1b7      	bne.n	8005036 <_ux_hcd_stm32_request_isochronous_transfer+0x6a>
 80050c6:	e7cb      	b.n	8005060 <_ux_hcd_stm32_request_isochronous_transfer+0x94>

080050c8 <_ux_host_stack_bandwidth_release>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_stack_bandwidth_release(UX_HCD *hcd, UX_ENDPOINT *endpoint)
{
 80050c8:	b5f0      	push	{r4, r5, r6, r7, lr}
     * 
     * Worst case bit stuffing is calculated as 1.1667 (7/6) times the raw time.
     */

    /* Get maximum packet size.  */
    max_packet_size  = endpoint -> ux_endpoint_descriptor.wMaxPacketSize & UX_MAX_PACKET_SIZE_MASK;
 80050ca:	e9d1 3506 	ldrd	r3, r5, [r1, #24]
{
 80050ce:	b085      	sub	sp, #20
    device =  endpoint -> ux_endpoint_device;
 80050d0:	f8d1 c02c 	ldr.w	ip, [r1, #44]	; 0x2c

    /* Rough time for possible Bit Stuffing.  */
    packet_size = (max_packet_size * 7 + 5) / 6;

    /* Add overhead.  */
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 80050d4:	f003 0303 	and.w	r3, r3, #3
    packet_size = (max_packet_size * 7 + 5) / 6;
 80050d8:	f3c5 020a 	ubfx	r2, r5, #0, #11
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 80050dc:	a904      	add	r1, sp, #16
{
 80050de:	4607      	mov	r7, r0
    packet_size = (max_packet_size * 7 + 5) / 6;
 80050e0:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
const UCHAR     overheads[4][3] = {
 80050e4:	f8df e134 	ldr.w	lr, [pc, #308]	; 800521c <_ux_host_stack_bandwidth_release+0x154>
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 80050e8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    packet_size = (max_packet_size * 7 + 5) / 6;
 80050ec:	484a      	ldr	r0, [pc, #296]	; (8005218 <_ux_host_stack_bandwidth_release+0x150>)
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 80050ee:	f8dc 6010 	ldr.w	r6, [ip, #16]
    packet_size = (max_packet_size * 7 + 5) / 6;
 80050f2:	1d54      	adds	r4, r2, #5
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 80050f4:	440b      	add	r3, r1
    packet_size = (max_packet_size * 7 + 5) / 6;
 80050f6:	fba0 2404 	umull	r2, r4, r0, r4
    max_packet_size = (USHORT)packet_size;

    /* Check for high-speed endpoint.  */
    if (device -> ux_device_speed == UX_HIGH_SPEED_DEVICE)
 80050fa:	2e02      	cmp	r6, #2
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 80050fc:	4433      	add	r3, r6
const UCHAR     overheads[4][3] = {
 80050fe:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
 8005102:	f10d 0e10 	add.w	lr, sp, #16
 8005106:	e90e 0007 	stmdb	lr, {r0, r1, r2}
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 800510a:	f813 2c0c 	ldrb.w	r2, [r3, #-12]
 800510e:	f8d7 00c0 	ldr.w	r0, [r7, #192]	; 0xc0
 8005112:	eb02 0494 	add.w	r4, r2, r4, lsr #2
 8005116:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    max_packet_size = (USHORT)packet_size;
 800511a:	b2a1      	uxth	r1, r4
    if (device -> ux_device_speed == UX_HIGH_SPEED_DEVICE)
 800511c:	d058      	beq.n	80051d0 <_ux_host_stack_bandwidth_release+0x108>
                    (((endpoint -> ux_endpoint_descriptor.wMaxPacketSize & UX_MAX_NUMBER_OF_TRANSACTIONS_MASK) >>
                        UX_MAX_NUMBER_OF_TRANSACTIONS_SHIFT) + 1));
    }

    /* Calculate the bandwidth claimed by this endpoint for the main bus.  */
    if (hcd -> ux_hcd_version != 0x200)
 800511e:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8005122:	d00f      	beq.n	8005144 <_ux_host_stack_bandwidth_release+0x7c>
    {

        if (device -> ux_device_speed == UX_LOW_SPEED_DEVICE)
 8005124:	2e00      	cmp	r6, #0
 8005126:	d15e      	bne.n	80051e6 <_ux_host_stack_bandwidth_release+0x11e>
            /* Low speed transfer takes 40x more units than high speed. */
            hcd_bandwidth_claimed =  (USHORT)(max_packet_size * 8 * 5);
 8005128:	eb01 0481 	add.w	r4, r1, r1, lsl #2
    hcd -> ux_hcd_available_bandwidth +=  hcd_bandwidth_claimed;

    /* We need to take care of the case where the endpoint belongs to a USB 1.1
       device that sits behind a 2.0 hub. We ignore cases where the device
       is either high speed or the bus is 1.1.  */
    if ((device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) || (hcd -> ux_hcd_version != 0x200))
 800512c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
USHORT          tt_bandwidth_claimed =  0;
 8005130:	4631      	mov	r1, r6
            hcd_bandwidth_claimed =  (USHORT)(max_packet_size * 8 * 5);
 8005132:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 8005136:	b2a4      	uxth	r4, r4
 8005138:	441c      	add	r4, r3
    hcd -> ux_hcd_available_bandwidth +=  hcd_bandwidth_claimed;
 800513a:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
    if ((device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) || (hcd -> ux_hcd_version != 0x200))
 800513e:	d00b      	beq.n	8005158 <_ux_host_stack_bandwidth_release+0x90>
    }

    /* We get here when we have not found a 2.0 hub in the list and we got
       to the root port.  */
    return;
}
 8005140:	b005      	add	sp, #20
 8005142:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005144:	441c      	add	r4, r3
        if (device -> ux_device_speed == UX_LOW_SPEED_DEVICE)
 8005146:	2e00      	cmp	r6, #0
 8005148:	d157      	bne.n	80051fa <_ux_host_stack_bandwidth_release+0x132>
            tt_bandwidth_claimed =  (USHORT)(max_packet_size * 8);
 800514a:	00c9      	lsls	r1, r1, #3
    if ((device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) || (hcd -> ux_hcd_version != 0x200))
 800514c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    hcd -> ux_hcd_available_bandwidth +=  hcd_bandwidth_claimed;
 8005150:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
            tt_bandwidth_claimed =  (USHORT)(max_packet_size * 8);
 8005154:	b289      	uxth	r1, r1
    if ((device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) || (hcd -> ux_hcd_version != 0x200))
 8005156:	d1f3      	bne.n	8005140 <_ux_host_stack_bandwidth_release+0x78>
    parent_device =  device -> ux_device_parent;
 8005158:	f8dc 3044 	ldr.w	r3, [ip, #68]	; 0x44
    if (parent_device == UX_NULL)
 800515c:	2b00      	cmp	r3, #0
 800515e:	d0ef      	beq.n	8005140 <_ux_host_stack_bandwidth_release+0x78>
    port_index =  device -> ux_device_port_location - 1;
 8005160:	f8dc 2014 	ldr.w	r2, [ip, #20]
 8005164:	3a01      	subs	r2, #1
 8005166:	e004      	b.n	8005172 <_ux_host_stack_bandwidth_release+0xaa>
        port_index =  parent_device -> ux_device_port_location - 1;
 8005168:	695a      	ldr	r2, [r3, #20]
        parent_device =  parent_device -> ux_device_parent;
 800516a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        port_index =  parent_device -> ux_device_port_location - 1;
 800516c:	3a01      	subs	r2, #1
    while (parent_device != UX_NULL)
 800516e:	2b00      	cmp	r3, #0
 8005170:	d0e6      	beq.n	8005140 <_ux_host_stack_bandwidth_release+0x78>
        if (parent_device -> ux_device_speed == UX_HIGH_SPEED_DEVICE)
 8005172:	6918      	ldr	r0, [r3, #16]
 8005174:	2802      	cmp	r0, #2
 8005176:	d1f7      	bne.n	8005168 <_ux_host_stack_bandwidth_release+0xa0>
            port_map =  (ULONG)(1 << port_index);
 8005178:	2401      	movs	r4, #1
                if ((parent_device -> ux_device_hub_tt[tt_index].ux_hub_tt_port_mapping & port_map) != 0)
 800517a:	f8d3 512c 	ldr.w	r5, [r3, #300]	; 0x12c
            port_map =  (ULONG)(1 << port_index);
 800517e:	fa04 f202 	lsl.w	r2, r4, r2
                if ((parent_device -> ux_device_hub_tt[tt_index].ux_hub_tt_port_mapping & port_map) != 0)
 8005182:	422a      	tst	r2, r5
 8005184:	d13c      	bne.n	8005200 <_ux_host_stack_bandwidth_release+0x138>
 8005186:	f8d3 5134 	ldr.w	r5, [r3, #308]	; 0x134
 800518a:	422a      	tst	r2, r5
 800518c:	d13a      	bne.n	8005204 <_ux_host_stack_bandwidth_release+0x13c>
 800518e:	f8d3 413c 	ldr.w	r4, [r3, #316]	; 0x13c
 8005192:	4222      	tst	r2, r4
 8005194:	d114      	bne.n	80051c0 <_ux_host_stack_bandwidth_release+0xf8>
 8005196:	f8d3 0144 	ldr.w	r0, [r3, #324]	; 0x144
 800519a:	4202      	tst	r2, r0
 800519c:	d134      	bne.n	8005208 <_ux_host_stack_bandwidth_release+0x140>
 800519e:	f8d3 014c 	ldr.w	r0, [r3, #332]	; 0x14c
 80051a2:	4202      	tst	r2, r0
 80051a4:	d132      	bne.n	800520c <_ux_host_stack_bandwidth_release+0x144>
 80051a6:	f8d3 0154 	ldr.w	r0, [r3, #340]	; 0x154
 80051aa:	4202      	tst	r2, r0
 80051ac:	d130      	bne.n	8005210 <_ux_host_stack_bandwidth_release+0x148>
 80051ae:	f8d3 015c 	ldr.w	r0, [r3, #348]	; 0x15c
 80051b2:	4202      	tst	r2, r0
 80051b4:	d12e      	bne.n	8005214 <_ux_host_stack_bandwidth_release+0x14c>
 80051b6:	f8d3 0164 	ldr.w	r0, [r3, #356]	; 0x164
 80051ba:	4202      	tst	r2, r0
 80051bc:	d0c0      	beq.n	8005140 <_ux_host_stack_bandwidth_release+0x78>
            for (tt_index = 0; tt_index < UX_MAX_TT; tt_index++)
 80051be:	2007      	movs	r0, #7
 80051c0:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
                    parent_device -> ux_device_hub_tt[tt_index].ux_hub_tt_max_bandwidth +=  tt_bandwidth_claimed;
 80051c4:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
 80051c8:	4411      	add	r1, r2
 80051ca:	f8c3 1130 	str.w	r1, [r3, #304]	; 0x130
                    return;
 80051ce:	e7b7      	b.n	8005140 <_ux_host_stack_bandwidth_release+0x78>
                    (((endpoint -> ux_endpoint_descriptor.wMaxPacketSize & UX_MAX_NUMBER_OF_TRANSACTIONS_MASK) >>
 80051d0:	f3c5 25c1 	ubfx	r5, r5, #11, #2
                        UX_MAX_NUMBER_OF_TRANSACTIONS_SHIFT) + 1));
 80051d4:	3501      	adds	r5, #1
        max_packet_size = (USHORT)(max_packet_size *
 80051d6:	fb15 f101 	smulbb	r1, r5, r1
 80051da:	b289      	uxth	r1, r1
    hcd -> ux_hcd_available_bandwidth +=  hcd_bandwidth_claimed;
 80051dc:	4419      	add	r1, r3
 80051de:	f8c7 10b8 	str.w	r1, [r7, #184]	; 0xb8
}
 80051e2:	b005      	add	sp, #20
 80051e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (device -> ux_device_speed == UX_FULL_SPEED_DEVICE)
 80051e6:	2e01      	cmp	r6, #1
 80051e8:	d1f8      	bne.n	80051dc <_ux_host_stack_bandwidth_release+0x114>
                hcd_bandwidth_claimed =  (USHORT)(max_packet_size * 5);
 80051ea:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    hcd -> ux_hcd_available_bandwidth +=  hcd_bandwidth_claimed;
 80051ee:	fa13 f381 	uxtah	r3, r3, r1
 80051f2:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
}
 80051f6:	b005      	add	sp, #20
 80051f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcd -> ux_hcd_available_bandwidth +=  hcd_bandwidth_claimed;
 80051fa:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
 80051fe:	e7ab      	b.n	8005158 <_ux_host_stack_bandwidth_release+0x90>
            for (tt_index = 0; tt_index < UX_MAX_TT; tt_index++)
 8005200:	2000      	movs	r0, #0
 8005202:	e7dd      	b.n	80051c0 <_ux_host_stack_bandwidth_release+0xf8>
 8005204:	4620      	mov	r0, r4
 8005206:	e7db      	b.n	80051c0 <_ux_host_stack_bandwidth_release+0xf8>
 8005208:	2003      	movs	r0, #3
 800520a:	e7d9      	b.n	80051c0 <_ux_host_stack_bandwidth_release+0xf8>
 800520c:	2004      	movs	r0, #4
 800520e:	e7d7      	b.n	80051c0 <_ux_host_stack_bandwidth_release+0xf8>
 8005210:	2005      	movs	r0, #5
 8005212:	e7d5      	b.n	80051c0 <_ux_host_stack_bandwidth_release+0xf8>
 8005214:	2006      	movs	r0, #6
 8005216:	e7d3      	b.n	80051c0 <_ux_host_stack_bandwidth_release+0xf8>
 8005218:	aaaaaaab 	.word	0xaaaaaaab
 800521c:	0800dd10 	.word	0x0800dd10

08005220 <_ux_host_stack_configuration_instance_create>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_configuration_instance_create(UX_CONFIGURATION *configuration)
{
 8005220:	b510      	push	{r4, lr}
    
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_CONFIGURATION_INSTANCE_CREATE, configuration, 0, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    /* Obtain the first interface for this configuration.  */
    interface =  configuration -> ux_configuration_first_interface;
 8005222:	6ac4      	ldr	r4, [r0, #44]	; 0x2c

    /* Each selected alternate setting 0 for each interface must be created.  */
    while (interface != UX_NULL)
 8005224:	b914      	cbnz	r4, 800522c <_ux_host_stack_configuration_instance_create+0xc>
 8005226:	e00a      	b.n	800523e <_ux_host_stack_configuration_instance_create+0x1e>
                return(status);
            
        }

        /* Next interface.  */
        interface =  interface -> ux_interface_next_interface;
 8005228:	6be4      	ldr	r4, [r4, #60]	; 0x3c
    while (interface != UX_NULL)
 800522a:	b144      	cbz	r4, 800523e <_ux_host_stack_configuration_instance_create+0x1e>
        if (interface -> ux_interface_descriptor.bAlternateSetting == 0)
 800522c:	69a3      	ldr	r3, [r4, #24]
 800522e:	2b00      	cmp	r3, #0
 8005230:	d1fa      	bne.n	8005228 <_ux_host_stack_configuration_instance_create+0x8>
            status = _ux_host_stack_interface_instance_create(interface);
 8005232:	4620      	mov	r0, r4
 8005234:	f000 f834 	bl	80052a0 <_ux_host_stack_interface_instance_create>
            if (status != UX_SUCCESS)
 8005238:	2800      	cmp	r0, #0
 800523a:	d0f5      	beq.n	8005228 <_ux_host_stack_configuration_instance_create+0x8>
    }

    /* Return successful completion.  */
    return(UX_SUCCESS); 
}
 800523c:	bd10      	pop	{r4, pc}
    return(UX_SUCCESS); 
 800523e:	2000      	movs	r0, #0
}
 8005240:	bd10      	pop	{r4, pc}
 8005242:	bf00      	nop

08005244 <_ux_host_stack_configuration_instance_delete>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_stack_configuration_instance_delete(UX_CONFIGURATION *configuration)
{
 8005244:	b538      	push	{r3, r4, r5, lr}
    
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_CONFIGURATION_INSTANCE_DELETE, configuration, 0, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    /* Obtain the first interface for this configuration.  */
    interface =  configuration -> ux_configuration_first_interface;
 8005246:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    
    /* In order to keep the compiler happy, we reset the alternate setting.  */
    current_alternate_setting =  0;

    /* Each selected alternate setting for each interface must be deleted.  */
    while (interface != UX_NULL)
 8005248:	b144      	cbz	r4, 800525c <_ux_host_stack_configuration_instance_delete+0x18>
    current_alternate_setting =  0;
 800524a:	2500      	movs	r5, #0
    {

        /* If this is the first alternate setting, the current alternate setting is maintained here.  */
        if (interface -> ux_interface_descriptor.bAlternateSetting == 0)
 800524c:	69a3      	ldr	r3, [r4, #24]
 800524e:	b903      	cbnz	r3, 8005252 <_ux_host_stack_configuration_instance_delete+0xe>
        {

            current_alternate_setting =  interface -> ux_interface_current_alternate_setting;
 8005250:	68a5      	ldr	r5, [r4, #8]
        }
        
        if (interface -> ux_interface_descriptor.bAlternateSetting == current_alternate_setting)
 8005252:	42ab      	cmp	r3, r5
 8005254:	d003      	beq.n	800525e <_ux_host_stack_configuration_instance_delete+0x1a>
        {
            _ux_host_stack_interface_instance_delete(interface);
        }

        interface =  interface -> ux_interface_next_interface;
 8005256:	6be4      	ldr	r4, [r4, #60]	; 0x3c
    while (interface != UX_NULL)
 8005258:	2c00      	cmp	r4, #0
 800525a:	d1f7      	bne.n	800524c <_ux_host_stack_configuration_instance_delete+0x8>
    }

    return; 
}
 800525c:	bd38      	pop	{r3, r4, r5, pc}
            _ux_host_stack_interface_instance_delete(interface);
 800525e:	4620      	mov	r0, r4
 8005260:	f000 f82c 	bl	80052bc <_ux_host_stack_interface_instance_delete>
        interface =  interface -> ux_interface_next_interface;
 8005264:	6be4      	ldr	r4, [r4, #60]	; 0x3c
    while (interface != UX_NULL)
 8005266:	2c00      	cmp	r4, #0
 8005268:	d1f0      	bne.n	800524c <_ux_host_stack_configuration_instance_delete+0x8>
}
 800526a:	bd38      	pop	{r3, r4, r5, pc}

0800526c <_ux_host_stack_configuration_set>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_configuration_set(UX_CONFIGURATION *configuration)
{
 800526c:	b538      	push	{r3, r4, r5, lr}

    /* Create a transfer_request for the SET_CONFIGURATION request. No data for this request.  */
    transfer_request -> ux_transfer_request_requested_length =  0;
    transfer_request -> ux_transfer_request_function =          UX_SET_CONFIGURATION;
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_OUT | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
    transfer_request -> ux_transfer_request_value =             (USHORT) configuration -> ux_configuration_descriptor.bConfigurationValue;
 800526e:	8b82      	ldrh	r2, [r0, #28]
    transfer_request -> ux_transfer_request_requested_length =  0;
 8005270:	2300      	movs	r3, #0
    device =            configuration -> ux_configuration_device;
 8005272:	6b44      	ldr	r4, [r0, #52]	; 0x34
    transfer_request -> ux_transfer_request_function =          UX_SET_CONFIGURATION;
 8005274:	2109      	movs	r1, #9
{
 8005276:	4605      	mov	r5, r0
    transfer_request -> ux_transfer_request_function =          UX_SET_CONFIGURATION;
 8005278:	f8c4 10dc 	str.w	r1, [r4, #220]	; 0xdc
    transfer_request -> ux_transfer_request_index =             0;

    /* Send request to HCD layer.  */
    status =  _ux_host_stack_transfer_request(transfer_request);
 800527c:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
    transfer_request -> ux_transfer_request_value =             (USHORT) configuration -> ux_configuration_descriptor.bConfigurationValue;
 8005280:	f8c4 20e0 	str.w	r2, [r4, #224]	; 0xe0
    transfer_request -> ux_transfer_request_requested_length =  0;
 8005284:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_OUT | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 8005288:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
    transfer_request -> ux_transfer_request_index =             0;
 800528c:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
    status =  _ux_host_stack_transfer_request(transfer_request);
 8005290:	f7ff f8ae 	bl	80043f0 <_ux_host_stack_transfer_request>

    /* Check completion status.  */
    if(status == UX_SUCCESS)
 8005294:	b918      	cbnz	r0, 800529e <_ux_host_stack_configuration_set+0x32>

        /* Change the device state to configured.  */
        device -> ux_device_state =  UX_DEVICE_CONFIGURED;
    
        /* Store the new configuration value in the device container.  */
        device -> ux_device_current_configuration =  configuration -> ux_configuration_descriptor.bConfigurationValue;
 8005296:	69ea      	ldr	r2, [r5, #28]
        device -> ux_device_state =  UX_DEVICE_CONFIGURED;
 8005298:	2303      	movs	r3, #3
        device -> ux_device_current_configuration =  configuration -> ux_configuration_descriptor.bConfigurationValue;
 800529a:	6222      	str	r2, [r4, #32]
        device -> ux_device_state =  UX_DEVICE_CONFIGURED;
 800529c:	60a3      	str	r3, [r4, #8]
    }

    /* Return status to caller.  */
    return(status);
}
 800529e:	bd38      	pop	{r3, r4, r5, pc}

080052a0 <_ux_host_stack_interface_instance_create>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_interface_instance_create(UX_INTERFACE *interface)
{
 80052a0:	b510      	push	{r4, lr}

    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_INTERFACE_INSTANCE_CREATE, interface, 0, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    /* Obtain the first endpoint for this alternate setting.  */
    endpoint =  interface -> ux_interface_first_endpoint;
 80052a2:	6b84      	ldr	r4, [r0, #56]	; 0x38

    /* Loop to create each endpoint.  */
    while (endpoint != UX_NULL)
 80052a4:	b914      	cbnz	r4, 80052ac <_ux_host_stack_interface_instance_create+0xc>
 80052a6:	e007      	b.n	80052b8 <_ux_host_stack_interface_instance_create+0x18>
        
            /* An error occurred at the controller level.  */
            return(status);
        
        /* Move to next endpoint.  */
        endpoint =  endpoint -> ux_endpoint_next_endpoint;
 80052a8:	6a64      	ldr	r4, [r4, #36]	; 0x24
    while (endpoint != UX_NULL)
 80052aa:	b12c      	cbz	r4, 80052b8 <_ux_host_stack_interface_instance_create+0x18>
        status = _ux_host_stack_endpoint_instance_create(endpoint);
 80052ac:	4620      	mov	r0, r4
 80052ae:	f000 fa5b 	bl	8005768 <_ux_host_stack_endpoint_instance_create>
        if (status != UX_SUCCESS)
 80052b2:	2800      	cmp	r0, #0
 80052b4:	d0f8      	beq.n	80052a8 <_ux_host_stack_interface_instance_create+0x8>
    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_REGISTER(UX_TRACE_HOST_OBJECT_TYPE_INTERFACE, interface, 0, 0, 0);

    /* Return completion status.  */
    return(UX_SUCCESS); 
}
 80052b6:	bd10      	pop	{r4, pc}
    return(UX_SUCCESS); 
 80052b8:	2000      	movs	r0, #0
}
 80052ba:	bd10      	pop	{r4, pc}

080052bc <_ux_host_stack_interface_instance_delete>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_stack_interface_instance_delete(UX_INTERFACE *interface)
{
 80052bc:	b510      	push	{r4, lr}

    /* If trace is enabled, register this object.  */
    UX_TRACE_OBJECT_UNREGISTER(interface);

    /* Obtain the first endpoint for this alternate setting.  */
    endpoint =  interface -> ux_interface_first_endpoint;
 80052be:	6b84      	ldr	r4, [r0, #56]	; 0x38

    /* Loop to delete each endpoint.  */
    while (endpoint != UX_NULL)
 80052c0:	b12c      	cbz	r4, 80052ce <_ux_host_stack_interface_instance_delete+0x12>
    {

        /* Delete endpoint.  */
        _ux_host_stack_endpoint_instance_delete(endpoint);
 80052c2:	4620      	mov	r0, r4
 80052c4:	f7fe ff0a 	bl	80040dc <_ux_host_stack_endpoint_instance_delete>

        /* Move to next endpoint. */
        endpoint =  endpoint -> ux_endpoint_next_endpoint;
 80052c8:	6a64      	ldr	r4, [r4, #36]	; 0x24
    while (endpoint != UX_NULL)
 80052ca:	2c00      	cmp	r4, #0
 80052cc:	d1f9      	bne.n	80052c2 <_ux_host_stack_interface_instance_delete+0x6>
    }

    /* Return to caller.  */
    return; 
}
 80052ce:	bd10      	pop	{r4, pc}

080052d0 <_ux_host_stack_new_device_create>:
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_new_device_create(UX_HCD *hcd, UX_DEVICE *device_owner,
                                UINT port_index, UINT device_speed,
                                UINT port_max_power)
{
 80052d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80052d4:	461f      	mov	r7, r3
UX_ENDPOINT         *control_endpoint;


    /* Verify the number of devices attached to the HCD already. Normally a HCD
       can have up to 127 devices but that can be tailored.  */
    if (hcd -> ux_hcd_nb_devices > UX_MAX_USB_DEVICES)
 80052d6:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
{
 80052da:	f8dd a020 	ldr.w	sl, [sp, #32]
    if (hcd -> ux_hcd_nb_devices > UX_MAX_USB_DEVICES)
 80052de:	2b7f      	cmp	r3, #127	; 0x7f
 80052e0:	d855      	bhi.n	800538e <_ux_host_stack_new_device_create+0xbe>
 80052e2:	4605      	mov	r5, r0
 80052e4:	4689      	mov	r9, r1
 80052e6:	4690      	mov	r8, r2

        return(UX_TOO_MANY_DEVICES);
    }

    /* Get a new device container to store this new device.  */
    device =  _ux_host_stack_new_device_get();
 80052e8:	f000 f85e 	bl	80053a8 <_ux_host_stack_new_device_get>
    if (device == UX_NULL)
 80052ec:	4604      	mov	r4, r0
 80052ee:	2800      	cmp	r0, #0
 80052f0:	d04d      	beq.n	800538e <_ux_host_stack_new_device_create+0xbe>

        return(UX_TOO_MANY_DEVICES);
    }

    /* Increment the number of devices on this bus.  */
    hcd -> ux_hcd_nb_devices++;
 80052f2:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4

    /* At this stage the device is attached but not configured.
       we don't have to worry about power consumption yet.
       Initialize the device structure.  */
    device -> ux_device_handle =         (ULONG) (ALIGN_TYPE) device;
    device -> ux_device_state =          UX_DEVICE_ATTACHED;
 80052f6:	2601      	movs	r6, #1
    device -> ux_device_port_location =  port_index;
    device -> ux_device_max_power =      port_max_power;

    /* Create a semaphore for the device. This is to protect endpoint 0 mostly for OTG HNP polling. The initial count is 1 as
       a mutex mechanism.  */
    status =  _ux_utility_semaphore_create(&device -> ux_device_protection_semaphore, "ux_host_endpoint0_semaphore", 1);
 80052f8:	4929      	ldr	r1, [pc, #164]	; (80053a0 <_ux_host_stack_new_device_create+0xd0>)
    hcd -> ux_hcd_nb_devices++;
 80052fa:	4433      	add	r3, r6
    status =  _ux_utility_semaphore_create(&device -> ux_device_protection_semaphore, "ux_host_endpoint0_semaphore", 1);
 80052fc:	4632      	mov	r2, r6
    hcd -> ux_hcd_nb_devices++;
 80052fe:	f8c5 30a4 	str.w	r3, [r5, #164]	; 0xa4
    device -> ux_device_handle =         (ULONG) (ALIGN_TYPE) device;
 8005302:	6020      	str	r0, [r4, #0]
    status =  _ux_utility_semaphore_create(&device -> ux_device_protection_semaphore, "ux_host_endpoint0_semaphore", 1);
 8005304:	3024      	adds	r0, #36	; 0x24
    device -> ux_device_parent =         device_owner;
 8005306:	f8c0 9020 	str.w	r9, [r0, #32]
    device -> ux_device_hcd =            hcd;
 800530a:	6525      	str	r5, [r4, #80]	; 0x50
    device -> ux_device_max_power =      port_max_power;
 800530c:	f8c4 a018 	str.w	sl, [r4, #24]
    device -> ux_device_state =          UX_DEVICE_ATTACHED;
 8005310:	60a6      	str	r6, [r4, #8]
    device -> ux_device_port_location =  port_index;
 8005312:	e9c4 7804 	strd	r7, r8, [r4, #16]
    status =  _ux_utility_semaphore_create(&device -> ux_device_protection_semaphore, "ux_host_endpoint0_semaphore", 1);
 8005316:	f7fc feab 	bl	8002070 <_ux_utility_semaphore_create>

    /* Check semaphore creation.  */
    if (status != UX_SUCCESS)
 800531a:	bba8      	cbnz	r0, 8005388 <_ux_host_stack_new_device_create+0xb8>
        return(UX_SEMAPHORE_ERROR);
    }

    /* Initialize the default control endpoint permanently attached
       to the device.  */
    control_endpoint =                               &device -> ux_device_control_endpoint;
 800531c:	f104 0894 	add.w	r8, r4, #148	; 0x94
    control_endpoint -> ux_endpoint_interface =      UX_NULL;
    control_endpoint -> ux_endpoint_device =         device;
    control_endpoint -> ux_endpoint_transfer_request.ux_transfer_request_endpoint = control_endpoint;

    /* Create a semaphore for this endpoint to be attached to its transfer request.  */
    status =  _ux_utility_semaphore_create(&control_endpoint -> ux_endpoint_transfer_request.ux_transfer_request_semaphore, "ux_host_transfer_request_semaphore", 0);
 8005320:	4602      	mov	r2, r0
    control_endpoint -> ux_endpoint_device =         device;
 8005322:	f8c4 40c0 	str.w	r4, [r4, #192]	; 0xc0
    control_endpoint -> ux_endpoint =                (ULONG) (ALIGN_TYPE) control_endpoint;
 8005326:	f8c4 8094 	str.w	r8, [r4, #148]	; 0x94
    control_endpoint -> ux_endpoint_transfer_request.ux_transfer_request_endpoint = control_endpoint;
 800532a:	f8c4 80c8 	str.w	r8, [r4, #200]	; 0xc8
    status =  _ux_utility_semaphore_create(&control_endpoint -> ux_endpoint_transfer_request.ux_transfer_request_semaphore, "ux_host_transfer_request_semaphore", 0);
 800532e:	491d      	ldr	r1, [pc, #116]	; (80053a4 <_ux_host_stack_new_device_create+0xd4>)
    control_endpoint -> ux_endpoint_interface =      UX_NULL;
 8005330:	e9c4 002e 	strd	r0, r0, [r4, #184]	; 0xb8
    status =  _ux_utility_semaphore_create(&control_endpoint -> ux_endpoint_transfer_request.ux_transfer_request_semaphore, "ux_host_transfer_request_semaphore", 0);
 8005334:	f104 00ec 	add.w	r0, r4, #236	; 0xec
 8005338:	f7fc fe9a 	bl	8002070 <_ux_utility_semaphore_create>

    /* Check semaphore creation.  */
    if (status != UX_SUCCESS)
 800533c:	bb20      	cbnz	r0, 8005388 <_ux_host_stack_new_device_create+0xb8>
    /* If the device is running in high speed the default max packet size for the control endpoint is 64.
       All other speeds the size is 8.  */
    if (device_speed == UX_HIGH_SPEED_DEVICE)
        control_endpoint -> ux_endpoint_descriptor.wMaxPacketSize =  UX_DEFAULT_HS_MPS;
    else
        control_endpoint -> ux_endpoint_descriptor.wMaxPacketSize =  UX_DEFAULT_MPS;
 800533e:	2f02      	cmp	r7, #2

    /* Create the default control endpoint at the HCD level.  */
    status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_CREATE_ENDPOINT, (VOID *) control_endpoint);
 8005340:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
 8005344:	4628      	mov	r0, r5
 8005346:	4642      	mov	r2, r8
        control_endpoint -> ux_endpoint_descriptor.wMaxPacketSize =  UX_DEFAULT_MPS;
 8005348:	bf0c      	ite	eq
 800534a:	2540      	moveq	r5, #64	; 0x40
 800534c:	2508      	movne	r5, #8
    status =  hcd -> ux_hcd_entry_function(hcd, UX_HCD_CREATE_ENDPOINT, (VOID *) control_endpoint);
 800534e:	210e      	movs	r1, #14
 8005350:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
 8005354:	4798      	blx	r3
    if (status == UX_SUCCESS)
 8005356:	b9c0      	cbnz	r0, 800538a <_ux_host_stack_new_device_create+0xba>
    {

        /* Now control endpoint is ready, set state to running. */
        control_endpoint -> ux_endpoint_state =          UX_ENDPOINT_RUNNING;
 8005358:	f8c4 6098 	str.w	r6, [r4, #152]	; 0x98

        /* Set the address of the device. The first time a USB device is
           accessed, it responds to the address 0. We need to change the address
           to a free device address between 1 and 127 ASAP.  */
        status =  _ux_host_stack_device_address_set(device);
 800535c:	4620      	mov	r0, r4
 800535e:	f000 f93f 	bl	80055e0 <_ux_host_stack_device_address_set>
        if (status == UX_SUCCESS)
 8005362:	b990      	cbnz	r0, 800538a <_ux_host_stack_new_device_create+0xba>
        {

            /* Get the device descriptor.  */
            status =  _ux_host_stack_device_descriptor_read(device);
 8005364:	4620      	mov	r0, r4
 8005366:	f000 f99f 	bl	80056a8 <_ux_host_stack_device_descriptor_read>
            if (status == UX_SUCCESS)
 800536a:	b970      	cbnz	r0, 800538a <_ux_host_stack_new_device_create+0xba>
            {

                /* Get the configuration descriptor(s) for the device
                   and parse all the configuration, interface, endpoints...  */
                status =  _ux_host_stack_configuration_enumerate(device);
 800536c:	4620      	mov	r0, r4
 800536e:	f000 f8cd 	bl	800550c <_ux_host_stack_configuration_enumerate>
    }

    /* Check the status of the previous operations. If there was an
       error during any of the phases, the device resources must be
       freed based on if we want to retry.  */
    if (status == UX_SUCCESS)
 8005372:	b950      	cbnz	r0, 800538a <_ux_host_stack_new_device_create+0xba>

        /* The device, configuration(s), interface(s), endpoint(s) are
           now in order for this device to work. No configuration is set
           yet. First we need to find a class driver that wants to own
           it. There is no need to have an orphan device in a configured state.   */
        status =  _ux_host_stack_class_device_scan(device);
 8005374:	4620      	mov	r0, r4
 8005376:	f000 f841 	bl	80053fc <_ux_host_stack_class_device_scan>
        if (status == UX_NO_CLASS_MATCH)
 800537a:	2857      	cmp	r0, #87	; 0x57
 800537c:	d105      	bne.n	800538a <_ux_host_stack_new_device_create+0xba>
        {

            status =  _ux_host_stack_class_interface_scan(device);
 800537e:	4620      	mov	r0, r4
    }

    /* Return status. If there's an error, device resources that have been 
       allocated until this point should be freed by the caller via _ux_host_stack_device_resources_free.  */
    return(status);
}
 8005380:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
            status =  _ux_host_stack_class_interface_scan(device);
 8005384:	f000 b870 	b.w	8005468 <_ux_host_stack_class_interface_scan>
        return(UX_SEMAPHORE_ERROR);
 8005388:	2015      	movs	r0, #21
}
 800538a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_TOO_MANY_DEVICES);
 800538e:	2211      	movs	r2, #17
 8005390:	2104      	movs	r1, #4
 8005392:	2002      	movs	r0, #2
 8005394:	f7fc fc34 	bl	8001c00 <_ux_system_error_handler>
        return(UX_TOO_MANY_DEVICES);
 8005398:	2011      	movs	r0, #17
}
 800539a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800539e:	bf00      	nop
 80053a0:	0800de00 	.word	0x0800de00
 80053a4:	0800de1c 	.word	0x0800de1c

080053a8 <_ux_host_stack_new_device_get>:
ULONG           container_index;
UX_DEVICE       *device;
    

    /* Start with the first device.  */
    device =  _ux_system_host -> ux_system_host_device_array;    
 80053a8:	4b10      	ldr	r3, [pc, #64]	; (80053ec <_ux_host_stack_new_device_get+0x44>)
 80053aa:	681b      	ldr	r3, [r3, #0]
{
 80053ac:	b510      	push	{r4, lr}
    device =  _ux_system_host -> ux_system_host_device_array;    
 80053ae:	e9d3 4106 	ldrd	r4, r1, [r3, #24]

    /* Reset the container index.  */
    container_index =  0;

    /* Search the list until the end.  */
    while (container_index++ < _ux_system_host -> ux_system_host_max_devices)
 80053b2:	b1c1      	cbz	r1, 80053e6 <_ux_host_stack_new_device_get+0x3e>
    {

        /* Until we have found an unused entry.  */
        if (device -> ux_device_handle == UX_UNUSED)
 80053b4:	6823      	ldr	r3, [r4, #0]
 80053b6:	b163      	cbz	r3, 80053d2 <_ux_host_stack_new_device_get+0x2a>
 80053b8:	3101      	adds	r1, #1
    while (container_index++ < _ux_system_host -> ux_system_host_max_devices)
 80053ba:	2301      	movs	r3, #1
 80053bc:	e001      	b.n	80053c2 <_ux_host_stack_new_device_get+0x1a>
        if (device -> ux_device_handle == UX_UNUSED)
 80053be:	6822      	ldr	r2, [r4, #0]
 80053c0:	b13a      	cbz	r2, 80053d2 <_ux_host_stack_new_device_get+0x2a>
    while (container_index++ < _ux_system_host -> ux_system_host_max_devices)
 80053c2:	3301      	adds	r3, #1
            /* Return the device pointer.  */
            return(device);
        }

        /* Move to the next device entry.  */
        device++;
 80053c4:	f504 74b6 	add.w	r4, r4, #364	; 0x16c
    while (container_index++ < _ux_system_host -> ux_system_host_max_devices)
 80053c8:	428b      	cmp	r3, r1
 80053ca:	d1f8      	bne.n	80053be <_ux_host_stack_new_device_get+0x16>
    }

    /* No unused devices, return NULL.  */
    return(UX_NULL);
 80053cc:	2400      	movs	r4, #0
}
 80053ce:	4620      	mov	r0, r4
 80053d0:	bd10      	pop	{r4, pc}
            _ux_utility_memory_set(device, 0, sizeof(UX_DEVICE));
 80053d2:	4620      	mov	r0, r4
 80053d4:	f44f 72b6 	mov.w	r2, #364	; 0x16c
 80053d8:	2100      	movs	r1, #0
 80053da:	f7fc fe27 	bl	800202c <_ux_utility_memory_set>
            device -> ux_device_handle =  UX_USED;
 80053de:	2301      	movs	r3, #1
}
 80053e0:	4620      	mov	r0, r4
            device -> ux_device_handle =  UX_USED;
 80053e2:	6023      	str	r3, [r4, #0]
}
 80053e4:	bd10      	pop	{r4, pc}
    return(UX_NULL);
 80053e6:	460c      	mov	r4, r1
 80053e8:	e7f1      	b.n	80053ce <_ux_host_stack_new_device_get+0x26>
 80053ea:	bf00      	nop
 80053ec:	20000db8 	.word	0x20000db8

080053f0 <_ux_utility_long_get_big_endian>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
ULONG  _ux_utility_long_get_big_endian(UCHAR * address)
{
 80053f0:	6800      	ldr	r0, [r0, #0]
    value |=  (ULONG) ((*address++) << 8);
    value |=  (ULONG) *address;

    /* Return 32-bit value.  */
    return(value);
}
 80053f2:	ba00      	rev	r0, r0
 80053f4:	4770      	bx	lr
 80053f6:	bf00      	nop

080053f8 <_ux_utility_thread_relinquish>:
/**************************************************************************/
VOID  _ux_utility_thread_relinquish(VOID)
{

    /* Call ThreadX to relinquish a USBX thread.  */
    tx_thread_relinquish();
 80053f8:	f007 bf20 	b.w	800d23c <_txe_thread_relinquish>

080053fc <_ux_host_stack_class_device_scan>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_class_device_scan(UX_DEVICE *device)
{
 80053fc:	b570      	push	{r4, r5, r6, lr}
 80053fe:	4604      	mov	r4, r0
 8005400:	b08e      	sub	sp, #56	; 0x38
UX_HOST_CLASS_COMMAND       class_command;

    /* Perform the command initialization.  */
    class_command.ux_host_class_command_request      =   UX_HOST_CLASS_COMMAND_QUERY;
    class_command.ux_host_class_command_container    =   (VOID *) device;
    class_command.ux_host_class_command_vid          =   device -> ux_device_descriptor.idVendor;
 8005402:	6f81      	ldr	r1, [r0, #120]	; 0x78
    class_command.ux_host_class_command_request      =   UX_HOST_CLASS_COMMAND_QUERY;
 8005404:	2501      	movs	r5, #1
    class_command.ux_host_class_command_pid          =   device -> ux_device_descriptor.idProduct;
 8005406:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    class_command.ux_host_class_command_class        =   device -> ux_device_descriptor.bDeviceClass;
    class_command.ux_host_class_command_subclass     =   device -> ux_device_descriptor.bDeviceSubClass;
    class_command.ux_host_class_command_subclass     =   device -> ux_device_descriptor.bDeviceSubClass;
    class_command.ux_host_class_command_protocol     =   device -> ux_device_descriptor.bDeviceProtocol;
    class_command.ux_host_class_command_iad_class    =   0;
 8005408:	2300      	movs	r3, #0
    class_command.ux_host_class_command_iad_subclass =   0;
    class_command.ux_host_class_command_iad_protocol =   0;

    /* We start with the PID/VID for this device.  */
    class_command.ux_host_class_command_usage =  UX_HOST_CLASS_COMMAND_USAGE_PIDVID;
    class =  _ux_host_stack_class_call(&class_command);
 800540a:	a801      	add	r0, sp, #4
    class_command.ux_host_class_command_container    =   (VOID *) device;
 800540c:	9402      	str	r4, [sp, #8]
    class_command.ux_host_class_command_request      =   UX_HOST_CLASS_COMMAND_QUERY;
 800540e:	9501      	str	r5, [sp, #4]
    class_command.ux_host_class_command_usage =  UX_HOST_CLASS_COMMAND_USAGE_PIDVID;
 8005410:	9504      	str	r5, [sp, #16]
    class_command.ux_host_class_command_iad_protocol =   0;
 8005412:	930c      	str	r3, [sp, #48]	; 0x30
    class_command.ux_host_class_command_pid          =   device -> ux_device_descriptor.idProduct;
 8005414:	e9cd 2105 	strd	r2, r1, [sp, #20]
    class_command.ux_host_class_command_subclass     =   device -> ux_device_descriptor.bDeviceSubClass;
 8005418:	e9d4 121a 	ldrd	r1, r2, [r4, #104]	; 0x68
    class_command.ux_host_class_command_iad_subclass =   0;
 800541c:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
    class_command.ux_host_class_command_subclass     =   device -> ux_device_descriptor.bDeviceSubClass;
 8005420:	e9cd 1207 	strd	r1, r2, [sp, #28]
    class_command.ux_host_class_command_protocol     =   device -> ux_device_descriptor.bDeviceProtocol;
 8005424:	6f22      	ldr	r2, [r4, #112]	; 0x70
 8005426:	9209      	str	r2, [sp, #36]	; 0x24
    class =  _ux_host_stack_class_call(&class_command);
 8005428:	f000 fb48 	bl	8005abc <_ux_host_stack_class_call>

    /* On return, either we have found a class or the device is still an orphan.  */
    if (class != UX_NULL)
 800542c:	b148      	cbz	r0, 8005442 <_ux_host_stack_class_device_scan+0x46>
 800542e:	4603      	mov	r3, r0
    {

        device -> ux_device_class =  class;
        class_command.ux_host_class_command_class_ptr =  class;
        class_command.ux_host_class_command_request =  UX_HOST_CLASS_COMMAND_ACTIVATE;
 8005430:	2202      	movs	r2, #2
        device -> ux_device_class =  class;
 8005432:	64a0      	str	r0, [r4, #72]	; 0x48
        class_command.ux_host_class_command_class_ptr =  class;
 8005434:	900d      	str	r0, [sp, #52]	; 0x34
        status =  device -> ux_device_class ->  ux_host_class_entry_function(&class_command);
 8005436:	a801      	add	r0, sp, #4
 8005438:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        class_command.ux_host_class_command_request =  UX_HOST_CLASS_COMMAND_ACTIVATE;
 800543a:	9201      	str	r2, [sp, #4]
        status =  device -> ux_device_class ->  ux_host_class_entry_function(&class_command);
 800543c:	4798      	blx	r3
        return(status);
    }

    /* Return an error.  */
    return(UX_NO_CLASS_MATCH);
}
 800543e:	b00e      	add	sp, #56	; 0x38
 8005440:	bd70      	pop	{r4, r5, r6, pc}
    class_command.ux_host_class_command_usage        =   UX_HOST_CLASS_COMMAND_USAGE_CSP;
 8005442:	2602      	movs	r6, #2
    class =  _ux_host_stack_class_call(&class_command);
 8005444:	a801      	add	r0, sp, #4
    class_command.ux_host_class_command_container    =   (VOID *) device;
 8005446:	e9cd 5401 	strd	r5, r4, [sp, #4]
    class_command.ux_host_class_command_usage        =   UX_HOST_CLASS_COMMAND_USAGE_CSP;
 800544a:	9604      	str	r6, [sp, #16]
    class =  _ux_host_stack_class_call(&class_command);
 800544c:	f000 fb36 	bl	8005abc <_ux_host_stack_class_call>
    if (class != UX_NULL)
 8005450:	4603      	mov	r3, r0
 8005452:	b130      	cbz	r0, 8005462 <_ux_host_stack_class_device_scan+0x66>
        device -> ux_device_class =  class;
 8005454:	64a0      	str	r0, [r4, #72]	; 0x48
        status =  device -> ux_device_class ->  ux_host_class_entry_function(&class_command);
 8005456:	a801      	add	r0, sp, #4
        class_command.ux_host_class_command_class_ptr =  class;
 8005458:	930d      	str	r3, [sp, #52]	; 0x34
        class_command.ux_host_class_command_request =  UX_HOST_CLASS_COMMAND_ACTIVATE;
 800545a:	9601      	str	r6, [sp, #4]
        status =  device -> ux_device_class ->  ux_host_class_entry_function(&class_command);
 800545c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800545e:	4798      	blx	r3
        return(status);
 8005460:	e7ed      	b.n	800543e <_ux_host_stack_class_device_scan+0x42>
    return(UX_NO_CLASS_MATCH);
 8005462:	2057      	movs	r0, #87	; 0x57
 8005464:	e7eb      	b.n	800543e <_ux_host_stack_class_device_scan+0x42>
 8005466:	bf00      	nop

08005468 <_ux_host_stack_class_interface_scan>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_class_interface_scan(UX_DEVICE *device)
{
 8005468:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    /* Initialize class owners to 0.  */
    nb_class_owners =  0;

    /* Get the 1st and only configuration.  If the device has multiple
       configurations, we simply use the first one as default. */
    configuration =  device -> ux_device_first_configuration;
 800546c:	6d46      	ldr	r6, [r0, #84]	; 0x54
{
 800546e:	b08e      	sub	sp, #56	; 0x38
    if (configuration == UX_NULL)
 8005470:	2e00      	cmp	r6, #0
 8005472:	d045      	beq.n	8005500 <_ux_host_stack_class_interface_scan+0x98>
        return(UX_ERROR);

    /* Get the first interface container for this configuration.  */
    interface =  configuration -> ux_configuration_first_interface;
 8005474:	6af4      	ldr	r4, [r6, #44]	; 0x2c

    /* We now scan all the alternate settings 0 for each of the interfaces.  */
    while (interface !=  UX_NULL)
 8005476:	2c00      	cmp	r4, #0
 8005478:	d03d      	beq.n	80054f6 <_ux_host_stack_class_interface_scan+0x8e>
    nb_class_owners =  0;
 800547a:	2500      	movs	r5, #0
        if(interface -> ux_interface_descriptor.bAlternateSetting == 0)
        {

            /* We have a default interface for this configuration. Call each class  
               with the class\subclass\protocol.  We include the IAD for the cdc classes.  */
            class_command.ux_host_class_command_request      =   UX_HOST_CLASS_COMMAND_QUERY;
 800547c:	f04f 0801 	mov.w	r8, #1
            class_command.ux_host_class_command_container    =   (VOID *)interface;
            class_command.ux_host_class_command_usage        =   UX_HOST_CLASS_COMMAND_USAGE_CSP;
 8005480:	2702      	movs	r7, #2
 8005482:	e001      	b.n	8005488 <_ux_host_stack_class_interface_scan+0x20>
                interface -> ux_interface_class =  class;
            }
        }

        /* point to the next interface until end of the list.  */
        interface =  interface -> ux_interface_next_interface; 
 8005484:	6be4      	ldr	r4, [r4, #60]	; 0x3c
    while (interface !=  UX_NULL)
 8005486:	b1dc      	cbz	r4, 80054c0 <_ux_host_stack_class_interface_scan+0x58>
        if(interface -> ux_interface_descriptor.bAlternateSetting == 0)
 8005488:	69a3      	ldr	r3, [r4, #24]
 800548a:	2b00      	cmp	r3, #0
 800548c:	d1fa      	bne.n	8005484 <_ux_host_stack_class_interface_scan+0x1c>
            class_command.ux_host_class_command_class        =   interface -> ux_interface_descriptor.bInterfaceClass;
 800548e:	6a22      	ldr	r2, [r4, #32]
            class =  _ux_host_stack_class_call(&class_command);
 8005490:	a801      	add	r0, sp, #4
            class_command.ux_host_class_command_subclass     =   interface -> ux_interface_descriptor.bInterfaceSubClass;
 8005492:	6a63      	ldr	r3, [r4, #36]	; 0x24
            class_command.ux_host_class_command_class        =   interface -> ux_interface_descriptor.bInterfaceClass;
 8005494:	9207      	str	r2, [sp, #28]
            class_command.ux_host_class_command_subclass     =   interface -> ux_interface_descriptor.bInterfaceSubClass;
 8005496:	9308      	str	r3, [sp, #32]
            class_command.ux_host_class_command_protocol     =   interface -> ux_interface_descriptor.bInterfaceProtocol;
 8005498:	6aa2      	ldr	r2, [r4, #40]	; 0x28
            class_command.ux_host_class_command_iad_class    =   interface -> ux_interface_iad_class   ;
 800549a:	6c63      	ldr	r3, [r4, #68]	; 0x44
            class_command.ux_host_class_command_protocol     =   interface -> ux_interface_descriptor.bInterfaceProtocol;
 800549c:	9209      	str	r2, [sp, #36]	; 0x24
            class_command.ux_host_class_command_iad_class    =   interface -> ux_interface_iad_class   ;
 800549e:	930a      	str	r3, [sp, #40]	; 0x28
            class_command.ux_host_class_command_iad_subclass =   interface -> ux_interface_iad_subclass;
 80054a0:	6ca2      	ldr	r2, [r4, #72]	; 0x48
            class_command.ux_host_class_command_iad_protocol =   interface -> ux_interface_iad_protocol;
 80054a2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
            class_command.ux_host_class_command_usage        =   UX_HOST_CLASS_COMMAND_USAGE_CSP;
 80054a4:	9704      	str	r7, [sp, #16]
            class_command.ux_host_class_command_container    =   (VOID *)interface;
 80054a6:	e9cd 8401 	strd	r8, r4, [sp, #4]
            class_command.ux_host_class_command_iad_protocol =   interface -> ux_interface_iad_protocol;
 80054aa:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
            class =  _ux_host_stack_class_call(&class_command);
 80054ae:	f000 fb05 	bl	8005abc <_ux_host_stack_class_call>
            if (class != UX_NULL)
 80054b2:	2800      	cmp	r0, #0
 80054b4:	d0e6      	beq.n	8005484 <_ux_host_stack_class_interface_scan+0x1c>
                interface -> ux_interface_class =  class;
 80054b6:	6320      	str	r0, [r4, #48]	; 0x30
                nb_class_owners++;
 80054b8:	3501      	adds	r5, #1
        interface =  interface -> ux_interface_next_interface; 
 80054ba:	6be4      	ldr	r4, [r4, #60]	; 0x3c
    while (interface !=  UX_NULL)
 80054bc:	2c00      	cmp	r4, #0
 80054be:	d1e3      	bne.n	8005488 <_ux_host_stack_class_interface_scan+0x20>

    /* Assume no classes.  */
    status = UX_NO_CLASS_MATCH;

    /* Check the number of class owner found.  */
    if (nb_class_owners != 0)
 80054c0:	b1cd      	cbz	r5, 80054f6 <_ux_host_stack_class_interface_scan+0x8e>
    {

        /* If we have found one or more classes for any of the interfaces,
           we can safely do a SET_CONFIGURATION of the device.  */
        status =  _ux_host_stack_device_configuration_select(configuration);
 80054c2:	4630      	mov	r0, r6
 80054c4:	f7fe fd16 	bl	8003ef4 <_ux_host_stack_device_configuration_select>

        /* Check the completion status.  */
        if (status == UX_SUCCESS)
 80054c8:	4603      	mov	r3, r0
 80054ca:	b9a8      	cbnz	r0, 80054f8 <_ux_host_stack_class_interface_scan+0x90>
        {

            /* The device is in the CONFIGURED state, we have to call each of the classes 
               again with an ACTIVATE signal.  */
            interface =  configuration -> ux_configuration_first_interface;
 80054cc:	6af4      	ldr	r4, [r6, #44]	; 0x2c
    
            while (interface != UX_NULL)
 80054ce:	b19c      	cbz	r4, 80054f8 <_ux_host_stack_class_interface_scan+0x90>
                if (interface -> ux_interface_descriptor.bAlternateSetting == 0)
                {
    
                    /* We have found the default interface. If this interface is owned,
                       activate its class.  */
                    class_command.ux_host_class_command_request =    UX_HOST_CLASS_COMMAND_ACTIVATE;
 80054d0:	2502      	movs	r5, #2
                if (interface -> ux_interface_descriptor.bAlternateSetting == 0)
 80054d2:	69a2      	ldr	r2, [r4, #24]
    
                        /* Save the class in the command container */
                        class_command.ux_host_class_command_class_ptr =  interface -> ux_interface_class;
                        
                        /* Send the ACTIVATE command to the class */
                        status =  interface -> ux_interface_class -> ux_host_class_entry_function(&class_command);
 80054d4:	a801      	add	r0, sp, #4
                if (interface -> ux_interface_descriptor.bAlternateSetting == 0)
 80054d6:	b93a      	cbnz	r2, 80054e8 <_ux_host_stack_class_interface_scan+0x80>
                    if (interface -> ux_interface_class != UX_NULL)
 80054d8:	6b22      	ldr	r2, [r4, #48]	; 0x30
                    class_command.ux_host_class_command_container =  (VOID *) interface;
 80054da:	e9cd 5401 	strd	r5, r4, [sp, #4]
                    if (interface -> ux_interface_class != UX_NULL)
 80054de:	b11a      	cbz	r2, 80054e8 <_ux_host_stack_class_interface_scan+0x80>
                        status =  interface -> ux_interface_class -> ux_host_class_entry_function(&class_command);
 80054e0:	6c53      	ldr	r3, [r2, #68]	; 0x44
                        class_command.ux_host_class_command_class_ptr =  interface -> ux_interface_class;
 80054e2:	920d      	str	r2, [sp, #52]	; 0x34
                        status =  interface -> ux_interface_class -> ux_host_class_entry_function(&class_command);
 80054e4:	4798      	blx	r3
 80054e6:	4603      	mov	r3, r0
    
                    }
                }
    
                /* Point to the next interface until end of the list.  */
                interface =  interface -> ux_interface_next_interface;
 80054e8:	6be4      	ldr	r4, [r4, #60]	; 0x3c
            while (interface != UX_NULL)
 80054ea:	2c00      	cmp	r4, #0
 80054ec:	d1f1      	bne.n	80054d2 <_ux_host_stack_class_interface_scan+0x6a>
        }
    }
    
    /* Return operation result.  */
    return(status);
}
 80054ee:	4618      	mov	r0, r3
 80054f0:	b00e      	add	sp, #56	; 0x38
 80054f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    status = UX_NO_CLASS_MATCH;
 80054f6:	2357      	movs	r3, #87	; 0x57
}
 80054f8:	4618      	mov	r0, r3
 80054fa:	b00e      	add	sp, #56	; 0x38
 80054fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return(UX_ERROR);
 8005500:	23ff      	movs	r3, #255	; 0xff
}
 8005502:	4618      	mov	r0, r3
 8005504:	b00e      	add	sp, #56	; 0x38
 8005506:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800550a:	bf00      	nop

0800550c <_ux_host_stack_configuration_enumerate>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_configuration_enumerate(UX_DEVICE *device)
{
 800550c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    /* Need to allocate memory for the configuration descriptor the first time we read 
       only the configuration descriptor when we have the configuration descriptor, we have 
       the length of the entire configuration\interface\endpoint descriptors.  */
    descriptor =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_CONFIGURATION_DESCRIPTOR_LENGTH);
 8005510:	2209      	movs	r2, #9
{
 8005512:	4604      	mov	r4, r0
    descriptor =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_CONFIGURATION_DESCRIPTOR_LENGTH);
 8005514:	2101      	movs	r1, #1
 8005516:	f04f 30ff 	mov.w	r0, #4294967295
 800551a:	f7fc fbe7 	bl	8001cec <_ux_utility_memory_allocate>
    if (descriptor == UX_NULL)
 800551e:	2800      	cmp	r0, #0
 8005520:	d053      	beq.n	80055ca <_ux_host_stack_configuration_enumerate+0xbe>
        return(UX_MEMORY_INSUFFICIENT);

    /* There maybe multiple configurations for this device.  */
    nb_configurations =  device -> ux_device_descriptor.bNumConfigurations;
 8005522:	f8d4 8090 	ldr.w	r8, [r4, #144]	; 0x90
 8005526:	4607      	mov	r7, r0

    /* Parse all the configurations attached to the device. We start with the first index. 
       The index and the actual configuration value may be different according to the USB specification!  */
    for (configuration_index = 0; configuration_index < nb_configurations; configuration_index++)
 8005528:	f1b8 0f00 	cmp.w	r8, #0
 800552c:	d052      	beq.n	80055d4 <_ux_host_stack_configuration_enumerate+0xc8>
 800552e:	f104 09c4 	add.w	r9, r4, #196	; 0xc4
 8005532:	2600      	movs	r6, #0

                /* This configuration must be linked to the device.  */
                _ux_host_stack_new_configuration_create(device, configuration);
                
                /* The descriptor is in a packed format, parse it locally.  */      
                _ux_utility_descriptor_parse(descriptor, _ux_system_configuration_descriptor_structure,
 8005534:	f8df b0a4 	ldr.w	fp, [pc, #164]	; 80055dc <_ux_host_stack_configuration_enumerate+0xd0>
 8005538:	e002      	b.n	8005540 <_ux_host_stack_configuration_enumerate+0x34>
    for (configuration_index = 0; configuration_index < nb_configurations; configuration_index++)
 800553a:	3601      	adds	r6, #1
 800553c:	45b0      	cmp	r8, r6
 800553e:	d034      	beq.n	80055aa <_ux_host_stack_configuration_enumerate+0x9e>
        transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 8005540:	2180      	movs	r1, #128	; 0x80
        transfer_request -> ux_transfer_request_value =             configuration_index | (UINT)(UX_CONFIGURATION_DESCRIPTOR_ITEM << 8);
 8005542:	f446 7200 	orr.w	r2, r6, #512	; 0x200
        transfer_request -> ux_transfer_request_index =             0;
 8005546:	2300      	movs	r3, #0
        transfer_request -> ux_transfer_request_requested_length =  UX_CONFIGURATION_DESCRIPTOR_LENGTH;
 8005548:	2009      	movs	r0, #9
        transfer_request -> ux_transfer_request_function =          UX_GET_DESCRIPTOR;
 800554a:	2506      	movs	r5, #6
        transfer_request -> ux_transfer_request_data_pointer =      descriptor;
 800554c:	f8c4 70cc 	str.w	r7, [r4, #204]	; 0xcc
        transfer_request -> ux_transfer_request_requested_length =  UX_CONFIGURATION_DESCRIPTOR_LENGTH;
 8005550:	f8c4 00d0 	str.w	r0, [r4, #208]	; 0xd0
        status =  _ux_host_stack_transfer_request(transfer_request);
 8005554:	4648      	mov	r0, r9
        transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 8005556:	e9c4 1536 	strd	r1, r5, [r4, #216]	; 0xd8
        transfer_request -> ux_transfer_request_index =             0;
 800555a:	e9c4 2338 	strd	r2, r3, [r4, #224]	; 0xe0
        status =  _ux_host_stack_transfer_request(transfer_request);
 800555e:	f7fe ff47 	bl	80043f0 <_ux_host_stack_transfer_request>
            configuration =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_CONFIGURATION));
 8005562:	2244      	movs	r2, #68	; 0x44
        if ((status == UX_SUCCESS) && (transfer_request -> ux_transfer_request_actual_length == UX_CONFIGURATION_DESCRIPTOR_LENGTH))
 8005564:	4601      	mov	r1, r0
 8005566:	bb30      	cbnz	r0, 80055b6 <_ux_host_stack_configuration_enumerate+0xaa>
 8005568:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 800556c:	2b09      	cmp	r3, #9
 800556e:	d122      	bne.n	80055b6 <_ux_host_stack_configuration_enumerate+0xaa>
            configuration =  _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_CONFIGURATION));
 8005570:	f7fc fbbc 	bl	8001cec <_ux_utility_memory_allocate>
            if (configuration != UX_NULL)
 8005574:	4605      	mov	r5, r0
 8005576:	b328      	cbz	r0, 80055c4 <_ux_host_stack_configuration_enumerate+0xb8>
                _ux_host_stack_new_configuration_create(device, configuration);
 8005578:	4601      	mov	r1, r0
 800557a:	4620      	mov	r0, r4
 800557c:	f000 f924 	bl	80057c8 <_ux_host_stack_new_configuration_create>
                _ux_utility_descriptor_parse(descriptor, _ux_system_configuration_descriptor_structure,
 8005580:	f105 030c 	add.w	r3, r5, #12
 8005584:	2208      	movs	r2, #8
 8005586:	4659      	mov	r1, fp
 8005588:	4638      	mov	r0, r7
 800558a:	f7fe ffa5 	bl	80044d8 <_ux_utility_descriptor_parse>
                                    UX_CONFIGURATION_DESCRIPTOR_ENTRIES, (UCHAR *) &configuration -> ux_configuration_descriptor);

                /* Parse the device descriptor so that we can retrieve the length 
                    of the entire configuration.  */
                status =  _ux_host_stack_configuration_descriptor_parse(device, configuration, configuration_index);
 800558e:	4632      	mov	r2, r6
 8005590:	4629      	mov	r1, r5
 8005592:	4620      	mov	r0, r4
 8005594:	f000 faae 	bl	8005af4 <_ux_host_stack_configuration_descriptor_parse>

                /* Check the completion status.  */
                if (status != UX_SUCCESS)
 8005598:	4682      	mov	sl, r0
 800559a:	2800      	cmp	r0, #0
 800559c:	d0cd      	beq.n	800553a <_ux_host_stack_configuration_enumerate+0x2e>
    for (configuration_index = 0; configuration_index < nb_configurations; configuration_index++)
 800559e:	3601      	adds	r6, #1
                {
                    /* Error, delete the configuration instance.  */
                    _ux_host_stack_configuration_instance_delete(configuration);
 80055a0:	4628      	mov	r0, r5
 80055a2:	f7ff fe4f 	bl	8005244 <_ux_host_stack_configuration_instance_delete>
    for (configuration_index = 0; configuration_index < nb_configurations; configuration_index++)
 80055a6:	45b0      	cmp	r8, r6
 80055a8:	d1ca      	bne.n	8005540 <_ux_host_stack_configuration_enumerate+0x34>
        }            
        
    }

    /* Free all used resources.  */
    _ux_utility_memory_free(descriptor);
 80055aa:	4638      	mov	r0, r7
 80055ac:	f7fc fcb2 	bl	8001f14 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(status);             
}
 80055b0:	4650      	mov	r0, sl
 80055b2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_DESCRIPTOR_CORRUPTED);
 80055b6:	2242      	movs	r2, #66	; 0x42
 80055b8:	2104      	movs	r1, #4
 80055ba:	2002      	movs	r0, #2
            status =  UX_DESCRIPTOR_CORRUPTED;
 80055bc:	4692      	mov	sl, r2
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_DESCRIPTOR_CORRUPTED);
 80055be:	f7fc fb1f 	bl	8001c00 <_ux_system_error_handler>
            break;
 80055c2:	e7f2      	b.n	80055aa <_ux_host_stack_configuration_enumerate+0x9e>
                status =  UX_MEMORY_INSUFFICIENT;
 80055c4:	f04f 0a12 	mov.w	sl, #18
 80055c8:	e7ef      	b.n	80055aa <_ux_host_stack_configuration_enumerate+0x9e>
        return(UX_MEMORY_INSUFFICIENT);
 80055ca:	f04f 0a12 	mov.w	sl, #18
}
 80055ce:	4650      	mov	r0, sl
 80055d0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
UINT                status =  UX_ERROR;
 80055d4:	f04f 0aff 	mov.w	sl, #255	; 0xff
 80055d8:	e7e7      	b.n	80055aa <_ux_host_stack_configuration_enumerate+0x9e>
 80055da:	bf00      	nop
 80055dc:	200000bc 	.word	0x200000bc

080055e0 <_ux_host_stack_device_address_set>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_device_address_set(UX_DEVICE *device)
{
 80055e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

    /* Retrieve the transfer request pointer.  */
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    /* We need the HCD pointer as well.  */
    hcd =  device -> ux_device_hcd;
 80055e2:	6d06      	ldr	r6, [r0, #80]	; 0x50
{
 80055e4:	4604      	mov	r4, r0

    /* Calculate the new address of this device. We start with address 1.  */
    device_address =  1;
 80055e6:	2501      	movs	r5, #1
    for (address_byte_index = 0; address_byte_index < 16; address_byte_index++)
 80055e8:	2200      	movs	r2, #0
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;
 80055ea:	30c4      	adds	r0, #196	; 0xc4
 80055ec:	f106 013f 	add.w	r1, r6, #63	; 0x3f
    {

        /* Get the address mask byte.  */
        device_address_byte =  hcd -> ux_hcd_address[address_byte_index];
 80055f0:	f811 3f01 	ldrb.w	r3, [r1, #1]!
                    return(status);
                }
            }

            /* This address was already taken, increment to the next address.  */
            device_address++;
 80055f4:	f105 0708 	add.w	r7, r5, #8
            if ((device_address_byte & (1 << address_bit_index)) == 0)
 80055f8:	f013 0f01 	tst.w	r3, #1
 80055fc:	d01b      	beq.n	8005636 <_ux_host_stack_device_address_set+0x56>
 80055fe:	f013 0f02 	tst.w	r3, #2
 8005602:	d034      	beq.n	800566e <_ux_host_stack_device_address_set+0x8e>
 8005604:	f013 0f04 	tst.w	r3, #4
 8005608:	d035      	beq.n	8005676 <_ux_host_stack_device_address_set+0x96>
 800560a:	f013 0f08 	tst.w	r3, #8
 800560e:	d036      	beq.n	800567e <_ux_host_stack_device_address_set+0x9e>
 8005610:	f013 0f10 	tst.w	r3, #16
 8005614:	d037      	beq.n	8005686 <_ux_host_stack_device_address_set+0xa6>
 8005616:	f013 0f20 	tst.w	r3, #32
 800561a:	d038      	beq.n	800568e <_ux_host_stack_device_address_set+0xae>
 800561c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8005620:	d039      	beq.n	8005696 <_ux_host_stack_device_address_set+0xb6>
 8005622:	ea5f 1cd3 	movs.w	ip, r3, lsr #7
 8005626:	d03a      	beq.n	800569e <_ux_host_stack_device_address_set+0xbe>
    for (address_byte_index = 0; address_byte_index < 16; address_byte_index++)
 8005628:	3201      	adds	r2, #1
            device_address++;
 800562a:	b2bd      	uxth	r5, r7
    for (address_byte_index = 0; address_byte_index < 16; address_byte_index++)
 800562c:	2a10      	cmp	r2, #16
 800562e:	d1df      	bne.n	80055f0 <_ux_host_stack_device_address_set+0x10>
        }       
    }

    /* We should never get here!  */
    return(UX_ERROR);
 8005630:	24ff      	movs	r4, #255	; 0xff
}
 8005632:	4620      	mov	r0, r4
 8005634:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if ((device_address_byte & (1 << address_bit_index)) == 0)
 8005636:	2101      	movs	r1, #1
                hcd -> ux_hcd_address[address_byte_index] =  device_address_byte;
 8005638:	4432      	add	r2, r6
                device_address_byte = (UCHAR)((UCHAR)device_address_byte | (UCHAR)(1 << address_bit_index));
 800563a:	430b      	orrs	r3, r1
                transfer_request -> ux_transfer_request_function =          UX_SET_ADDRESS;
 800563c:	2605      	movs	r6, #5
                transfer_request -> ux_transfer_request_data_pointer =      UX_NULL;
 800563e:	2100      	movs	r1, #0
                hcd -> ux_hcd_address[address_byte_index] =  device_address_byte;
 8005640:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
                transfer_request -> ux_transfer_request_value =             device_address;
 8005644:	f8c4 50e0 	str.w	r5, [r4, #224]	; 0xe0
                transfer_request -> ux_transfer_request_type =              UX_REQUEST_OUT | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 8005648:	f8c4 10d8 	str.w	r1, [r4, #216]	; 0xd8
                transfer_request -> ux_transfer_request_index =             0;
 800564c:	f8c4 10e4 	str.w	r1, [r4, #228]	; 0xe4
                transfer_request -> ux_transfer_request_function =          UX_SET_ADDRESS;
 8005650:	f8c4 60dc 	str.w	r6, [r4, #220]	; 0xdc
                transfer_request -> ux_transfer_request_requested_length =  0;
 8005654:	e9c4 1133 	strd	r1, r1, [r4, #204]	; 0xcc
                status =  _ux_host_stack_transfer_request(transfer_request);
 8005658:	f7fe feca 	bl	80043f0 <_ux_host_stack_transfer_request>
                device -> ux_device_address =  (ULONG) device_address;
 800565c:	60e5      	str	r5, [r4, #12]
                if (status == UX_SUCCESS)
 800565e:	4604      	mov	r4, r0
 8005660:	2800      	cmp	r0, #0
 8005662:	d1e6      	bne.n	8005632 <_ux_host_stack_device_address_set+0x52>
                    _ux_utility_delay_ms(UX_DEVICE_ADDRESS_SET_WAIT);
 8005664:	2032      	movs	r0, #50	; 0x32
 8005666:	f7fc fb35 	bl	8001cd4 <_ux_utility_delay_ms>
}
 800566a:	4620      	mov	r0, r4
 800566c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            device_address++;
 800566e:	3501      	adds	r5, #1
 8005670:	2102      	movs	r1, #2
 8005672:	b2ad      	uxth	r5, r5
 8005674:	e7e0      	b.n	8005638 <_ux_host_stack_device_address_set+0x58>
 8005676:	3502      	adds	r5, #2
 8005678:	2104      	movs	r1, #4
 800567a:	b2ad      	uxth	r5, r5
 800567c:	e7dc      	b.n	8005638 <_ux_host_stack_device_address_set+0x58>
 800567e:	3503      	adds	r5, #3
 8005680:	2108      	movs	r1, #8
 8005682:	b2ad      	uxth	r5, r5
 8005684:	e7d8      	b.n	8005638 <_ux_host_stack_device_address_set+0x58>
 8005686:	3504      	adds	r5, #4
 8005688:	2110      	movs	r1, #16
 800568a:	b2ad      	uxth	r5, r5
 800568c:	e7d4      	b.n	8005638 <_ux_host_stack_device_address_set+0x58>
 800568e:	3505      	adds	r5, #5
 8005690:	2120      	movs	r1, #32
 8005692:	b2ad      	uxth	r5, r5
 8005694:	e7d0      	b.n	8005638 <_ux_host_stack_device_address_set+0x58>
 8005696:	3506      	adds	r5, #6
 8005698:	2140      	movs	r1, #64	; 0x40
 800569a:	b2ad      	uxth	r5, r5
 800569c:	e7cc      	b.n	8005638 <_ux_host_stack_device_address_set+0x58>
 800569e:	3507      	adds	r5, #7
 80056a0:	2180      	movs	r1, #128	; 0x80
 80056a2:	b2ad      	uxth	r5, r5
 80056a4:	e7c8      	b.n	8005638 <_ux_host_stack_device_address_set+0x58>
 80056a6:	bf00      	nop

080056a8 <_ux_host_stack_device_descriptor_read>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_device_descriptor_read(UX_DEVICE *device)
{
 80056a8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    /* Retrieve the pointer to the control endpoint.  */
    control_endpoint =  &device -> ux_device_control_endpoint;
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;

    /* Need to allocate memory for the descriptor.  */
    descriptor =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_DEVICE_DESCRIPTOR_LENGTH);
 80056ac:	2212      	movs	r2, #18
{
 80056ae:	4604      	mov	r4, r0
    descriptor =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, UX_DEVICE_DESCRIPTOR_LENGTH);
 80056b0:	2101      	movs	r1, #1
 80056b2:	f04f 30ff 	mov.w	r0, #4294967295
 80056b6:	f7fc fb19 	bl	8001cec <_ux_utility_memory_allocate>
    if (descriptor == UX_NULL)
 80056ba:	b308      	cbz	r0, 8005700 <_ux_host_stack_device_descriptor_read+0x58>

    /* Create a transfer_request for the GET_DESCRIPTOR request. The first transfer_request asks 
       for the first 8 bytes only. This way we will know the real MaxPacketSize
       value for the control endpoint.  */
    transfer_request -> ux_transfer_request_data_pointer =      descriptor;
    transfer_request -> ux_transfer_request_requested_length =  8;
 80056bc:	2208      	movs	r2, #8
    transfer_request -> ux_transfer_request_function =          UX_GET_DESCRIPTOR;
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
    transfer_request -> ux_transfer_request_value =             UX_DEVICE_DESCRIPTOR_ITEM << 8;
    transfer_request -> ux_transfer_request_index =             0;
 80056be:	2300      	movs	r3, #0
    transfer_request =  &control_endpoint -> ux_endpoint_transfer_request;
 80056c0:	f104 09c4 	add.w	r9, r4, #196	; 0xc4
    transfer_request -> ux_transfer_request_function =          UX_GET_DESCRIPTOR;
 80056c4:	f04f 0a06 	mov.w	sl, #6
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 80056c8:	f04f 0880 	mov.w	r8, #128	; 0x80
    transfer_request -> ux_transfer_request_value =             UX_DEVICE_DESCRIPTOR_ITEM << 8;
 80056cc:	f44f 7780 	mov.w	r7, #256	; 0x100
    transfer_request -> ux_transfer_request_data_pointer =      descriptor;
 80056d0:	f8c4 00cc 	str.w	r0, [r4, #204]	; 0xcc
 80056d4:	4605      	mov	r5, r0
    transfer_request -> ux_transfer_request_requested_length =  8;
 80056d6:	f8c4 20d0 	str.w	r2, [r4, #208]	; 0xd0

    /* Send request to HCD layer.  */
    status =  _ux_host_stack_transfer_request(transfer_request);
 80056da:	4648      	mov	r0, r9
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 80056dc:	e9c4 8a36 	strd	r8, sl, [r4, #216]	; 0xd8
    transfer_request -> ux_transfer_request_index =             0;
 80056e0:	e9c4 7338 	strd	r7, r3, [r4, #224]	; 0xe0
    status =  _ux_host_stack_transfer_request(transfer_request);
 80056e4:	f7fe fe84 	bl	80043f0 <_ux_host_stack_transfer_request>

    /* Check for correct transfer and entire descriptor returned.  */
    if ((status == UX_SUCCESS) && (transfer_request -> ux_transfer_request_actual_length == 8))
 80056e8:	4606      	mov	r6, r0
 80056ea:	b918      	cbnz	r0, 80056f4 <_ux_host_stack_device_descriptor_read+0x4c>
 80056ec:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 80056f0:	2b08      	cmp	r3, #8
 80056f2:	d009      	beq.n	8005708 <_ux_host_stack_device_descriptor_read+0x60>
        /* The device descriptor does not contain the right amount of data. Maybe corruption.  */
        status =  UX_DESCRIPTOR_CORRUPTED;
    }
    
    /* Free all used resources.  */
    _ux_utility_memory_free(descriptor);
 80056f4:	4628      	mov	r0, r5
 80056f6:	f7fc fc0d 	bl	8001f14 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(status);             
}
 80056fa:	4630      	mov	r0, r6
 80056fc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8005700:	2612      	movs	r6, #18
}
 8005702:	4630      	mov	r0, r6
 8005704:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                                                                (UCHAR *) &device -> ux_device_descriptor);
 8005708:	f104 0b5c 	add.w	fp, r4, #92	; 0x5c
        _ux_utility_descriptor_parse(descriptor, _ux_system_device_descriptor_structure, UX_DEVICE_DESCRIPTOR_ENTRIES,
 800570c:	220e      	movs	r2, #14
 800570e:	4915      	ldr	r1, [pc, #84]	; (8005764 <_ux_host_stack_device_descriptor_read+0xbc>)
 8005710:	4628      	mov	r0, r5
 8005712:	465b      	mov	r3, fp
 8005714:	f7fe fee0 	bl	80044d8 <_ux_utility_descriptor_parse>
    control_endpoint -> ux_endpoint_descriptor.wMaxPacketSize =  device -> ux_device_descriptor.bMaxPacketSize0;
 8005718:	6f62      	ldr	r2, [r4, #116]	; 0x74
    transfer_request -> ux_transfer_request_requested_length =  UX_DEVICE_DESCRIPTOR_LENGTH;
 800571a:	2312      	movs	r3, #18
    transfer_request -> ux_transfer_request_data_pointer =      descriptor;
 800571c:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc
    transfer_request -> ux_transfer_request_function =          UX_GET_DESCRIPTOR;
 8005720:	f8c4 a0dc 	str.w	sl, [r4, #220]	; 0xdc
    status =  _ux_host_stack_transfer_request(transfer_request);
 8005724:	4648      	mov	r0, r9
    transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 8005726:	f8c4 80d8 	str.w	r8, [r4, #216]	; 0xd8
    control_endpoint -> ux_endpoint_descriptor.wMaxPacketSize =  device -> ux_device_descriptor.bMaxPacketSize0;
 800572a:	f8c4 20b0 	str.w	r2, [r4, #176]	; 0xb0
    transfer_request -> ux_transfer_request_requested_length =  UX_DEVICE_DESCRIPTOR_LENGTH;
 800572e:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
    transfer_request -> ux_transfer_request_index =             0;
 8005732:	e9c4 7638 	strd	r7, r6, [r4, #224]	; 0xe0
    status =  _ux_host_stack_transfer_request(transfer_request);
 8005736:	f7fe fe5b 	bl	80043f0 <_ux_host_stack_transfer_request>
    if ((status == UX_SUCCESS) && (transfer_request -> ux_transfer_request_actual_length == UX_DEVICE_DESCRIPTOR_LENGTH))
 800573a:	4606      	mov	r6, r0
 800573c:	b918      	cbnz	r0, 8005746 <_ux_host_stack_device_descriptor_read+0x9e>
 800573e:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8005742:	2b12      	cmp	r3, #18
 8005744:	d006      	beq.n	8005754 <_ux_host_stack_device_descriptor_read+0xac>
        status =  UX_DESCRIPTOR_CORRUPTED;
 8005746:	2642      	movs	r6, #66	; 0x42
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_DESCRIPTOR_CORRUPTED);
 8005748:	2104      	movs	r1, #4
 800574a:	2002      	movs	r0, #2
 800574c:	4632      	mov	r2, r6
 800574e:	f7fc fa57 	bl	8001c00 <_ux_system_error_handler>
 8005752:	e7cf      	b.n	80056f4 <_ux_host_stack_device_descriptor_read+0x4c>
        _ux_utility_descriptor_parse(descriptor, _ux_system_device_descriptor_structure, UX_DEVICE_DESCRIPTOR_ENTRIES,
 8005754:	465b      	mov	r3, fp
 8005756:	220e      	movs	r2, #14
 8005758:	4902      	ldr	r1, [pc, #8]	; (8005764 <_ux_host_stack_device_descriptor_read+0xbc>)
 800575a:	4628      	mov	r0, r5
 800575c:	f7fe febc 	bl	80044d8 <_ux_utility_descriptor_parse>
 8005760:	e7c8      	b.n	80056f4 <_ux_host_stack_device_descriptor_read+0x4c>
 8005762:	bf00      	nop
 8005764:	200000c4 	.word	0x200000c4

08005768 <_ux_host_stack_endpoint_instance_create>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_endpoint_instance_create(UX_ENDPOINT *endpoint)
{
 8005768:	b570      	push	{r4, r5, r6, lr}
UCHAR           endpoint_type;


    /* Obtain the HCD for this endpoint.  */
    device =  endpoint -> ux_endpoint_device;
    hcd =  device -> ux_device_hcd;
 800576a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
{
 800576c:	4604      	mov	r4, r0
    /* If trace is enabled, insert this event into the trace buffer.  */
    UX_TRACE_IN_LINE_INSERT(UX_TRACE_HOST_STACK_ENDPOINT_INSTANCE_CREATE, device, endpoint, 0, 0, UX_TRACE_HOST_STACK_EVENTS, 0, 0)

    
    /* If the endpoint needs guaranteed bandwidth, check if we have enough */
    endpoint_type = (endpoint -> ux_endpoint_descriptor.bmAttributes) & UX_MASK_ENDPOINT_TYPE;
 800576e:	7e05      	ldrb	r5, [r0, #24]
    hcd =  device -> ux_device_hcd;
 8005770:	6d1e      	ldr	r6, [r3, #80]	; 0x50
    switch (endpoint_type)
 8005772:	f015 0303 	ands.w	r3, r5, #3
 8005776:	d001      	beq.n	800577c <_ux_host_stack_endpoint_instance_create+0x14>
 8005778:	2b02      	cmp	r3, #2
 800577a:	d110      	bne.n	800579e <_ux_host_stack_endpoint_instance_create+0x36>

        break;
    }

    /* Create this endpoint.  */
    status = hcd -> ux_hcd_entry_function(hcd, UX_HCD_CREATE_ENDPOINT, (VOID *) endpoint);
 800577c:	f8d6 30c4 	ldr.w	r3, [r6, #196]	; 0xc4
 8005780:	4622      	mov	r2, r4
 8005782:	210e      	movs	r1, #14
 8005784:	4630      	mov	r0, r6
 8005786:	4798      	blx	r3

    /* Check status.  */
    if (status != UX_SUCCESS)
 8005788:	b9a8      	cbnz	r0, 80057b6 <_ux_host_stack_endpoint_instance_create+0x4e>
        /* Return completion status.  */
        return(status);
    }

    /* Claim bandwidth if needed.  */
    if ((endpoint_type == UX_INTERRUPT_ENDPOINT) || (endpoint_type == UX_ISOCHRONOUS_ENDPOINT))
 800578a:	07eb      	lsls	r3, r5, #31
 800578c:	d414      	bmi.n	80057b8 <_ux_host_stack_endpoint_instance_create+0x50>
        /* Claim its bandwidth */
        _ux_host_stack_bandwidth_claim(hcd, endpoint);
    }

    /* Create a semaphore for this endpoint to be attached to its transfer request.  */
    status =  _ux_utility_semaphore_create(&endpoint -> ux_endpoint_transfer_request.ux_transfer_request_semaphore,
 800578e:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8005792:	2200      	movs	r2, #0
 8005794:	490b      	ldr	r1, [pc, #44]	; (80057c4 <_ux_host_stack_endpoint_instance_create+0x5c>)

    }

    /* Return completion status.  */
    return(status);
}
 8005796:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    status =  _ux_utility_semaphore_create(&endpoint -> ux_endpoint_transfer_request.ux_transfer_request_semaphore,
 800579a:	f7fc bc69 	b.w	8002070 <_ux_utility_semaphore_create>
        if (_ux_host_stack_bandwidth_check(hcd, endpoint) != UX_SUCCESS)
 800579e:	4601      	mov	r1, r0
 80057a0:	4630      	mov	r0, r6
 80057a2:	f000 f81f 	bl	80057e4 <_ux_host_stack_bandwidth_check>
 80057a6:	2800      	cmp	r0, #0
 80057a8:	d0e8      	beq.n	800577c <_ux_host_stack_endpoint_instance_create+0x14>
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_NO_BANDWIDTH_AVAILABLE);
 80057aa:	2002      	movs	r0, #2
 80057ac:	2241      	movs	r2, #65	; 0x41
 80057ae:	2104      	movs	r1, #4
 80057b0:	f7fc fa26 	bl	8001c00 <_ux_system_error_handler>
            return(UX_NO_BANDWIDTH_AVAILABLE);
 80057b4:	2041      	movs	r0, #65	; 0x41
}
 80057b6:	bd70      	pop	{r4, r5, r6, pc}
        _ux_host_stack_bandwidth_claim(hcd, endpoint);
 80057b8:	4630      	mov	r0, r6
 80057ba:	4621      	mov	r1, r4
 80057bc:	f000 f8c0 	bl	8005940 <_ux_host_stack_bandwidth_claim>
 80057c0:	e7e5      	b.n	800578e <_ux_host_stack_endpoint_instance_create+0x26>
 80057c2:	bf00      	nop
 80057c4:	0800de40 	.word	0x0800de40

080057c8 <_ux_host_stack_new_configuration_create>:

    /* There is 2 cases for the creation of the configuration descriptor 
       if this is the first one, the configuration descriptor is hooked
       to the device. If it is not the first one, the configuration is 
       hooked to the end of the chain of configurations.  */
    if (device -> ux_device_first_configuration == UX_NULL)
 80057c8:	6d42      	ldr	r2, [r0, #84]	; 0x54
    configuration -> ux_configuration_device =  device;
 80057ca:	6348      	str	r0, [r1, #52]	; 0x34
    configuration -> ux_configuration_handle =  (ULONG) (ALIGN_TYPE) configuration;
 80057cc:	6009      	str	r1, [r1, #0]
    if (device -> ux_device_first_configuration == UX_NULL)
 80057ce:	b90a      	cbnz	r2, 80057d4 <_ux_host_stack_new_configuration_create+0xc>
 80057d0:	e005      	b.n	80057de <_ux_host_stack_new_configuration_create+0x16>
 80057d2:	461a      	mov	r2, r3

        /* Get the pointer to the first configuration.  */
        list_configuration =  device -> ux_device_first_configuration;

        /* And traverse until we have reached the end of the configuration list.  */
        while (list_configuration -> ux_configuration_next_configuration != UX_NULL)
 80057d4:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80057d6:	2b00      	cmp	r3, #0
 80057d8:	d1fb      	bne.n	80057d2 <_ux_host_stack_new_configuration_create+0xa>
        {
            list_configuration =  list_configuration -> ux_configuration_next_configuration;
        }

        /* Hook the new configuration.  */
        list_configuration -> ux_configuration_next_configuration =  configuration;
 80057da:	6311      	str	r1, [r2, #48]	; 0x30
    }

    /* Return to caller.  */
    return;
}
 80057dc:	4770      	bx	lr
        device -> ux_device_first_configuration =  configuration;
 80057de:	6541      	str	r1, [r0, #84]	; 0x54
 80057e0:	4770      	bx	lr
 80057e2:	bf00      	nop

080057e4 <_ux_host_stack_bandwidth_check>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_bandwidth_check(UX_HCD *hcd, UX_ENDPOINT *endpoint)
{
 80057e4:	b5f0      	push	{r4, r5, r6, r7, lr}
     * 
     * Worst case bit stuffing is calculated as 1.1667 (7/6) times the raw time.
     */

    /* Get maximum packet size.  */
    max_packet_size  = endpoint -> ux_endpoint_descriptor.wMaxPacketSize & UX_MAX_PACKET_SIZE_MASK;
 80057e6:	e9d1 3506 	ldrd	r3, r5, [r1, #24]
{
 80057ea:	b085      	sub	sp, #20
    device =  endpoint -> ux_endpoint_device;
 80057ec:	f8d1 c02c 	ldr.w	ip, [r1, #44]	; 0x2c

    /* Rough time for possible Bit Stuffing.  */
    packet_size = (max_packet_size * 7 + 5) / 6;

    /* Add overhead.  */
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 80057f0:	f003 0303 	and.w	r3, r3, #3
    packet_size = (max_packet_size * 7 + 5) / 6;
 80057f4:	f3c5 020a 	ubfx	r2, r5, #0, #11
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 80057f8:	a904      	add	r1, sp, #16
const UCHAR     overheads[4][3] = {
 80057fa:	4e4f      	ldr	r6, [pc, #316]	; (8005938 <_ux_host_stack_bandwidth_check+0x154>)
    packet_size = (max_packet_size * 7 + 5) / 6;
 80057fc:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 8005800:	f8dc e010 	ldr.w	lr, [ip, #16]
 8005804:	eb03 0343 	add.w	r3, r3, r3, lsl #1
{
 8005808:	4607      	mov	r7, r0
    packet_size = (max_packet_size * 7 + 5) / 6;
 800580a:	1d54      	adds	r4, r2, #5
 800580c:	484b      	ldr	r0, [pc, #300]	; (800593c <_ux_host_stack_bandwidth_check+0x158>)
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 800580e:	440b      	add	r3, r1
    max_packet_size = (USHORT)packet_size;

    /* Check for high-speed endpoint.  */
    if (device -> ux_device_speed == UX_HIGH_SPEED_DEVICE)
 8005810:	f1be 0f02 	cmp.w	lr, #2
    packet_size = (max_packet_size * 7 + 5) / 6;
 8005814:	fba0 2404 	umull	r2, r4, r0, r4
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 8005818:	4473      	add	r3, lr
const UCHAR     overheads[4][3] = {
 800581a:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 800581e:	ae04      	add	r6, sp, #16
 8005820:	e906 0007 	stmdb	r6, {r0, r1, r2}
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 8005824:	f813 2c0c 	ldrb.w	r2, [r3, #-12]
 8005828:	eb02 0494 	add.w	r4, r2, r4, lsr #2
    max_packet_size = (USHORT)packet_size;
 800582c:	b2a3      	uxth	r3, r4
    if (device -> ux_device_speed == UX_HIGH_SPEED_DEVICE)
 800582e:	d05c      	beq.n	80058ea <_ux_host_stack_bandwidth_check+0x106>
                    (((endpoint -> ux_endpoint_descriptor.wMaxPacketSize & UX_MAX_NUMBER_OF_TRANSACTIONS_MASK) >>
                        UX_MAX_NUMBER_OF_TRANSACTIONS_SHIFT) + 1));
    }

    /* Calculate the bandwidth claimed by this endpoint for the main bus.  */
    if (hcd -> ux_hcd_version != 0x200)
 8005830:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
 8005834:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8005838:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800583c:	d00b      	beq.n	8005856 <_ux_host_stack_bandwidth_check+0x72>
    {

        if (device -> ux_device_speed == UX_LOW_SPEED_DEVICE)
 800583e:	f1be 0f00 	cmp.w	lr, #0
 8005842:	d166      	bne.n	8005912 <_ux_host_stack_bandwidth_check+0x12e>
            /* Low speed transfer takes 40x more units than high speed. */
            hcd_bandwidth_claimed =  (USHORT)(max_packet_size * 8 * 5);
 8005844:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8005848:	00db      	lsls	r3, r3, #3
 800584a:	b29b      	uxth	r3, r3
            /* Use full speed timing as base for TT bandwidth calculation. */
            tt_bandwidth_claimed =  (USHORT)max_packet_size;
    }

    /* Do we have enough on the bus for this new endpoint?  */
    if (hcd -> ux_hcd_available_bandwidth < hcd_bandwidth_claimed)
 800584c:	4293      	cmp	r3, r2
 800584e:	d844      	bhi.n	80058da <_ux_host_stack_bandwidth_check+0xf6>
       is either high speed or the bus is 1.1.  */
    if ((device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) || (hcd -> ux_hcd_version != 0x200))
    {

        /* The device is high speed, therefore no need for TT.  */
        return(UX_SUCCESS);
 8005850:	2000      	movs	r0, #0
        parent_device =  parent_device -> ux_device_parent;
    }

    /* We get here when we have not found a 2.0 hub in the list and we got to the root port.  */
    return(UX_SUCCESS);
}
 8005852:	b005      	add	sp, #20
 8005854:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005856:	4621      	mov	r1, r4
        if (device -> ux_device_speed == UX_LOW_SPEED_DEVICE)
 8005858:	f1be 0f00 	cmp.w	lr, #0
 800585c:	d153      	bne.n	8005906 <_ux_host_stack_bandwidth_check+0x122>
            tt_bandwidth_claimed =  (USHORT)(max_packet_size * 8);
 800585e:	00db      	lsls	r3, r3, #3
    if (hcd -> ux_hcd_available_bandwidth < hcd_bandwidth_claimed)
 8005860:	4294      	cmp	r4, r2
            tt_bandwidth_claimed =  (USHORT)(max_packet_size * 8);
 8005862:	b29b      	uxth	r3, r3
    if (hcd -> ux_hcd_available_bandwidth < hcd_bandwidth_claimed)
 8005864:	d839      	bhi.n	80058da <_ux_host_stack_bandwidth_check+0xf6>
    parent_device =  device -> ux_device_parent;
 8005866:	f8dc 0044 	ldr.w	r0, [ip, #68]	; 0x44
    if (parent_device == UX_NULL)
 800586a:	2800      	cmp	r0, #0
 800586c:	d0f1      	beq.n	8005852 <_ux_host_stack_bandwidth_check+0x6e>
    port_index =  device -> ux_device_port_location - 1;
 800586e:	f8dc 2014 	ldr.w	r2, [ip, #20]
 8005872:	3a01      	subs	r2, #1
 8005874:	e004      	b.n	8005880 <_ux_host_stack_bandwidth_check+0x9c>
        port_index =  parent_device -> ux_device_port_location - 1;
 8005876:	6942      	ldr	r2, [r0, #20]
        parent_device =  parent_device -> ux_device_parent;
 8005878:	6c40      	ldr	r0, [r0, #68]	; 0x44
        port_index =  parent_device -> ux_device_port_location - 1;
 800587a:	3a01      	subs	r2, #1
    while (parent_device != UX_NULL)
 800587c:	2800      	cmp	r0, #0
 800587e:	d0e8      	beq.n	8005852 <_ux_host_stack_bandwidth_check+0x6e>
        if (parent_device -> ux_device_speed == UX_HIGH_SPEED_DEVICE)
 8005880:	6901      	ldr	r1, [r0, #16]
 8005882:	2902      	cmp	r1, #2
 8005884:	d1f7      	bne.n	8005876 <_ux_host_stack_bandwidth_check+0x92>
            port_map = (ULONG)(1 << port_index);
 8005886:	2401      	movs	r4, #1
                if ((parent_device -> ux_device_hub_tt[tt_index].ux_hub_tt_port_mapping & port_map) != 0)
 8005888:	f8d0 512c 	ldr.w	r5, [r0, #300]	; 0x12c
            port_map = (ULONG)(1 << port_index);
 800588c:	fa04 f202 	lsl.w	r2, r4, r2
                if ((parent_device -> ux_device_hub_tt[tt_index].ux_hub_tt_port_mapping & port_map) != 0)
 8005890:	422a      	tst	r2, r5
 8005892:	d147      	bne.n	8005924 <_ux_host_stack_bandwidth_check+0x140>
 8005894:	f8d0 5134 	ldr.w	r5, [r0, #308]	; 0x134
 8005898:	422a      	tst	r2, r5
 800589a:	d145      	bne.n	8005928 <_ux_host_stack_bandwidth_check+0x144>
 800589c:	f8d0 413c 	ldr.w	r4, [r0, #316]	; 0x13c
 80058a0:	4222      	tst	r2, r4
 80058a2:	d114      	bne.n	80058ce <_ux_host_stack_bandwidth_check+0xea>
 80058a4:	f8d0 1144 	ldr.w	r1, [r0, #324]	; 0x144
 80058a8:	420a      	tst	r2, r1
 80058aa:	d13f      	bne.n	800592c <_ux_host_stack_bandwidth_check+0x148>
 80058ac:	f8d0 114c 	ldr.w	r1, [r0, #332]	; 0x14c
 80058b0:	420a      	tst	r2, r1
 80058b2:	d13d      	bne.n	8005930 <_ux_host_stack_bandwidth_check+0x14c>
 80058b4:	f8d0 1154 	ldr.w	r1, [r0, #340]	; 0x154
 80058b8:	420a      	tst	r2, r1
 80058ba:	d131      	bne.n	8005920 <_ux_host_stack_bandwidth_check+0x13c>
 80058bc:	f8d0 115c 	ldr.w	r1, [r0, #348]	; 0x15c
 80058c0:	420a      	tst	r2, r1
 80058c2:	d137      	bne.n	8005934 <_ux_host_stack_bandwidth_check+0x150>
 80058c4:	f8d0 1164 	ldr.w	r1, [r0, #356]	; 0x164
 80058c8:	420a      	tst	r2, r1
 80058ca:	d006      	beq.n	80058da <_ux_host_stack_bandwidth_check+0xf6>
            for (tt_index = 0; tt_index < UX_MAX_TT; tt_index++)
 80058cc:	2107      	movs	r1, #7
                    if (parent_device -> ux_device_hub_tt[tt_index].ux_hub_tt_max_bandwidth < tt_bandwidth_claimed)
 80058ce:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
 80058d2:	f8d0 2130 	ldr.w	r2, [r0, #304]	; 0x130
 80058d6:	429a      	cmp	r2, r3
 80058d8:	d2ba      	bcs.n	8005850 <_ux_host_stack_bandwidth_check+0x6c>
        _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_NO_BANDWIDTH_AVAILABLE);
 80058da:	2241      	movs	r2, #65	; 0x41
 80058dc:	2104      	movs	r1, #4
 80058de:	2002      	movs	r0, #2
 80058e0:	f7fc f98e 	bl	8001c00 <_ux_system_error_handler>
        return(UX_NO_BANDWIDTH_AVAILABLE);
 80058e4:	2041      	movs	r0, #65	; 0x41
}
 80058e6:	b005      	add	sp, #20
 80058e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    (((endpoint -> ux_endpoint_descriptor.wMaxPacketSize & UX_MAX_NUMBER_OF_TRANSACTIONS_MASK) >>
 80058ea:	f3c5 25c1 	ubfx	r5, r5, #11, #2
    if (hcd -> ux_hcd_version != 0x200)
 80058ee:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
 80058f2:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
                        UX_MAX_NUMBER_OF_TRANSACTIONS_SHIFT) + 1));
 80058f6:	3501      	adds	r5, #1
    if (hcd -> ux_hcd_version != 0x200)
 80058f8:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
        max_packet_size = (USHORT)(max_packet_size *
 80058fc:	fb15 f303 	smulbb	r3, r5, r3
 8005900:	b29b      	uxth	r3, r3
    if (hcd -> ux_hcd_version != 0x200)
 8005902:	d1a3      	bne.n	800584c <_ux_host_stack_bandwidth_check+0x68>
 8005904:	4619      	mov	r1, r3
    if (hcd -> ux_hcd_available_bandwidth < hcd_bandwidth_claimed)
 8005906:	428a      	cmp	r2, r1
 8005908:	d3e7      	bcc.n	80058da <_ux_host_stack_bandwidth_check+0xf6>
    if ((device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) || (hcd -> ux_hcd_version != 0x200))
 800590a:	f1be 0f02 	cmp.w	lr, #2
 800590e:	d1aa      	bne.n	8005866 <_ux_host_stack_bandwidth_check+0x82>
 8005910:	e79e      	b.n	8005850 <_ux_host_stack_bandwidth_check+0x6c>
            if (device -> ux_device_speed == UX_FULL_SPEED_DEVICE)
 8005912:	f1be 0f01 	cmp.w	lr, #1
 8005916:	d199      	bne.n	800584c <_ux_host_stack_bandwidth_check+0x68>
                hcd_bandwidth_claimed =  (USHORT)(max_packet_size * 5);
 8005918:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800591c:	b29b      	uxth	r3, r3
 800591e:	e795      	b.n	800584c <_ux_host_stack_bandwidth_check+0x68>
            for (tt_index = 0; tt_index < UX_MAX_TT; tt_index++)
 8005920:	2105      	movs	r1, #5
 8005922:	e7d4      	b.n	80058ce <_ux_host_stack_bandwidth_check+0xea>
 8005924:	2100      	movs	r1, #0
 8005926:	e7d2      	b.n	80058ce <_ux_host_stack_bandwidth_check+0xea>
 8005928:	4621      	mov	r1, r4
 800592a:	e7d0      	b.n	80058ce <_ux_host_stack_bandwidth_check+0xea>
 800592c:	2103      	movs	r1, #3
 800592e:	e7ce      	b.n	80058ce <_ux_host_stack_bandwidth_check+0xea>
 8005930:	2104      	movs	r1, #4
 8005932:	e7cc      	b.n	80058ce <_ux_host_stack_bandwidth_check+0xea>
 8005934:	2106      	movs	r1, #6
 8005936:	e7ca      	b.n	80058ce <_ux_host_stack_bandwidth_check+0xea>
 8005938:	0800dd1c 	.word	0x0800dd1c
 800593c:	aaaaaaab 	.word	0xaaaaaaab

08005940 <_ux_host_stack_bandwidth_claim>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _ux_host_stack_bandwidth_claim(UX_HCD *hcd, UX_ENDPOINT *endpoint)
{
 8005940:	b5f0      	push	{r4, r5, r6, r7, lr}
     * 
     * Worst case bit stuffing is calculated as 1.1667 (7/6) times the raw time.
     */

    /* Get maximum packet size.  */
    max_packet_size  = endpoint -> ux_endpoint_descriptor.wMaxPacketSize & UX_MAX_PACKET_SIZE_MASK;
 8005942:	e9d1 3506 	ldrd	r3, r5, [r1, #24]
{
 8005946:	b085      	sub	sp, #20
    device =  endpoint -> ux_endpoint_device;
 8005948:	f8d1 c02c 	ldr.w	ip, [r1, #44]	; 0x2c

    /* Rough time for possible Bit Stuffing.  */
    packet_size = (max_packet_size * 7 + 5) / 6;

    /* Add overhead.  */
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 800594c:	f003 0303 	and.w	r3, r3, #3
    packet_size = (max_packet_size * 7 + 5) / 6;
 8005950:	f3c5 020a 	ubfx	r2, r5, #0, #11
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 8005954:	a904      	add	r1, sp, #16
{
 8005956:	4607      	mov	r7, r0
    packet_size = (max_packet_size * 7 + 5) / 6;
 8005958:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
const UCHAR     overheads[4][3] = {
 800595c:	f8df e158 	ldr.w	lr, [pc, #344]	; 8005ab8 <_ux_host_stack_bandwidth_claim+0x178>
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 8005960:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    packet_size = (max_packet_size * 7 + 5) / 6;
 8005964:	4853      	ldr	r0, [pc, #332]	; (8005ab4 <_ux_host_stack_bandwidth_claim+0x174>)
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 8005966:	f8dc 6010 	ldr.w	r6, [ip, #16]
    packet_size = (max_packet_size * 7 + 5) / 6;
 800596a:	1d54      	adds	r4, r2, #5
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 800596c:	440b      	add	r3, r1
    packet_size = (max_packet_size * 7 + 5) / 6;
 800596e:	fba0 2404 	umull	r2, r4, r0, r4
    max_packet_size = (USHORT)packet_size;

    /* Check for high-speed endpoint.  */
    if (device -> ux_device_speed == UX_HIGH_SPEED_DEVICE)
 8005972:	2e02      	cmp	r6, #2
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 8005974:	4433      	add	r3, r6
const UCHAR     overheads[4][3] = {
 8005976:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
 800597a:	f10d 0e10 	add.w	lr, sp, #16
 800597e:	e90e 0007 	stmdb	lr, {r0, r1, r2}
    packet_size += overheads[endpoint -> ux_endpoint_descriptor.bmAttributes & UX_MASK_ENDPOINT_TYPE][device -> ux_device_speed];
 8005982:	f813 2c0c 	ldrb.w	r2, [r3, #-12]
 8005986:	f8d7 00c0 	ldr.w	r0, [r7, #192]	; 0xc0
 800598a:	eb02 0494 	add.w	r4, r2, r4, lsr #2
 800598e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
    max_packet_size = (USHORT)packet_size;
 8005992:	b2a1      	uxth	r1, r4
    if (device -> ux_device_speed == UX_HIGH_SPEED_DEVICE)
 8005994:	d05d      	beq.n	8005a52 <_ux_host_stack_bandwidth_claim+0x112>
                    (((endpoint -> ux_endpoint_descriptor.wMaxPacketSize & UX_MAX_NUMBER_OF_TRANSACTIONS_MASK) >>
                        UX_MAX_NUMBER_OF_TRANSACTIONS_SHIFT) + 1));
    }

    /* Calculate the bandwidth claimed by this endpoint for the main bus.  */
    if (hcd -> ux_hcd_version != 0x200)
 8005996:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800599a:	d010      	beq.n	80059be <_ux_host_stack_bandwidth_claim+0x7e>
    {

        if (device -> ux_device_speed == UX_LOW_SPEED_DEVICE)
 800599c:	2e00      	cmp	r6, #0
 800599e:	d163      	bne.n	8005a68 <_ux_host_stack_bandwidth_claim+0x128>
            /* Low speed transfer takes 40x more units than high speed. */
            hcd_bandwidth_claimed =  (USHORT)(max_packet_size * 8 * 5);
 80059a0:	eb01 0481 	add.w	r4, r1, r1, lsl #2
    hcd -> ux_hcd_available_bandwidth -=  hcd_bandwidth_claimed;

    /* We need to take care of the case where the endpoint belongs to a USB 1.1
       device that sits behind a 2.0 hub. We ignore cases where the device
       is either high speed or the bus is 1.1.  */
    if ((device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) || (hcd -> ux_hcd_version != 0x200))
 80059a4:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
USHORT          tt_bandwidth_claimed =  0;
 80059a8:	4631      	mov	r1, r6
            hcd_bandwidth_claimed =  (USHORT)(max_packet_size * 8 * 5);
 80059aa:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 80059ae:	b2a4      	uxth	r4, r4
 80059b0:	eba3 0404 	sub.w	r4, r3, r4
    hcd -> ux_hcd_available_bandwidth -=  hcd_bandwidth_claimed;
 80059b4:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
    if ((device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) || (hcd -> ux_hcd_version != 0x200))
 80059b8:	d00b      	beq.n	80059d2 <_ux_host_stack_bandwidth_claim+0x92>
    }

    /* We get here when we have not found a 2.0 hub in the list and we got
       to the root port.  */
    return;
}
 80059ba:	b005      	add	sp, #20
 80059bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80059be:	1b1c      	subs	r4, r3, r4
        if (device -> ux_device_speed == UX_LOW_SPEED_DEVICE)
 80059c0:	2e00      	cmp	r6, #0
 80059c2:	d15b      	bne.n	8005a7c <_ux_host_stack_bandwidth_claim+0x13c>
            tt_bandwidth_claimed =  (USHORT)(max_packet_size * 8);
 80059c4:	00c9      	lsls	r1, r1, #3
    if ((device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) || (hcd -> ux_hcd_version != 0x200))
 80059c6:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    hcd -> ux_hcd_available_bandwidth -=  hcd_bandwidth_claimed;
 80059ca:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
            tt_bandwidth_claimed =  (USHORT)(max_packet_size * 8);
 80059ce:	b289      	uxth	r1, r1
    if ((device -> ux_device_speed == UX_HIGH_SPEED_DEVICE) || (hcd -> ux_hcd_version != 0x200))
 80059d0:	d1f3      	bne.n	80059ba <_ux_host_stack_bandwidth_claim+0x7a>
    parent_device =  device -> ux_device_parent;
 80059d2:	f8dc 3044 	ldr.w	r3, [ip, #68]	; 0x44
    if (parent_device == UX_NULL)
 80059d6:	2b00      	cmp	r3, #0
 80059d8:	d0ef      	beq.n	80059ba <_ux_host_stack_bandwidth_claim+0x7a>
    port_index =  device -> ux_device_port_location - 1;
 80059da:	f8dc 2014 	ldr.w	r2, [ip, #20]
 80059de:	3a01      	subs	r2, #1
 80059e0:	e004      	b.n	80059ec <_ux_host_stack_bandwidth_claim+0xac>
        port_index =  parent_device -> ux_device_port_location - 1;
 80059e2:	695a      	ldr	r2, [r3, #20]
        parent_device =  parent_device -> ux_device_parent;
 80059e4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        port_index =  parent_device -> ux_device_port_location - 1;
 80059e6:	3a01      	subs	r2, #1
    while (parent_device != UX_NULL)
 80059e8:	2b00      	cmp	r3, #0
 80059ea:	d0e6      	beq.n	80059ba <_ux_host_stack_bandwidth_claim+0x7a>
        if (parent_device -> ux_device_speed == UX_HIGH_SPEED_DEVICE)
 80059ec:	6918      	ldr	r0, [r3, #16]
 80059ee:	2802      	cmp	r0, #2
 80059f0:	d1f7      	bne.n	80059e2 <_ux_host_stack_bandwidth_claim+0xa2>
            port_map =  (ULONG)(1 << port_index);
 80059f2:	2401      	movs	r4, #1
                if ((parent_device -> ux_device_hub_tt[tt_index].ux_hub_tt_port_mapping & port_map) != 0)
 80059f4:	f8d3 012c 	ldr.w	r0, [r3, #300]	; 0x12c
            port_map =  (ULONG)(1 << port_index);
 80059f8:	fa04 f202 	lsl.w	r2, r4, r2
                if ((parent_device -> ux_device_hub_tt[tt_index].ux_hub_tt_port_mapping & port_map) != 0)
 80059fc:	4202      	tst	r2, r0
 80059fe:	d148      	bne.n	8005a92 <_ux_host_stack_bandwidth_claim+0x152>
 8005a00:	f8d3 0134 	ldr.w	r0, [r3, #308]	; 0x134
 8005a04:	4202      	tst	r2, r0
 8005a06:	d146      	bne.n	8005a96 <_ux_host_stack_bandwidth_claim+0x156>
 8005a08:	f8d3 013c 	ldr.w	r0, [r3, #316]	; 0x13c
 8005a0c:	4202      	tst	r2, r0
 8005a0e:	d144      	bne.n	8005a9a <_ux_host_stack_bandwidth_claim+0x15a>
 8005a10:	f8d3 0144 	ldr.w	r0, [r3, #324]	; 0x144
 8005a14:	4202      	tst	r2, r0
 8005a16:	d134      	bne.n	8005a82 <_ux_host_stack_bandwidth_claim+0x142>
 8005a18:	f8d3 014c 	ldr.w	r0, [r3, #332]	; 0x14c
 8005a1c:	4202      	tst	r2, r0
 8005a1e:	d13e      	bne.n	8005a9e <_ux_host_stack_bandwidth_claim+0x15e>
 8005a20:	f8d3 0154 	ldr.w	r0, [r3, #340]	; 0x154
 8005a24:	4202      	tst	r2, r0
 8005a26:	d13c      	bne.n	8005aa2 <_ux_host_stack_bandwidth_claim+0x162>
 8005a28:	f8d3 015c 	ldr.w	r0, [r3, #348]	; 0x15c
 8005a2c:	4202      	tst	r2, r0
 8005a2e:	d13a      	bne.n	8005aa6 <_ux_host_stack_bandwidth_claim+0x166>
 8005a30:	f8d3 0164 	ldr.w	r0, [r3, #356]	; 0x164
 8005a34:	4202      	tst	r2, r0
 8005a36:	d138      	bne.n	8005aaa <_ux_host_stack_bandwidth_claim+0x16a>
 8005a38:	f8d3 016c 	ldr.w	r0, [r3, #364]	; 0x16c
 8005a3c:	4202      	tst	r2, r0
 8005a3e:	d136      	bne.n	8005aae <_ux_host_stack_bandwidth_claim+0x16e>
                tt_index ++;
 8005a40:	2008      	movs	r0, #8
 8005a42:	3001      	adds	r0, #1
                if ((parent_device -> ux_device_hub_tt[tt_index].ux_hub_tt_port_mapping & port_map) != 0)
 8005a44:	00c4      	lsls	r4, r0, #3
 8005a46:	191d      	adds	r5, r3, r4
 8005a48:	f8d5 512c 	ldr.w	r5, [r5, #300]	; 0x12c
 8005a4c:	422a      	tst	r2, r5
 8005a4e:	d0f8      	beq.n	8005a42 <_ux_host_stack_bandwidth_claim+0x102>
 8005a50:	e018      	b.n	8005a84 <_ux_host_stack_bandwidth_claim+0x144>
                    (((endpoint -> ux_endpoint_descriptor.wMaxPacketSize & UX_MAX_NUMBER_OF_TRANSACTIONS_MASK) >>
 8005a52:	f3c5 25c1 	ubfx	r5, r5, #11, #2
                        UX_MAX_NUMBER_OF_TRANSACTIONS_SHIFT) + 1));
 8005a56:	3501      	adds	r5, #1
        max_packet_size = (USHORT)(max_packet_size *
 8005a58:	fb15 f101 	smulbb	r1, r5, r1
 8005a5c:	b289      	uxth	r1, r1
    hcd -> ux_hcd_available_bandwidth -=  hcd_bandwidth_claimed;
 8005a5e:	1a59      	subs	r1, r3, r1
 8005a60:	f8c7 10b8 	str.w	r1, [r7, #184]	; 0xb8
}
 8005a64:	b005      	add	sp, #20
 8005a66:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if (device -> ux_device_speed == UX_FULL_SPEED_DEVICE)
 8005a68:	2e01      	cmp	r6, #1
 8005a6a:	d1f8      	bne.n	8005a5e <_ux_host_stack_bandwidth_claim+0x11e>
                hcd_bandwidth_claimed =  (USHORT)(max_packet_size * 5);
 8005a6c:	eb01 0181 	add.w	r1, r1, r1, lsl #2
    hcd -> ux_hcd_available_bandwidth -=  hcd_bandwidth_claimed;
 8005a70:	b289      	uxth	r1, r1
 8005a72:	1a5b      	subs	r3, r3, r1
 8005a74:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
}
 8005a78:	b005      	add	sp, #20
 8005a7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcd -> ux_hcd_available_bandwidth -=  hcd_bandwidth_claimed;
 8005a7c:	f8c7 40b8 	str.w	r4, [r7, #184]	; 0xb8
 8005a80:	e7a7      	b.n	80059d2 <_ux_host_stack_bandwidth_claim+0x92>
 8005a82:	2418      	movs	r4, #24
 8005a84:	4423      	add	r3, r4
                    parent_device -> ux_device_hub_tt[tt_index].ux_hub_tt_max_bandwidth -=  tt_bandwidth_claimed;
 8005a86:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
 8005a8a:	1a51      	subs	r1, r2, r1
 8005a8c:	f8c3 1130 	str.w	r1, [r3, #304]	; 0x130
                    return;
 8005a90:	e793      	b.n	80059ba <_ux_host_stack_bandwidth_claim+0x7a>
 8005a92:	2400      	movs	r4, #0
 8005a94:	e7f6      	b.n	8005a84 <_ux_host_stack_bandwidth_claim+0x144>
 8005a96:	2408      	movs	r4, #8
 8005a98:	e7f4      	b.n	8005a84 <_ux_host_stack_bandwidth_claim+0x144>
 8005a9a:	2410      	movs	r4, #16
 8005a9c:	e7f2      	b.n	8005a84 <_ux_host_stack_bandwidth_claim+0x144>
 8005a9e:	2420      	movs	r4, #32
 8005aa0:	e7f0      	b.n	8005a84 <_ux_host_stack_bandwidth_claim+0x144>
 8005aa2:	2428      	movs	r4, #40	; 0x28
 8005aa4:	e7ee      	b.n	8005a84 <_ux_host_stack_bandwidth_claim+0x144>
 8005aa6:	2430      	movs	r4, #48	; 0x30
 8005aa8:	e7ec      	b.n	8005a84 <_ux_host_stack_bandwidth_claim+0x144>
 8005aaa:	2438      	movs	r4, #56	; 0x38
 8005aac:	e7ea      	b.n	8005a84 <_ux_host_stack_bandwidth_claim+0x144>
 8005aae:	2440      	movs	r4, #64	; 0x40
 8005ab0:	e7e8      	b.n	8005a84 <_ux_host_stack_bandwidth_claim+0x144>
 8005ab2:	bf00      	nop
 8005ab4:	aaaaaaab 	.word	0xaaaaaaab
 8005ab8:	0800dd28 	.word	0x0800dd28

08005abc <_ux_host_stack_class_call>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UX_HOST_CLASS  *_ux_host_stack_class_call(UX_HOST_CLASS_COMMAND *class_command)
{
 8005abc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
ULONG           class_index;
UINT            status;


    /* Start from the 1st registered classes with USBX.  */
    class =  _ux_system_host -> ux_system_host_class_array;
 8005abe:	4f0c      	ldr	r7, [pc, #48]	; (8005af0 <_ux_host_stack_class_call+0x34>)
 8005ac0:	683b      	ldr	r3, [r7, #0]

    /* Parse all the class drivers.  */
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 8005ac2:	681a      	ldr	r2, [r3, #0]
    class =  _ux_system_host -> ux_system_host_class_array;
 8005ac4:	689c      	ldr	r4, [r3, #8]
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 8005ac6:	b17a      	cbz	r2, 8005ae8 <_ux_host_stack_class_call+0x2c>
 8005ac8:	4606      	mov	r6, r0
 8005aca:	2500      	movs	r5, #0
    {

        /* Check if this class driver is used.  */
        if (class -> ux_host_class_status == UX_USED)
 8005acc:	6c23      	ldr	r3, [r4, #64]	; 0x40
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 8005ace:	3501      	adds	r5, #1
        {

            /* We have found a potential candidate. Call this registered class entry function.  */
            status = class -> ux_host_class_entry_function(class_command);
 8005ad0:	4630      	mov	r0, r6
        if (class -> ux_host_class_status == UX_USED)
 8005ad2:	2b01      	cmp	r3, #1
 8005ad4:	d104      	bne.n	8005ae0 <_ux_host_stack_class_call+0x24>
            status = class -> ux_host_class_entry_function(class_command);
 8005ad6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005ad8:	4798      	blx	r3

            /* The status tells us if the registered class wants to own this class.  */
            if (status == UX_SUCCESS)
 8005ada:	b130      	cbz	r0, 8005aea <_ux_host_stack_class_call+0x2e>
 8005adc:	683b      	ldr	r3, [r7, #0]
 8005ade:	681a      	ldr	r2, [r3, #0]
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 8005ae0:	4295      	cmp	r5, r2
                return(class); 
            }
        }    

        /* Move to the next registered class. */
        class++;
 8005ae2:	f504 7494 	add.w	r4, r4, #296	; 0x128
    for (class_index = 0; class_index < _ux_system_host -> ux_system_host_max_class; class_index++)
 8005ae6:	d3f1      	bcc.n	8005acc <_ux_host_stack_class_call+0x10>
    }       

    /* There is no driver who want to own this class!  */
    return(UX_NULL);
 8005ae8:	2400      	movs	r4, #0
}
 8005aea:	4620      	mov	r0, r4
 8005aec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005aee:	bf00      	nop
 8005af0:	20000db8 	.word	0x20000db8

08005af4 <_ux_host_stack_configuration_descriptor_parse>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_configuration_descriptor_parse(UX_DEVICE *device, UX_CONFIGURATION *configuration,
                                                                        UINT configuration_index)
{
 8005af4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005af8:	4688      	mov	r8, r1
 8005afa:	4604      	mov	r4, r0
 8005afc:	4616      	mov	r6, r2

    /* Retrieve the size of all the configuration descriptor.  */
    total_configuration_length =  configuration -> ux_configuration_descriptor.wTotalLength;

    /* Allocate enough memory to read all descriptors attached to this configuration.  */
    descriptor =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, total_configuration_length);
 8005afe:	2101      	movs	r1, #1
    total_configuration_length =  configuration -> ux_configuration_descriptor.wTotalLength;
 8005b00:	f8d8 7014 	ldr.w	r7, [r8, #20]
    descriptor =  _ux_utility_memory_allocate(UX_SAFE_ALIGN, UX_CACHE_SAFE_MEMORY, total_configuration_length);
 8005b04:	f04f 30ff 	mov.w	r0, #4294967295
 8005b08:	463a      	mov	r2, r7
 8005b0a:	f7fc f8ef 	bl	8001cec <_ux_utility_memory_allocate>

    /* Determine if the memory was allocated.  */
    if (descriptor == UX_NULL)
 8005b0e:	b328      	cbz	r0, 8005b5c <_ux_host_stack_configuration_descriptor_parse+0x68>
        /* Create a transfer_request for the GET_DESCRIPTOR request.  */
        transfer_request -> ux_transfer_request_data_pointer =      descriptor;
        transfer_request -> ux_transfer_request_requested_length =  total_configuration_length;
        transfer_request -> ux_transfer_request_function =          UX_GET_DESCRIPTOR;
        transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
        transfer_request -> ux_transfer_request_value =             configuration_index | (UINT)(UX_CONFIGURATION_DESCRIPTOR_ITEM << 8);
 8005b10:	f446 7600 	orr.w	r6, r6, #512	; 0x200
        transfer_request -> ux_transfer_request_function =          UX_GET_DESCRIPTOR;
 8005b14:	2106      	movs	r1, #6
        transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 8005b16:	2280      	movs	r2, #128	; 0x80
        transfer_request -> ux_transfer_request_index =             0;
 8005b18:	2300      	movs	r3, #0
        transfer_request -> ux_transfer_request_value =             configuration_index | (UINT)(UX_CONFIGURATION_DESCRIPTOR_ITEM << 8);
 8005b1a:	f8c4 60e0 	str.w	r6, [r4, #224]	; 0xe0
 8005b1e:	4605      	mov	r5, r0
        transfer_request -> ux_transfer_request_function =          UX_GET_DESCRIPTOR;
 8005b20:	f8c4 10dc 	str.w	r1, [r4, #220]	; 0xdc
        transfer_request -> ux_transfer_request_type =              UX_REQUEST_IN | UX_REQUEST_TYPE_STANDARD | UX_REQUEST_TARGET_DEVICE;
 8005b24:	f8c4 20d8 	str.w	r2, [r4, #216]	; 0xd8
        transfer_request -> ux_transfer_request_index =             0;
 8005b28:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
        transfer_request -> ux_transfer_request_requested_length =  total_configuration_length;
 8005b2c:	e9c4 0733 	strd	r0, r7, [r4, #204]	; 0xcc

        /* Send request to HCD layer.  */
        status =  _ux_host_stack_transfer_request(transfer_request);
 8005b30:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
 8005b34:	f7fe fc5c 	bl	80043f0 <_ux_host_stack_transfer_request>

        /* Check for correct transfer and entire descriptor returned.  */
        if((status == UX_SUCCESS) && (transfer_request -> ux_transfer_request_actual_length == total_configuration_length))
 8005b38:	4606      	mov	r6, r0
 8005b3a:	b128      	cbz	r0, 8005b48 <_ux_host_stack_configuration_descriptor_parse+0x54>
            status =  _ux_host_stack_interfaces_scan(configuration, descriptor);
        }
    }

    /* Free all used resources.  */
    _ux_utility_memory_free(descriptor);
 8005b3c:	4628      	mov	r0, r5
 8005b3e:	f7fc f9e9 	bl	8001f14 <_ux_utility_memory_free>

    /* Return completion status.  */
    return(status);
}
 8005b42:	4630      	mov	r0, r6
 8005b44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if((status == UX_SUCCESS) && (transfer_request -> ux_transfer_request_actual_length == total_configuration_length))
 8005b48:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
 8005b4c:	42bb      	cmp	r3, r7
 8005b4e:	d1f5      	bne.n	8005b3c <_ux_host_stack_configuration_descriptor_parse+0x48>
            status =  _ux_host_stack_interfaces_scan(configuration, descriptor);
 8005b50:	4640      	mov	r0, r8
 8005b52:	4629      	mov	r1, r5
 8005b54:	f000 f806 	bl	8005b64 <_ux_host_stack_interfaces_scan>
 8005b58:	4606      	mov	r6, r0
 8005b5a:	e7ef      	b.n	8005b3c <_ux_host_stack_configuration_descriptor_parse+0x48>
        return(UX_MEMORY_INSUFFICIENT);
 8005b5c:	2612      	movs	r6, #18
}
 8005b5e:	4630      	mov	r0, r6
 8005b60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005b64 <_ux_host_stack_interfaces_scan>:
/*                                                                        */ 
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_interfaces_scan(UX_CONFIGURATION *configuration, UCHAR * descriptor)
{
 8005b64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
ULONG                               interface_association_descriptor_present;
ULONG                               interface_in_iad_count;
UX_INTERFACE_ASSOCIATION_DESCRIPTOR interface_association;

    /* Retrieve the size of all the configuration descriptor.  */
    total_configuration_length =  configuration -> ux_configuration_descriptor.wTotalLength;
 8005b68:	6946      	ldr	r6, [r0, #20]
{
 8005b6a:	b088      	sub	sp, #32
    /* Set the IAD interface count to zero.  */
    interface_in_iad_count = 0;

    /* Scan the entire descriptor and search for interfaces. We should also ensure that 
       the descriptor is valid by verifying the length of each descriptor scanned.  */
    while (total_configuration_length)
 8005b6c:	2e00      	cmp	r6, #0
 8005b6e:	d04d      	beq.n	8005c0c <_ux_host_stack_interfaces_scan+0xa8>
    {

        /* Gather the length and type of the descriptor.  */
        descriptor_length =  *descriptor;
 8005b70:	780c      	ldrb	r4, [r1, #0]
 8005b72:	460d      	mov	r5, r1
        descriptor_type =    *(descriptor + 1);
 8005b74:	784b      	ldrb	r3, [r1, #1]

        /* Make sure this descriptor has at least the minimum length.  */
        if (descriptor_length < 3)
 8005b76:	2c02      	cmp	r4, #2
 8005b78:	d929      	bls.n	8005bce <_ux_host_stack_interfaces_scan+0x6a>
    interface_in_iad_count = 0;
 8005b7a:	f04f 0800 	mov.w	r8, #0
 8005b7e:	4607      	mov	r7, r0
        /* Check the type for an interface association descriptor.  */
        if (descriptor_type == UX_INTERFACE_ASSOCIATION_DESCRIPTOR_ITEM)
        {

            /* Parse the interface association descriptor and make it machine independent.  */
            _ux_utility_descriptor_parse(descriptor,
 8005b80:	f8df 9090 	ldr.w	r9, [pc, #144]	; 8005c14 <_ux_host_stack_interfaces_scan+0xb0>
    interface_association_descriptor_present = UX_FALSE;
 8005b84:	46c2      	mov	sl, r8
 8005b86:	e00e      	b.n	8005ba6 <_ux_host_stack_interfaces_scan+0x42>
            /* Memorize the number of interfaces attached to this IAD.  */
            interface_in_iad_count = interface_association.bInterfaceCount;
        }
        
        /* Check the type for an interface descriptor.  */
        if (descriptor_type == UX_INTERFACE_DESCRIPTOR_ITEM)
 8005b88:	2b04      	cmp	r3, #4
 8005b8a:	d029      	beq.n	8005be0 <_ux_host_stack_interfaces_scan+0x7c>
            if(status != UX_SUCCESS)
                return(status);
        }       

        /* Check the type for an OTG descriptor.  */
        if (descriptor_type == UX_OTG_DESCRIPTOR_ITEM)
 8005b8c:	2b09      	cmp	r3, #9
 8005b8e:	d101      	bne.n	8005b94 <_ux_host_stack_interfaces_scan+0x30>
        
            /* Retrieve the bmAttributes for SRP/HNP support.  */
            configuration -> ux_configuration_otg_capabilities = (ULONG) *(descriptor + UX_OTG_BM_ATTRIBUTES);
 8005b90:	78ab      	ldrb	r3, [r5, #2]
 8005b92:	60bb      	str	r3, [r7, #8]

        /* Verify if the descriptor is still valid.  */
        if (descriptor_length > total_configuration_length)
 8005b94:	42a6      	cmp	r6, r4
 8005b96:	d31a      	bcc.n	8005bce <_ux_host_stack_interfaces_scan+0x6a>
    while (total_configuration_length)
 8005b98:	1b36      	subs	r6, r6, r4
            UX_TRACE_IN_LINE_INSERT(UX_TRACE_ERROR, UX_DESCRIPTOR_CORRUPTED, descriptor, 0, 0, UX_TRACE_ERRORS, 0, 0)

            return(UX_DESCRIPTOR_CORRUPTED);
        }
        /* Jump to the next descriptor if we have not reached the end.  */
        descriptor +=  descriptor_length;
 8005b9a:	4425      	add	r5, r4
    while (total_configuration_length)
 8005b9c:	d036      	beq.n	8005c0c <_ux_host_stack_interfaces_scan+0xa8>
        descriptor_length =  *descriptor;
 8005b9e:	782c      	ldrb	r4, [r5, #0]
        descriptor_type =    *(descriptor + 1);
 8005ba0:	786b      	ldrb	r3, [r5, #1]
        if (descriptor_length < 3)
 8005ba2:	2c02      	cmp	r4, #2
 8005ba4:	d913      	bls.n	8005bce <_ux_host_stack_interfaces_scan+0x6a>
        if (descriptor_type == UX_INTERFACE_ASSOCIATION_DESCRIPTOR_ITEM)
 8005ba6:	2b0b      	cmp	r3, #11
 8005ba8:	d1ee      	bne.n	8005b88 <_ux_host_stack_interfaces_scan+0x24>
            _ux_utility_descriptor_parse(descriptor,
 8005baa:	466b      	mov	r3, sp
 8005bac:	2208      	movs	r2, #8
 8005bae:	4649      	mov	r1, r9
 8005bb0:	4628      	mov	r0, r5
 8005bb2:	f7fe fc91 	bl	80044d8 <_ux_utility_descriptor_parse>
            configuration -> ux_configuration_iad_protocol = interface_association.bFunctionProtocol;
 8005bb6:	9b06      	ldr	r3, [sp, #24]
        if (descriptor_length > total_configuration_length)
 8005bb8:	42a6      	cmp	r6, r4
            interface_association_descriptor_present = UX_TRUE;
 8005bba:	f04f 0a01 	mov.w	sl, #1
            configuration -> ux_configuration_iad_protocol = interface_association.bFunctionProtocol;
 8005bbe:	643b      	str	r3, [r7, #64]	; 0x40
            interface_in_iad_count = interface_association.bInterfaceCount;
 8005bc0:	f8dd 800c 	ldr.w	r8, [sp, #12]
            configuration -> ux_configuration_iad_subclass = interface_association.bFunctionSubClass;
 8005bc4:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
 8005bc8:	e9c7 120e 	strd	r1, r2, [r7, #56]	; 0x38
        if (descriptor_length > total_configuration_length)
 8005bcc:	d2e4      	bcs.n	8005b98 <_ux_host_stack_interfaces_scan+0x34>
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_DESCRIPTOR_CORRUPTED);
 8005bce:	2002      	movs	r0, #2
 8005bd0:	2242      	movs	r2, #66	; 0x42
 8005bd2:	2104      	movs	r1, #4
 8005bd4:	f7fc f814 	bl	8001c00 <_ux_system_error_handler>
            return(UX_DESCRIPTOR_CORRUPTED);
 8005bd8:	2042      	movs	r0, #66	; 0x42
        total_configuration_length -=  descriptor_length;
    }

    /* Return successful completion.  */
    return(UX_SUCCESS);
}
 8005bda:	b008      	add	sp, #32
 8005bdc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            status =  _ux_host_stack_new_interface_create(configuration, descriptor, total_configuration_length);
 8005be0:	4632      	mov	r2, r6
 8005be2:	4629      	mov	r1, r5
 8005be4:	4638      	mov	r0, r7
 8005be6:	f000 f817 	bl	8005c18 <_ux_host_stack_new_interface_create>
            if (interface_association_descriptor_present == UX_TRUE)
 8005bea:	f1ba 0f00 	cmp.w	sl, #0
 8005bee:	d102      	bne.n	8005bf6 <_ux_host_stack_interfaces_scan+0x92>
            if(status != UX_SUCCESS)
 8005bf0:	2800      	cmp	r0, #0
 8005bf2:	d0cf      	beq.n	8005b94 <_ux_host_stack_interfaces_scan+0x30>
 8005bf4:	e7f1      	b.n	8005bda <_ux_host_stack_interfaces_scan+0x76>
                if (interface_in_iad_count == 0)
 8005bf6:	f1b8 0801 	subs.w	r8, r8, #1
 8005bfa:	d1f9      	bne.n	8005bf0 <_ux_host_stack_interfaces_scan+0x8c>
                    interface_association_descriptor_present = UX_FALSE;
 8005bfc:	46c2      	mov	sl, r8
                    configuration -> ux_configuration_iad_protocol = 0;
 8005bfe:	f8c7 8040 	str.w	r8, [r7, #64]	; 0x40
                    configuration -> ux_configuration_iad_subclass = 0;
 8005c02:	e9c7 880e 	strd	r8, r8, [r7, #56]	; 0x38
            if(status != UX_SUCCESS)
 8005c06:	2800      	cmp	r0, #0
 8005c08:	d0c4      	beq.n	8005b94 <_ux_host_stack_interfaces_scan+0x30>
 8005c0a:	e7e6      	b.n	8005bda <_ux_host_stack_interfaces_scan+0x76>
    return(UX_SUCCESS);
 8005c0c:	2000      	movs	r0, #0
}
 8005c0e:	b008      	add	sp, #32
 8005c10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005c14:	200000e4 	.word	0x200000e4

08005c18 <_ux_host_stack_new_interface_create>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_new_interface_create(UX_CONFIGURATION *configuration,
                                            UCHAR * descriptor, ULONG length)
{
 8005c18:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005c1c:	4689      	mov	r9, r1
UINT                descriptor_type;
UINT                status;
UCHAR               *this_interface_descriptor;

    /* Obtain memory for storing this new interface.  */
    interface =  (UX_INTERFACE *) _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_INTERFACE));
 8005c1e:	2100      	movs	r1, #0
{
 8005c20:	4604      	mov	r4, r0
 8005c22:	4616      	mov	r6, r2
    interface =  (UX_INTERFACE *) _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_INTERFACE));
 8005c24:	4608      	mov	r0, r1
 8005c26:	2250      	movs	r2, #80	; 0x50
 8005c28:	f7fc f860 	bl	8001cec <_ux_utility_memory_allocate>
    
    /* If no memory left, exit with error.  */        
    if (interface == UX_NULL)
 8005c2c:	2800      	cmp	r0, #0
 8005c2e:	d048      	beq.n	8005cc2 <_ux_host_stack_new_interface_create+0xaa>
 8005c30:	4607      	mov	r7, r0
    /* Save the interface handle in the container, this is for ensuring the
       interface container is not corrupted.  */
    interface -> ux_interface_handle =  (ULONG) (ALIGN_TYPE) interface;

    /* Parse the interface descriptor and make it machine independent.  */
    _ux_utility_descriptor_parse(descriptor,
 8005c32:	f100 030c 	add.w	r3, r0, #12
 8005c36:	2209      	movs	r2, #9
 8005c38:	4926      	ldr	r1, [pc, #152]	; (8005cd4 <_ux_host_stack_new_interface_create+0xbc>)
    interface -> ux_interface_handle =  (ULONG) (ALIGN_TYPE) interface;
 8005c3a:	6038      	str	r0, [r7, #0]
    _ux_utility_descriptor_parse(descriptor,
 8005c3c:	4648      	mov	r0, r9
 8005c3e:	f7fe fc4b 	bl	80044d8 <_ux_utility_descriptor_parse>
    interface -> ux_interface_configuration =  configuration;
    
    /* If the interface belongs to an IAD, remember the IAD Class/SubClass/Protocol.  */
    interface -> ux_interface_iad_class    = configuration -> ux_configuration_iad_class;
    interface -> ux_interface_iad_subclass = configuration -> ux_configuration_iad_subclass;
    interface -> ux_interface_iad_protocol = configuration -> ux_configuration_iad_protocol;
 8005c42:	6c23      	ldr	r3, [r4, #64]	; 0x40

    /* There is 2 cases for the creation of the interface descriptor 
       if this is the first one, the interface descriptor is hooked
       to the configuration. If it is not the first one, the interface 
       is hooked to the end of the chain of interfaces.  */
    if (configuration -> ux_configuration_first_interface == UX_NULL)
 8005c44:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    interface -> ux_interface_iad_subclass = configuration -> ux_configuration_iad_subclass;
 8005c46:	e9d4 010e 	ldrd	r0, r1, [r4, #56]	; 0x38
    interface -> ux_interface_iad_class    = configuration -> ux_configuration_iad_class;
 8005c4a:	e9c7 4010 	strd	r4, r0, [r7, #64]	; 0x40
    interface -> ux_interface_iad_protocol = configuration -> ux_configuration_iad_protocol;
 8005c4e:	e9c7 1312 	strd	r1, r3, [r7, #72]	; 0x48
    if (configuration -> ux_configuration_first_interface == UX_NULL)
 8005c52:	b90a      	cbnz	r2, 8005c58 <_ux_host_stack_new_interface_create+0x40>
 8005c54:	e038      	b.n	8005cc8 <_ux_host_stack_new_interface_create+0xb0>
 8005c56:	461a      	mov	r2, r3
    {
    
        list_interface =  configuration -> ux_configuration_first_interface;
        
        /* Traverse the list until we reach the end */
        while (list_interface -> ux_interface_next_interface != UX_NULL)
 8005c58:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8005c5a:	2b00      	cmp	r3, #0
 8005c5c:	d1fb      	bne.n	8005c56 <_ux_host_stack_new_interface_create+0x3e>

            list_interface =  list_interface -> ux_interface_next_interface;
        }

        /* Hook the interface.  */
        list_interface -> ux_interface_next_interface =  interface;
 8005c5e:	63d7      	str	r7, [r2, #60]	; 0x3c
    }

    /* Traverse the interface in search of all endpoints that belong to it.
       We need the length remaining in the descriptor and the number of endpoints
       reported for this interface.  */
    number_endpoints =  interface -> ux_interface_descriptor.bNumEndpoints;
 8005c60:	f8d7 801c 	ldr.w	r8, [r7, #28]

    this_interface_descriptor = descriptor;

    while (length && (number_endpoints != 0))
 8005c64:	f1b8 0f00 	cmp.w	r8, #0
 8005c68:	d030      	beq.n	8005ccc <_ux_host_stack_new_interface_create+0xb4>
 8005c6a:	b37e      	cbz	r6, 8005ccc <_ux_host_stack_new_interface_create+0xb4>
    {

        /* Gather the length and type of the descriptor.  */
        descriptor_length =  *descriptor;
 8005c6c:	f899 4000 	ldrb.w	r4, [r9]
        descriptor_type =    *(descriptor+1);
 8005c70:	f899 3001 	ldrb.w	r3, [r9, #1]

        /* make sure this descriptor has at least the minimum length.  */
        if (descriptor_length < 3)
 8005c74:	2c02      	cmp	r4, #2
 8005c76:	d91c      	bls.n	8005cb2 <_ux_host_stack_new_interface_create+0x9a>
 8005c78:	464d      	mov	r5, r9
 8005c7a:	e00f      	b.n	8005c9c <_ux_host_stack_new_interface_create+0x84>

            number_endpoints--;
        }       

        /* Verify if the descriptor is still valid, or we moved to next interface.  */
        if ((descriptor_length > length) || (descriptor_type == UX_INTERFACE_DESCRIPTOR_ITEM && descriptor != this_interface_descriptor))
 8005c7c:	42a6      	cmp	r6, r4
 8005c7e:	d318      	bcc.n	8005cb2 <_ux_host_stack_new_interface_create+0x9a>
 8005c80:	2b04      	cmp	r3, #4
 8005c82:	d101      	bne.n	8005c88 <_ux_host_stack_new_interface_create+0x70>
 8005c84:	45a9      	cmp	r9, r5
 8005c86:	d114      	bne.n	8005cb2 <_ux_host_stack_new_interface_create+0x9a>
    while (length && (number_endpoints != 0))
 8005c88:	1b36      	subs	r6, r6, r4

            return(UX_DESCRIPTOR_CORRUPTED);
        }

        /* Jump to the next descriptor if we have not reached the end.  */
        descriptor +=  descriptor_length;
 8005c8a:	4425      	add	r5, r4
    while (length && (number_endpoints != 0))
 8005c8c:	d01e      	beq.n	8005ccc <_ux_host_stack_new_interface_create+0xb4>
 8005c8e:	f1b8 0f00 	cmp.w	r8, #0
 8005c92:	d01b      	beq.n	8005ccc <_ux_host_stack_new_interface_create+0xb4>
        descriptor_length =  *descriptor;
 8005c94:	782c      	ldrb	r4, [r5, #0]
        descriptor_type =    *(descriptor+1);
 8005c96:	786b      	ldrb	r3, [r5, #1]
        if (descriptor_length < 3)
 8005c98:	2c02      	cmp	r4, #2
 8005c9a:	d90a      	bls.n	8005cb2 <_ux_host_stack_new_interface_create+0x9a>
        if (descriptor_type == UX_ENDPOINT_DESCRIPTOR_ITEM)
 8005c9c:	2b05      	cmp	r3, #5
 8005c9e:	d1ed      	bne.n	8005c7c <_ux_host_stack_new_interface_create+0x64>
            status =  _ux_host_stack_new_endpoint_create(interface, descriptor);
 8005ca0:	4629      	mov	r1, r5
 8005ca2:	4638      	mov	r0, r7
            number_endpoints--;
 8005ca4:	f108 38ff 	add.w	r8, r8, #4294967295
            status =  _ux_host_stack_new_endpoint_create(interface, descriptor);
 8005ca8:	f000 f816 	bl	8005cd8 <_ux_host_stack_new_endpoint_create>
            if(status != UX_SUCCESS)
 8005cac:	b938      	cbnz	r0, 8005cbe <_ux_host_stack_new_interface_create+0xa6>
        if ((descriptor_length > length) || (descriptor_type == UX_INTERFACE_DESCRIPTOR_ITEM && descriptor != this_interface_descriptor))
 8005cae:	42a6      	cmp	r6, r4
 8005cb0:	d2ea      	bcs.n	8005c88 <_ux_host_stack_new_interface_create+0x70>
            _ux_system_error_handler(UX_SYSTEM_LEVEL_THREAD, UX_SYSTEM_CONTEXT_ENUMERATOR, UX_DESCRIPTOR_CORRUPTED);
 8005cb2:	2002      	movs	r0, #2
 8005cb4:	2242      	movs	r2, #66	; 0x42
 8005cb6:	2104      	movs	r1, #4
 8005cb8:	f7fb ffa2 	bl	8001c00 <_ux_system_error_handler>
            return(UX_DESCRIPTOR_CORRUPTED);
 8005cbc:	2042      	movs	r0, #66	; 0x42
        length -=  descriptor_length;
    }

    /* Return success!  */
    return(UX_SUCCESS);
}
 8005cbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8005cc2:	2012      	movs	r0, #18
}
 8005cc4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        configuration -> ux_configuration_first_interface =  interface;
 8005cc8:	62e7      	str	r7, [r4, #44]	; 0x2c
 8005cca:	e7c9      	b.n	8005c60 <_ux_host_stack_new_interface_create+0x48>
    return(UX_SUCCESS);
 8005ccc:	2000      	movs	r0, #0
}
 8005cce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005cd2:	bf00      	nop
 8005cd4:	200000ec 	.word	0x200000ec

08005cd8 <_ux_host_stack_new_endpoint_create>:
/*  05-19-2020     Chaoqiong Xiao           Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _ux_host_stack_new_endpoint_create(UX_INTERFACE *interface,
                                                 UCHAR * interface_endpoint)
{
 8005cd8:	b570      	push	{r4, r5, r6, lr}
 8005cda:	460e      	mov	r6, r1

UX_ENDPOINT     *endpoint;
UX_ENDPOINT     *list_endpoint;

    /* Obtain memory for storing this new endpoint.  */
    endpoint =  (UX_ENDPOINT *) _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_ENDPOINT));
 8005cdc:	2100      	movs	r1, #0
{
 8005cde:	4605      	mov	r5, r0
    endpoint =  (UX_ENDPOINT *) _ux_utility_memory_allocate(UX_NO_ALIGN, UX_REGULAR_MEMORY, sizeof(UX_ENDPOINT));
 8005ce0:	2298      	movs	r2, #152	; 0x98
 8005ce2:	4608      	mov	r0, r1
 8005ce4:	f7fc f802 	bl	8001cec <_ux_utility_memory_allocate>
    if (endpoint == UX_NULL)
 8005ce8:	b1b0      	cbz	r0, 8005d18 <_ux_host_stack_new_endpoint_create+0x40>
    /* The endpoint container has a built in transfer_request. 
       The transfer_request needs to point to the endpoint as well.  */
    endpoint -> ux_endpoint_transfer_request.ux_transfer_request_endpoint =  endpoint;

    /* Save the pointer to the device. This is useful for the HCD layer.  */
    endpoint -> ux_endpoint_device =  interface -> ux_interface_configuration -> ux_configuration_device;
 8005cea:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 8005cec:	4604      	mov	r4, r0

    /* Parse the interface descriptor and make it machine independent.  */
    _ux_utility_descriptor_parse(interface_endpoint,
 8005cee:	4630      	mov	r0, r6
    endpoint -> ux_endpoint_device =  interface -> ux_interface_configuration -> ux_configuration_device;
 8005cf0:	6b51      	ldr	r1, [r2, #52]	; 0x34
    _ux_utility_descriptor_parse(interface_endpoint,
 8005cf2:	f104 030c 	add.w	r3, r4, #12
    endpoint -> ux_endpoint =  (ULONG) (ALIGN_TYPE) endpoint;
 8005cf6:	6024      	str	r4, [r4, #0]
    _ux_utility_descriptor_parse(interface_endpoint,
 8005cf8:	2206      	movs	r2, #6
    endpoint -> ux_endpoint_device =  interface -> ux_interface_configuration -> ux_configuration_device;
 8005cfa:	62e1      	str	r1, [r4, #44]	; 0x2c
    endpoint -> ux_endpoint_transfer_request.ux_transfer_request_endpoint =  endpoint;
 8005cfc:	6364      	str	r4, [r4, #52]	; 0x34
    _ux_utility_descriptor_parse(interface_endpoint,
 8005cfe:	4909      	ldr	r1, [pc, #36]	; (8005d24 <_ux_host_stack_new_endpoint_create+0x4c>)
 8005d00:	f7fe fbea 	bl	80044d8 <_ux_utility_descriptor_parse>
    /* There is 2 cases for the creation of the endpoint descriptor 
       if this is the first one, the endpoint descriptor is hooked
       to the interface. 
       If it is not the first one, the endpoint is hooked to the
       end of the chain of endpoints.  */
    if (interface -> ux_interface_first_endpoint == UX_NULL)
 8005d04:	6bab      	ldr	r3, [r5, #56]	; 0x38
    endpoint -> ux_endpoint_interface =  interface;
 8005d06:	62a5      	str	r5, [r4, #40]	; 0x28
    if (interface -> ux_interface_first_endpoint == UX_NULL)
 8005d08:	b90b      	cbnz	r3, 8005d0e <_ux_host_stack_new_endpoint_create+0x36>
 8005d0a:	e007      	b.n	8005d1c <_ux_host_stack_new_endpoint_create+0x44>
 8005d0c:	4603      	mov	r3, r0
    {

        list_endpoint =  interface -> ux_interface_first_endpoint;
        
        /* Traverse the list until the end.  */
        while (list_endpoint -> ux_endpoint_next_endpoint != UX_NULL)
 8005d0e:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005d10:	2800      	cmp	r0, #0
 8005d12:	d1fb      	bne.n	8005d0c <_ux_host_stack_new_endpoint_create+0x34>
            list_endpoint =  list_endpoint -> ux_endpoint_next_endpoint;

        /* Hook the endpoint.  */
        list_endpoint -> ux_endpoint_next_endpoint =  endpoint;
 8005d14:	625c      	str	r4, [r3, #36]	; 0x24
    }

    /* Return successful status.  */
    return(UX_SUCCESS);
}
 8005d16:	bd70      	pop	{r4, r5, r6, pc}
        return(UX_MEMORY_INSUFFICIENT);
 8005d18:	2012      	movs	r0, #18
}
 8005d1a:	bd70      	pop	{r4, r5, r6, pc}
        interface -> ux_interface_first_endpoint =  endpoint;
 8005d1c:	63ac      	str	r4, [r5, #56]	; 0x38
    return(UX_SUCCESS);
 8005d1e:	4618      	mov	r0, r3
}
 8005d20:	bd70      	pop	{r4, r5, r6, pc}
 8005d22:	bf00      	nop
 8005d24:	200000d4 	.word	0x200000d4

08005d28 <_fx_system_initialize>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _fx_system_initialize(VOID)
{
 8005d28:	b570      	push	{r4, r5, r6, lr}
    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_SYSTEM_INITIALIZE, 0, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Initialize the head pointer of the opened media list and the
       number of opened media.  */
    _fx_system_media_opened_ptr =       FX_NULL;
 8005d2a:	2300      	movs	r3, #0
{
 8005d2c:	b084      	sub	sp, #16
       FX_UPDATE_RATE_IN_TICKS.  Note that the timer is not necessary for
       regular FileX operation - it is only needed for accurate system
       date and time stamps on files.  */

#ifndef FX_NO_TIMER
    tx_timer_create(&_fx_system_timer, "FileX System Timer", _fx_system_timer_entry, FX_TIMER_ID,
 8005d2e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8005d32:	2001      	movs	r0, #1
    _fx_system_media_opened_ptr =       FX_NULL;
 8005d34:	4917      	ldr	r1, [pc, #92]	; (8005d94 <_fx_system_initialize+0x6c>)
    _fx_system_media_max_fat_cache =     FX_MAX_FAT_CACHE;
 8005d36:	2510      	movs	r5, #16
    tx_timer_create(&_fx_system_timer, "FileX System Timer", _fx_system_timer_entry, FX_TIMER_ID,
 8005d38:	9002      	str	r0, [sp, #8]
    _fx_system_date =   FX_INITIAL_DATE;
 8005d3a:	f644 2621 	movw	r6, #18977	; 0x4a21
    tx_timer_create(&_fx_system_timer, "FileX System Timer", _fx_system_timer_entry, FX_TIMER_ID,
 8005d3e:	9201      	str	r2, [sp, #4]
    _fx_system_media_max_sector_cache =  FX_MAX_SECTOR_CACHE;
 8005d40:	f44f 7080 	mov.w	r0, #256	; 0x100
    tx_timer_create(&_fx_system_timer, "FileX System Timer", _fx_system_timer_entry, FX_TIMER_ID,
 8005d44:	9200      	str	r2, [sp, #0]
    _fx_system_media_opened_count =     0;
 8005d46:	4c14      	ldr	r4, [pc, #80]	; (8005d98 <_fx_system_initialize+0x70>)
    _fx_system_media_opened_ptr =       FX_NULL;
 8005d48:	600b      	str	r3, [r1, #0]
    _fx_system_time =   FX_INITIAL_TIME;
 8005d4a:	4914      	ldr	r1, [pc, #80]	; (8005d9c <_fx_system_initialize+0x74>)
    _fx_system_media_opened_count =     0;
 8005d4c:	6023      	str	r3, [r4, #0]
    _fx_system_time =   FX_INITIAL_TIME;
 8005d4e:	600b      	str	r3, [r1, #0]
    tx_timer_create(&_fx_system_timer, "FileX System Timer", _fx_system_timer_entry, FX_TIMER_ID,
 8005d50:	f103 438e 	add.w	r3, r3, #1191182336	; 0x47000000
    _fx_system_media_max_fat_cache =     FX_MAX_FAT_CACHE;
 8005d54:	4c12      	ldr	r4, [pc, #72]	; (8005da0 <_fx_system_initialize+0x78>)
    _fx_system_date =   FX_INITIAL_DATE;
 8005d56:	4a13      	ldr	r2, [pc, #76]	; (8005da4 <_fx_system_initialize+0x7c>)
    tx_timer_create(&_fx_system_timer, "FileX System Timer", _fx_system_timer_entry, FX_TIMER_ID,
 8005d58:	f1a3 13a7 	sub.w	r3, r3, #10944679	; 0xa700a7
    _fx_system_media_max_sector_cache =  FX_MAX_SECTOR_CACHE;
 8005d5c:	4912      	ldr	r1, [pc, #72]	; (8005da8 <_fx_system_initialize+0x80>)
    _fx_system_media_max_fat_cache =     FX_MAX_FAT_CACHE;
 8005d5e:	6025      	str	r5, [r4, #0]
    tx_timer_create(&_fx_system_timer, "FileX System Timer", _fx_system_timer_entry, FX_TIMER_ID,
 8005d60:	f5a3 432c 	sub.w	r3, r3, #44032	; 0xac00
    {
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)(FX_MAX_LONG_NAME_LEN & 0xFF)) << 24);
    }
    if (FX_MAX_LAST_NAME_LEN > 0xFF)
    {
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)0xFF) << 16);
 8005d64:	4d11      	ldr	r5, [pc, #68]	; (8005dac <_fx_system_initialize+0x84>)
    _fx_system_date =   FX_INITIAL_DATE;
 8005d66:	6016      	str	r6, [r2, #0]
    _fx_system_media_max_sector_cache =  FX_MAX_SECTOR_CACHE;
 8005d68:	6008      	str	r0, [r1, #0]
    tx_timer_create(&_fx_system_timer, "FileX System Timer", _fx_system_timer_entry, FX_TIMER_ID,
 8005d6a:	4a11      	ldr	r2, [pc, #68]	; (8005db0 <_fx_system_initialize+0x88>)
 8005d6c:	4911      	ldr	r1, [pc, #68]	; (8005db4 <_fx_system_initialize+0x8c>)
 8005d6e:	4812      	ldr	r0, [pc, #72]	; (8005db8 <_fx_system_initialize+0x90>)
 8005d70:	f006 fe7c 	bl	800ca6c <_tx_timer_create>
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | ((ULONG)0xFF);
    }
    else
    {
        _fx_system_build_options_2 =  _fx_system_build_options_2 | ((ULONG)FX_MAX_FAT_CACHE);
 8005d74:	4c11      	ldr	r4, [pc, #68]	; (8005dbc <_fx_system_initialize+0x94>)
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)0xFF) << 16);
 8005d76:	682a      	ldr	r2, [r5, #0]
 8005d78:	4911      	ldr	r1, [pc, #68]	; (8005dc0 <_fx_system_initialize+0x98>)
        _fx_system_build_options_2 =  _fx_system_build_options_2 | ((ULONG)FX_MAX_FAT_CACHE);
 8005d7a:	6823      	ldr	r3, [r4, #0]
    {
        _fx_system_build_options_3 =  _fx_system_build_options_3 | ((ULONG)0xFFFF);
    }
    else
    {
        _fx_system_build_options_3 =  _fx_system_build_options_3 | ((ULONG)FX_UPDATE_RATE_IN_TICKS);
 8005d7c:	4811      	ldr	r0, [pc, #68]	; (8005dc4 <_fx_system_initialize+0x9c>)
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)0xFF) << 16);
 8005d7e:	4311      	orrs	r1, r2
        _fx_system_build_options_2 =  _fx_system_build_options_2 | ((ULONG)FX_MAX_FAT_CACHE);
 8005d80:	4a11      	ldr	r2, [pc, #68]	; (8005dc8 <_fx_system_initialize+0xa0>)
        _fx_system_build_options_3 =  _fx_system_build_options_3 | ((ULONG)FX_UPDATE_RATE_IN_TICKS);
 8005d82:	6806      	ldr	r6, [r0, #0]
        _fx_system_build_options_2 =  _fx_system_build_options_2 | ((ULONG)FX_MAX_FAT_CACHE);
 8005d84:	431a      	orrs	r2, r3
        _fx_system_build_options_3 =  _fx_system_build_options_3 | ((ULONG)FX_UPDATE_RATE_IN_TICKS);
 8005d86:	4b11      	ldr	r3, [pc, #68]	; (8005dcc <_fx_system_initialize+0xa4>)
        _fx_system_build_options_1 =  _fx_system_build_options_1 | (((ULONG)0xFF) << 16);
 8005d88:	6029      	str	r1, [r5, #0]
        _fx_system_build_options_3 =  _fx_system_build_options_3 | ((ULONG)FX_UPDATE_RATE_IN_TICKS);
 8005d8a:	4333      	orrs	r3, r6
        _fx_system_build_options_2 =  _fx_system_build_options_2 | ((ULONG)FX_MAX_FAT_CACHE);
 8005d8c:	6022      	str	r2, [r4, #0]
        _fx_system_build_options_3 =  _fx_system_build_options_3 | ((ULONG)FX_UPDATE_RATE_IN_TICKS);
 8005d8e:	6003      	str	r3, [r0, #0]
    }
}
 8005d90:	b004      	add	sp, #16
 8005d92:	bd70      	pop	{r4, r5, r6, pc}
 8005d94:	20000e08 	.word	0x20000e08
 8005d98:	20000e00 	.word	0x20000e00
 8005d9c:	20000e14 	.word	0x20000e14
 8005da0:	20000e04 	.word	0x20000e04
 8005da4:	20000dfc 	.word	0x20000dfc
 8005da8:	20000df8 	.word	0x20000df8
 8005dac:	20000e0c 	.word	0x20000e0c
 8005db0:	08005dd1 	.word	0x08005dd1
 8005db4:	0800de60 	.word	0x0800de60
 8005db8:	20000dcc 	.word	0x20000dcc
 8005dbc:	20000dc8 	.word	0x20000dc8
 8005dc0:	ffff0000 	.word	0xffff0000
 8005dc4:	20000e10 	.word	0x20000e10
 8005dc8:	01008010 	.word	0x01008010
 8005dcc:	000a03e8 	.word	0x000a03e8

08005dd0 <_fx_system_timer_entry>:
UINT month;
UINT year;


    /* Determine if the ID is valid.  */
    if (id == FX_TIMER_ID)
 8005dd0:	4b67      	ldr	r3, [pc, #412]	; (8005f70 <_fx_system_timer_entry+0x1a0>)
 8005dd2:	4298      	cmp	r0, r3
 8005dd4:	d000      	beq.n	8005dd8 <_fx_system_timer_entry+0x8>
 8005dd6:	4770      	bx	lr
{
 8005dd8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    {

        /* Break the current date time into separate fields for easier work!  */
        second =  (_fx_system_time & FX_SECOND_MASK) * 2;
 8005ddc:	4d65      	ldr	r5, [pc, #404]	; (8005f74 <_fx_system_timer_entry+0x1a4>)
        minute =  (_fx_system_time >> FX_MINUTE_SHIFT) & FX_MINUTE_MASK;
        hour =    (_fx_system_time >> FX_HOUR_SHIFT) & FX_HOUR_MASK;
        day =     _fx_system_date & FX_DAY_MASK;
 8005dde:	4e66      	ldr	r6, [pc, #408]	; (8005f78 <_fx_system_timer_entry+0x1a8>)
        second =  (_fx_system_time & FX_SECOND_MASK) * 2;
 8005de0:	6829      	ldr	r1, [r5, #0]
        day =     _fx_system_date & FX_DAY_MASK;
 8005de2:	6834      	ldr	r4, [r6, #0]
        second =  (_fx_system_time & FX_SECOND_MASK) * 2;
 8005de4:	f001 001f 	and.w	r0, r1, #31
        minute =  (_fx_system_time >> FX_MINUTE_SHIFT) & FX_MINUTE_MASK;
 8005de8:	f3c1 1745 	ubfx	r7, r1, #5, #6
        month =   (_fx_system_date >> FX_MONTH_SHIFT) & FX_MONTH_MASK;
        year =    ((_fx_system_date >> FX_YEAR_SHIFT) & FX_YEAR_MASK) + FX_BASE_YEAR;
 8005dec:	f3c4 2e46 	ubfx	lr, r4, #9, #7
        day =     _fx_system_date & FX_DAY_MASK;
 8005df0:	f004 021f 	and.w	r2, r4, #31
        second =  (_fx_system_time & FX_SECOND_MASK) * 2;
 8005df4:	0040      	lsls	r0, r0, #1
        hour =    (_fx_system_time >> FX_HOUR_SHIFT) & FX_HOUR_MASK;
 8005df6:	f3c1 21c4 	ubfx	r1, r1, #11, #5
        year =    ((_fx_system_date >> FX_YEAR_SHIFT) & FX_YEAR_MASK) + FX_BASE_YEAR;
 8005dfa:	f20e 7cbc 	addw	ip, lr, #1980	; 0x7bc
        month =   (_fx_system_date >> FX_MONTH_SHIFT) & FX_MONTH_MASK;
 8005dfe:	f3c4 1443 	ubfx	r4, r4, #5, #4

        /* Now apply the "second" update.  */
        second =  second + FX_UPDATE_RATE_IN_SECONDS;
 8005e02:	f100 030a 	add.w	r3, r0, #10

        /* Determine if we need to adjust the minute field.  */
        if (second > FX_MAXIMUM_SECOND)
 8005e06:	2b3b      	cmp	r3, #59	; 0x3b
 8005e08:	d80e      	bhi.n	8005e28 <_fx_system_timer_entry+0x58>
 8005e0a:	02c9      	lsls	r1, r1, #11
 8005e0c:	ea42 1244 	orr.w	r2, r2, r4, lsl #5
        _fx_system_date =  ((year - FX_BASE_YEAR) << FX_YEAR_SHIFT) |
                            (month << FX_MONTH_SHIFT) | day;

        /* Set the new system time.  */
        _fx_system_time  =  (hour << FX_HOUR_SHIFT) |
                            (minute << FX_MINUTE_SHIFT) | (second / 2);
 8005e10:	085b      	lsrs	r3, r3, #1
        _fx_system_date =  ((year - FX_BASE_YEAR) << FX_YEAR_SHIFT) |
 8005e12:	f2ac 7cbc 	subw	ip, ip, #1980	; 0x7bc
                            (minute << FX_MINUTE_SHIFT) | (second / 2);
 8005e16:	ea43 1347 	orr.w	r3, r3, r7, lsl #5
                            (month << FX_MONTH_SHIFT) | day;
 8005e1a:	ea42 224c 	orr.w	r2, r2, ip, lsl #9
                            (minute << FX_MINUTE_SHIFT) | (second / 2);
 8005e1e:	430b      	orrs	r3, r1
        _fx_system_date =  ((year - FX_BASE_YEAR) << FX_YEAR_SHIFT) |
 8005e20:	6032      	str	r2, [r6, #0]
        _fx_system_time  =  (hour << FX_HOUR_SHIFT) |
 8005e22:	602b      	str	r3, [r5, #0]
    }
}
 8005e24:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            second =  second % 60;
 8005e28:	f8df 8150 	ldr.w	r8, [pc, #336]	; 8005f7c <_fx_system_timer_entry+0x1ac>
            minute =  minute + second / 60;
 8005e2c:	3701      	adds	r7, #1
            second =  second % 60;
 8005e2e:	fba8 9003 	umull	r9, r0, r8, r3
            if (minute > FX_MAXIMUM_MINUTE)
 8005e32:	2f3b      	cmp	r7, #59	; 0x3b
            second =  second % 60;
 8005e34:	ea4f 1050 	mov.w	r0, r0, lsr #5
 8005e38:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
 8005e3c:	eba3 0380 	sub.w	r3, r3, r0, lsl #2
            if (minute > FX_MAXIMUM_MINUTE)
 8005e40:	d9e3      	bls.n	8005e0a <_fx_system_timer_entry+0x3a>
                minute =  minute % 60;
 8005e42:	fba8 0807 	umull	r0, r8, r8, r7
                hour =    hour + minute / 60;
 8005e46:	3101      	adds	r1, #1
                minute =  minute % 60;
 8005e48:	ea4f 1858 	mov.w	r8, r8, lsr #5
                if (hour > FX_MAXIMUM_HOUR)
 8005e4c:	2917      	cmp	r1, #23
                minute =  minute % 60;
 8005e4e:	ebc8 1808 	rsb	r8, r8, r8, lsl #4
 8005e52:	eba7 0788 	sub.w	r7, r7, r8, lsl #2
                if (hour > FX_MAXIMUM_HOUR)
 8005e56:	d9d8      	bls.n	8005e0a <_fx_system_timer_entry+0x3a>
                    switch (month)
 8005e58:	3c01      	subs	r4, #1
                    day++;
 8005e5a:	3201      	adds	r2, #1
                    switch (month)
 8005e5c:	2c0b      	cmp	r4, #11
 8005e5e:	d8e1      	bhi.n	8005e24 <_fx_system_timer_entry+0x54>
 8005e60:	e8df f004 	tbb	[pc, r4]
 8005e64:	243e304a 	.word	0x243e304a
 8005e68:	1e382a44 	.word	0x1e382a44
 8005e6c:	060c1218 	.word	0x060c1218
                        if (day > 31)
 8005e70:	2a20      	cmp	r2, #32
 8005e72:	d04b      	beq.n	8005f0c <_fx_system_timer_entry+0x13c>
 8005e74:	f442 72c0 	orr.w	r2, r2, #384	; 0x180
 8005e78:	2100      	movs	r1, #0
 8005e7a:	e7c9      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if (day > 30)
 8005e7c:	2a1e      	cmp	r2, #30
 8005e7e:	d841      	bhi.n	8005f04 <_fx_system_timer_entry+0x134>
 8005e80:	f442 72b0 	orr.w	r2, r2, #352	; 0x160
 8005e84:	2100      	movs	r1, #0
 8005e86:	e7c3      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if (day > 31)
 8005e88:	2a20      	cmp	r2, #32
 8005e8a:	d04b      	beq.n	8005f24 <_fx_system_timer_entry+0x154>
 8005e8c:	f442 72a0 	orr.w	r2, r2, #320	; 0x140
 8005e90:	2100      	movs	r1, #0
 8005e92:	e7bd      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if (day > 30)
 8005e94:	2a1e      	cmp	r2, #30
 8005e96:	d841      	bhi.n	8005f1c <_fx_system_timer_entry+0x14c>
 8005e98:	f442 7290 	orr.w	r2, r2, #288	; 0x120
 8005e9c:	2100      	movs	r1, #0
 8005e9e:	e7b7      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if (day > 31)
 8005ea0:	2a20      	cmp	r2, #32
 8005ea2:	d052      	beq.n	8005f4a <_fx_system_timer_entry+0x17a>
 8005ea4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8005ea8:	2100      	movs	r1, #0
 8005eaa:	e7b1      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if (day > 30)
 8005eac:	2a1e      	cmp	r2, #30
 8005eae:	d846      	bhi.n	8005f3e <_fx_system_timer_entry+0x16e>
 8005eb0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8005eb4:	2100      	movs	r1, #0
 8005eb6:	e7ab      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if (day > 30)
 8005eb8:	2a1e      	cmp	r2, #30
 8005eba:	d84e      	bhi.n	8005f5a <_fx_system_timer_entry+0x18a>
 8005ebc:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8005ec0:	2100      	movs	r1, #0
 8005ec2:	e7a5      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if ((year % 4) == 0)
 8005ec4:	f01c 0103 	ands.w	r1, ip, #3
 8005ec8:	d133      	bne.n	8005f32 <_fx_system_timer_entry+0x162>
                            if (day > 29)
 8005eca:	2a1d      	cmp	r2, #29
 8005ecc:	d84b      	bhi.n	8005f66 <_fx_system_timer_entry+0x196>
 8005ece:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8005ed2:	e79d      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if (day > 31)
 8005ed4:	2a20      	cmp	r2, #32
 8005ed6:	d03c      	beq.n	8005f52 <_fx_system_timer_entry+0x182>
 8005ed8:	f042 02e0 	orr.w	r2, r2, #224	; 0xe0
 8005edc:	2100      	movs	r1, #0
 8005ede:	e797      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if (day > 31)
 8005ee0:	2a20      	cmp	r2, #32
 8005ee2:	d02f      	beq.n	8005f44 <_fx_system_timer_entry+0x174>
 8005ee4:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 8005ee8:	2100      	movs	r1, #0
 8005eea:	e791      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if (day > 31)
 8005eec:	2a20      	cmp	r2, #32
 8005eee:	d037      	beq.n	8005f60 <_fx_system_timer_entry+0x190>
 8005ef0:	f042 02a0 	orr.w	r2, r2, #160	; 0xa0
 8005ef4:	2100      	movs	r1, #0
 8005ef6:	e78b      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                        if (day > 31)
 8005ef8:	2a20      	cmp	r2, #32
 8005efa:	d017      	beq.n	8005f2c <_fx_system_timer_entry+0x15c>
 8005efc:	f042 0220 	orr.w	r2, r2, #32
 8005f00:	2100      	movs	r1, #0
 8005f02:	e785      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f04:	f240 1281 	movw	r2, #385	; 0x181
 8005f08:	2100      	movs	r1, #0
 8005f0a:	e781      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                            if (year > FX_MAXIMUM_YEAR)
 8005f0c:	f1be 0f7f 	cmp.w	lr, #127	; 0x7f
 8005f10:	f20e 7cbd 	addw	ip, lr, #1981	; 0x7bd
 8005f14:	d086      	beq.n	8005e24 <_fx_system_timer_entry+0x54>
 8005f16:	2221      	movs	r2, #33	; 0x21
 8005f18:	2100      	movs	r1, #0
 8005f1a:	e779      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f1c:	f240 1241 	movw	r2, #321	; 0x141
 8005f20:	2100      	movs	r1, #0
 8005f22:	e775      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f24:	f240 1261 	movw	r2, #353	; 0x161
 8005f28:	2100      	movs	r1, #0
 8005f2a:	e771      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f2c:	2241      	movs	r2, #65	; 0x41
 8005f2e:	2100      	movs	r1, #0
 8005f30:	e76e      	b.n	8005e10 <_fx_system_timer_entry+0x40>
                            if (day > 28)
 8005f32:	2a1c      	cmp	r2, #28
 8005f34:	d819      	bhi.n	8005f6a <_fx_system_timer_entry+0x19a>
 8005f36:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8005f3a:	2100      	movs	r1, #0
 8005f3c:	e768      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f3e:	22a1      	movs	r2, #161	; 0xa1
 8005f40:	2100      	movs	r1, #0
 8005f42:	e765      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f44:	2281      	movs	r2, #129	; 0x81
 8005f46:	2100      	movs	r1, #0
 8005f48:	e762      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f4a:	f240 1221 	movw	r2, #289	; 0x121
 8005f4e:	2100      	movs	r1, #0
 8005f50:	e75e      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f52:	f240 1201 	movw	r2, #257	; 0x101
 8005f56:	2100      	movs	r1, #0
 8005f58:	e75a      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f5a:	22e1      	movs	r2, #225	; 0xe1
 8005f5c:	2100      	movs	r1, #0
 8005f5e:	e757      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f60:	22c1      	movs	r2, #193	; 0xc1
 8005f62:	2100      	movs	r1, #0
 8005f64:	e754      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f66:	2261      	movs	r2, #97	; 0x61
 8005f68:	e752      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f6a:	2261      	movs	r2, #97	; 0x61
 8005f6c:	2100      	movs	r1, #0
 8005f6e:	e74f      	b.n	8005e10 <_fx_system_timer_entry+0x40>
 8005f70:	46585359 	.word	0x46585359
 8005f74:	20000e14 	.word	0x20000e14
 8005f78:	20000dfc 	.word	0x20000dfc
 8005f7c:	88888889 	.word	0x88888889

08005f80 <_fxe_directory_first_entry_find>:

UINT status;


    /* Check for a null media pointer.  */
    if (media_ptr == FX_NULL)
 8005f80:	b178      	cbz	r0, 8005fa2 <_fxe_directory_first_entry_find+0x22>
__attribute__( ( always_inline ) ) static inline unsigned int __get_ipsr_value(void)
{

unsigned int  ipsr_value;

    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 8005f82:	f3ef 8305 	mrs	r3, IPSR
    {
        return(FX_PTR_ERROR);
    }

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE
 8005f86:	4a08      	ldr	r2, [pc, #32]	; (8005fa8 <_fxe_directory_first_entry_find+0x28>)
 8005f88:	6812      	ldr	r2, [r2, #0]
 8005f8a:	4313      	orrs	r3, r2
 8005f8c:	d107      	bne.n	8005f9e <_fxe_directory_first_entry_find+0x1e>
 8005f8e:	4b07      	ldr	r3, [pc, #28]	; (8005fac <_fxe_directory_first_entry_find+0x2c>)
 8005f90:	4a07      	ldr	r2, [pc, #28]	; (8005fb0 <_fxe_directory_first_entry_find+0x30>)
 8005f92:	681b      	ldr	r3, [r3, #0]
 8005f94:	4293      	cmp	r3, r2
 8005f96:	d002      	beq.n	8005f9e <_fxe_directory_first_entry_find+0x1e>
 8005f98:	b10b      	cbz	r3, 8005f9e <_fxe_directory_first_entry_find+0x1e>

    /* Call actual directory find first service.  */
    status =  _fx_directory_first_entry_find(media_ptr, directory_name);
 8005f9a:	f000 b969 	b.w	8006270 <_fx_directory_first_entry_find>
    FX_CALLER_CHECKING_CODE
 8005f9e:	2020      	movs	r0, #32

    /* Return status to the caller.  */
    return(status);
}
 8005fa0:	4770      	bx	lr
        return(FX_PTR_ERROR);
 8005fa2:	2018      	movs	r0, #24
 8005fa4:	4770      	bx	lr
 8005fa6:	bf00      	nop
 8005fa8:	20000164 	.word	0x20000164
 8005fac:	20000f2c 	.word	0x20000f2c
 8005fb0:	20000fd8 	.word	0x20000fd8

08005fb4 <_fxe_directory_next_entry_find>:

UINT status;


    /* Check for a null media pointer.  */
    if (media_ptr == FX_NULL)
 8005fb4:	b178      	cbz	r0, 8005fd6 <_fxe_directory_next_entry_find+0x22>
 8005fb6:	f3ef 8305 	mrs	r3, IPSR
    {
        return(FX_PTR_ERROR);
    }

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE
 8005fba:	4a08      	ldr	r2, [pc, #32]	; (8005fdc <_fxe_directory_next_entry_find+0x28>)
 8005fbc:	6812      	ldr	r2, [r2, #0]
 8005fbe:	4313      	orrs	r3, r2
 8005fc0:	d107      	bne.n	8005fd2 <_fxe_directory_next_entry_find+0x1e>
 8005fc2:	4b07      	ldr	r3, [pc, #28]	; (8005fe0 <_fxe_directory_next_entry_find+0x2c>)
 8005fc4:	4a07      	ldr	r2, [pc, #28]	; (8005fe4 <_fxe_directory_next_entry_find+0x30>)
 8005fc6:	681b      	ldr	r3, [r3, #0]
 8005fc8:	4293      	cmp	r3, r2
 8005fca:	d002      	beq.n	8005fd2 <_fxe_directory_next_entry_find+0x1e>
 8005fcc:	b10b      	cbz	r3, 8005fd2 <_fxe_directory_next_entry_find+0x1e>

    /* Call actual next directory entry find service.  */
    status =  _fx_directory_next_entry_find(media_ptr, directory_name);
 8005fce:	f000 b97d 	b.w	80062cc <_fx_directory_next_entry_find>
    FX_CALLER_CHECKING_CODE
 8005fd2:	2020      	movs	r0, #32

    /* Return status to the caller.  */
    return(status);
}
 8005fd4:	4770      	bx	lr
        return(FX_PTR_ERROR);
 8005fd6:	2018      	movs	r0, #24
 8005fd8:	4770      	bx	lr
 8005fda:	bf00      	nop
 8005fdc:	20000164 	.word	0x20000164
 8005fe0:	20000f2c 	.word	0x20000f2c
 8005fe4:	20000fd8 	.word	0x20000fd8

08005fe8 <_fxe_file_attributes_read>:
{

UINT status;

    /* Check for a null media or attributes pointer.  */
    if ((media_ptr == FX_NULL) || (attributes_ptr == FX_NULL))
 8005fe8:	b1a8      	cbz	r0, 8006016 <_fxe_file_attributes_read+0x2e>
 8005fea:	b1a2      	cbz	r2, 8006016 <_fxe_file_attributes_read+0x2e>
{
 8005fec:	b410      	push	{r4}
 8005fee:	f3ef 8305 	mrs	r3, IPSR
    {
        return(FX_PTR_ERROR);
    }

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE
 8005ff2:	4c0a      	ldr	r4, [pc, #40]	; (800601c <_fxe_file_attributes_read+0x34>)
 8005ff4:	6824      	ldr	r4, [r4, #0]
 8005ff6:	4323      	orrs	r3, r4
 8005ff8:	d109      	bne.n	800600e <_fxe_file_attributes_read+0x26>
 8005ffa:	4b09      	ldr	r3, [pc, #36]	; (8006020 <_fxe_file_attributes_read+0x38>)
 8005ffc:	4c09      	ldr	r4, [pc, #36]	; (8006024 <_fxe_file_attributes_read+0x3c>)
 8005ffe:	681b      	ldr	r3, [r3, #0]
 8006000:	42a3      	cmp	r3, r4
 8006002:	d004      	beq.n	800600e <_fxe_file_attributes_read+0x26>
 8006004:	b11b      	cbz	r3, 800600e <_fxe_file_attributes_read+0x26>
    /* Call actual read file attributes service.  */
    status =  _fx_file_attributes_read(media_ptr, file_name, attributes_ptr);

    /* File attribute read is complete, return status.  */
    return(status);
}
 8006006:	f85d 4b04 	ldr.w	r4, [sp], #4
    status =  _fx_file_attributes_read(media_ptr, file_name, attributes_ptr);
 800600a:	f000 baa1 	b.w	8006550 <_fx_file_attributes_read>
    FX_CALLER_CHECKING_CODE
 800600e:	2020      	movs	r0, #32
}
 8006010:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006014:	4770      	bx	lr
        return(FX_PTR_ERROR);
 8006016:	2018      	movs	r0, #24
}
 8006018:	4770      	bx	lr
 800601a:	bf00      	nop
 800601c:	20000164 	.word	0x20000164
 8006020:	20000f2c 	.word	0x20000f2c
 8006024:	20000fd8 	.word	0x20000fd8

08006028 <_fxe_file_close>:

UINT status;


    /* Check for a null file pointer.  */
    if (file_ptr == FX_NULL)
 8006028:	b178      	cbz	r0, 800604a <_fxe_file_close+0x22>
 800602a:	f3ef 8305 	mrs	r3, IPSR
    {
        return(FX_PTR_ERROR);
    }

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE
 800602e:	4a08      	ldr	r2, [pc, #32]	; (8006050 <_fxe_file_close+0x28>)
 8006030:	6812      	ldr	r2, [r2, #0]
 8006032:	4313      	orrs	r3, r2
 8006034:	d107      	bne.n	8006046 <_fxe_file_close+0x1e>
 8006036:	4b07      	ldr	r3, [pc, #28]	; (8006054 <_fxe_file_close+0x2c>)
 8006038:	4a07      	ldr	r2, [pc, #28]	; (8006058 <_fxe_file_close+0x30>)
 800603a:	681b      	ldr	r3, [r3, #0]
 800603c:	4293      	cmp	r3, r2
 800603e:	d002      	beq.n	8006046 <_fxe_file_close+0x1e>
 8006040:	b10b      	cbz	r3, 8006046 <_fxe_file_close+0x1e>

    /* Call actual file close service.  */
    status =  _fx_file_close(file_ptr);
 8006042:	f000 bac3 	b.w	80065cc <_fx_file_close>
    FX_CALLER_CHECKING_CODE
 8006046:	2020      	movs	r0, #32

    /* Return status to the caller.  */
    return(status);
}
 8006048:	4770      	bx	lr
        return(FX_PTR_ERROR);
 800604a:	2018      	movs	r0, #24
 800604c:	4770      	bx	lr
 800604e:	bf00      	nop
 8006050:	20000164 	.word	0x20000164
 8006054:	20000f2c 	.word	0x20000f2c
 8006058:	20000fd8 	.word	0x20000fd8

0800605c <_fxe_file_open>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fxe_file_open(FX_MEDIA *media_ptr, FX_FILE *file_ptr, CHAR *file_name, UINT open_type, UINT file_control_block_size)
{
 800605c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006060:	9e06      	ldr	r6, [sp, #24]
FX_FILE *current_file;
ULONG    open_count;


    /* Check for a null media or file pointer.  */
    if ((media_ptr == FX_NULL) || (media_ptr -> fx_media_id != FX_MEDIA_ID) || (file_ptr == FX_NULL) || (file_control_block_size != sizeof(FX_FILE)))
 8006062:	b388      	cbz	r0, 80060c8 <_fxe_file_open+0x6c>
 8006064:	4c23      	ldr	r4, [pc, #140]	; (80060f4 <_fxe_file_open+0x98>)
 8006066:	6805      	ldr	r5, [r0, #0]
 8006068:	42a5      	cmp	r5, r4
 800606a:	d12d      	bne.n	80060c8 <_fxe_file_open+0x6c>
 800606c:	b361      	cbz	r1, 80060c8 <_fxe_file_open+0x6c>
 800606e:	f5b6 7ff0 	cmp.w	r6, #480	; 0x1e0
 8006072:	d129      	bne.n	80060c8 <_fxe_file_open+0x6c>
    {
        return(FX_PTR_ERROR);
    }

    /* Check for an invalid open type.  */
    if ((open_type != FX_OPEN_FOR_READ) && (open_type != FX_OPEN_FOR_READ_FAST) && (open_type != FX_OPEN_FOR_WRITE))
 8006074:	2b02      	cmp	r3, #2
 8006076:	d82d      	bhi.n	80060d4 <_fxe_file_open+0x78>
 8006078:	f3ef 8405 	mrs	r4, IPSR
    {
        return(FX_ACCESS_ERROR);
    }

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE
 800607c:	4d1e      	ldr	r5, [pc, #120]	; (80060f8 <_fxe_file_open+0x9c>)
 800607e:	682d      	ldr	r5, [r5, #0]
 8006080:	432c      	orrs	r4, r5
 8006082:	d124      	bne.n	80060ce <_fxe_file_open+0x72>
 8006084:	4c1d      	ldr	r4, [pc, #116]	; (80060fc <_fxe_file_open+0xa0>)
 8006086:	4d1e      	ldr	r5, [pc, #120]	; (8006100 <_fxe_file_open+0xa4>)
 8006088:	6824      	ldr	r4, [r4, #0]
 800608a:	42ac      	cmp	r4, r5
 800608c:	d01f      	beq.n	80060ce <_fxe_file_open+0x72>
 800608e:	b1f4      	cbz	r4, 80060ce <_fxe_file_open+0x72>

    /* Get protection.  */
    FX_PROTECT
 8006090:	f500 76e4 	add.w	r6, r0, #456	; 0x1c8
 8006094:	4604      	mov	r4, r0
 8006096:	460d      	mov	r5, r1
 8006098:	f04f 31ff 	mov.w	r1, #4294967295
 800609c:	4630      	mov	r0, r6
 800609e:	461f      	mov	r7, r3
 80060a0:	4690      	mov	r8, r2
 80060a2:	f006 f8b9 	bl	800c218 <_tx_mutex_get>
 80060a6:	bb10      	cbnz	r0, 80060ee <_fxe_file_open+0x92>

    /* Check for a duplicate file open.  */

    /* Loop to search the list for the same file handle.  */
    current_file =  media_ptr -> fx_media_opened_file_list;
 80060a8:	e9d4 3232 	ldrd	r3, r2, [r4, #200]	; 0xc8
    open_count =    media_ptr -> fx_media_opened_file_count;

    while (open_count--)
 80060ac:	1e51      	subs	r1, r2, #1
 80060ae:	b922      	cbnz	r2, 80060ba <_fxe_file_open+0x5e>
 80060b0:	e012      	b.n	80060d8 <_fxe_file_open+0x7c>
 80060b2:	3901      	subs	r1, #1
            /* Return error.  */
            return(FX_PTR_ERROR);
        }

        /* Move to the next opened file.  */
        current_file =  current_file -> fx_file_opened_next;
 80060b4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    while (open_count--)
 80060b6:	1c4a      	adds	r2, r1, #1
 80060b8:	d00e      	beq.n	80060d8 <_fxe_file_open+0x7c>
        if (file_ptr == current_file)
 80060ba:	429d      	cmp	r5, r3
 80060bc:	d1f9      	bne.n	80060b2 <_fxe_file_open+0x56>
            FX_UNPROTECT
 80060be:	4630      	mov	r0, r6
 80060c0:	f006 f994 	bl	800c3ec <_tx_mutex_put>
            return(FX_PTR_ERROR);
 80060c4:	2018      	movs	r0, #24
 80060c6:	e000      	b.n	80060ca <_fxe_file_open+0x6e>
        return(FX_PTR_ERROR);
 80060c8:	2018      	movs	r0, #24
    /* Call actual file open service.  */
    status =  _fx_file_open(media_ptr, file_ptr, file_name, open_type);

    /* Open is complete, return status.  */
    return(status);
}
 80060ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FX_CALLER_CHECKING_CODE
 80060ce:	2020      	movs	r0, #32
}
 80060d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return(FX_ACCESS_ERROR);
 80060d4:	2006      	movs	r0, #6
 80060d6:	e7f8      	b.n	80060ca <_fxe_file_open+0x6e>
    FX_UNPROTECT
 80060d8:	4630      	mov	r0, r6
 80060da:	f006 f987 	bl	800c3ec <_tx_mutex_put>
    status =  _fx_file_open(media_ptr, file_ptr, file_name, open_type);
 80060de:	463b      	mov	r3, r7
 80060e0:	4642      	mov	r2, r8
 80060e2:	4629      	mov	r1, r5
 80060e4:	4620      	mov	r0, r4
}
 80060e6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    status =  _fx_file_open(media_ptr, file_ptr, file_name, open_type);
 80060ea:	f000 badd 	b.w	80066a8 <_fx_file_open>
    FX_PROTECT
 80060ee:	2011      	movs	r0, #17
 80060f0:	e7eb      	b.n	80060ca <_fxe_file_open+0x6e>
 80060f2:	bf00      	nop
 80060f4:	4d454449 	.word	0x4d454449
 80060f8:	20000164 	.word	0x20000164
 80060fc:	20000f2c 	.word	0x20000f2c
 8006100:	20000fd8 	.word	0x20000fd8

08006104 <_fxe_file_read>:

UINT status;


    /* Check for a null file or buffer pointer.  */
    if ((file_ptr == FX_NULL) || (buffer_ptr == FX_NULL) || (actual_size == FX_NULL))
 8006104:	2b00      	cmp	r3, #0
 8006106:	bf18      	it	ne
 8006108:	2900      	cmpne	r1, #0
 800610a:	d016      	beq.n	800613a <_fxe_file_read+0x36>
{
 800610c:	b430      	push	{r4, r5}
    if ((file_ptr == FX_NULL) || (buffer_ptr == FX_NULL) || (actual_size == FX_NULL))
 800610e:	b188      	cbz	r0, 8006134 <_fxe_file_read+0x30>
 8006110:	f3ef 8405 	mrs	r4, IPSR
    {
        return(FX_PTR_ERROR);
    }

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE
 8006114:	4d0a      	ldr	r5, [pc, #40]	; (8006140 <_fxe_file_read+0x3c>)
 8006116:	682d      	ldr	r5, [r5, #0]
 8006118:	432c      	orrs	r4, r5
 800611a:	d108      	bne.n	800612e <_fxe_file_read+0x2a>
 800611c:	4c09      	ldr	r4, [pc, #36]	; (8006144 <_fxe_file_read+0x40>)
 800611e:	6824      	ldr	r4, [r4, #0]
 8006120:	b12c      	cbz	r4, 800612e <_fxe_file_read+0x2a>
 8006122:	4d09      	ldr	r5, [pc, #36]	; (8006148 <_fxe_file_read+0x44>)
 8006124:	42ac      	cmp	r4, r5
 8006126:	d002      	beq.n	800612e <_fxe_file_read+0x2a>
    /* Call actual file read service.  */
    status =  _fx_file_read(file_ptr, buffer_ptr, request_size, actual_size);

    /* Return status to the caller.  */
    return(status);
}
 8006128:	bc30      	pop	{r4, r5}
    status =  _fx_file_read(file_ptr, buffer_ptr, request_size, actual_size);
 800612a:	f000 bcfb 	b.w	8006b24 <_fx_file_read>
    FX_CALLER_CHECKING_CODE
 800612e:	2020      	movs	r0, #32
}
 8006130:	bc30      	pop	{r4, r5}
 8006132:	4770      	bx	lr
        return(FX_PTR_ERROR);
 8006134:	2018      	movs	r0, #24
}
 8006136:	bc30      	pop	{r4, r5}
 8006138:	4770      	bx	lr
        return(FX_PTR_ERROR);
 800613a:	2018      	movs	r0, #24
}
 800613c:	4770      	bx	lr
 800613e:	bf00      	nop
 8006140:	20000164 	.word	0x20000164
 8006144:	20000f2c 	.word	0x20000f2c
 8006148:	20000fd8 	.word	0x20000fd8

0800614c <_fxe_media_close>:

UINT status;


    /* Check for a null media pointer.  */
    if (media_ptr == FX_NULL)
 800614c:	b178      	cbz	r0, 800616e <_fxe_media_close+0x22>
 800614e:	f3ef 8305 	mrs	r3, IPSR
    {
        return(FX_PTR_ERROR);
    }

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE
 8006152:	4a08      	ldr	r2, [pc, #32]	; (8006174 <_fxe_media_close+0x28>)
 8006154:	6812      	ldr	r2, [r2, #0]
 8006156:	4313      	orrs	r3, r2
 8006158:	d107      	bne.n	800616a <_fxe_media_close+0x1e>
 800615a:	4b07      	ldr	r3, [pc, #28]	; (8006178 <_fxe_media_close+0x2c>)
 800615c:	4a07      	ldr	r2, [pc, #28]	; (800617c <_fxe_media_close+0x30>)
 800615e:	681b      	ldr	r3, [r3, #0]
 8006160:	4293      	cmp	r3, r2
 8006162:	d002      	beq.n	800616a <_fxe_media_close+0x1e>
 8006164:	b10b      	cbz	r3, 800616a <_fxe_media_close+0x1e>

    /* Call actual media close service.  */
    status =  _fx_media_close(media_ptr);
 8006166:	f000 be67 	b.w	8006e38 <_fx_media_close>
    FX_CALLER_CHECKING_CODE
 800616a:	2020      	movs	r0, #32

    /* Return status to the caller.  */
    return(status);
}
 800616c:	4770      	bx	lr
        return(FX_PTR_ERROR);
 800616e:	2018      	movs	r0, #24
 8006170:	4770      	bx	lr
 8006172:	bf00      	nop
 8006174:	20000164 	.word	0x20000164
 8006178:	20000f2c 	.word	0x20000f2c
 800617c:	20000fd8 	.word	0x20000fd8

08006180 <_fxe_media_open>:
UINT       old_threshold;
#endif


    /* Check for invalid input pointers.  */
    if ((media_ptr == FX_NULL) || (media_driver == FX_NULL) || (memory_ptr == FX_NULL) || (media_control_block_size != sizeof(FX_MEDIA)))
 8006180:	2800      	cmp	r0, #0
 8006182:	d031      	beq.n	80061e8 <_fxe_media_open+0x68>
 8006184:	2a00      	cmp	r2, #0
 8006186:	d02f      	beq.n	80061e8 <_fxe_media_open+0x68>
{
 8006188:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800618c:	b085      	sub	sp, #20
    if ((media_ptr == FX_NULL) || (media_driver == FX_NULL) || (memory_ptr == FX_NULL) || (media_control_block_size != sizeof(FX_MEDIA)))
 800618e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8006190:	b334      	cbz	r4, 80061e0 <_fxe_media_open+0x60>
 8006192:	f242 44b8 	movw	r4, #9400	; 0x24b8
 8006196:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8006198:	42a5      	cmp	r5, r4
 800619a:	d121      	bne.n	80061e0 <_fxe_media_open+0x60>
 800619c:	f3ef 8405 	mrs	r4, IPSR
    {
        return(FX_PTR_ERROR);
    }

    /* Check for a valid caller.  */
    FX_CALLER_CHECKING_CODE
 80061a0:	4d2c      	ldr	r5, [pc, #176]	; (8006254 <_fxe_media_open+0xd4>)
 80061a2:	682d      	ldr	r5, [r5, #0]
 80061a4:	432c      	orrs	r4, r5
 80061a6:	d121      	bne.n	80061ec <_fxe_media_open+0x6c>
 80061a8:	4c2b      	ldr	r4, [pc, #172]	; (8006258 <_fxe_media_open+0xd8>)
 80061aa:	4d2c      	ldr	r5, [pc, #176]	; (800625c <_fxe_media_open+0xdc>)
 80061ac:	6824      	ldr	r4, [r4, #0]
 80061ae:	42ac      	cmp	r4, r5
 80061b0:	d01c      	beq.n	80061ec <_fxe_media_open+0x6c>
 80061b2:	b1dc      	cbz	r4, 80061ec <_fxe_media_open+0x6c>

    /* Check for proper size of the logical sector cache.  */
    temp =  _fx_system_media_max_sector_cache;
 80061b4:	4c2a      	ldr	r4, [pc, #168]	; (8006260 <_fxe_media_open+0xe0>)
 80061b6:	6825      	ldr	r5, [r4, #0]

    /* Isolate the lowest set bit.  */
    temp =  (temp & ((~temp) + ((ULONG) 1)));
 80061b8:	426c      	negs	r4, r5
 80061ba:	402c      	ands	r4, r5

    /* If FX_MAX_SECTOR_CACHE is a power of 2, the value of temp should be unchanged.  */
    if ((temp == 1) || (temp != _fx_system_media_max_sector_cache))
 80061bc:	2c01      	cmp	r4, #1
 80061be:	d00b      	beq.n	80061d8 <_fxe_media_open+0x58>
 80061c0:	42a5      	cmp	r5, r4
 80061c2:	d109      	bne.n	80061d8 <_fxe_media_open+0x58>
        /* Not a power of 2, return an error.  */
        return(FX_MEDIA_INVALID);
    }

    /* Check for proper size of the FAT cache.  */
    temp =  _fx_system_media_max_fat_cache;
 80061c4:	4c27      	ldr	r4, [pc, #156]	; (8006264 <_fxe_media_open+0xe4>)
 80061c6:	6824      	ldr	r4, [r4, #0]

    /* Isolate the lowest set bit.  */
    temp =  (temp & ((~temp) + ((ULONG) 1)));
 80061c8:	4265      	negs	r5, r4
 80061ca:	4025      	ands	r5, r4

    /* If FX_MAX_FAT_CACHE is a power of 2, the value of temp should be unchanged.  */
    if ((temp == 1) || (temp != _fx_system_media_max_fat_cache))
 80061cc:	2d01      	cmp	r5, #1
 80061ce:	d003      	beq.n	80061d8 <_fxe_media_open+0x58>
 80061d0:	1b64      	subs	r4, r4, r5
 80061d2:	bf18      	it	ne
 80061d4:	2401      	movne	r4, #1
 80061d6:	b16c      	cbz	r4, 80061f4 <_fxe_media_open+0x74>
        return(FX_MEDIA_INVALID);
 80061d8:	2002      	movs	r0, #2
    status =  _fx_media_open(media_ptr, media_name, media_driver, driver_info_ptr,
                             memory_ptr, memory_size);

    /* Return status.  */
    return(status);
}
 80061da:	b005      	add	sp, #20
 80061dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return(FX_PTR_ERROR);
 80061e0:	2018      	movs	r0, #24
}
 80061e2:	b005      	add	sp, #20
 80061e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return(FX_PTR_ERROR);
 80061e8:	2018      	movs	r0, #24
}
 80061ea:	4770      	bx	lr
    FX_CALLER_CHECKING_CODE
 80061ec:	2020      	movs	r0, #32
}
 80061ee:	b005      	add	sp, #20
 80061f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80061f4:	461e      	mov	r6, r3
 80061f6:	4617      	mov	r7, r2
 80061f8:	4688      	mov	r8, r1
 80061fa:	4605      	mov	r5, r0
    current_thread =  tx_thread_identify();
 80061fc:	f006 fa00 	bl	800c600 <_tx_thread_identify>
    tx_thread_preemption_change(current_thread, 0, &old_threshold);
 8006200:	4621      	mov	r1, r4
 8006202:	aa03      	add	r2, sp, #12
    current_thread =  tx_thread_identify();
 8006204:	4681      	mov	r9, r0
    tx_thread_preemption_change(current_thread, 0, &old_threshold);
 8006206:	f006 fa3d 	bl	800c684 <_tx_thread_preemption_change>
    open_count =     _fx_system_media_opened_count;
 800620a:	4a17      	ldr	r2, [pc, #92]	; (8006268 <_fxe_media_open+0xe8>)
    current_media =  _fx_system_media_opened_ptr;
 800620c:	4b17      	ldr	r3, [pc, #92]	; (800626c <_fxe_media_open+0xec>)
    open_count =     _fx_system_media_opened_count;
 800620e:	6811      	ldr	r1, [r2, #0]
    current_media =  _fx_system_media_opened_ptr;
 8006210:	681b      	ldr	r3, [r3, #0]
    while (open_count--)
 8006212:	1e4a      	subs	r2, r1, #1
 8006214:	b929      	cbnz	r1, 8006222 <_fxe_media_open+0xa2>
 8006216:	e00d      	b.n	8006234 <_fxe_media_open+0xb4>
 8006218:	3a01      	subs	r2, #1
        current_media =  current_media -> fx_media_opened_next;
 800621a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
    while (open_count--)
 800621e:	1c51      	adds	r1, r2, #1
 8006220:	d008      	beq.n	8006234 <_fxe_media_open+0xb4>
        if (media_ptr == current_media)
 8006222:	429d      	cmp	r5, r3
 8006224:	d1f8      	bne.n	8006218 <_fxe_media_open+0x98>
            tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
 8006226:	aa03      	add	r2, sp, #12
 8006228:	4648      	mov	r0, r9
 800622a:	9903      	ldr	r1, [sp, #12]
 800622c:	f006 fa2a 	bl	800c684 <_tx_thread_preemption_change>
            return(FX_PTR_ERROR);
 8006230:	2018      	movs	r0, #24
 8006232:	e7d6      	b.n	80061e2 <_fxe_media_open+0x62>
    tx_thread_preemption_change(current_thread, old_threshold, &old_threshold);
 8006234:	aa03      	add	r2, sp, #12
 8006236:	9903      	ldr	r1, [sp, #12]
 8006238:	4648      	mov	r0, r9
 800623a:	f006 fa23 	bl	800c684 <_tx_thread_preemption_change>
    status =  _fx_media_open(media_ptr, media_name, media_driver, driver_info_ptr,
 800623e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8006240:	463a      	mov	r2, r7
 8006242:	4641      	mov	r1, r8
 8006244:	9301      	str	r3, [sp, #4]
 8006246:	4628      	mov	r0, r5
 8006248:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800624a:	9300      	str	r3, [sp, #0]
 800624c:	4633      	mov	r3, r6
 800624e:	f000 ff19 	bl	8007084 <_fx_media_open>
    return(status);
 8006252:	e7c6      	b.n	80061e2 <_fxe_media_open+0x62>
 8006254:	20000164 	.word	0x20000164
 8006258:	20000f2c 	.word	0x20000f2c
 800625c:	20000fd8 	.word	0x20000fd8
 8006260:	20000df8 	.word	0x20000df8
 8006264:	20000e04 	.word	0x20000e04
 8006268:	20000e00 	.word	0x20000e00
 800626c:	20000e08 	.word	0x20000e08

08006270 <_fx_directory_first_entry_find>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_directory_first_entry_find(FX_MEDIA *media_ptr, CHAR *directory_name)
{
 8006270:	b570      	push	{r4, r5, r6, lr}


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_directory_first_entry_finds++;
 8006272:	f8d0 30f0 	ldr.w	r3, [r0, #240]	; 0xf0
#endif

    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 8006276:	4a13      	ldr	r2, [pc, #76]	; (80062c4 <_fx_directory_first_entry_find+0x54>)
 8006278:	6804      	ldr	r4, [r0, #0]
    media_ptr -> fx_media_directory_first_entry_finds++;
 800627a:	3301      	adds	r3, #1
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800627c:	4294      	cmp	r4, r2
    media_ptr -> fx_media_directory_first_entry_finds++;
 800627e:	f8c0 30f0 	str.w	r3, [r0, #240]	; 0xf0
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 8006282:	d001      	beq.n	8006288 <_fx_directory_first_entry_find+0x18>
    /* Call the next directory entry to pickup the first entry.  */
    status =  _fx_directory_next_entry_find(media_ptr, directory_name);

    /* Return status to the caller.  */
    return(status);
}
 8006284:	2011      	movs	r0, #17
 8006286:	bd70      	pop	{r4, r5, r6, pc}
    FX_PROTECT
 8006288:	f500 76e4 	add.w	r6, r0, #456	; 0x1c8
 800628c:	460d      	mov	r5, r1
 800628e:	4604      	mov	r4, r0
 8006290:	f04f 31ff 	mov.w	r1, #4294967295
 8006294:	4630      	mov	r0, r6
 8006296:	f005 ffbf 	bl	800c218 <_tx_mutex_get>
 800629a:	2800      	cmp	r0, #0
 800629c:	d1f2      	bne.n	8006284 <_fx_directory_first_entry_find+0x14>
    if (_tx_thread_current_ptr -> tx_thread_filex_ptr)
 800629e:	4b0a      	ldr	r3, [pc, #40]	; (80062c8 <_fx_directory_first_entry_find+0x58>)
 80062a0:	681b      	ldr	r3, [r3, #0]
 80062a2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80062a6:	b153      	cbz	r3, 80062be <_fx_directory_first_entry_find+0x4e>
        ((FX_PATH *)_tx_thread_current_ptr -> tx_thread_filex_ptr) -> fx_path_current_entry =  0;
 80062a8:	f8c3 0270 	str.w	r0, [r3, #624]	; 0x270
    FX_UNPROTECT
 80062ac:	4630      	mov	r0, r6
 80062ae:	f006 f89d 	bl	800c3ec <_tx_mutex_put>
    status =  _fx_directory_next_entry_find(media_ptr, directory_name);
 80062b2:	4629      	mov	r1, r5
 80062b4:	4620      	mov	r0, r4
}
 80062b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    status =  _fx_directory_next_entry_find(media_ptr, directory_name);
 80062ba:	f000 b807 	b.w	80062cc <_fx_directory_next_entry_find>
        media_ptr -> fx_media_default_path.fx_path_current_entry =  0;
 80062be:	f8c4 3750 	str.w	r3, [r4, #1872]	; 0x750
 80062c2:	e7f3      	b.n	80062ac <_fx_directory_first_entry_find+0x3c>
 80062c4:	4d454449 	.word	0x4d454449
 80062c8:	20000f2c 	.word	0x20000f2c

080062cc <_fx_directory_next_entry_find>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_directory_next_entry_find(FX_MEDIA *media_ptr, CHAR *directory_name)
{
 80062cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80062d0:	4604      	mov	r4, r0
 80062d2:	b0a1      	sub	sp, #132	; 0x84
 80062d4:	460f      	mov	r7, r1

    /* Clear the short name string.  */
    entry.fx_dir_entry_short_name[0] =  0;

    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 80062d6:	489c      	ldr	r0, [pc, #624]	; (8006548 <_fx_directory_next_entry_find+0x27c>)
    entry.fx_dir_entry_name = media_ptr -> fx_media_name_buffer + FX_MAX_LONG_NAME_LEN;
 80062d8:	f604 119c 	addw	r1, r4, #2460	; 0x99c
    media_ptr -> fx_media_directory_next_entry_finds++;
 80062dc:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
ULONG         cluster, next_cluster = 0;
 80062e0:	2200      	movs	r2, #0
    entry.fx_dir_entry_name = media_ptr -> fx_media_name_buffer + FX_MAX_LONG_NAME_LEN;
 80062e2:	9104      	str	r1, [sp, #16]
    media_ptr -> fx_media_directory_next_entry_finds++;
 80062e4:	3301      	adds	r3, #1
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 80062e6:	6821      	ldr	r1, [r4, #0]
ULONG         cluster, next_cluster = 0;
 80062e8:	9203      	str	r2, [sp, #12]
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 80062ea:	4281      	cmp	r1, r0
    media_ptr -> fx_media_directory_next_entry_finds++;
 80062ec:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
    entry.fx_dir_entry_short_name[0] =  0;
 80062f0:	f88d 2014 	strb.w	r2, [sp, #20]
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 80062f4:	d005      	beq.n	8006302 <_fx_directory_next_entry_find+0x36>
    {

        /* Return the media not opened error.  */
        return(FX_MEDIA_NOT_OPEN);
 80062f6:	f04f 0a11 	mov.w	sl, #17
    /* Release media protection.  */
    FX_UNPROTECT

    /* Return status to the caller.  */
    return(status);
}
 80062fa:	4650      	mov	r0, sl
 80062fc:	b021      	add	sp, #132	; 0x84
 80062fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    FX_PROTECT
 8006302:	f504 79e4 	add.w	r9, r4, #456	; 0x1c8
 8006306:	f04f 31ff 	mov.w	r1, #4294967295
 800630a:	4648      	mov	r0, r9
 800630c:	f005 ff84 	bl	800c218 <_tx_mutex_get>
 8006310:	2800      	cmp	r0, #0
 8006312:	d1f0      	bne.n	80062f6 <_fx_directory_next_entry_find+0x2a>
    if (_tx_thread_current_ptr -> tx_thread_filex_ptr)
 8006314:	4b8d      	ldr	r3, [pc, #564]	; (800654c <_fx_directory_next_entry_find+0x280>)
 8006316:	681b      	ldr	r3, [r3, #0]
 8006318:	f8d3 8090 	ldr.w	r8, [r3, #144]	; 0x90
 800631c:	f1b8 0f00 	cmp.w	r8, #0
 8006320:	f000 8093 	beq.w	800644a <_fx_directory_next_entry_find+0x17e>
        if (path_ptr -> fx_path_directory.fx_dir_entry_name[0])
 8006324:	f8d8 3000 	ldr.w	r3, [r8]
 8006328:	781b      	ldrb	r3, [r3, #0]
 800632a:	2b00      	cmp	r3, #0
 800632c:	f040 809b 	bne.w	8006466 <_fx_directory_next_entry_find+0x19a>
        directory_size =  (ULONG)media_ptr -> fx_media_root_directory_entries;
 8006330:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8006332:	2100      	movs	r1, #0
 8006334:	2200      	movs	r2, #0
 8006336:	f8d8 6270 	ldr.w	r6, [r8, #624]	; 0x270
 800633a:	469a      	mov	sl, r3
 800633c:	468b      	mov	fp, r1
 800633e:	9201      	str	r2, [sp, #4]
 8006340:	9200      	str	r2, [sp, #0]
    while (path_ptr -> fx_path_current_entry < directory_size)
 8006342:	2300      	movs	r3, #0
 8006344:	455b      	cmp	r3, fp
 8006346:	bf08      	it	eq
 8006348:	4556      	cmpeq	r6, sl
 800634a:	f080 80d6 	bcs.w	80064fa <_fx_directory_next_entry_find+0x22e>
 800634e:	f508 751c 	add.w	r5, r8, #624	; 0x270
        temp_status =  _fx_directory_entry_read(media_ptr, search_dir_ptr,
 8006352:	ab04      	add	r3, sp, #16
 8006354:	462a      	mov	r2, r5
 8006356:	9900      	ldr	r1, [sp, #0]
 8006358:	4620      	mov	r0, r4
 800635a:	f002 fb5f 	bl	8008a1c <_fx_directory_entry_read>
        if (temp_status != FX_SUCCESS)
 800635e:	2800      	cmp	r0, #0
 8006360:	f040 80de 	bne.w	8006520 <_fx_directory_next_entry_find+0x254>
        if (((UCHAR)entry.fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) && (entry.fx_dir_entry_short_name[0] == 0))
 8006364:	9e04      	ldr	r6, [sp, #16]
 8006366:	7832      	ldrb	r2, [r6, #0]
 8006368:	2ae5      	cmp	r2, #229	; 0xe5
 800636a:	f040 80e5 	bne.w	8006538 <_fx_directory_next_entry_find+0x26c>
 800636e:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8006372:	2b00      	cmp	r3, #0
 8006374:	f000 80b5 	beq.w	80064e2 <_fx_directory_next_entry_find+0x216>
 8006378:	4682      	mov	sl, r0
        directory_size =  (ULONG)media_ptr -> fx_media_root_directory_entries;
 800637a:	4631      	mov	r1, r6
                *directory_name = entry.fx_dir_entry_name[i];
 800637c:	f807 2b01 	strb.w	r2, [r7], #1
            for (i = 0; entry.fx_dir_entry_name[i]; i++)
 8006380:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8006384:	2a00      	cmp	r2, #0
 8006386:	d1f9      	bne.n	800637c <_fx_directory_next_entry_find+0xb0>
            *directory_name =  (CHAR)0;
 8006388:	703a      	strb	r2, [r7, #0]
            path_ptr -> fx_path_current_entry++;
 800638a:	f8d8 1270 	ldr.w	r1, [r8, #624]	; 0x270
                if (path_string_ptr)
 800638e:	9b01      	ldr	r3, [sp, #4]
            path_ptr -> fx_path_current_entry++;
 8006390:	3101      	adds	r1, #1
 8006392:	f8c8 1270 	str.w	r1, [r8, #624]	; 0x270
                if (path_string_ptr)
 8006396:	2b00      	cmp	r3, #0
 8006398:	f000 80c9 	beq.w	800652e <_fx_directory_next_entry_find+0x262>
 800639c:	1e58      	subs	r0, r3, #1
 800639e:	f204 37df 	addw	r7, r4, #991	; 0x3df
 80063a2:	e005      	b.n	80063b0 <_fx_directory_next_entry_find+0xe4>
                    while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (path_string_ptr[v]))
 80063a4:	2dff      	cmp	r5, #255	; 0xff
 80063a6:	462a      	mov	r2, r5
                        media_ptr -> fx_media_last_found_name[v] =  path_string_ptr[v];
 80063a8:	f807 3f01 	strb.w	r3, [r7, #1]!
                    while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (path_string_ptr[v]))
 80063ac:	f000 80c8 	beq.w	8006540 <_fx_directory_next_entry_find+0x274>
 80063b0:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 80063b4:	1c55      	adds	r5, r2, #1
 80063b6:	2b00      	cmp	r3, #0
 80063b8:	d1f4      	bne.n	80063a4 <_fx_directory_next_entry_find+0xd8>
                media_ptr -> fx_media_last_found_name[v++] =  '/';
 80063ba:	4422      	add	r2, r4
 80063bc:	212f      	movs	r1, #47	; 0x2f
 80063be:	f882 13e0 	strb.w	r1, [r2, #992]	; 0x3e0
                while ((v < FX_MAX_LAST_NAME_LEN) && (entry.fx_dir_entry_name[j]))
 80063c2:	7832      	ldrb	r2, [r6, #0]
 80063c4:	2a00      	cmp	r2, #0
 80063c6:	f000 80a1 	beq.w	800650c <_fx_directory_next_entry_find+0x240>
 80063ca:	f505 7178 	add.w	r1, r5, #992	; 0x3e0
 80063ce:	4630      	mov	r0, r6
 80063d0:	4421      	add	r1, r4
 80063d2:	e004      	b.n	80063de <_fx_directory_next_entry_find+0x112>
 80063d4:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 80063d8:	2a00      	cmp	r2, #0
 80063da:	f000 8097 	beq.w	800650c <_fx_directory_next_entry_find+0x240>
                    v++;
 80063de:	3501      	adds	r5, #1
                    media_ptr -> fx_media_last_found_name[v] =  entry.fx_dir_entry_name[j];
 80063e0:	f801 2b01 	strb.w	r2, [r1], #1
                while ((v < FX_MAX_LAST_NAME_LEN) && (entry.fx_dir_entry_name[j]))
 80063e4:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 80063e8:	d1f4      	bne.n	80063d4 <_fx_directory_next_entry_find+0x108>
                    media_ptr -> fx_media_last_found_name[0] =  FX_NULL;
 80063ea:	2500      	movs	r5, #0
 80063ec:	f884 53e0 	strb.w	r5, [r4, #992]	; 0x3e0
                if (search_dir_ptr)
 80063f0:	9900      	ldr	r1, [sp, #0]
 80063f2:	2900      	cmp	r1, #0
 80063f4:	f000 8099 	beq.w	800652a <_fx_directory_next_entry_find+0x25e>
                    media_ptr -> fx_media_last_found_directory =  *search_dir_ptr;
 80063f8:	2270      	movs	r2, #112	; 0x70
 80063fa:	f504 7000 	add.w	r0, r4, #512	; 0x200
 80063fe:	f007 fc63 	bl	800dcc8 <memcpy>
                    media_ptr -> fx_media_last_found_directory_valid =  FX_TRUE;
 8006402:	2201      	movs	r2, #1
 8006404:	f8c4 21fc 	str.w	r2, [r4, #508]	; 0x1fc
                media_ptr -> fx_media_last_found_entry =  entry;
 8006408:	a904      	add	r1, sp, #16
 800640a:	2270      	movs	r2, #112	; 0x70
 800640c:	f504 701c 	add.w	r0, r4, #624	; 0x270
 8006410:	f007 fc5a 	bl	800dcc8 <memcpy>
                media_ptr -> fx_media_last_found_entry.fx_dir_entry_name =  media_ptr -> fx_media_last_found_file_name;
 8006414:	f504 7038 	add.w	r0, r4, #736	; 0x2e0
 8006418:	1e72      	subs	r2, r6, #1
 800641a:	f204 21df 	addw	r1, r4, #735	; 0x2df
 800641e:	36ff      	adds	r6, #255	; 0xff
 8006420:	f8c4 0270 	str.w	r0, [r4, #624]	; 0x270
 8006424:	e001      	b.n	800642a <_fx_directory_next_entry_find+0x15e>
                for (index = 0; index < FX_MAX_LONG_NAME_LEN; index++)
 8006426:	42b2      	cmp	r2, r6
 8006428:	d008      	beq.n	800643c <_fx_directory_next_entry_find+0x170>
                    media_ptr -> fx_media_last_found_file_name[index] =  entry.fx_dir_entry_name[index];
 800642a:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 800642e:	f801 3f01 	strb.w	r3, [r1, #1]!
                    if (entry.fx_dir_entry_name[index] == (CHAR)FX_NULL)
 8006432:	7813      	ldrb	r3, [r2, #0]
                        if (v < (FX_MAX_LONG_NAME_LEN - 1))
 8006434:	2b00      	cmp	r3, #0
 8006436:	d1f6      	bne.n	8006426 <_fx_directory_next_entry_find+0x15a>
 8006438:	2d00      	cmp	r5, #0
 800643a:	d0f4      	beq.n	8006426 <_fx_directory_next_entry_find+0x15a>
    FX_UNPROTECT
 800643c:	4648      	mov	r0, r9
 800643e:	f005 ffd5 	bl	800c3ec <_tx_mutex_put>
}
 8006442:	4650      	mov	r0, sl
 8006444:	b021      	add	sp, #132	; 0x84
 8006446:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name[0])
 800644a:	f8d4 34e0 	ldr.w	r3, [r4, #1248]	; 0x4e0
 800644e:	f504 689c 	add.w	r8, r4, #1248	; 0x4e0
 8006452:	781b      	ldrb	r3, [r3, #0]
 8006454:	2b00      	cmp	r3, #0
 8006456:	f43f af6b 	beq.w	8006330 <_fx_directory_next_entry_find+0x64>
        path_string_ptr =  media_ptr -> fx_media_default_path.fx_path_string;
 800645a:	f504 63aa 	add.w	r3, r4, #1360	; 0x550
        search_dir_ptr =  &(path_ptr -> fx_path_directory);
 800645e:	f8cd 8000 	str.w	r8, [sp]
        path_string_ptr =  media_ptr -> fx_media_default_path.fx_path_string;
 8006462:	9301      	str	r3, [sp, #4]
 8006464:	e004      	b.n	8006470 <_fx_directory_next_entry_find+0x1a4>
            path_string_ptr =  ((FX_PATH *)_tx_thread_current_ptr -> tx_thread_filex_ptr) -> fx_path_string;
 8006466:	f108 0370 	add.w	r3, r8, #112	; 0x70
            search_dir_ptr =  &(path_ptr -> fx_path_directory);
 800646a:	f8cd 8000 	str.w	r8, [sp]
            path_string_ptr =  ((FX_PATH *)_tx_thread_current_ptr -> tx_thread_filex_ptr) -> fx_path_string;
 800646e:	9301      	str	r3, [sp, #4]
            if (path_ptr -> fx_path_current_entry != 0)
 8006470:	f8d8 6270 	ldr.w	r6, [r8, #624]	; 0x270
 8006474:	b126      	cbz	r6, 8006480 <_fx_directory_next_entry_find+0x1b4>
                directory_size =  search_dir_ptr -> fx_dir_entry_file_size;
 8006476:	e9d8 230e 	ldrd	r2, r3, [r8, #56]	; 0x38
 800647a:	4692      	mov	sl, r2
 800647c:	469b      	mov	fp, r3
 800647e:	e760      	b.n	8006342 <_fx_directory_next_entry_find+0x76>
 8006480:	f242 4ba8 	movw	fp, #9384	; 0x24a8
                search_dir_ptr -> fx_dir_entry_last_search_cluster =  0;
 8006484:	f8c8 6050 	str.w	r6, [r8, #80]	; 0x50
                cluster =  search_dir_ptr -> fx_dir_entry_cluster;
 8006488:	f8d8 5034 	ldr.w	r5, [r8, #52]	; 0x34
 800648c:	44a3      	add	fp, r4
                while (cluster < media_ptr -> fx_media_fat_reserved)
 800648e:	e00d      	b.n	80064ac <_fx_directory_next_entry_find+0x1e0>
                    status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8006490:	f001 f9a8 	bl	80077e4 <_fx_utility_FAT_entry_read>
                    i++;
 8006494:	3601      	adds	r6, #1
                    if (status != FX_SUCCESS)
 8006496:	2800      	cmp	r0, #0
 8006498:	d142      	bne.n	8006520 <_fx_directory_next_entry_find+0x254>
                    if ((cluster < FX_FAT_ENTRY_START) || (cluster == next_cluster) || (i > media_ptr -> fx_media_total_clusters))
 800649a:	2d01      	cmp	r5, #1
 800649c:	d930      	bls.n	8006500 <_fx_directory_next_entry_find+0x234>
 800649e:	9b03      	ldr	r3, [sp, #12]
 80064a0:	42ab      	cmp	r3, r5
 80064a2:	461d      	mov	r5, r3
 80064a4:	d02c      	beq.n	8006500 <_fx_directory_next_entry_find+0x234>
 80064a6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80064a8:	42b3      	cmp	r3, r6
 80064aa:	d329      	bcc.n	8006500 <_fx_directory_next_entry_find+0x234>
                while (cluster < media_ptr -> fx_media_fat_reserved)
 80064ac:	f8db 3000 	ldr.w	r3, [fp]
                    status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 80064b0:	4629      	mov	r1, r5
 80064b2:	aa03      	add	r2, sp, #12
 80064b4:	4620      	mov	r0, r4
                while (cluster < media_ptr -> fx_media_fat_reserved)
 80064b6:	42ab      	cmp	r3, r5
 80064b8:	d8ea      	bhi.n	8006490 <_fx_directory_next_entry_find+0x1c4>
                directory_size =  (((ULONG64)media_ptr -> fx_media_bytes_per_sector) *
 80064ba:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80064bc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80064be:	fba0 0103 	umull	r0, r1, r0, r3
                                   ((ULONG64)media_ptr -> fx_media_sectors_per_cluster) * i) /
 80064c2:	fba0 2306 	umull	r2, r3, r0, r6
 80064c6:	fb06 3301 	mla	r3, r6, r1, r3
                directory_size =  (((ULONG64)media_ptr -> fx_media_bytes_per_sector) *
 80064ca:	0951      	lsrs	r1, r2, #5
 80064cc:	f8d8 6270 	ldr.w	r6, [r8, #624]	; 0x270
 80064d0:	ea41 61c3 	orr.w	r1, r1, r3, lsl #27
 80064d4:	095b      	lsrs	r3, r3, #5
                search_dir_ptr -> fx_dir_entry_file_size =  directory_size;
 80064d6:	460a      	mov	r2, r1
                directory_size =  (((ULONG64)media_ptr -> fx_media_bytes_per_sector) *
 80064d8:	468a      	mov	sl, r1
 80064da:	469b      	mov	fp, r3
                search_dir_ptr -> fx_dir_entry_file_size =  directory_size;
 80064dc:	e9c8 230e 	strd	r2, r3, [r8, #56]	; 0x38
 80064e0:	e72f      	b.n	8006342 <_fx_directory_next_entry_find+0x76>
            path_ptr -> fx_path_current_entry++;
 80064e2:	f8d8 3270 	ldr.w	r3, [r8, #624]	; 0x270
    while (path_ptr -> fx_path_current_entry < directory_size)
 80064e6:	2100      	movs	r1, #0
            path_ptr -> fx_path_current_entry++;
 80064e8:	3301      	adds	r3, #1
    while (path_ptr -> fx_path_current_entry < directory_size)
 80064ea:	4559      	cmp	r1, fp
 80064ec:	4618      	mov	r0, r3
            path_ptr -> fx_path_current_entry++;
 80064ee:	f8c8 3270 	str.w	r3, [r8, #624]	; 0x270
    while (path_ptr -> fx_path_current_entry < directory_size)
 80064f2:	bf08      	it	eq
 80064f4:	4550      	cmpeq	r0, sl
 80064f6:	f4ff af2c 	bcc.w	8006352 <_fx_directory_next_entry_find+0x86>
    status =  FX_NO_MORE_ENTRIES;
 80064fa:	f04f 0a0f 	mov.w	sl, #15
 80064fe:	e79d      	b.n	800643c <_fx_directory_next_entry_find+0x170>
                        FX_UNPROTECT
 8006500:	4648      	mov	r0, r9
                        return(FX_FAT_READ_ERROR);
 8006502:	f04f 0a03 	mov.w	sl, #3
                        FX_UNPROTECT
 8006506:	f005 ff71 	bl	800c3ec <_tx_mutex_put>
                        return(FX_FAT_READ_ERROR);
 800650a:	e6f6      	b.n	80062fa <_fx_directory_next_entry_find+0x2e>
                    media_ptr -> fx_media_last_found_name[v] =  FX_NULL;
 800650c:	1962      	adds	r2, r4, r5
 800650e:	2dfe      	cmp	r5, #254	; 0xfe
 8006510:	f04f 0100 	mov.w	r1, #0
 8006514:	bf8c      	ite	hi
 8006516:	2500      	movhi	r5, #0
 8006518:	2501      	movls	r5, #1
 800651a:	f882 13e0 	strb.w	r1, [r2, #992]	; 0x3e0
 800651e:	e767      	b.n	80063f0 <_fx_directory_next_entry_find+0x124>
 8006520:	4682      	mov	sl, r0
            FX_UNPROTECT
 8006522:	4648      	mov	r0, r9
 8006524:	f005 ff62 	bl	800c3ec <_tx_mutex_put>
            return(temp_status);
 8006528:	e6e7      	b.n	80062fa <_fx_directory_next_entry_find+0x2e>
 800652a:	460a      	mov	r2, r1
 800652c:	e76a      	b.n	8006404 <_fx_directory_next_entry_find+0x138>
                media_ptr -> fx_media_last_found_name[v++] =  '/';
 800652e:	222f      	movs	r2, #47	; 0x2f
 8006530:	2501      	movs	r5, #1
 8006532:	f884 23e0 	strb.w	r2, [r4, #992]	; 0x3e0
 8006536:	e744      	b.n	80063c2 <_fx_directory_next_entry_find+0xf6>
 8006538:	4682      	mov	sl, r0
        else if ((UCHAR)entry.fx_dir_entry_name[0] != (UCHAR)FX_DIR_ENTRY_DONE)
 800653a:	2a00      	cmp	r2, #0
 800653c:	d0dd      	beq.n	80064fa <_fx_directory_next_entry_find+0x22e>
 800653e:	e71c      	b.n	800637a <_fx_directory_next_entry_find+0xae>
                media_ptr -> fx_media_last_found_name[v++] =  '/';
 8006540:	222f      	movs	r2, #47	; 0x2f
 8006542:	f884 24df 	strb.w	r2, [r4, #1247]	; 0x4df
 8006546:	e750      	b.n	80063ea <_fx_directory_next_entry_find+0x11e>
 8006548:	4d454449 	.word	0x4d454449
 800654c:	20000f2c 	.word	0x20000f2c

08006550 <_fx_file_attributes_read>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_file_attributes_read(FX_MEDIA *media_ptr, CHAR *file_name, UINT *attributes_ptr)
{
 8006550:	b5f0      	push	{r4, r5, r6, r7, lr}

    /* Setup pointer to media name buffer.  */
    dir_entry.fx_dir_entry_name =  media_ptr -> fx_media_name_buffer + FX_MAX_LONG_NAME_LEN;

    /* Clear the short name string.  */
    dir_entry.fx_dir_entry_short_name[0] =  0;
 8006552:	2500      	movs	r5, #0
{
 8006554:	b09f      	sub	sp, #124	; 0x7c
    dir_entry.fx_dir_entry_name =  media_ptr -> fx_media_name_buffer + FX_MAX_LONG_NAME_LEN;
 8006556:	f600 149c 	addw	r4, r0, #2460	; 0x99c
    media_ptr -> fx_media_file_attributes_reads++;
 800655a:	f8d0 3120 	ldr.w	r3, [r0, #288]	; 0x120
    dir_entry.fx_dir_entry_short_name[0] =  0;
 800655e:	f88d 500c 	strb.w	r5, [sp, #12]
    dir_entry.fx_dir_entry_name =  media_ptr -> fx_media_name_buffer + FX_MAX_LONG_NAME_LEN;
 8006562:	9402      	str	r4, [sp, #8]
    media_ptr -> fx_media_file_attributes_reads++;
 8006564:	3301      	adds	r3, #1

    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 8006566:	6805      	ldr	r5, [r0, #0]
 8006568:	4c17      	ldr	r4, [pc, #92]	; (80065c8 <_fx_file_attributes_read+0x78>)
    media_ptr -> fx_media_file_attributes_reads++;
 800656a:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800656e:	42a5      	cmp	r5, r4
 8006570:	d003      	beq.n	800657a <_fx_file_attributes_read+0x2a>
    {

        /* Return the media not opened error.  */
        return(FX_MEDIA_NOT_OPEN);
 8006572:	2411      	movs	r4, #17
    /* Release media protection.  */
    FX_UNPROTECT

    /* File attribute read is complete, return successful status.  */
    return(FX_SUCCESS);
}
 8006574:	4620      	mov	r0, r4
 8006576:	b01f      	add	sp, #124	; 0x7c
 8006578:	bdf0      	pop	{r4, r5, r6, r7, pc}
    FX_PROTECT
 800657a:	f500 77e4 	add.w	r7, r0, #456	; 0x1c8
 800657e:	460d      	mov	r5, r1
 8006580:	4604      	mov	r4, r0
 8006582:	f04f 31ff 	mov.w	r1, #4294967295
 8006586:	4638      	mov	r0, r7
 8006588:	4616      	mov	r6, r2
 800658a:	f005 fe45 	bl	800c218 <_tx_mutex_get>
 800658e:	2800      	cmp	r0, #0
 8006590:	d1ef      	bne.n	8006572 <_fx_file_attributes_read+0x22>
    status =  _fx_directory_search(media_ptr, file_name, &dir_entry, FX_NULL, FX_NULL);
 8006592:	9000      	str	r0, [sp, #0]
 8006594:	4603      	mov	r3, r0
 8006596:	4629      	mov	r1, r5
 8006598:	4620      	mov	r0, r4
 800659a:	aa02      	add	r2, sp, #8
 800659c:	f003 fb9a 	bl	8009cd4 <_fx_directory_search>
    if (status != FX_SUCCESS)
 80065a0:	4604      	mov	r4, r0
 80065a2:	b928      	cbnz	r0, 80065b0 <_fx_file_attributes_read+0x60>
    if (dir_entry.fx_dir_entry_attributes & not_a_file_attr)
 80065a4:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
 80065a8:	f013 0f18 	tst.w	r3, #24
 80065ac:	d106      	bne.n	80065bc <_fx_file_attributes_read+0x6c>
    *attributes_ptr =  (UINT)dir_entry.fx_dir_entry_attributes;
 80065ae:	6033      	str	r3, [r6, #0]
    FX_UNPROTECT
 80065b0:	4638      	mov	r0, r7
 80065b2:	f005 ff1b 	bl	800c3ec <_tx_mutex_put>
}
 80065b6:	4620      	mov	r0, r4
 80065b8:	b01f      	add	sp, #124	; 0x7c
 80065ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
        FX_UNPROTECT
 80065bc:	4638      	mov	r0, r7
        return(FX_NOT_A_FILE);
 80065be:	2405      	movs	r4, #5
        FX_UNPROTECT
 80065c0:	f005 ff14 	bl	800c3ec <_tx_mutex_put>
        return(FX_NOT_A_FILE);
 80065c4:	e7d6      	b.n	8006574 <_fx_file_attributes_read+0x24>
 80065c6:	bf00      	nop
 80065c8:	4d454449 	.word	0x4d454449

080065cc <_fx_file_close>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_file_close(FX_FILE *file_ptr)
{
 80065cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
FX_MEDIA *media_ptr;
FX_INT_SAVE_AREA


    /* First, determine if the file is still open.  */
    if (file_ptr -> fx_file_id != FX_FILE_ID)
 80065ce:	6802      	ldr	r2, [r0, #0]
 80065d0:	4b30      	ldr	r3, [pc, #192]	; (8006694 <_fx_file_close+0xc8>)
 80065d2:	429a      	cmp	r2, r3
 80065d4:	d10c      	bne.n	80065f0 <_fx_file_close+0x24>
        /* Return the file not open error status.  */
        return(FX_NOT_OPEN);
    }

    /* Setup a pointer to the associated media.  */
    media_ptr =  file_ptr -> fx_file_media_ptr;
 80065d6:	6d85      	ldr	r5, [r0, #88]	; 0x58

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_FILE_CLOSE, file_ptr, file_ptr -> fx_file_current_file_size, 0, 0, FX_TRACE_FILE_EVENTS, 0, 0)

    /* Protect against other threads accessing the media.  */
    FX_PROTECT
 80065d8:	4a2f      	ldr	r2, [pc, #188]	; (8006698 <_fx_file_close+0xcc>)
    media_ptr -> fx_media_file_closes++;
 80065da:	f8d5 312c 	ldr.w	r3, [r5, #300]	; 0x12c
    FX_PROTECT
 80065de:	6829      	ldr	r1, [r5, #0]
    media_ptr -> fx_media_file_closes++;
 80065e0:	3301      	adds	r3, #1
    FX_PROTECT
 80065e2:	4291      	cmp	r1, r2
    media_ptr -> fx_media_file_closes++;
 80065e4:	f8c5 312c 	str.w	r3, [r5, #300]	; 0x12c
    FX_PROTECT
 80065e8:	d005      	beq.n	80065f6 <_fx_file_close+0x2a>
 80065ea:	2611      	movs	r6, #17
    /* Release media protection.  */
    FX_UNPROTECT

    /* Return status to the caller.  */
    return(FX_SUCCESS);
}
 80065ec:	4630      	mov	r0, r6
 80065ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return(FX_NOT_OPEN);
 80065f0:	2607      	movs	r6, #7
}
 80065f2:	4630      	mov	r0, r6
 80065f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    FX_PROTECT
 80065f6:	f505 77e4 	add.w	r7, r5, #456	; 0x1c8
 80065fa:	4604      	mov	r4, r0
 80065fc:	f04f 31ff 	mov.w	r1, #4294967295
 8006600:	4638      	mov	r0, r7
 8006602:	f005 fe09 	bl	800c218 <_tx_mutex_get>
 8006606:	4606      	mov	r6, r0
 8006608:	2800      	cmp	r0, #0
 800660a:	d1ee      	bne.n	80065ea <_fx_file_close+0x1e>
    if (file_ptr == file_ptr -> fx_file_opened_next)
 800660c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800660e:	42a3      	cmp	r3, r4
 8006610:	d038      	beq.n	8006684 <_fx_file_close+0xb8>
            file_ptr -> fx_file_opened_previous;
 8006612:	6e21      	ldr	r1, [r4, #96]	; 0x60
        if (media_ptr -> fx_media_opened_file_list == file_ptr)
 8006614:	f8d5 20c8 	ldr.w	r2, [r5, #200]	; 0xc8
        (file_ptr -> fx_file_opened_next) -> fx_file_opened_previous =
 8006618:	6619      	str	r1, [r3, #96]	; 0x60
        if (media_ptr -> fx_media_opened_file_list == file_ptr)
 800661a:	42a2      	cmp	r2, r4
        (file_ptr -> fx_file_opened_previous) -> fx_file_opened_next =
 800661c:	6e21      	ldr	r1, [r4, #96]	; 0x60
 800661e:	65cb      	str	r3, [r1, #92]	; 0x5c
        if (media_ptr -> fx_media_opened_file_list == file_ptr)
 8006620:	d033      	beq.n	800668a <_fx_file_close+0xbe>
    media_ptr -> fx_media_opened_file_count--;
 8006622:	f8d5 30cc 	ldr.w	r3, [r5, #204]	; 0xcc
    if ((file_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE) &&
 8006626:	68a2      	ldr	r2, [r4, #8]
    file_ptr -> fx_file_id =  FX_FILE_CLOSED_ID;
 8006628:	491c      	ldr	r1, [pc, #112]	; (800669c <_fx_file_close+0xd0>)
    media_ptr -> fx_media_opened_file_count--;
 800662a:	3b01      	subs	r3, #1
    if ((file_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE) &&
 800662c:	2a01      	cmp	r2, #1
    media_ptr -> fx_media_opened_file_count--;
 800662e:	f8c5 30cc 	str.w	r3, [r5, #204]	; 0xcc
    file_ptr -> fx_file_id =  FX_FILE_CLOSED_ID;
 8006632:	6021      	str	r1, [r4, #0]
    if ((file_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE) &&
 8006634:	d101      	bne.n	800663a <_fx_file_close+0x6e>
 8006636:	7b23      	ldrb	r3, [r4, #12]
 8006638:	b923      	cbnz	r3, 8006644 <_fx_file_close+0x78>
    FX_UNPROTECT
 800663a:	4638      	mov	r0, r7
 800663c:	f005 fed6 	bl	800c3ec <_tx_mutex_put>
}
 8006640:	4630      	mov	r0, r6
 8006642:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
__attribute__( ( always_inline ) ) static inline unsigned int __disable_interrupts(void)
{

unsigned int  primask_value;

    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 8006644:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 8006648:	b672      	cpsid	i
        file_ptr -> fx_file_dir_entry.fx_dir_entry_time =  _fx_system_time;
 800664a:	4915      	ldr	r1, [pc, #84]	; (80066a0 <_fx_file_close+0xd4>)
        file_ptr -> fx_file_dir_entry.fx_dir_entry_date =  _fx_system_date;
 800664c:	4b15      	ldr	r3, [pc, #84]	; (80066a4 <_fx_file_close+0xd8>)
        file_ptr -> fx_file_dir_entry.fx_dir_entry_time =  _fx_system_time;
 800664e:	6809      	ldr	r1, [r1, #0]
        file_ptr -> fx_file_dir_entry.fx_dir_entry_date =  _fx_system_date;
 8006650:	681b      	ldr	r3, [r3, #0]
        file_ptr -> fx_file_dir_entry.fx_dir_entry_time =  _fx_system_time;
 8006652:	f8c4 1094 	str.w	r1, [r4, #148]	; 0x94
        file_ptr -> fx_file_dir_entry.fx_dir_entry_date =  _fx_system_date;
 8006656:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
        file_ptr -> fx_file_dir_entry.fx_dir_entry_last_accessed_date =  _fx_system_date;
 800665a:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
}

__attribute__( ( always_inline ) ) static inline void __restore_interrupts(unsigned int primask_value)
{

    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800665e:	f382 8810 	msr	PRIMASK, r2
        file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
 8006662:	e9d4 2312 	ldrd	r2, r3, [r4, #72]	; 0x48
            status = _fx_directory_entry_write(media_ptr, &(file_ptr -> fx_file_dir_entry));
 8006666:	4628      	mov	r0, r5
 8006668:	f104 0168 	add.w	r1, r4, #104	; 0x68
        file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
 800666c:	e9c4 2328 	strd	r2, r3, [r4, #160]	; 0xa0
            status = _fx_directory_entry_write(media_ptr, &(file_ptr -> fx_file_dir_entry));
 8006670:	f002 fcb2 	bl	8008fd8 <_fx_directory_entry_write>
        if (status != FX_SUCCESS)
 8006674:	4603      	mov	r3, r0
 8006676:	2800      	cmp	r0, #0
 8006678:	d0df      	beq.n	800663a <_fx_file_close+0x6e>
            FX_UNPROTECT
 800667a:	4638      	mov	r0, r7
            return(status);
 800667c:	461e      	mov	r6, r3
            FX_UNPROTECT
 800667e:	f005 feb5 	bl	800c3ec <_tx_mutex_put>
            return(status);
 8006682:	e7b3      	b.n	80065ec <_fx_file_close+0x20>
        media_ptr -> fx_media_opened_file_list =  FX_NULL;
 8006684:	f8c5 00c8 	str.w	r0, [r5, #200]	; 0xc8
 8006688:	e7cb      	b.n	8006622 <_fx_file_close+0x56>
            media_ptr -> fx_media_opened_file_list =  file_ptr -> fx_file_opened_next;
 800668a:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800668c:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
 8006690:	e7c7      	b.n	8006622 <_fx_file_close+0x56>
 8006692:	bf00      	nop
 8006694:	46494c45 	.word	0x46494c45
 8006698:	4d454449 	.word	0x4d454449
 800669c:	46494c43 	.word	0x46494c43
 80066a0:	20000e14 	.word	0x20000e14
 80066a4:	20000dfc 	.word	0x20000dfc

080066a8 <_fx_file_open>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_file_open(FX_MEDIA *media_ptr, FX_FILE *file_ptr, CHAR *file_name, UINT open_type)
{
 80066a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80066ac:	4604      	mov	r4, r0
 80066ae:	460d      	mov	r5, r1
UINT     fast_open;
UCHAR    not_a_file_attr;


    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 80066b0:	486e      	ldr	r0, [pc, #440]	; (800686c <_fx_file_open+0x1c4>)
{
 80066b2:	b093      	sub	sp, #76	; 0x4c
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 80066b4:	6821      	ldr	r1, [r4, #0]
ULONG    contents = 0;
 80066b6:	2600      	movs	r6, #0
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 80066b8:	4281      	cmp	r1, r0
ULONG    contents = 0;
 80066ba:	9611      	str	r6, [sp, #68]	; 0x44
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 80066bc:	f040 80bb 	bne.w	8006836 <_fx_file_open+0x18e>
 80066c0:	4698      	mov	r8, r3
    }

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_file_opens++;
 80066c2:	f8d4 3138 	ldr.w	r3, [r4, #312]	; 0x138
    else if (media_ptr -> fx_media_FAT_type == FX_FAT32)
#else
    if (media_ptr -> fx_media_32_bit_FAT)
#endif /* FX_ENABLE_EXFAT */
    {
        fat_last        = FX_LAST_CLUSTER_1_32;
 80066c6:	f64f 70f8 	movw	r0, #65528	; 0xfff8
 80066ca:	4617      	mov	r7, r2
    media_ptr -> fx_media_file_opens++;
 80066cc:	3301      	adds	r3, #1
    if (media_ptr -> fx_media_32_bit_FAT)
 80066ce:	6e62      	ldr	r2, [r4, #100]	; 0x64
        fat_last        = FX_LAST_CLUSTER_1_32;
 80066d0:	4967      	ldr	r1, [pc, #412]	; (8006870 <_fx_file_open+0x1c8>)
    media_ptr -> fx_media_file_opens++;
 80066d2:	f8c4 3138 	str.w	r3, [r4, #312]	; 0x138
        fat_last        = FX_LAST_CLUSTER_1_32;
 80066d6:	4603      	mov	r3, r0
    file_ptr -> fx_file_write_notify = FX_NULL;
 80066d8:	f8c5 61dc 	str.w	r6, [r5, #476]	; 0x1dc
        fat_last        = FX_LAST_CLUSTER_1_32;
 80066dc:	2a00      	cmp	r2, #0
 80066de:	bf18      	it	ne
 80066e0:	460b      	movne	r3, r1
        fat_last        = FX_LAST_CLUSTER_1;
        not_a_file_attr = FX_DIRECTORY | FX_VOLUME;
    }

    /* Determine if a fast open is selected.  */
    if (open_type == FX_OPEN_FOR_READ_FAST)
 80066e2:	f1b8 0f02 	cmp.w	r8, #2
        fat_last        = FX_LAST_CLUSTER_1_32;
 80066e6:	9304      	str	r3, [sp, #16]
    if (open_type == FX_OPEN_FOR_READ_FAST)
 80066e8:	f000 80aa 	beq.w	8006840 <_fx_file_open+0x198>

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_FILE_OPEN, media_ptr, file_ptr, file_name, open_type, FX_TRACE_FILE_EVENTS, 0, 0)

    /* Protect against other threads accessing the media.  */
    FX_PROTECT
 80066ec:	f504 7be4 	add.w	fp, r4, #456	; 0x1c8
 80066f0:	f04f 31ff 	mov.w	r1, #4294967295
 80066f4:	4658      	mov	r0, fp
 80066f6:	f005 fd8f 	bl	800c218 <_tx_mutex_get>
 80066fa:	2800      	cmp	r0, #0
 80066fc:	f040 809b 	bne.w	8006836 <_fx_file_open+0x18e>

    /* Setup file name pointer.  */
    file_ptr -> fx_file_dir_entry.fx_dir_entry_name =  file_ptr -> fx_file_name_buffer;
 8006700:	f105 03d8 	add.w	r3, r5, #216	; 0xd8
    file_ptr -> fx_file_dir_entry.fx_dir_entry_short_name[0] =  0;
 8006704:	f885 006c 	strb.w	r0, [r5, #108]	; 0x6c

    /* Search the system for the supplied file name.  */
    status =  _fx_directory_search(media_ptr, file_name, &(file_ptr -> fx_file_dir_entry), FX_NULL, FX_NULL);
 8006708:	4639      	mov	r1, r7
 800670a:	9000      	str	r0, [sp, #0]
    file_ptr -> fx_file_dir_entry.fx_dir_entry_name =  file_ptr -> fx_file_name_buffer;
 800670c:	461a      	mov	r2, r3
 800670e:	930b      	str	r3, [sp, #44]	; 0x2c
    status =  _fx_directory_search(media_ptr, file_name, &(file_ptr -> fx_file_dir_entry), FX_NULL, FX_NULL);
 8006710:	4603      	mov	r3, r0
 8006712:	4620      	mov	r0, r4
    file_ptr -> fx_file_dir_entry.fx_dir_entry_name =  file_ptr -> fx_file_name_buffer;
 8006714:	66aa      	str	r2, [r5, #104]	; 0x68
    status =  _fx_directory_search(media_ptr, file_name, &(file_ptr -> fx_file_dir_entry), FX_NULL, FX_NULL);
 8006716:	f105 0268 	add.w	r2, r5, #104	; 0x68
 800671a:	f003 fadb 	bl	8009cd4 <_fx_directory_search>

    /* Determine if the search was successful.  */
    if (status != FX_SUCCESS)
 800671e:	4607      	mov	r7, r0
 8006720:	2800      	cmp	r0, #0
 8006722:	f040 809a 	bne.w	800685a <_fx_file_open+0x1b2>
        /* Return the error code.  */
        return(status);
    }

    /* Check to make sure the found entry is a file.  */
    if (file_ptr -> fx_file_dir_entry.fx_dir_entry_attributes & not_a_file_attr)
 8006726:	f895 3084 	ldrb.w	r3, [r5, #132]	; 0x84
 800672a:	f013 0f18 	tst.w	r3, #24
 800672e:	f040 8181 	bne.w	8006a34 <_fx_file_open+0x38c>
            open_count--;
        }
    }
    else
#else
    if (open_type == FX_OPEN_FOR_WRITE)
 8006732:	f1b8 0f01 	cmp.w	r8, #1
 8006736:	f000 8134 	beq.w	80069a2 <_fx_file_open+0x2fa>
    /* At this point, we are ready to walk list of clusters to setup the
       initial condition of this file as well as to verify its integrity.  */
    cluster =           file_ptr -> fx_file_dir_entry.fx_dir_entry_cluster;
    bytes_remaining =   file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size;
    bytes_per_cluster = ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
        ((ULONG)media_ptr -> fx_media_sectors_per_cluster);
 800673a:	6d62      	ldr	r2, [r4, #84]	; 0x54
    file_ptr -> fx_file_current_physical_cluster =  0;
 800673c:	f04f 0a00 	mov.w	sl, #0
    bytes_per_cluster = ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 8006740:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    cluster =           file_ptr -> fx_file_dir_entry.fx_dir_entry_cluster;
 8006742:	f8d5 109c 	ldr.w	r1, [r5, #156]	; 0x9c
    bytes_per_cluster = ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 8006746:	930e      	str	r3, [sp, #56]	; 0x38
        ((ULONG)media_ptr -> fx_media_sectors_per_cluster);
 8006748:	920c      	str	r2, [sp, #48]	; 0x30
    bytes_per_cluster = ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 800674a:	fb02 f303 	mul.w	r3, r2, r3
    cluster =           file_ptr -> fx_file_dir_entry.fx_dir_entry_cluster;
 800674e:	9109      	str	r1, [sp, #36]	; 0x24
    bytes_per_cluster = ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 8006750:	930a      	str	r3, [sp, #40]	; 0x28
    file_ptr -> fx_file_current_physical_cluster =  0;
 8006752:	f8c5 a020 	str.w	sl, [r5, #32]
    bytes_remaining =   file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size;
 8006756:	e9d5 1228 	ldrd	r1, r2, [r5, #160]	; 0xa0
 800675a:	e9cd 1202 	strd	r1, r2, [sp, #8]

    /* Check for invalid value.  */
    if (bytes_per_cluster == 0)
 800675e:	2b00      	cmp	r3, #0
 8006760:	f000 8170 	beq.w	8006a44 <_fx_file_open+0x39c>
    }

    last_cluster =      0;
    cluster_count =     0;
    leading_consecutive = 1;
    file_ptr -> fx_file_consecutive_cluster = 1;
 8006764:	2301      	movs	r3, #1
 8006766:	61ab      	str	r3, [r5, #24]

    /* Determine if the file is being open for reading with the fast option.  */
    if (fast_open)
 8006768:	2e00      	cmp	r6, #0
 800676a:	f040 8083 	bne.w	8006874 <_fx_file_open+0x1cc>
        else
        {
#endif /* FX_ENABLE_EXFAT */

            /* Follow the link of FAT entries.  */
            while ((cluster >= FX_FAT_ENTRY_START) && (cluster < media_ptr -> fx_media_fat_reserved))
 800676e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8006770:	4298      	cmp	r0, r3
 8006772:	f240 81c6 	bls.w	8006b02 <_fx_file_open+0x45a>
 8006776:	f242 42a8 	movw	r2, #9384	; 0x24a8
 800677a:	58a1      	ldr	r1, [r4, r2]
 800677c:	4288      	cmp	r0, r1
 800677e:	f080 81c0 	bcs.w	8006b02 <_fx_file_open+0x45a>
 8006782:	eb04 0a02 	add.w	sl, r4, r2
                /* Setup for the next cluster.  */
                cluster =  contents;

                /* Determine if this is the last written cluster.  We need to remember this
                   for open for writing.  */
                if (bytes_remaining > bytes_per_cluster)
 8006786:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8006788:	2100      	movs	r1, #0
 800678a:	970e      	str	r7, [sp, #56]	; 0x38
 800678c:	4610      	mov	r0, r2
 800678e:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8006790:	f8cd b030 	str.w	fp, [sp, #48]	; 0x30
 8006794:	4699      	mov	r9, r3
 8006796:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 800679a:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
 800679e:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80067a2:	e010      	b.n	80067c6 <_fx_file_open+0x11e>
                {

                    /* Still more written clusters, just decrement the counter.  */
                    bytes_remaining =  bytes_remaining - bytes_per_cluster;
 80067a4:	ebbb 0909 	subs.w	r9, fp, r9
 80067a8:	eb6c 0a0a 	sbc.w	sl, ip, sl
 80067ac:	e9cd 9a02 	strd	r9, sl, [sp, #8]
            while ((cluster >= FX_FAT_ENTRY_START) && (cluster < media_ptr -> fx_media_fat_reserved))
 80067b0:	2a01      	cmp	r2, #1
 80067b2:	f240 8158 	bls.w	8006a66 <_fx_file_open+0x3be>
 80067b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80067b8:	681b      	ldr	r3, [r3, #0]
 80067ba:	429a      	cmp	r2, r3
 80067bc:	f080 8153 	bcs.w	8006a66 <_fx_file_open+0x3be>
 80067c0:	4646      	mov	r6, r8
                        /* We need to position to next allocated cluster.  */
                        file_ptr -> fx_file_current_physical_cluster =  cluster;
                        file_ptr -> fx_file_current_relative_cluster++;

                        /* Clear the remaining bytes.  */
                        bytes_remaining =  0;
 80067c2:	4617      	mov	r7, r2
 80067c4:	4681      	mov	r9, r0
                status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &contents);
 80067c6:	aa11      	add	r2, sp, #68	; 0x44
 80067c8:	4639      	mov	r1, r7
 80067ca:	4620      	mov	r0, r4
                cluster_count++;
 80067cc:	f106 0801 	add.w	r8, r6, #1
                status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &contents);
 80067d0:	f001 f808 	bl	80077e4 <_fx_utility_FAT_entry_read>
                if (status != FX_SUCCESS)
 80067d4:	2800      	cmp	r0, #0
 80067d6:	f040 8187 	bne.w	8006ae8 <_fx_file_open+0x440>
                if ((cluster == contents) || (cluster_count > media_ptr -> fx_media_total_clusters))
 80067da:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80067dc:	42ba      	cmp	r2, r7
 80067de:	f000 813b 	beq.w	8006a58 <_fx_file_open+0x3b0>
 80067e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80067e4:	4543      	cmp	r3, r8
 80067e6:	f0c0 8137 	bcc.w	8006a58 <_fx_file_open+0x3b0>
                if (cluster + 1 == contents)
 80067ea:	1c7b      	adds	r3, r7, #1
                    if (leading_consecutive)
 80067ec:	4293      	cmp	r3, r2
 80067ee:	d102      	bne.n	80067f6 <_fx_file_open+0x14e>
 80067f0:	f019 0f01 	tst.w	r9, #1
 80067f4:	d135      	bne.n	8006862 <_fx_file_open+0x1ba>
                if (bytes_remaining > bytes_per_cluster)
 80067f6:	e9dd 9a06 	ldrd	r9, sl, [sp, #24]
 80067fa:	e9dd bc02 	ldrd	fp, ip, [sp, #8]
 80067fe:	45e2      	cmp	sl, ip
 8006800:	bf08      	it	eq
 8006802:	45d9      	cmpeq	r9, fp
 8006804:	d3ce      	bcc.n	80067a4 <_fx_file_open+0xfc>
                else if (!file_ptr -> fx_file_current_physical_cluster)
 8006806:	6a2b      	ldr	r3, [r5, #32]
 8006808:	2b00      	cmp	r3, #0
 800680a:	d1d1      	bne.n	80067b0 <_fx_file_open+0x108>
                    if ((bytes_remaining == bytes_per_cluster) &&
 800680c:	45e2      	cmp	sl, ip
                    file_ptr -> fx_file_current_physical_cluster =  last_cluster;
 800680e:	622f      	str	r7, [r5, #32]
                    file_ptr -> fx_file_current_relative_cluster =  cluster_count - 1;
 8006810:	636e      	str	r6, [r5, #52]	; 0x34
                    if ((bytes_remaining == bytes_per_cluster) &&
 8006812:	bf08      	it	eq
 8006814:	45d9      	cmpeq	r9, fp
 8006816:	d1cb      	bne.n	80067b0 <_fx_file_open+0x108>
 8006818:	2a01      	cmp	r2, #1
 800681a:	d9c9      	bls.n	80067b0 <_fx_file_open+0x108>
                        (cluster >= FX_FAT_ENTRY_START) && (cluster < media_ptr -> fx_media_fat_reserved))
 800681c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800681e:	681b      	ldr	r3, [r3, #0]
 8006820:	429a      	cmp	r2, r3
 8006822:	f080 8120 	bcs.w	8006a66 <_fx_file_open+0x3be>
                        bytes_remaining =  0;
 8006826:	2600      	movs	r6, #0
 8006828:	2700      	movs	r7, #0
                        file_ptr -> fx_file_current_physical_cluster =  cluster;
 800682a:	622a      	str	r2, [r5, #32]
                        file_ptr -> fx_file_current_relative_cluster++;
 800682c:	f8c5 8034 	str.w	r8, [r5, #52]	; 0x34
                        bytes_remaining =  0;
 8006830:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8006834:	e7c4      	b.n	80067c0 <_fx_file_open+0x118>
        return(FX_MEDIA_NOT_OPEN);
 8006836:	2711      	movs	r7, #17
    /* Release media protection.  */
    FX_UNPROTECT

    /* Open is complete, return successful status.  */
    return(FX_SUCCESS);
}
 8006838:	4638      	mov	r0, r7
 800683a:	b013      	add	sp, #76	; 0x4c
 800683c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    FX_PROTECT
 8006840:	f504 7be4 	add.w	fp, r4, #456	; 0x1c8
 8006844:	f04f 31ff 	mov.w	r1, #4294967295
        open_type =  FX_OPEN_FOR_READ;
 8006848:	46b0      	mov	r8, r6
        fast_open =  FX_TRUE;
 800684a:	2601      	movs	r6, #1
    FX_PROTECT
 800684c:	4658      	mov	r0, fp
 800684e:	f005 fce3 	bl	800c218 <_tx_mutex_get>
 8006852:	2800      	cmp	r0, #0
 8006854:	f43f af54 	beq.w	8006700 <_fx_file_open+0x58>
 8006858:	e7ed      	b.n	8006836 <_fx_file_open+0x18e>
        FX_UNPROTECT
 800685a:	4658      	mov	r0, fp
 800685c:	f005 fdc6 	bl	800c3ec <_tx_mutex_put>
        return(status);
 8006860:	e7ea      	b.n	8006838 <_fx_file_open+0x190>
                        file_ptr -> fx_file_consecutive_cluster++;
 8006862:	69ab      	ldr	r3, [r5, #24]
 8006864:	2001      	movs	r0, #1
 8006866:	4403      	add	r3, r0
 8006868:	61ab      	str	r3, [r5, #24]
 800686a:	e7c4      	b.n	80067f6 <_fx_file_open+0x14e>
 800686c:	4d454449 	.word	0x4d454449
 8006870:	0ffffff8 	.word	0x0ffffff8
 8006874:	4608      	mov	r0, r1
        bytes_available =  ((bytes_remaining + bytes_per_cluster - 1) / bytes_per_cluster) * bytes_per_cluster;
 8006876:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8006878:	f110 30ff 	adds.w	r0, r0, #4294967295
 800687c:	f142 31ff 	adc.w	r1, r2, #4294967295
 8006880:	2200      	movs	r2, #0
 8006882:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8006886:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 800688a:	4613      	mov	r3, r2
 800688c:	4632      	mov	r2, r6
 800688e:	1980      	adds	r0, r0, r6
 8006890:	4159      	adcs	r1, r3
 8006892:	f7f9 fe09 	bl	80004a8 <__aeabi_uldivmod>
 8006896:	fba0 2306 	umull	r2, r3, r0, r6
 800689a:	46d6      	mov	lr, sl
 800689c:	960a      	str	r6, [sp, #40]	; 0x28
 800689e:	469a      	mov	sl, r3
 80068a0:	4691      	mov	r9, r2
 80068a2:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
    last_cluster =      0;
 80068a6:	4676      	mov	r6, lr
    bytes_remaining =   file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size;
 80068a8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
        bytes_available =  ((bytes_remaining + bytes_per_cluster - 1) / bytes_per_cluster) * bytes_per_cluster;
 80068ac:	e9cd 9a06 	strd	r9, sl, [sp, #24]
    bytes_remaining =   file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size;
 80068b0:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
        bytes_available =  ((bytes_remaining + bytes_per_cluster - 1) / bytes_per_cluster) * bytes_per_cluster;
 80068b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80068b6:	fb03 a301 	mla	r3, r3, r1, sl
 80068ba:	9307      	str	r3, [sp, #28]
    cluster_count =     0;
 80068bc:	4673      	mov	r3, lr
    file_ptr -> fx_file_name =                      file_ptr -> fx_file_name_buffer;
 80068be:	990b      	ldr	r1, [sp, #44]	; 0x2c
    file_ptr -> fx_file_modified =                  FX_FALSE;
 80068c0:	2200      	movs	r2, #0
    file_ptr -> fx_file_id =                        FX_FILE_ID;
 80068c2:	4897      	ldr	r0, [pc, #604]	; (8006b20 <_fx_file_open+0x478>)
    file_ptr -> fx_file_name =                      file_ptr -> fx_file_name_buffer;
 80068c4:	6069      	str	r1, [r5, #4]
    file_ptr -> fx_file_first_physical_cluster =    file_ptr -> fx_file_dir_entry.fx_dir_entry_cluster;
 80068c6:	9909      	ldr	r1, [sp, #36]	; 0x24
    file_ptr -> fx_file_modified =                  FX_FALSE;
 80068c8:	732a      	strb	r2, [r5, #12]
    file_ptr -> fx_file_total_clusters =            cluster_count;
 80068ca:	612b      	str	r3, [r5, #16]
 80068cc:	6d23      	ldr	r3, [r4, #80]	; 0x50
    file_ptr -> fx_file_first_physical_cluster =    file_ptr -> fx_file_dir_entry.fx_dir_entry_cluster;
 80068ce:	6169      	str	r1, [r5, #20]
 80068d0:	2100      	movs	r1, #0
    file_ptr -> fx_file_id =                        FX_FILE_ID;
 80068d2:	6028      	str	r0, [r5, #0]
 80068d4:	4699      	mov	r9, r3
 80068d6:	468a      	mov	sl, r1
    file_ptr -> fx_file_media_ptr =                 media_ptr;
 80068d8:	65ac      	str	r4, [r5, #88]	; 0x58
    file_ptr -> fx_file_open_mode =                 open_type;
 80068da:	f8c5 8008 	str.w	r8, [r5, #8]
    file_ptr -> fx_file_last_physical_cluster =     last_cluster;
 80068de:	61ee      	str	r6, [r5, #28]
    file_ptr -> fx_file_disable_burst_cache =       FX_FALSE;
 80068e0:	f8c5 21d8 	str.w	r2, [r5, #472]	; 0x1d8
    file_ptr -> fx_file_current_file_size =         file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size;
 80068e4:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80068e8:	e9cd 9a04 	strd	r9, sl, [sp, #16]
 80068ec:	e9c5 0112 	strd	r0, r1, [r5, #72]	; 0x48
    file_ptr -> fx_file_current_available_size =    bytes_available;
 80068f0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80068f4:	e9c5 0114 	strd	r0, r1, [r5, #80]	; 0x50
    if (open_type == FX_OPEN_FOR_READ)
 80068f8:	f1b8 0f00 	cmp.w	r8, #0
 80068fc:	d07a      	beq.n	80069f4 <_fx_file_open+0x34c>
        if (bytes_remaining == bytes_per_cluster)
 80068fe:	990a      	ldr	r1, [sp, #40]	; 0x28
 8006900:	f04f 0900 	mov.w	r9, #0
 8006904:	6a2b      	ldr	r3, [r5, #32]
 8006906:	4688      	mov	r8, r1
 8006908:	1e98      	subs	r0, r3, #2
 800690a:	e9cd 8906 	strd	r8, r9, [sp, #24]
 800690e:	f04f 0900 	mov.w	r9, #0
 8006912:	fb00 fa0e 	mul.w	sl, r0, lr
 8006916:	f149 31ff 	adc.w	r1, r9, #4294967295
 800691a:	fba0 890c 	umull	r8, r9, r0, ip
 800691e:	fb0c aa01 	mla	sl, ip, r1, sl
 8006922:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8006926:	44d1      	add	r9, sl
 8006928:	eb10 0008 	adds.w	r0, r0, r8
 800692c:	eb41 0109 	adc.w	r1, r1, r9
 8006930:	e9dd 8906 	ldrd	r8, r9, [sp, #24]
 8006934:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8006938:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800693c:	4589      	cmp	r9, r1
 800693e:	bf08      	it	eq
 8006940:	4580      	cmpeq	r8, r0
 8006942:	f000 80b9 	beq.w	8006ab8 <_fx_file_open+0x410>
                ((ULONG)((bytes_remaining / (ULONG)media_ptr -> fx_media_bytes_per_sector)));
 8006946:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8006948:	4680      	mov	r8, r0
 800694a:	4689      	mov	r9, r1
 800694c:	4613      	mov	r3, r2
 800694e:	4632      	mov	r2, r6
 8006950:	f7f9 fdaa 	bl	80004a8 <__aeabi_uldivmod>
 8006954:	63a8      	str	r0, [r5, #56]	; 0x38
            file_ptr -> fx_file_current_logical_offset =    (ULONG)bytes_remaining % ((ULONG)media_ptr -> fx_media_bytes_per_sector);
 8006956:	fbb8 f3f6 	udiv	r3, r8, r6
 800695a:	e9cd 8902 	strd	r8, r9, [sp, #8]
 800695e:	9902      	ldr	r1, [sp, #8]
                 ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 8006960:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
            file_ptr -> fx_file_current_logical_offset =    (ULONG)bytes_remaining % ((ULONG)media_ptr -> fx_media_bytes_per_sector);
 8006964:	fb06 1313 	mls	r3, r6, r3, r1
                 ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 8006968:	eb18 0800 	adds.w	r8, r8, r0
            file_ptr -> fx_file_current_logical_offset =    (ULONG)bytes_remaining % ((ULONG)media_ptr -> fx_media_bytes_per_sector);
 800696c:	632b      	str	r3, [r5, #48]	; 0x30
                 ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 800696e:	f149 0900 	adc.w	r9, r9, #0
            file_ptr -> fx_file_current_file_offset =       file_ptr -> fx_file_current_file_size;
 8006972:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
            file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8006976:	e9c5 890a 	strd	r8, r9, [r5, #40]	; 0x28
            file_ptr -> fx_file_current_file_offset =       file_ptr -> fx_file_current_file_size;
 800697a:	e9c5 2310 	strd	r2, r3, [r5, #64]	; 0x40
    if (media_ptr -> fx_media_opened_file_list)
 800697e:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 8006982:	2b00      	cmp	r3, #0
 8006984:	d063      	beq.n	8006a4e <_fx_file_open+0x3a6>
        tail_ptr =  (media_ptr -> fx_media_opened_file_list) -> fx_file_opened_previous;
 8006986:	6e1a      	ldr	r2, [r3, #96]	; 0x60
        (media_ptr -> fx_media_opened_file_list) -> fx_file_opened_previous =  file_ptr;
 8006988:	661d      	str	r5, [r3, #96]	; 0x60
        tail_ptr -> fx_file_opened_next =  file_ptr;
 800698a:	65d5      	str	r5, [r2, #92]	; 0x5c
        file_ptr -> fx_file_opened_previous =  tail_ptr;
 800698c:	662a      	str	r2, [r5, #96]	; 0x60
        file_ptr -> fx_file_opened_next =      media_ptr -> fx_media_opened_file_list;
 800698e:	65eb      	str	r3, [r5, #92]	; 0x5c
    media_ptr -> fx_media_opened_file_count++;
 8006990:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
    FX_UNPROTECT
 8006994:	4658      	mov	r0, fp
    media_ptr -> fx_media_opened_file_count++;
 8006996:	3301      	adds	r3, #1
 8006998:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
    FX_UNPROTECT
 800699c:	f005 fd26 	bl	800c3ec <_tx_mutex_put>
    return(FX_SUCCESS);
 80069a0:	e74a      	b.n	8006838 <_fx_file_open+0x190>
        if (media_ptr -> fx_media_driver_write_protect)
 80069a2:	f8d4 20a8 	ldr.w	r2, [r4, #168]	; 0xa8
 80069a6:	2a00      	cmp	r2, #0
 80069a8:	d13f      	bne.n	8006a2a <_fx_file_open+0x382>
        if (file_ptr -> fx_file_dir_entry.fx_dir_entry_attributes & (UCHAR)(FX_READ_ONLY))
 80069aa:	07db      	lsls	r3, r3, #31
 80069ac:	d41d      	bmi.n	80069ea <_fx_file_open+0x342>
        search_ptr =  media_ptr -> fx_media_opened_file_list;
 80069ae:	e9d4 3232 	ldrd	r3, r2, [r4, #200]	; 0xc8
        while (open_count)
 80069b2:	2a00      	cmp	r2, #0
 80069b4:	f43f aec1 	beq.w	800673a <_fx_file_open+0x92>
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector) &&
 80069b8:	46dc      	mov	ip, fp
 80069ba:	46a1      	mov	r9, r4
 80069bc:	e9d5 012a 	ldrd	r0, r1, [r5, #168]	; 0xa8
 80069c0:	e002      	b.n	80069c8 <_fx_file_open+0x320>
        while (open_count)
 80069c2:	3a01      	subs	r2, #1
            search_ptr =  search_ptr -> fx_file_opened_next;
 80069c4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
        while (open_count)
 80069c6:	d03a      	beq.n	8006a3e <_fx_file_open+0x396>
            if ((search_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector ==
 80069c8:	e9d3 ab2a 	ldrd	sl, fp, [r3, #168]	; 0xa8
 80069cc:	458b      	cmp	fp, r1
 80069ce:	bf08      	it	eq
 80069d0:	4582      	cmpeq	sl, r0
 80069d2:	d1f6      	bne.n	80069c2 <_fx_file_open+0x31a>
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_log_sector) &&
 80069d4:	f8d3 40b0 	ldr.w	r4, [r3, #176]	; 0xb0
 80069d8:	46a6      	mov	lr, r4
 80069da:	f8d5 40b0 	ldr.w	r4, [r5, #176]	; 0xb0
 80069de:	45a6      	cmp	lr, r4
 80069e0:	d1ef      	bne.n	80069c2 <_fx_file_open+0x31a>
                 file_ptr -> fx_file_dir_entry.fx_dir_entry_byte_offset) &&
 80069e2:	689c      	ldr	r4, [r3, #8]
 80069e4:	2c01      	cmp	r4, #1
 80069e6:	d1ec      	bne.n	80069c2 <_fx_file_open+0x31a>
 80069e8:	46e3      	mov	fp, ip
                FX_UNPROTECT
 80069ea:	4658      	mov	r0, fp
                return(FX_ACCESS_ERROR);
 80069ec:	2706      	movs	r7, #6
                FX_UNPROTECT
 80069ee:	f005 fcfd 	bl	800c3ec <_tx_mutex_put>
                return(FX_ACCESS_ERROR);
 80069f2:	e721      	b.n	8006838 <_fx_file_open+0x190>
            (((ULONG64)(file_ptr -> fx_file_first_physical_cluster - FX_FAT_ENTRY_START)) *
 80069f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
        file_ptr -> fx_file_current_file_offset =       0;
 80069f6:	2000      	movs	r0, #0
        file_ptr -> fx_file_current_relative_cluster =  0;
 80069f8:	f8c5 8034 	str.w	r8, [r5, #52]	; 0x34
        file_ptr -> fx_file_current_file_offset =       0;
 80069fc:	2100      	movs	r1, #0
            (((ULONG64)(file_ptr -> fx_file_first_physical_cluster - FX_FAT_ENTRY_START)) *
 80069fe:	1e9e      	subs	r6, r3, #2
        file_ptr -> fx_file_current_physical_cluster =  file_ptr -> fx_file_first_physical_cluster;
 8006a00:	622b      	str	r3, [r5, #32]
        file_ptr -> fx_file_current_relative_sector =   0;
 8006a02:	f8c5 8038 	str.w	r8, [r5, #56]	; 0x38
            (((ULONG64)(file_ptr -> fx_file_first_physical_cluster - FX_FAT_ENTRY_START)) *
 8006a06:	fba6 230c 	umull	r2, r3, r6, ip
        file_ptr -> fx_file_current_logical_offset =    0;
 8006a0a:	f8c5 8030 	str.w	r8, [r5, #48]	; 0x30
        file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8006a0e:	46c8      	mov	r8, r9
            (((ULONG64)(file_ptr -> fx_file_first_physical_cluster - FX_FAT_ENTRY_START)) *
 8006a10:	fb06 330e 	mla	r3, r6, lr, r3
        file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8006a14:	eb18 0802 	adds.w	r8, r8, r2
 8006a18:	eb4a 0903 	adc.w	r9, sl, r3
 8006a1c:	4642      	mov	r2, r8
 8006a1e:	464b      	mov	r3, r9
        file_ptr -> fx_file_current_file_offset =       0;
 8006a20:	e9c5 0110 	strd	r0, r1, [r5, #64]	; 0x40
        file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8006a24:	e9c5 230a 	strd	r2, r3, [r5, #40]	; 0x28
 8006a28:	e7a9      	b.n	800697e <_fx_file_open+0x2d6>
            FX_UNPROTECT
 8006a2a:	4658      	mov	r0, fp
            return(FX_WRITE_PROTECT);
 8006a2c:	2723      	movs	r7, #35	; 0x23
            FX_UNPROTECT
 8006a2e:	f005 fcdd 	bl	800c3ec <_tx_mutex_put>
            return(FX_WRITE_PROTECT);
 8006a32:	e701      	b.n	8006838 <_fx_file_open+0x190>
        FX_UNPROTECT
 8006a34:	4658      	mov	r0, fp
        return(FX_NOT_A_FILE);
 8006a36:	2705      	movs	r7, #5
        FX_UNPROTECT
 8006a38:	f005 fcd8 	bl	800c3ec <_tx_mutex_put>
        return(FX_NOT_A_FILE);
 8006a3c:	e6fc      	b.n	8006838 <_fx_file_open+0x190>
 8006a3e:	46e3      	mov	fp, ip
 8006a40:	464c      	mov	r4, r9
 8006a42:	e67a      	b.n	800673a <_fx_file_open+0x92>
        FX_UNPROTECT
 8006a44:	4658      	mov	r0, fp
        return(FX_MEDIA_INVALID);
 8006a46:	2702      	movs	r7, #2
        FX_UNPROTECT
 8006a48:	f005 fcd0 	bl	800c3ec <_tx_mutex_put>
        return(FX_MEDIA_INVALID);
 8006a4c:	e6f4      	b.n	8006838 <_fx_file_open+0x190>
        media_ptr -> fx_media_opened_file_list =   file_ptr;
 8006a4e:	f8c4 50c8 	str.w	r5, [r4, #200]	; 0xc8
        file_ptr ->  fx_file_opened_next =         file_ptr;
 8006a52:	65ed      	str	r5, [r5, #92]	; 0x5c
        file_ptr ->  fx_file_opened_previous =     file_ptr;
 8006a54:	662d      	str	r5, [r5, #96]	; 0x60
 8006a56:	e79b      	b.n	8006990 <_fx_file_open+0x2e8>
 8006a58:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
                    return(FX_FAT_READ_ERROR);
 8006a5c:	2703      	movs	r7, #3
                    FX_UNPROTECT
 8006a5e:	4658      	mov	r0, fp
 8006a60:	f005 fcc4 	bl	800c3ec <_tx_mutex_put>
                    return(FX_FAT_READ_ERROR);
 8006a64:	e6e8      	b.n	8006838 <_fx_file_open+0x190>
            bytes_available =  ((ULONG64)media_ptr -> fx_media_bytes_per_sector) *
 8006a66:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8006a68:	4643      	mov	r3, r8
                ((ULONG64)media_ptr -> fx_media_sectors_per_cluster) *
 8006a6a:	f8d4 c054 	ldr.w	ip, [r4, #84]	; 0x54
 8006a6e:	f04f 0e00 	mov.w	lr, #0
 8006a72:	9709      	str	r7, [sp, #36]	; 0x24
 8006a74:	9f0e      	ldr	r7, [sp, #56]	; 0x38
            bytes_available =  ((ULONG64)media_ptr -> fx_media_bytes_per_sector) *
 8006a76:	910e      	str	r1, [sp, #56]	; 0x38
 8006a78:	fba1 010c 	umull	r0, r1, r1, ip
 8006a7c:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8006a80:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
 8006a84:	fba0 9a03 	umull	r9, sl, r0, r3
 8006a88:	fb03 a101 	mla	r1, r3, r1, sl
 8006a8c:	e9cd 9a06 	strd	r9, sl, [sp, #24]
 8006a90:	9107      	str	r1, [sp, #28]
            if ((bytes_available < file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size) ||
 8006a92:	e9dd 9a06 	ldrd	r9, sl, [sp, #24]
 8006a96:	e9d5 0128 	ldrd	r0, r1, [r5, #160]	; 0xa0
 8006a9a:	458a      	cmp	sl, r1
 8006a9c:	bf08      	it	eq
 8006a9e:	4581      	cmpeq	r9, r0
 8006aa0:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 8006aa4:	d328      	bcc.n	8006af8 <_fx_file_open+0x450>
 8006aa6:	b113      	cbz	r3, 8006aae <_fx_file_open+0x406>
                ((cluster_count) && (contents < fat_last)))
 8006aa8:	9904      	ldr	r1, [sp, #16]
 8006aaa:	428a      	cmp	r2, r1
 8006aac:	d324      	bcc.n	8006af8 <_fx_file_open+0x450>
            if ((bytes_available < file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size) ||
 8006aae:	f8d5 209c 	ldr.w	r2, [r5, #156]	; 0x9c
 8006ab2:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8006ab4:	9209      	str	r2, [sp, #36]	; 0x24
 8006ab6:	e702      	b.n	80068be <_fx_file_open+0x216>
                ((ULONG)(((bytes_remaining - 1) / (ULONG)media_ptr -> fx_media_bytes_per_sector)));
 8006ab8:	f110 30ff 	adds.w	r0, r0, #4294967295
 8006abc:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8006abe:	4613      	mov	r3, r2
 8006ac0:	f141 31ff 	adc.w	r1, r1, #4294967295
 8006ac4:	4632      	mov	r2, r6
 8006ac6:	f7f9 fcef 	bl	80004a8 <__aeabi_uldivmod>
            file_ptr -> fx_file_current_logical_offset =    media_ptr -> fx_media_bytes_per_sector;
 8006aca:	632e      	str	r6, [r5, #48]	; 0x30
                ((ULONG)(((bytes_remaining - 1) / (ULONG)media_ptr -> fx_media_bytes_per_sector)));
 8006acc:	63a8      	str	r0, [r5, #56]	; 0x38
                 ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 8006ace:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
            file_ptr -> fx_file_current_file_offset =       file_ptr -> fx_file_current_file_size;
 8006ad2:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
                 ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
 8006ad6:	eb18 0800 	adds.w	r8, r8, r0
 8006ada:	eb49 0901 	adc.w	r9, r9, r1
            file_ptr -> fx_file_current_file_offset =       file_ptr -> fx_file_current_file_size;
 8006ade:	e9c5 2310 	strd	r2, r3, [r5, #64]	; 0x40
            file_ptr -> fx_file_current_logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8006ae2:	e9c5 890a 	strd	r8, r9, [r5, #40]	; 0x28
 8006ae6:	e74a      	b.n	800697e <_fx_file_open+0x2d6>
 8006ae8:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8006aec:	4601      	mov	r1, r0
                    FX_UNPROTECT
 8006aee:	4658      	mov	r0, fp
                status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &contents);
 8006af0:	460f      	mov	r7, r1
                    FX_UNPROTECT
 8006af2:	f005 fc7b 	bl	800c3ec <_tx_mutex_put>
                    return(status);
 8006af6:	e69f      	b.n	8006838 <_fx_file_open+0x190>
                FX_UNPROTECT
 8006af8:	4658      	mov	r0, fp
                return(FX_FILE_CORRUPT);
 8006afa:	2708      	movs	r7, #8
                FX_UNPROTECT
 8006afc:	f005 fc76 	bl	800c3ec <_tx_mutex_put>
                return(FX_FILE_CORRUPT);
 8006b00:	e69a      	b.n	8006838 <_fx_file_open+0x190>
            if ((bytes_available < file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size) ||
 8006b02:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8006b06:	ea52 0103 	orrs.w	r1, r2, r3
 8006b0a:	d1f5      	bne.n	8006af8 <_fx_file_open+0x450>
 8006b0c:	f04f 0e00 	mov.w	lr, #0
 8006b10:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
            bytes_available =  ((ULONG64)media_ptr -> fx_media_bytes_per_sector) *
 8006b14:	e9cd 2306 	strd	r2, r3, [sp, #24]
            if ((bytes_available < file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size) ||
 8006b18:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 8006b1c:	4673      	mov	r3, lr
 8006b1e:	e6ce      	b.n	80068be <_fx_file_open+0x216>
 8006b20:	46494c45 	.word	0x46494c45

08006b24 <_fx_file_read>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_file_read(FX_FILE *file_ptr, VOID *buffer_ptr, ULONG request_size, ULONG *actual_size)
{
 8006b24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006b28:	4605      	mov	r5, r0
 8006b2a:	b08f      	sub	sp, #60	; 0x3c
ULONG                  trace_timestamp;
#endif


    /* First, determine if the file is still open.  */
    if (file_ptr -> fx_file_id != FX_FILE_ID)
 8006b2c:	48ac      	ldr	r0, [pc, #688]	; (8006de0 <_fx_file_read+0x2bc>)
{
 8006b2e:	9205      	str	r2, [sp, #20]
    if (file_ptr -> fx_file_id != FX_FILE_ID)
 8006b30:	682a      	ldr	r2, [r5, #0]
{
 8006b32:	9308      	str	r3, [sp, #32]
    if (file_ptr -> fx_file_id != FX_FILE_ID)
 8006b34:	4282      	cmp	r2, r0
 8006b36:	d10f      	bne.n	8006b58 <_fx_file_read+0x34>
        return(FX_NOT_OPEN);
    }

#ifndef FX_MEDIA_STATISTICS_DISABLE
    /* Setup pointer to media structure.  */
    media_ptr =  file_ptr -> fx_file_media_ptr;
 8006b38:	6dac      	ldr	r4, [r5, #88]	; 0x58
 8006b3a:	468a      	mov	sl, r1

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_FILE_READ, file_ptr, buffer_ptr, request_size, 0, FX_TRACE_FILE_EVENTS, &trace_event, &trace_timestamp)

    /* Protect against other threads accessing the media.  */
    FX_PROTECT
 8006b3c:	4aa9      	ldr	r2, [pc, #676]	; (8006de4 <_fx_file_read+0x2c0>)
    media_ptr -> fx_media_file_reads++;
 8006b3e:	f8d4 313c 	ldr.w	r3, [r4, #316]	; 0x13c
    FX_PROTECT
 8006b42:	6821      	ldr	r1, [r4, #0]
    media_ptr -> fx_media_file_reads++;
 8006b44:	3301      	adds	r3, #1
    FX_PROTECT
 8006b46:	4291      	cmp	r1, r2
    media_ptr -> fx_media_file_reads++;
 8006b48:	f8c4 313c 	str.w	r3, [r4, #316]	; 0x13c
    FX_PROTECT
 8006b4c:	d009      	beq.n	8006b62 <_fx_file_read+0x3e>
 8006b4e:	2211      	movs	r2, #17
    /* Release media protection.  */
    FX_UNPROTECT

    /* Return a successful status to the caller.  */
    return(FX_SUCCESS);
}
 8006b50:	4610      	mov	r0, r2
 8006b52:	b00f      	add	sp, #60	; 0x3c
 8006b54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return(FX_NOT_OPEN);
 8006b58:	2207      	movs	r2, #7
}
 8006b5a:	4610      	mov	r0, r2
 8006b5c:	b00f      	add	sp, #60	; 0x3c
 8006b5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    FX_PROTECT
 8006b62:	f504 73e4 	add.w	r3, r4, #456	; 0x1c8
 8006b66:	f04f 31ff 	mov.w	r1, #4294967295
 8006b6a:	4618      	mov	r0, r3
 8006b6c:	9309      	str	r3, [sp, #36]	; 0x24
 8006b6e:	f005 fb53 	bl	800c218 <_tx_mutex_get>
 8006b72:	4680      	mov	r8, r0
 8006b74:	2800      	cmp	r0, #0
 8006b76:	d1ea      	bne.n	8006b4e <_fx_file_read+0x2a>
    if (file_ptr -> fx_file_current_file_offset >=
 8006b78:	e9d5 bc10 	ldrd	fp, ip, [r5, #64]	; 0x40
        file_ptr -> fx_file_current_file_size)
 8006b7c:	e9d5 6712 	ldrd	r6, r7, [r5, #72]	; 0x48
    if (file_ptr -> fx_file_current_file_offset >=
 8006b80:	45bc      	cmp	ip, r7
 8006b82:	bf08      	it	eq
 8006b84:	45b3      	cmpeq	fp, r6
 8006b86:	f080 8131 	bcs.w	8006dec <_fx_file_read+0x2c8>
        (file_ptr -> fx_file_current_file_size - file_ptr -> fx_file_current_file_offset))
 8006b8a:	ebb6 080b 	subs.w	r8, r6, fp
    if ((ULONG64)request_size >
 8006b8e:	f04f 0100 	mov.w	r1, #0
 8006b92:	9b05      	ldr	r3, [sp, #20]
        (file_ptr -> fx_file_current_file_size - file_ptr -> fx_file_current_file_offset))
 8006b94:	eb67 090c 	sbc.w	r9, r7, ip
    if ((ULONG64)request_size >
 8006b98:	4589      	cmp	r9, r1
 8006b9a:	bf08      	it	eq
 8006b9c:	4598      	cmpeq	r8, r3
 8006b9e:	d202      	bcs.n	8006ba6 <_fx_file_read+0x82>
        request_size =  (ULONG)(file_ptr -> fx_file_current_file_size - file_ptr -> fx_file_current_file_offset);
 8006ba0:	eba6 030b 	sub.w	r3, r6, fp
 8006ba4:	9305      	str	r3, [sp, #20]
    while (bytes_remaining)
 8006ba6:	9f05      	ldr	r7, [sp, #20]
 8006ba8:	2f00      	cmp	r7, #0
 8006baa:	d033      	beq.n	8006c14 <_fx_file_read+0xf0>
                        (next_cluster > media_ptr -> fx_media_fat_reserved))
 8006bac:	f242 48a8 	movw	r8, #9384	; 0x24a8
 8006bb0:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8006bb2:	44a0      	add	r8, r4
        if ((file_ptr -> fx_file_current_logical_offset) ||
 8006bb4:	b91a      	cbnz	r2, 8006bbe <_fx_file_read+0x9a>
            (bytes_remaining < media_ptr -> fx_media_bytes_per_sector))
 8006bb6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
        if ((file_ptr -> fx_file_current_logical_offset) ||
 8006bb8:	42bb      	cmp	r3, r7
 8006bba:	f240 80a5 	bls.w	8006d08 <_fx_file_read+0x1e4>
            status =  _fx_utility_logical_sector_read(media_ptr,
 8006bbe:	2204      	movs	r2, #4
 8006bc0:	2301      	movs	r3, #1
 8006bc2:	4620      	mov	r0, r4
 8006bc4:	9202      	str	r2, [sp, #8]
 8006bc6:	9301      	str	r3, [sp, #4]
 8006bc8:	68a1      	ldr	r1, [r4, #8]
 8006bca:	e9d5 230a 	ldrd	r2, r3, [r5, #40]	; 0x28
 8006bce:	9100      	str	r1, [sp, #0]
 8006bd0:	f001 fc82 	bl	80084d8 <_fx_utility_logical_sector_read>
            if (status !=  FX_SUCCESS)
 8006bd4:	2800      	cmp	r0, #0
 8006bd6:	f040 80c0 	bne.w	8006d5a <_fx_file_read+0x236>
                file_ptr -> fx_file_current_logical_offset;
 8006bda:	6b28      	ldr	r0, [r5, #48]	; 0x30
            _fx_utility_memory_copy(((UCHAR *)media_ptr -> fx_media_memory_buffer) +
 8006bdc:	4651      	mov	r1, sl
            copy_bytes =  media_ptr -> fx_media_bytes_per_sector -
 8006bde:	6aa6      	ldr	r6, [r4, #40]	; 0x28
            _fx_utility_memory_copy(((UCHAR *)media_ptr -> fx_media_memory_buffer) +
 8006be0:	68a3      	ldr	r3, [r4, #8]
            copy_bytes =  media_ptr -> fx_media_bytes_per_sector -
 8006be2:	1a36      	subs	r6, r6, r0
            _fx_utility_memory_copy(((UCHAR *)media_ptr -> fx_media_memory_buffer) +
 8006be4:	4418      	add	r0, r3
 8006be6:	42be      	cmp	r6, r7
 8006be8:	bf28      	it	cs
 8006bea:	463e      	movcs	r6, r7
 8006bec:	4632      	mov	r2, r6
            bytes_remaining =  bytes_remaining - copy_bytes;
 8006bee:	1bbf      	subs	r7, r7, r6
            _fx_utility_memory_copy(((UCHAR *)media_ptr -> fx_media_memory_buffer) +
 8006bf0:	f001 ff0e 	bl	8008a10 <_fx_utility_memory_copy>
                file_ptr -> fx_file_current_logical_offset + copy_bytes;
 8006bf4:	6b2a      	ldr	r2, [r5, #48]	; 0x30
        if (file_ptr -> fx_file_current_logical_offset >=
 8006bf6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
            destination_ptr =  destination_ptr + copy_bytes;
 8006bf8:	44b2      	add	sl, r6
                file_ptr -> fx_file_current_logical_offset + copy_bytes;
 8006bfa:	4432      	add	r2, r6
        if (file_ptr -> fx_file_current_logical_offset >=
 8006bfc:	429a      	cmp	r2, r3
            file_ptr -> fx_file_current_logical_offset =
 8006bfe:	632a      	str	r2, [r5, #48]	; 0x30
        if (file_ptr -> fx_file_current_logical_offset >=
 8006c00:	d260      	bcs.n	8006cc4 <_fx_file_read+0x1a0>
    while (bytes_remaining)
 8006c02:	2f00      	cmp	r7, #0
 8006c04:	d1d6      	bne.n	8006bb4 <_fx_file_read+0x90>
 8006c06:	e9d5 2310 	ldrd	r2, r3, [r5, #64]	; 0x40
 8006c0a:	9905      	ldr	r1, [sp, #20]
 8006c0c:	eb12 0b01 	adds.w	fp, r2, r1
 8006c10:	f143 0c00 	adc.w	ip, r3, #0
    *actual_size =  request_size;
 8006c14:	9b08      	ldr	r3, [sp, #32]
    file_ptr -> fx_file_dir_entry.fx_dir_entry_last_accessed_date =  _fx_system_date;
 8006c16:	4974      	ldr	r1, [pc, #464]	; (8006de8 <_fx_file_read+0x2c4>)
    *actual_size =  request_size;
 8006c18:	461a      	mov	r2, r3
 8006c1a:	9b05      	ldr	r3, [sp, #20]
    file_ptr -> fx_file_dir_entry.fx_dir_entry_last_accessed_date =  _fx_system_date;
 8006c1c:	6809      	ldr	r1, [r1, #0]
    FX_UNPROTECT
 8006c1e:	9809      	ldr	r0, [sp, #36]	; 0x24
    file_ptr -> fx_file_current_file_offset =
 8006c20:	e9c5 bc10 	strd	fp, ip, [r5, #64]	; 0x40
    *actual_size =  request_size;
 8006c24:	6013      	str	r3, [r2, #0]
    return(FX_SUCCESS);
 8006c26:	2200      	movs	r2, #0
    file_ptr -> fx_file_dir_entry.fx_dir_entry_last_accessed_date =  _fx_system_date;
 8006c28:	f8c5 1090 	str.w	r1, [r5, #144]	; 0x90
    return(FX_SUCCESS);
 8006c2c:	9205      	str	r2, [sp, #20]
    FX_UNPROTECT
 8006c2e:	f005 fbdd 	bl	800c3ec <_tx_mutex_put>
    return(FX_SUCCESS);
 8006c32:	9a05      	ldr	r2, [sp, #20]
 8006c34:	e78c      	b.n	8006b50 <_fx_file_read+0x2c>
 8006c36:	9b06      	ldr	r3, [sp, #24]
 8006c38:	4645      	mov	r5, r8
 8006c3a:	464e      	mov	r6, r9
 8006c3c:	46b8      	mov	r8, r7
 8006c3e:	455b      	cmp	r3, fp
 8006c40:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8006c42:	bf28      	it	cs
 8006c44:	465b      	movcs	r3, fp
 8006c46:	4619      	mov	r1, r3
 8006c48:	9306      	str	r3, [sp, #24]
            if (sectors == 1)
 8006c4a:	2901      	cmp	r1, #1
 8006c4c:	e9d5 230a 	ldrd	r2, r3, [r5, #40]	; 0x28
 8006c50:	f000 80d6 	beq.w	8006e00 <_fx_file_read+0x2dc>
                media_ptr -> fx_media_disable_burst_cache = file_ptr -> fx_file_disable_burst_cache;
 8006c54:	f8d5 01d8 	ldr.w	r0, [r5, #472]	; 0x1d8
 8006c58:	f242 4ba4 	movw	fp, #9380	; 0x24a4
                status =  _fx_utility_logical_sector_read(media_ptr, file_ptr -> fx_file_current_logical_sector,
 8006c5c:	f04f 0c04 	mov.w	ip, #4
                media_ptr -> fx_media_disable_burst_cache = file_ptr -> fx_file_disable_burst_cache;
 8006c60:	f844 000b 	str.w	r0, [r4, fp]
                status =  _fx_utility_logical_sector_read(media_ptr, file_ptr -> fx_file_current_logical_sector,
 8006c64:	4620      	mov	r0, r4
 8006c66:	9101      	str	r1, [sp, #4]
 8006c68:	f8cd a000 	str.w	sl, [sp]
 8006c6c:	f8cd c008 	str.w	ip, [sp, #8]
 8006c70:	f001 fc32 	bl	80084d8 <_fx_utility_logical_sector_read>
                media_ptr -> fx_media_disable_burst_cache = FX_FALSE;
 8006c74:	2300      	movs	r3, #0
 8006c76:	f844 300b 	str.w	r3, [r4, fp]
                if (status !=  FX_SUCCESS)
 8006c7a:	2800      	cmp	r0, #0
 8006c7c:	d16d      	bne.n	8006d5a <_fx_file_read+0x236>
                (file_ptr -> fx_file_current_relative_sector + (sectors - 1)) /
 8006c7e:	6bab      	ldr	r3, [r5, #56]	; 0x38
                (sectors - 1);
 8006c80:	9906      	ldr	r1, [sp, #24]
                (file_ptr -> fx_file_current_relative_sector + (sectors - 1)) /
 8006c82:	3b01      	subs	r3, #1
                media_ptr -> fx_media_sectors_per_cluster;
 8006c84:	6d60      	ldr	r0, [r4, #84]	; 0x54
                media_ptr -> fx_media_bytes_per_sector;
 8006c86:	6aa2      	ldr	r2, [r4, #40]	; 0x28
                (sectors - 1);
 8006c88:	f101 3cff 	add.w	ip, r1, #4294967295
            file_ptr -> fx_file_current_physical_cluster = cluster;
 8006c8c:	622e      	str	r6, [r5, #32]
                (file_ptr -> fx_file_current_relative_sector + (sectors - 1)) /
 8006c8e:	185e      	adds	r6, r3, r1
                (((ULONG)media_ptr -> fx_media_bytes_per_sector) * sectors);
 8006c90:	fb01 f902 	mul.w	r9, r1, r2
            file_ptr -> fx_file_current_relative_cluster = file_ptr -> fx_file_current_relative_cluster +
 8006c94:	6b69      	ldr	r1, [r5, #52]	; 0x34
            file_ptr -> fx_file_current_logical_offset =
 8006c96:	632a      	str	r2, [r5, #48]	; 0x30
            bytes_remaining =  bytes_remaining -
 8006c98:	eba7 0709 	sub.w	r7, r7, r9
            destination_ptr =  destination_ptr +
 8006c9c:	44ca      	add	sl, r9
                (file_ptr -> fx_file_current_relative_sector + (sectors - 1)) /
 8006c9e:	fbb6 fef0 	udiv	lr, r6, r0
                file_ptr -> fx_file_current_logical_sector +
 8006ca2:	e9d5 230a 	ldrd	r2, r3, [r5, #40]	; 0x28
                 (sectors - 1)) % media_ptr -> fx_media_sectors_per_cluster;
 8006ca6:	fb00 691e 	mls	r9, r0, lr, r6
            file_ptr -> fx_file_current_relative_cluster = file_ptr -> fx_file_current_relative_cluster +
 8006caa:	eb01 060e 	add.w	r6, r1, lr
                file_ptr -> fx_file_current_logical_sector +
 8006cae:	eb12 000c 	adds.w	r0, r2, ip
            file_ptr -> fx_file_current_relative_sector =
 8006cb2:	f8c5 9038 	str.w	r9, [r5, #56]	; 0x38
                file_ptr -> fx_file_current_logical_sector +
 8006cb6:	f143 0100 	adc.w	r1, r3, #0
 8006cba:	4602      	mov	r2, r0
            file_ptr -> fx_file_current_relative_cluster = file_ptr -> fx_file_current_relative_cluster +
 8006cbc:	636e      	str	r6, [r5, #52]	; 0x34
                file_ptr -> fx_file_current_logical_sector +
 8006cbe:	460b      	mov	r3, r1
            file_ptr -> fx_file_current_logical_sector =
 8006cc0:	e9c5 230a 	strd	r2, r3, [r5, #40]	; 0x28
            if ((bytes_remaining == 0) && ((file_ptr -> fx_file_current_file_offset + (ULONG64)request_size) >=
 8006cc4:	b967      	cbnz	r7, 8006ce0 <_fx_file_read+0x1bc>
 8006cc6:	9e05      	ldr	r6, [sp, #20]
 8006cc8:	e9d5 2310 	ldrd	r2, r3, [r5, #64]	; 0x40
 8006ccc:	e9d5 0114 	ldrd	r0, r1, [r5, #80]	; 0x50
 8006cd0:	eb12 0b06 	adds.w	fp, r2, r6
 8006cd4:	f143 0c00 	adc.w	ip, r3, #0
 8006cd8:	458c      	cmp	ip, r1
 8006cda:	bf08      	it	eq
 8006cdc:	4583      	cmpeq	fp, r0
 8006cde:	d299      	bcs.n	8006c14 <_fx_file_read+0xf0>
            file_ptr -> fx_file_current_relative_sector++;
 8006ce0:	6bab      	ldr	r3, [r5, #56]	; 0x38
            if (file_ptr -> fx_file_current_relative_sector >=
 8006ce2:	6d62      	ldr	r2, [r4, #84]	; 0x54
            file_ptr -> fx_file_current_relative_sector++;
 8006ce4:	3301      	adds	r3, #1
            if (file_ptr -> fx_file_current_relative_sector >=
 8006ce6:	4293      	cmp	r3, r2
            file_ptr -> fx_file_current_relative_sector++;
 8006ce8:	63ab      	str	r3, [r5, #56]	; 0x38
            if (file_ptr -> fx_file_current_relative_sector >=
 8006cea:	d23c      	bcs.n	8006d66 <_fx_file_read+0x242>
                file_ptr -> fx_file_current_logical_sector++;
 8006cec:	e9d5 230a 	ldrd	r2, r3, [r5, #40]	; 0x28
 8006cf0:	1c50      	adds	r0, r2, #1
 8006cf2:	f143 0100 	adc.w	r1, r3, #0
 8006cf6:	e9c5 010a 	strd	r0, r1, [r5, #40]	; 0x28
            file_ptr -> fx_file_current_logical_offset =  0;
 8006cfa:	2300      	movs	r3, #0
 8006cfc:	461a      	mov	r2, r3
 8006cfe:	632b      	str	r3, [r5, #48]	; 0x30
    while (bytes_remaining)
 8006d00:	2f00      	cmp	r7, #0
 8006d02:	f47f af57 	bne.w	8006bb4 <_fx_file_read+0x90>
 8006d06:	e77e      	b.n	8006c06 <_fx_file_read+0xe2>
            sectors =  (UINT)(bytes_remaining / media_ptr -> fx_media_bytes_per_sector);
 8006d08:	fbb7 f3f3 	udiv	r3, r7, r3
            for (i = (media_ptr -> fx_media_sectors_per_cluster -
 8006d0c:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8006d0e:	6baa      	ldr	r2, [r5, #56]	; 0x38
            next_cluster = cluster = file_ptr -> fx_file_current_physical_cluster;
 8006d10:	f8d5 9020 	ldr.w	r9, [r5, #32]
            for (i = (media_ptr -> fx_media_sectors_per_cluster -
 8006d14:	eba1 0b02 	sub.w	fp, r1, r2
            sectors =  (UINT)(bytes_remaining / media_ptr -> fx_media_bytes_per_sector);
 8006d18:	9306      	str	r3, [sp, #24]
            next_cluster = cluster = file_ptr -> fx_file_current_physical_cluster;
 8006d1a:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
            for (i = (media_ptr -> fx_media_sectors_per_cluster -
 8006d1e:	455b      	cmp	r3, fp
 8006d20:	d97f      	bls.n	8006e22 <_fx_file_read+0x2fe>
 8006d22:	970a      	str	r7, [sp, #40]	; 0x28
 8006d24:	4647      	mov	r7, r8
 8006d26:	46a8      	mov	r8, r5
 8006d28:	461d      	mov	r5, r3
 8006d2a:	e00d      	b.n	8006d48 <_fx_file_read+0x224>
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 8006d2c:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 8006d2e:	2e01      	cmp	r6, #1
 8006d30:	d94a      	bls.n	8006dc8 <_fx_file_read+0x2a4>
 8006d32:	6839      	ldr	r1, [r7, #0]
 8006d34:	428e      	cmp	r6, r1
 8006d36:	d847      	bhi.n	8006dc8 <_fx_file_read+0x2a4>
                    if (next_cluster != cluster + 1)
 8006d38:	4296      	cmp	r6, r2
 8006d3a:	f47f af7c 	bne.w	8006c36 <_fx_file_read+0x112>
                      file_ptr -> fx_file_current_relative_sector); i < sectors; i += media_ptr -> fx_media_sectors_per_cluster)
 8006d3e:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8006d40:	46b1      	mov	r9, r6
 8006d42:	4493      	add	fp, r2
            for (i = (media_ptr -> fx_media_sectors_per_cluster -
 8006d44:	455d      	cmp	r5, fp
 8006d46:	d946      	bls.n	8006dd6 <_fx_file_read+0x2b2>
                    status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8006d48:	aa0d      	add	r2, sp, #52	; 0x34
 8006d4a:	4649      	mov	r1, r9
 8006d4c:	4620      	mov	r0, r4
 8006d4e:	f000 fd49 	bl	80077e4 <_fx_utility_FAT_entry_read>
                    if (next_cluster != cluster + 1)
 8006d52:	f109 0201 	add.w	r2, r9, #1
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 8006d56:	2800      	cmp	r0, #0
 8006d58:	d0e8      	beq.n	8006d2c <_fx_file_read+0x208>
 8006d5a:	9005      	str	r0, [sp, #20]
                        FX_UNPROTECT
 8006d5c:	9809      	ldr	r0, [sp, #36]	; 0x24
 8006d5e:	f005 fb45 	bl	800c3ec <_tx_mutex_put>
 8006d62:	9a05      	ldr	r2, [sp, #20]
 8006d64:	e6f4      	b.n	8006b50 <_fx_file_read+0x2c>
                    status =  _fx_utility_FAT_entry_read(media_ptr,
 8006d66:	aa0d      	add	r2, sp, #52	; 0x34
 8006d68:	6a29      	ldr	r1, [r5, #32]
 8006d6a:	4620      	mov	r0, r4
 8006d6c:	f000 fd3a 	bl	80077e4 <_fx_utility_FAT_entry_read>
                    if ((status != FX_SUCCESS) || (next_cluster < FX_FAT_ENTRY_START) ||
 8006d70:	2800      	cmp	r0, #0
 8006d72:	d1f2      	bne.n	8006d5a <_fx_file_read+0x236>
 8006d74:	990d      	ldr	r1, [sp, #52]	; 0x34
 8006d76:	2901      	cmp	r1, #1
 8006d78:	d956      	bls.n	8006e28 <_fx_file_read+0x304>
 8006d7a:	f8d8 3000 	ldr.w	r3, [r8]
 8006d7e:	4299      	cmp	r1, r3
 8006d80:	d852      	bhi.n	8006e28 <_fx_file_read+0x304>
                    ((((ULONG64)next_cluster) - FX_FAT_ENTRY_START) *
 8006d82:	f1b1 0b02 	subs.w	fp, r1, #2
 8006d86:	f04f 0300 	mov.w	r3, #0
                     ((ULONG)media_ptr -> fx_media_sectors_per_cluster));
 8006d8a:	6d66      	ldr	r6, [r4, #84]	; 0x54
                    ((((ULONG64)next_cluster) - FX_FAT_ENTRY_START) *
 8006d8c:	f143 3cff 	adc.w	ip, r3, #4294967295
 8006d90:	465a      	mov	r2, fp
                file_ptr -> fx_file_current_physical_cluster =  next_cluster;
 8006d92:	6229      	str	r1, [r5, #32]
                    ((((ULONG64)next_cluster) - FX_FAT_ENTRY_START) *
 8006d94:	4663      	mov	r3, ip
                file_ptr -> fx_file_current_logical_sector = ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8006d96:	f8d4 c050 	ldr.w	ip, [r4, #80]	; 0x50
                file_ptr -> fx_file_current_relative_sector =  0;
 8006d9a:	63a8      	str	r0, [r5, #56]	; 0x38
                    ((((ULONG64)next_cluster) - FX_FAT_ENTRY_START) *
 8006d9c:	fbab 0106 	umull	r0, r1, fp, r6
 8006da0:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 8006da4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
                file_ptr -> fx_file_current_relative_cluster++;
 8006da6:	6b6a      	ldr	r2, [r5, #52]	; 0x34
                    ((((ULONG64)next_cluster) - FX_FAT_ENTRY_START) *
 8006da8:	fb06 1303 	mla	r3, r6, r3, r1
                file_ptr -> fx_file_current_relative_cluster++;
 8006dac:	3201      	adds	r2, #1
                    ((((ULONG64)next_cluster) - FX_FAT_ENTRY_START) *
 8006dae:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8006db2:	9307      	str	r3, [sp, #28]
                file_ptr -> fx_file_current_relative_cluster++;
 8006db4:	636a      	str	r2, [r5, #52]	; 0x34
                file_ptr -> fx_file_current_logical_sector = ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8006db6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8006dba:	eb10 000c 	adds.w	r0, r0, ip
 8006dbe:	f141 0100 	adc.w	r1, r1, #0
 8006dc2:	e9c5 010a 	strd	r0, r1, [r5, #40]	; 0x28
 8006dc6:	e798      	b.n	8006cfa <_fx_file_read+0x1d6>
                            return(FX_FILE_CORRUPT);
 8006dc8:	2208      	movs	r2, #8
                        FX_UNPROTECT
 8006dca:	9809      	ldr	r0, [sp, #36]	; 0x24
                            return(FX_FILE_CORRUPT);
 8006dcc:	9205      	str	r2, [sp, #20]
                        FX_UNPROTECT
 8006dce:	f005 fb0d 	bl	800c3ec <_tx_mutex_put>
 8006dd2:	9a05      	ldr	r2, [sp, #20]
 8006dd4:	e6bc      	b.n	8006b50 <_fx_file_read+0x2c>
 8006dd6:	4645      	mov	r5, r8
 8006dd8:	9906      	ldr	r1, [sp, #24]
 8006dda:	46b8      	mov	r8, r7
 8006ddc:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8006dde:	e734      	b.n	8006c4a <_fx_file_read+0x126>
 8006de0:	46494c45 	.word	0x46494c45
 8006de4:	4d454449 	.word	0x4d454449
 8006de8:	20000dfc 	.word	0x20000dfc
        return(FX_END_OF_FILE);
 8006dec:	2209      	movs	r2, #9
        FX_UNPROTECT
 8006dee:	9809      	ldr	r0, [sp, #36]	; 0x24
        return(FX_END_OF_FILE);
 8006df0:	9205      	str	r2, [sp, #20]
        FX_UNPROTECT
 8006df2:	f005 fafb 	bl	800c3ec <_tx_mutex_put>
        *actual_size =  0;
 8006df6:	9b08      	ldr	r3, [sp, #32]
        return(FX_END_OF_FILE);
 8006df8:	9a05      	ldr	r2, [sp, #20]
        *actual_size =  0;
 8006dfa:	f8c3 8000 	str.w	r8, [r3]
        return(FX_END_OF_FILE);
 8006dfe:	e6a7      	b.n	8006b50 <_fx_file_read+0x2c>
 8006e00:	4608      	mov	r0, r1
                status =  _fx_utility_logical_sector_read(media_ptr,
 8006e02:	2104      	movs	r1, #4
 8006e04:	9001      	str	r0, [sp, #4]
 8006e06:	4620      	mov	r0, r4
 8006e08:	9102      	str	r1, [sp, #8]
 8006e0a:	68a1      	ldr	r1, [r4, #8]
 8006e0c:	9100      	str	r1, [sp, #0]
 8006e0e:	f001 fb63 	bl	80084d8 <_fx_utility_logical_sector_read>
                if (status !=  FX_SUCCESS)
 8006e12:	2800      	cmp	r0, #0
 8006e14:	d1a1      	bne.n	8006d5a <_fx_file_read+0x236>
                _fx_utility_memory_copy((UCHAR *)media_ptr -> fx_media_memory_buffer, destination_ptr, media_ptr -> fx_media_bytes_per_sector);
 8006e16:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8006e18:	4651      	mov	r1, sl
 8006e1a:	68a0      	ldr	r0, [r4, #8]
 8006e1c:	f001 fdf8 	bl	8008a10 <_fx_utility_memory_copy>
 8006e20:	e72d      	b.n	8006c7e <_fx_file_read+0x15a>
            next_cluster = cluster = file_ptr -> fx_file_current_physical_cluster;
 8006e22:	464e      	mov	r6, r9
 8006e24:	4619      	mov	r1, r3
 8006e26:	e710      	b.n	8006c4a <_fx_file_read+0x126>
                            return(FX_FILE_CORRUPT);
 8006e28:	2208      	movs	r2, #8
                        FX_UNPROTECT
 8006e2a:	9809      	ldr	r0, [sp, #36]	; 0x24
                            return(FX_FILE_CORRUPT);
 8006e2c:	9205      	str	r2, [sp, #20]
                        FX_UNPROTECT
 8006e2e:	f005 fadd 	bl	800c3ec <_tx_mutex_put>
 8006e32:	9a05      	ldr	r2, [sp, #20]
 8006e34:	e68c      	b.n	8006b50 <_fx_file_read+0x2c>
 8006e36:	bf00      	nop

08006e38 <_fx_media_close>:
FX_FILE *file_ptr;
UINT     status;


    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 8006e38:	4b89      	ldr	r3, [pc, #548]	; (8007060 <_fx_media_close+0x228>)
 8006e3a:	6802      	ldr	r2, [r0, #0]
 8006e3c:	429a      	cmp	r2, r3
{
 8006e3e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006e42:	b084      	sub	sp, #16
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 8006e44:	d004      	beq.n	8006e50 <_fx_media_close+0x18>
    {

        /* Return the media not opened error.  */
        return(FX_MEDIA_NOT_OPEN);
 8006e46:	2411      	movs	r4, #17
    FX_UNPROTECT
#endif

    /* Return success status to the caller.  */
    return(FX_SUCCESS);
}
 8006e48:	4620      	mov	r0, r4
 8006e4a:	b004      	add	sp, #16
 8006e4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    FX_PROTECT
 8006e50:	f500 78e4 	add.w	r8, r0, #456	; 0x1c8
 8006e54:	4606      	mov	r6, r0
 8006e56:	f04f 31ff 	mov.w	r1, #4294967295
 8006e5a:	4640      	mov	r0, r8
 8006e5c:	f005 f9dc 	bl	800c218 <_tx_mutex_get>
 8006e60:	2800      	cmp	r0, #0
 8006e62:	d1f0      	bne.n	8006e46 <_fx_media_close+0xe>
    file_ptr =    media_ptr -> fx_media_opened_file_list;
 8006e64:	e9d6 4532 	ldrd	r4, r5, [r6, #200]	; 0xc8
    while (open_count)
 8006e68:	b365      	cbz	r5, 8006ec4 <_fx_media_close+0x8c>
            file_ptr -> fx_file_dir_entry.fx_dir_entry_time =  _fx_system_time;
 8006e6a:	f8df a210 	ldr.w	sl, [pc, #528]	; 800707c <_fx_media_close+0x244>
            file_ptr -> fx_file_dir_entry.fx_dir_entry_date =  _fx_system_date;
 8006e6e:	f8df 9210 	ldr.w	r9, [pc, #528]	; 8007080 <_fx_media_close+0x248>
        file_ptr -> fx_file_id =  FX_FILE_CLOSED_ID;
 8006e72:	4f7c      	ldr	r7, [pc, #496]	; (8007064 <_fx_media_close+0x22c>)
 8006e74:	e003      	b.n	8006e7e <_fx_media_close+0x46>
    while (open_count)
 8006e76:	3d01      	subs	r5, #1
        file_ptr -> fx_file_id =  FX_FILE_CLOSED_ID;
 8006e78:	6027      	str	r7, [r4, #0]
        file_ptr =  file_ptr -> fx_file_opened_next;
 8006e7a:	6de4      	ldr	r4, [r4, #92]	; 0x5c
    while (open_count)
 8006e7c:	d022      	beq.n	8006ec4 <_fx_media_close+0x8c>
        if ((file_ptr -> fx_file_open_mode == FX_OPEN_FOR_WRITE) &&
 8006e7e:	68a3      	ldr	r3, [r4, #8]
 8006e80:	2b01      	cmp	r3, #1
 8006e82:	d1f8      	bne.n	8006e76 <_fx_media_close+0x3e>
 8006e84:	7b23      	ldrb	r3, [r4, #12]
 8006e86:	2b00      	cmp	r3, #0
 8006e88:	d0f5      	beq.n	8006e76 <_fx_media_close+0x3e>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 8006e8a:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 8006e8e:	b672      	cpsid	i
            file_ptr -> fx_file_dir_entry.fx_dir_entry_time =  _fx_system_time;
 8006e90:	f8da 2000 	ldr.w	r2, [sl]
            file_ptr -> fx_file_dir_entry.fx_dir_entry_date =  _fx_system_date;
 8006e94:	f8d9 3000 	ldr.w	r3, [r9]
            file_ptr -> fx_file_dir_entry.fx_dir_entry_time =  _fx_system_time;
 8006e98:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
            file_ptr -> fx_file_dir_entry.fx_dir_entry_date =  _fx_system_date;
 8006e9c:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 8006ea0:	f381 8810 	msr	PRIMASK, r1
            file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
 8006ea4:	e9d4 2312 	ldrd	r2, r3, [r4, #72]	; 0x48
                status = _fx_directory_entry_write(media_ptr, &(file_ptr -> fx_file_dir_entry));
 8006ea8:	f104 0168 	add.w	r1, r4, #104	; 0x68
 8006eac:	4630      	mov	r0, r6
            file_ptr -> fx_file_dir_entry.fx_dir_entry_file_size =
 8006eae:	e9c4 2328 	strd	r2, r3, [r4, #160]	; 0xa0
                status = _fx_directory_entry_write(media_ptr, &(file_ptr -> fx_file_dir_entry));
 8006eb2:	f002 f891 	bl	8008fd8 <_fx_directory_entry_write>
            if (status != FX_SUCCESS)
 8006eb6:	2800      	cmp	r0, #0
 8006eb8:	d158      	bne.n	8006f6c <_fx_media_close+0x134>
    while (open_count)
 8006eba:	3d01      	subs	r5, #1
            file_ptr -> fx_file_modified =  FX_FALSE;
 8006ebc:	7320      	strb	r0, [r4, #12]
        file_ptr -> fx_file_id =  FX_FILE_CLOSED_ID;
 8006ebe:	6027      	str	r7, [r4, #0]
        file_ptr =  file_ptr -> fx_file_opened_next;
 8006ec0:	6de4      	ldr	r4, [r4, #92]	; 0x5c
    while (open_count)
 8006ec2:	d1dc      	bne.n	8006e7e <_fx_media_close+0x46>
    _fx_utility_FAT_flush(media_ptr);
 8006ec4:	4630      	mov	r0, r6
 8006ec6:	f000 fded 	bl	8007aa4 <_fx_utility_FAT_flush>
    _fx_utility_FAT_map_flush(media_ptr);
 8006eca:	4630      	mov	r0, r6
 8006ecc:	f000 ff66 	bl	8007d9c <_fx_utility_FAT_map_flush>
    status =  _fx_utility_logical_sector_flush(media_ptr, ((ULONG64) 1), (ULONG64) (media_ptr -> fx_media_total_sectors), FX_FALSE);
 8006ed0:	2100      	movs	r1, #0
 8006ed2:	2201      	movs	r2, #1
 8006ed4:	2300      	movs	r3, #0
 8006ed6:	9102      	str	r1, [sp, #8]
 8006ed8:	4630      	mov	r0, r6
 8006eda:	e9d6 450e 	ldrd	r4, r5, [r6, #56]	; 0x38
 8006ede:	e9cd 4500 	strd	r4, r5, [sp]
 8006ee2:	f000 ffd5 	bl	8007e90 <_fx_utility_logical_sector_flush>
    if (status != FX_SUCCESS)
 8006ee6:	4604      	mov	r4, r0
 8006ee8:	2800      	cmp	r0, #0
 8006eea:	d13f      	bne.n	8006f6c <_fx_media_close+0x134>
    if ((media_ptr -> fx_media_FAT32_additional_info_sector) &&
 8006eec:	6eb3      	ldr	r3, [r6, #104]	; 0x68
 8006eee:	2b00      	cmp	r3, #0
 8006ef0:	d14c      	bne.n	8006f8c <_fx_media_close+0x154>
    media_ptr -> fx_media_driver_flush_requests++;
 8006ef2:	f8d6 31c0 	ldr.w	r3, [r6, #448]	; 0x1c0
    media_ptr -> fx_media_driver_request =      FX_DRIVER_FLUSH;
 8006ef6:	2102      	movs	r1, #2
    media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 8006ef8:	2590      	movs	r5, #144	; 0x90
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 8006efa:	f8d6 20bc 	ldr.w	r2, [r6, #188]	; 0xbc
    media_ptr -> fx_media_driver_flush_requests++;
 8006efe:	3301      	adds	r3, #1
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 8006f00:	4630      	mov	r0, r6
    media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 8006f02:	e9c6 1522 	strd	r1, r5, [r6, #136]	; 0x88
    media_ptr -> fx_media_driver_flush_requests++;
 8006f06:	f8c6 31c0 	str.w	r3, [r6, #448]	; 0x1c0
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 8006f0a:	4790      	blx	r2
    media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8006f0c:	2308      	movs	r3, #8
    media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 8006f0e:	f8c6 508c 	str.w	r5, [r6, #140]	; 0x8c
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 8006f12:	4630      	mov	r0, r6
    media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8006f14:	f8c6 3088 	str.w	r3, [r6, #136]	; 0x88
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 8006f18:	f8d6 30bc 	ldr.w	r3, [r6, #188]	; 0xbc
 8006f1c:	4798      	blx	r3
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 8006f1e:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 8006f22:	b672      	cpsid	i
    if (_fx_system_media_opened_count == ((ULONG) 1))
 8006f24:	4a50      	ldr	r2, [pc, #320]	; (8007068 <_fx_media_close+0x230>)
 8006f26:	6813      	ldr	r3, [r2, #0]
 8006f28:	2b01      	cmp	r3, #1
 8006f2a:	d027      	beq.n	8006f7c <_fx_media_close+0x144>
        if (_fx_system_media_opened_ptr == media_ptr)
 8006f2c:	484f      	ldr	r0, [pc, #316]	; (800706c <_fx_media_close+0x234>)
            media_ptr -> fx_media_opened_previous;
 8006f2e:	e9d6 7534 	ldrd	r7, r5, [r6, #208]	; 0xd0
        (media_ptr -> fx_media_opened_next) -> fx_media_opened_previous =
 8006f32:	f8c7 50d4 	str.w	r5, [r7, #212]	; 0xd4
        (media_ptr -> fx_media_opened_previous) -> fx_media_opened_next =
 8006f36:	f8d6 50d4 	ldr.w	r5, [r6, #212]	; 0xd4
 8006f3a:	f8c5 70d0 	str.w	r7, [r5, #208]	; 0xd0
        if (_fx_system_media_opened_ptr == media_ptr)
 8006f3e:	6805      	ldr	r5, [r0, #0]
 8006f40:	42b5      	cmp	r5, r6
 8006f42:	d01f      	beq.n	8006f84 <_fx_media_close+0x14c>
    _fx_system_media_opened_count--;
 8006f44:	3b01      	subs	r3, #1
    media_ptr -> fx_media_id =  FX_MEDIA_CLOSED_ID;
 8006f46:	484a      	ldr	r0, [pc, #296]	; (8007070 <_fx_media_close+0x238>)
    _fx_system_media_opened_count--;
 8006f48:	6013      	str	r3, [r2, #0]
    media_ptr -> fx_media_id =  FX_MEDIA_CLOSED_ID;
 8006f4a:	6030      	str	r0, [r6, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 8006f4c:	f381 8810 	msr	PRIMASK, r1
    tx_mutex_delete(& (media_ptr -> fx_media_protect));
 8006f50:	4640      	mov	r0, r8
 8006f52:	f005 f907 	bl	800c164 <_tx_mutex_delete>
    if (media_ptr -> fx_media_close_notify)
 8006f56:	f8d6 30c4 	ldr.w	r3, [r6, #196]	; 0xc4
 8006f5a:	2b00      	cmp	r3, #0
 8006f5c:	f43f af74 	beq.w	8006e48 <_fx_media_close+0x10>
        media_ptr -> fx_media_close_notify(media_ptr);
 8006f60:	4630      	mov	r0, r6
 8006f62:	4798      	blx	r3
}
 8006f64:	4620      	mov	r0, r4
 8006f66:	b004      	add	sp, #16
 8006f68:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        FX_UNPROTECT
 8006f6c:	4640      	mov	r0, r8
        return(FX_IO_ERROR);
 8006f6e:	2490      	movs	r4, #144	; 0x90
        FX_UNPROTECT
 8006f70:	f005 fa3c 	bl	800c3ec <_tx_mutex_put>
        _fx_media_abort(media_ptr);
 8006f74:	4630      	mov	r0, r6
 8006f76:	f003 f97d 	bl	800a274 <_fx_media_abort>
        return(FX_IO_ERROR);
 8006f7a:	e765      	b.n	8006e48 <_fx_media_close+0x10>
        _fx_system_media_opened_ptr =  FX_NULL;
 8006f7c:	483b      	ldr	r0, [pc, #236]	; (800706c <_fx_media_close+0x234>)
 8006f7e:	2500      	movs	r5, #0
 8006f80:	6005      	str	r5, [r0, #0]
 8006f82:	e7df      	b.n	8006f44 <_fx_media_close+0x10c>
            _fx_system_media_opened_ptr =  media_ptr -> fx_media_opened_next;
 8006f84:	f8d6 50d0 	ldr.w	r5, [r6, #208]	; 0xd0
 8006f88:	6005      	str	r5, [r0, #0]
 8006f8a:	e7db      	b.n	8006f44 <_fx_media_close+0x10c>
    if ((media_ptr -> fx_media_FAT32_additional_info_sector) &&
 8006f8c:	6ef2      	ldr	r2, [r6, #108]	; 0x6c
 8006f8e:	6ff3      	ldr	r3, [r6, #124]	; 0x7c
 8006f90:	429a      	cmp	r2, r3
 8006f92:	d0ae      	beq.n	8006ef2 <_fx_media_close+0xba>
        (media_ptr -> fx_media_FAT32_additional_info_last_available != media_ptr -> fx_media_available_clusters) &&
 8006f94:	f8d6 30a8 	ldr.w	r3, [r6, #168]	; 0xa8
 8006f98:	2b00      	cmp	r3, #0
 8006f9a:	d1aa      	bne.n	8006ef2 <_fx_media_close+0xba>
        buffer_ptr =  (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_memory_buffer;
 8006f9c:	69f0      	ldr	r0, [r6, #28]
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector =  (~(ULONG64)0);
 8006f9e:	f04f 32ff 	mov.w	r2, #4294967295
 8006fa2:	f04f 33ff 	mov.w	r3, #4294967295
        media_ptr -> fx_media_driver_sectors =          1;
 8006fa6:	2701      	movs	r7, #1
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_valid =  FX_FALSE;
 8006fa8:	7444      	strb	r4, [r0, #17]
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8006faa:	2590      	movs	r5, #144	; 0x90
        media_ptr -> fx_media_driver_read_requests++;
 8006fac:	f8d6 11ac 	ldr.w	r1, [r6, #428]	; 0x1ac
        media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 8006fb0:	f04f 0903 	mov.w	r9, #3
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector =  (~(ULONG64)0);
 8006fb4:	e9c0 2302 	strd	r2, r3, [r0, #8]
        buffer_ptr =  (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_memory_buffer;
 8006fb8:	6803      	ldr	r3, [r0, #0]
        media_ptr -> fx_media_driver_read_requests++;
 8006fba:	4439      	add	r1, r7
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8006fbc:	4630      	mov	r0, r6
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 8006fbe:	f8c6 4088 	str.w	r4, [r6, #136]	; 0x88
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 8006fc2:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
        media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 8006fc6:	6eb3      	ldr	r3, [r6, #104]	; 0x68
        media_ptr -> fx_media_driver_read_requests++;
 8006fc8:	f8c6 11ac 	str.w	r1, [r6, #428]	; 0x1ac
        media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 8006fcc:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8006fd0:	f8c6 508c 	str.w	r5, [r6, #140]	; 0x8c
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8006fd4:	f8d6 30bc 	ldr.w	r3, [r6, #188]	; 0xbc
        media_ptr -> fx_media_driver_sectors =          1;
 8006fd8:	f8c6 7098 	str.w	r7, [r6, #152]	; 0x98
        media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 8006fdc:	f8c6 90b8 	str.w	r9, [r6, #184]	; 0xb8
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8006fe0:	4798      	blx	r3
        if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 8006fe2:	f8d6 308c 	ldr.w	r3, [r6, #140]	; 0x8c
 8006fe6:	2b00      	cmp	r3, #0
 8006fe8:	d1c0      	bne.n	8006f6c <_fx_media_close+0x134>
        buffer_ptr =  media_ptr -> fx_media_driver_buffer;
 8006fea:	f8d6 a090 	ldr.w	sl, [r6, #144]	; 0x90
        signature =  _fx_utility_32_unsigned_read(&buffer_ptr[0]);
 8006fee:	4650      	mov	r0, sl
 8006ff0:	f000 fbe4 	bl	80077bc <_fx_utility_32_unsigned_read>
        if (signature == 0x41615252)
 8006ff4:	4b1f      	ldr	r3, [pc, #124]	; (8007074 <_fx_media_close+0x23c>)
 8006ff6:	4298      	cmp	r0, r3
 8006ff8:	f47f af7b 	bne.w	8006ef2 <_fx_media_close+0xba>
            signature =  _fx_utility_32_unsigned_read(&buffer_ptr[484]);
 8006ffc:	f50a 70f2 	add.w	r0, sl, #484	; 0x1e4
 8007000:	f000 fbdc 	bl	80077bc <_fx_utility_32_unsigned_read>
            if (signature == 0x61417272)
 8007004:	4b1c      	ldr	r3, [pc, #112]	; (8007078 <_fx_media_close+0x240>)
 8007006:	4298      	cmp	r0, r3
 8007008:	f47f af73 	bne.w	8006ef2 <_fx_media_close+0xba>
                _fx_utility_32_unsigned_write(&buffer_ptr[488], media_ptr -> fx_media_available_clusters);
 800700c:	6ff1      	ldr	r1, [r6, #124]	; 0x7c
 800700e:	f50a 70f4 	add.w	r0, sl, #488	; 0x1e8
 8007012:	f000 fbdf 	bl	80077d4 <_fx_utility_32_unsigned_write>
                _fx_utility_32_unsigned_write(&buffer_ptr[492], media_ptr -> fx_media_cluster_search_start);
 8007016:	f8d6 1080 	ldr.w	r1, [r6, #128]	; 0x80
 800701a:	f50a 70f6 	add.w	r0, sl, #492	; 0x1ec
 800701e:	f000 fbd9 	bl	80077d4 <_fx_utility_32_unsigned_write>
                media_ptr -> fx_media_driver_write_requests++;
 8007022:	f8d6 31b0 	ldr.w	r3, [r6, #432]	; 0x1b0
                media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 8007026:	6eb2      	ldr	r2, [r6, #104]	; 0x68
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 8007028:	4630      	mov	r0, r6
                media_ptr -> fx_media_driver_write_requests++;
 800702a:	3301      	adds	r3, #1
                media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 800702c:	f8c6 a090 	str.w	sl, [r6, #144]	; 0x90
                media_ptr -> fx_media_driver_sectors =          1;
 8007030:	f8c6 7098 	str.w	r7, [r6, #152]	; 0x98
                media_ptr -> fx_media_driver_write_requests++;
 8007034:	f8c6 31b0 	str.w	r3, [r6, #432]	; 0x1b0
                media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 8007038:	f8c6 90b8 	str.w	r9, [r6, #184]	; 0xb8
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800703c:	f8d6 30bc 	ldr.w	r3, [r6, #188]	; 0xbc
                media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 8007040:	f8c6 70b0 	str.w	r7, [r6, #176]	; 0xb0
                media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 8007044:	f8c6 2094 	str.w	r2, [r6, #148]	; 0x94
                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8007048:	e9c6 7522 	strd	r7, r5, [r6, #136]	; 0x88
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800704c:	4798      	blx	r3
                if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800704e:	f8d6 308c 	ldr.w	r3, [r6, #140]	; 0x8c
                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 8007052:	f8c6 40b0 	str.w	r4, [r6, #176]	; 0xb0
                if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 8007056:	2b00      	cmp	r3, #0
 8007058:	d188      	bne.n	8006f6c <_fx_media_close+0x134>
                media_ptr -> fx_media_FAT32_additional_info_last_available =  media_ptr -> fx_media_available_clusters;
 800705a:	6ff3      	ldr	r3, [r6, #124]	; 0x7c
 800705c:	66f3      	str	r3, [r6, #108]	; 0x6c
 800705e:	e748      	b.n	8006ef2 <_fx_media_close+0xba>
 8007060:	4d454449 	.word	0x4d454449
 8007064:	46494c43 	.word	0x46494c43
 8007068:	20000e00 	.word	0x20000e00
 800706c:	20000e08 	.word	0x20000e08
 8007070:	4d454443 	.word	0x4d454443
 8007074:	41615252 	.word	0x41615252
 8007078:	61417272 	.word	0x61417272
 800707c:	20000e14 	.word	0x20000e14
 8007080:	20000dfc 	.word	0x20000dfc

08007084 <_fx_media_open>:
/*                                                                        */
/**************************************************************************/
UINT  _fx_media_open(FX_MEDIA *media_ptr, CHAR *media_name,
                     VOID (*media_driver)(FX_MEDIA *), VOID *driver_info_ptr,
                     VOID *memory_ptr, ULONG memory_size)
{
 8007084:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
ULONG             bytes_in_buffer;
FX_INT_SAVE_AREA


    /* Reference the version ID and option words to ensure they are linked in.  */
    if ((_fx_system_build_options_1 | _fx_system_build_options_2 | _fx_system_build_options_3) == 0 ||
 8007088:	4d78      	ldr	r5, [pc, #480]	; (800726c <_fx_media_open+0x1e8>)
{
 800708a:	b087      	sub	sp, #28
    if ((_fx_system_build_options_1 | _fx_system_build_options_2 | _fx_system_build_options_3) == 0 ||
 800708c:	4c78      	ldr	r4, [pc, #480]	; (8007270 <_fx_media_open+0x1ec>)
 800708e:	4e79      	ldr	r6, [pc, #484]	; (8007274 <_fx_media_open+0x1f0>)
 8007090:	6827      	ldr	r7, [r4, #0]
 8007092:	682d      	ldr	r5, [r5, #0]
 8007094:	433d      	orrs	r5, r7
 8007096:	6837      	ldr	r7, [r6, #0]
{
 8007098:	9e10      	ldr	r6, [sp, #64]	; 0x40
    if ((_fx_system_build_options_1 | _fx_system_build_options_2 | _fx_system_build_options_3) == 0 ||
 800709a:	433d      	orrs	r5, r7
 800709c:	f000 80b8 	beq.w	8007210 <_fx_media_open+0x18c>
        _fx_version_id[0] == 0)
 80070a0:	4d75      	ldr	r5, [pc, #468]	; (8007278 <_fx_media_open+0x1f4>)
    if ((_fx_system_build_options_1 | _fx_system_build_options_2 | _fx_system_build_options_3) == 0 ||
 80070a2:	782d      	ldrb	r5, [r5, #0]
 80070a4:	2d00      	cmp	r5, #0
 80070a6:	f000 80b3 	beq.w	8007210 <_fx_media_open+0x18c>
    /* Save the basic information in the media control block.  */
    media_ptr -> fx_media_name =                        media_name;
    media_ptr -> fx_media_driver_entry =                media_driver;
    media_ptr -> fx_media_memory_buffer =               (UCHAR *)memory_ptr;
    media_ptr -> fx_media_memory_size =                 memory_size;
    media_ptr -> fx_media_disable_burst_cache =         FX_FALSE;
 80070aa:	2500      	movs	r5, #0
    media_ptr -> fx_media_name =                        media_name;
 80070ac:	6041      	str	r1, [r0, #4]
 80070ae:	4698      	mov	r8, r3
    media_ptr -> fx_media_disable_burst_cache =         FX_FALSE;
 80070b0:	f242 4ea4 	movw	lr, #9380	; 0x24a4
    media_ptr -> fx_media_memory_size =                 memory_size;
 80070b4:	9b11      	ldr	r3, [sp, #68]	; 0x44
    media_ptr -> fx_media_FAT_type =                    0;
 80070b6:	f242 4cb0 	movw	ip, #9392	; 0x24b0
    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_MEDIA_OPEN, media_ptr, media_driver, memory_ptr, memory_size, FX_TRACE_MEDIA_EVENTS, 0, 0)

    /* Initialize the supplied media I/O driver.  First, build the
       initialize driver request.  */
    media_ptr -> fx_media_driver_request =              FX_DRIVER_INIT;
 80070ba:	2104      	movs	r1, #4
    media_ptr -> fx_media_driver_status =               FX_IO_ERROR;
 80070bc:	2790      	movs	r7, #144	; 0x90
 80070be:	4604      	mov	r4, r0
    media_ptr -> fx_media_memory_size =                 memory_size;
 80070c0:	60c3      	str	r3, [r0, #12]
    media_ptr -> fx_media_driver_entry =                media_driver;
 80070c2:	f8c0 20bc 	str.w	r2, [r0, #188]	; 0xbc
    media_ptr -> fx_media_memory_buffer =               (UCHAR *)memory_ptr;
 80070c6:	6086      	str	r6, [r0, #8]
    media_ptr -> fx_media_disable_burst_cache =         FX_FALSE;
 80070c8:	f840 500e 	str.w	r5, [r0, lr]
    media_ptr -> fx_media_directory_local_path_gets =  0;
 80070cc:	f8c0 5100 	str.w	r5, [r0, #256]	; 0x100
    media_ptr -> fx_media_directory_local_path_restores =  0;
 80070d0:	f8c0 5104 	str.w	r5, [r0, #260]	; 0x104
    media_ptr -> fx_media_directory_local_path_sets =  0;
 80070d4:	f8c0 5108 	str.w	r5, [r0, #264]	; 0x108
    media_ptr -> fx_media_directory_name_tests =  0;
 80070d8:	f8c0 510c 	str.w	r5, [r0, #268]	; 0x10c
    media_ptr -> fx_media_directory_next_entry_finds =  0;
 80070dc:	f8c0 5110 	str.w	r5, [r0, #272]	; 0x110
    media_ptr -> fx_media_directory_next_full_entry_finds =  0;
 80070e0:	f8c0 5114 	str.w	r5, [r0, #276]	; 0x114
    media_ptr -> fx_media_directory_renames =  0;
 80070e4:	f8c0 5118 	str.w	r5, [r0, #280]	; 0x118
    media_ptr -> fx_media_file_allocates =  0;
 80070e8:	f8c0 511c 	str.w	r5, [r0, #284]	; 0x11c
    media_ptr -> fx_media_file_attributes_reads =  0;
 80070ec:	f8c0 5120 	str.w	r5, [r0, #288]	; 0x120
    media_ptr -> fx_media_file_attributes_sets =  0;
 80070f0:	f8c0 5124 	str.w	r5, [r0, #292]	; 0x124
    media_ptr -> fx_media_file_best_effort_allocates =  0;
 80070f4:	f8c0 5128 	str.w	r5, [r0, #296]	; 0x128
    media_ptr -> fx_media_file_closes =  0;
 80070f8:	f8c0 512c 	str.w	r5, [r0, #300]	; 0x12c
    media_ptr -> fx_media_file_creates =  0;
 80070fc:	f8c0 5130 	str.w	r5, [r0, #304]	; 0x130
    media_ptr -> fx_media_file_deletes =  0;
 8007100:	f8c0 5134 	str.w	r5, [r0, #308]	; 0x134
    media_ptr -> fx_media_file_opens =  0;
 8007104:	f8c0 5138 	str.w	r5, [r0, #312]	; 0x138
    media_ptr -> fx_media_file_reads =  0;
 8007108:	f8c0 513c 	str.w	r5, [r0, #316]	; 0x13c
    media_ptr -> fx_media_directory_attributes_sets =  0;
 800710c:	e9c0 5536 	strd	r5, r5, [r0, #216]	; 0xd8
    media_ptr -> fx_media_directory_default_gets =  0;
 8007110:	e9c0 5538 	strd	r5, r5, [r0, #224]	; 0xe0
    media_ptr -> fx_media_directory_deletes =  0;
 8007114:	e9c0 553a 	strd	r5, r5, [r0, #232]	; 0xe8
    media_ptr -> fx_media_directory_first_full_entry_finds =  0;
 8007118:	e9c0 553c 	strd	r5, r5, [r0, #240]	; 0xf0
    media_ptr -> fx_media_directory_local_path_clears =  0;
 800711c:	e9c0 553e 	strd	r5, r5, [r0, #248]	; 0xf8
    media_ptr -> fx_media_FAT_type =                    0;
 8007120:	f800 500c 	strb.w	r5, [r0, ip]
    media_ptr -> fx_media_file_relative_seeks =  0;
 8007124:	f8c0 5140 	str.w	r5, [r0, #320]	; 0x140
    media_ptr -> fx_media_file_renames =  0;
 8007128:	f8c0 5144 	str.w	r5, [r0, #324]	; 0x144
    media_ptr -> fx_media_file_seeks =  0;
 800712c:	f8c0 5148 	str.w	r5, [r0, #328]	; 0x148
    media_ptr -> fx_media_file_truncates =  0;
 8007130:	f8c0 514c 	str.w	r5, [r0, #332]	; 0x14c
    media_ptr -> fx_media_file_truncate_releases =  0;
 8007134:	f8c0 5150 	str.w	r5, [r0, #336]	; 0x150
    media_ptr -> fx_media_file_writes =  0;
 8007138:	f8c0 5154 	str.w	r5, [r0, #340]	; 0x154
    media_ptr -> fx_media_aborts =  0;
 800713c:	f8c0 5158 	str.w	r5, [r0, #344]	; 0x158
    media_ptr -> fx_media_flushes =  0;
 8007140:	f8c0 515c 	str.w	r5, [r0, #348]	; 0x15c
    media_ptr -> fx_media_reads =  0;
 8007144:	f8c0 5160 	str.w	r5, [r0, #352]	; 0x160
    media_ptr -> fx_media_writes =  0;
 8007148:	f8c0 5164 	str.w	r5, [r0, #356]	; 0x164
    media_ptr -> fx_media_directory_entry_reads =  0;
 800714c:	f8c0 5168 	str.w	r5, [r0, #360]	; 0x168
    media_ptr -> fx_media_directory_entry_writes =  0;
 8007150:	f8c0 516c 	str.w	r5, [r0, #364]	; 0x16c
    media_ptr -> fx_media_directory_searches =  0;
 8007154:	f8c0 5170 	str.w	r5, [r0, #368]	; 0x170
    media_ptr -> fx_media_directory_search_cache_hits =  0;
 8007158:	f8c0 51c4 	str.w	r5, [r0, #452]	; 0x1c4
    media_ptr -> fx_media_directory_free_searches =  0;
 800715c:	f8c0 5174 	str.w	r5, [r0, #372]	; 0x174
    media_ptr -> fx_media_fat_entry_reads =  0;
 8007160:	f8c0 5178 	str.w	r5, [r0, #376]	; 0x178
    media_ptr -> fx_media_fat_entry_writes =  0;
 8007164:	f8c0 517c 	str.w	r5, [r0, #380]	; 0x17c
    media_ptr -> fx_media_fat_entry_cache_read_hits =  0;
 8007168:	f8c0 5180 	str.w	r5, [r0, #384]	; 0x180
    media_ptr -> fx_media_fat_entry_cache_read_misses =  0;
 800716c:	f8c0 5184 	str.w	r5, [r0, #388]	; 0x184
    media_ptr -> fx_media_fat_entry_cache_write_hits =  0;
 8007170:	f8c0 5188 	str.w	r5, [r0, #392]	; 0x188
    media_ptr -> fx_media_fat_entry_cache_write_misses =  0;
 8007174:	f8c0 518c 	str.w	r5, [r0, #396]	; 0x18c
    media_ptr -> fx_media_fat_cache_flushes =  0;
 8007178:	f8c0 5190 	str.w	r5, [r0, #400]	; 0x190
    media_ptr -> fx_media_fat_sector_reads =  0;
 800717c:	f8c0 5194 	str.w	r5, [r0, #404]	; 0x194
    media_ptr -> fx_media_fat_sector_writes =  0;
 8007180:	f8c0 5198 	str.w	r5, [r0, #408]	; 0x198
    media_ptr -> fx_media_logical_sector_reads =  0;
 8007184:	f8c0 519c 	str.w	r5, [r0, #412]	; 0x19c
    media_ptr -> fx_media_logical_sector_writes =  0;
 8007188:	f8c0 51a0 	str.w	r5, [r0, #416]	; 0x1a0
    media_ptr -> fx_media_logical_sector_cache_read_hits =  0;
 800718c:	f8c0 51a4 	str.w	r5, [r0, #420]	; 0x1a4
    media_ptr -> fx_media_logical_sector_cache_read_misses =  0;
 8007190:	f8c0 51a8 	str.w	r5, [r0, #424]	; 0x1a8
    media_ptr -> fx_media_driver_read_requests =  0;
 8007194:	f8c0 51ac 	str.w	r5, [r0, #428]	; 0x1ac
    media_ptr -> fx_media_driver_write_requests =  0;
 8007198:	f8c0 51b0 	str.w	r5, [r0, #432]	; 0x1b0
    media_ptr -> fx_media_driver_boot_read_requests =  0;
 800719c:	f8c0 51b4 	str.w	r5, [r0, #436]	; 0x1b4
    media_ptr -> fx_media_driver_boot_write_requests =  0;
 80071a0:	f8c0 51b8 	str.w	r5, [r0, #440]	; 0x1b8
    media_ptr -> fx_media_driver_release_sectors_requests =  0;
 80071a4:	f8c0 51bc 	str.w	r5, [r0, #444]	; 0x1bc
    media_ptr -> fx_media_driver_flush_requests =  0;
 80071a8:	f8c0 51c0 	str.w	r5, [r0, #448]	; 0x1c0
    media_ptr -> fx_media_driver_info =                 driver_info_ptr;
    media_ptr -> fx_media_driver_write_protect =        FX_FALSE;
    media_ptr -> fx_media_driver_free_sector_update =   FX_FALSE;
    media_ptr -> fx_media_driver_data_sector_read =     FX_FALSE;
 80071ac:	f8c0 50b4 	str.w	r5, [r0, #180]	; 0xb4
    media_ptr -> fx_media_driver_info =                 driver_info_ptr;
 80071b0:	f8c0 8084 	str.w	r8, [r0, #132]	; 0x84
    media_ptr -> fx_media_driver_free_sector_update =   FX_FALSE;
 80071b4:	e9c0 552a 	strd	r5, r5, [r0, #168]	; 0xa8
    media_ptr -> fx_media_driver_status =               FX_IO_ERROR;
 80071b8:	e9c0 1722 	strd	r1, r7, [r0, #136]	; 0x88

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_INIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Call the specified I/O driver with the initialize request.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 80071bc:	4790      	blx	r2

    /* Determine if the I/O driver initialized successfully.  */
    if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 80071be:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80071c2:	2b00      	cmp	r3, #0
 80071c4:	d150      	bne.n	8007268 <_fx_media_open+0x1e4>
    }

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of driver boot read requests.  */
    media_ptr -> fx_media_driver_boot_read_requests++;
 80071c6:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
    /* Read the boot sector from the device.  Build the read boot sector
       command.  */
    media_ptr -> fx_media_driver_request =          FX_DRIVER_BOOT_READ;
    media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
    media_ptr -> fx_media_driver_buffer =           memory_ptr;
    media_ptr -> fx_media_driver_sectors =          1;
 80071ca:	2501      	movs	r5, #1
    media_ptr -> fx_media_driver_request =          FX_DRIVER_BOOT_READ;
 80071cc:	2205      	movs	r2, #5
    media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80071ce:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
    media_ptr -> fx_media_driver_boot_read_requests++;
 80071d2:	442b      	add	r3, r5
    media_ptr -> fx_media_driver_buffer =           memory_ptr;
 80071d4:	f8c4 6090 	str.w	r6, [r4, #144]	; 0x90
    media_ptr -> fx_media_driver_request =          FX_DRIVER_BOOT_READ;
 80071d8:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_BOOT_READ, media_ptr, memory_ptr, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Invoke the driver to read the boot sector.  */
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 80071dc:	4620      	mov	r0, r4
    media_ptr -> fx_media_driver_boot_read_requests++;
 80071de:	f8c4 31b4 	str.w	r3, [r4, #436]	; 0x1b4
    media_ptr -> fx_media_driver_sectors =          1;
 80071e2:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 80071e6:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
    media_ptr -> fx_media_driver_sector_type =      FX_BOOT_SECTOR;
 80071ea:	f8c4 50b8 	str.w	r5, [r4, #184]	; 0xb8
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 80071ee:	4798      	blx	r3

    /* Determine if the boot sector was read correctly. */
    if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 80071f0:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80071f4:	b18b      	cbz	r3, 800721a <_fx_media_open+0x196>
    {

        /* Build the "uninitialize" I/O driver request.  */
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 80071f6:	2208      	movs	r2, #8
        media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 80071f8:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_UNINIT, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Call the specified I/O driver with the uninitialize request.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 80071fc:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 8007200:	4620      	mov	r0, r4
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8007202:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8007206:	4798      	blx	r3
    FX_UNPROTECT
#endif

    /* Return a successful status.  */
    return(FX_SUCCESS);
}
 8007208:	4628      	mov	r0, r5
 800720a:	b007      	add	sp, #28
 800720c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return(FX_NOT_IMPLEMENTED);
 8007210:	2522      	movs	r5, #34	; 0x22
}
 8007212:	4628      	mov	r0, r5
 8007214:	b007      	add	sp, #28
 8007216:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (_fx_media_boot_info_extract(media_ptr) != FX_SUCCESS)
 800721a:	4620      	mov	r0, r4
 800721c:	f003 f888 	bl	800a330 <_fx_media_boot_info_extract>
 8007220:	4605      	mov	r5, r0
 8007222:	b150      	cbz	r0, 800723a <_fx_media_open+0x1b6>
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8007224:	2208      	movs	r2, #8
        media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 8007226:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800722a:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 800722e:	4620      	mov	r0, r4
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8007230:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        return(FX_MEDIA_INVALID);
 8007234:	2502      	movs	r5, #2
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8007236:	4798      	blx	r3
        return(FX_MEDIA_INVALID);
 8007238:	e7e6      	b.n	8007208 <_fx_media_open+0x184>
    additional_info_sector =  _fx_utility_16_unsigned_read(&media_ptr -> fx_media_driver_buffer[48]);
 800723a:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
 800723e:	3030      	adds	r0, #48	; 0x30
 8007240:	f000 fab6 	bl	80077b0 <_fx_utility_16_unsigned_read>
    media_ptr -> fx_media_sector_cache_size =  memory_size / media_ptr -> fx_media_bytes_per_sector;
 8007244:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007246:	9a11      	ldr	r2, [sp, #68]	; 0x44
    additional_info_sector =  _fx_utility_16_unsigned_read(&media_ptr -> fx_media_driver_buffer[48]);
 8007248:	4680      	mov	r8, r0
    media_ptr -> fx_media_sector_cache_size =  memory_size / media_ptr -> fx_media_bytes_per_sector;
 800724a:	fbb2 f3f3 	udiv	r3, r2, r3
 800724e:	6163      	str	r3, [r4, #20]
    if (media_ptr -> fx_media_sector_cache_size == 0)
 8007250:	b9a3      	cbnz	r3, 800727c <_fx_media_open+0x1f8>
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 8007252:	2208      	movs	r2, #8
        media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 8007254:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8007258:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 800725c:	4620      	mov	r0, r4
        media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 800725e:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        return(FX_BUFFER_ERROR);
 8007262:	2521      	movs	r5, #33	; 0x21
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8007264:	4798      	blx	r3
        return(FX_BUFFER_ERROR);
 8007266:	e7cf      	b.n	8007208 <_fx_media_open+0x184>
        return(FX_IO_ERROR);
 8007268:	463d      	mov	r5, r7
 800726a:	e7cd      	b.n	8007208 <_fx_media_open+0x184>
 800726c:	20000e0c 	.word	0x20000e0c
 8007270:	20000dc8 	.word	0x20000dc8
 8007274:	20000e10 	.word	0x20000e10
 8007278:	200000f8 	.word	0x200000f8
    if (media_ptr -> fx_media_sector_cache_size > FX_MAX_SECTOR_CACHE)
 800727c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007280:	f240 817e 	bls.w	8007580 <_fx_media_open+0x4fc>
        media_ptr -> fx_media_sector_cache_size =  FX_MAX_SECTOR_CACHE;
 8007284:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007288:	23ff      	movs	r3, #255	; 0xff
 800728a:	6162      	str	r2, [r4, #20]
    cache_entry_ptr =  media_ptr -> fx_media_sector_cache;
 800728c:	f504 6e4a 	add.w	lr, r4, #3232	; 0xca0
 8007290:	f604 42b8 	addw	r2, r4, #3256	; 0xcb8
    while (i--)
 8007294:	469a      	mov	sl, r3
    cache_entry_ptr =  media_ptr -> fx_media_sector_cache;
 8007296:	46b1      	mov	r9, r6
        cache_entry_ptr -> fx_cached_sector =                (~(ULONG64)0);
 8007298:	f04f 30ff 	mov.w	r0, #4294967295
 800729c:	f04f 31ff 	mov.w	r1, #4294967295
        cache_entry_ptr -> fx_cached_sector_buffer_dirty =   FX_FALSE;
 80072a0:	f04f 0c00 	mov.w	ip, #0
    while (i--)
 80072a4:	f10a 3aff 	add.w	sl, sl, #4294967295
        cache_entry_ptr -> fx_cached_sector_buffer_dirty =   FX_FALSE;
 80072a8:	f802 cc08 	strb.w	ip, [r2, #-8]
        cache_entry_ptr -> fx_cached_sector_valid =          FX_FALSE;
 80072ac:	f802 cc07 	strb.w	ip, [r2, #-7]
    while (i--)
 80072b0:	f1ba 3fff 	cmp.w	sl, #4294967295
        memory_ptr =  (VOID *)(((UCHAR *)memory_ptr) + media_ptr -> fx_media_bytes_per_sector);
 80072b4:	6aa7      	ldr	r7, [r4, #40]	; 0x28
        cache_entry_ptr -> fx_cached_sector_memory_buffer =  (UCHAR *)memory_ptr;
 80072b6:	f842 9c18 	str.w	r9, [r2, #-24]
        cache_entry_ptr -> fx_cached_sector_next_used =      cache_entry_ptr + 1;
 80072ba:	f842 2c04 	str.w	r2, [r2, #-4]
        memory_ptr =  (VOID *)(((UCHAR *)memory_ptr) + media_ptr -> fx_media_bytes_per_sector);
 80072be:	44b9      	add	r9, r7
 80072c0:	f102 0218 	add.w	r2, r2, #24
        cache_entry_ptr -> fx_cached_sector =                (~(ULONG64)0);
 80072c4:	e942 010a 	strd	r0, r1, [r2, #-40]	; 0x28
    while (i--)
 80072c8:	d1ec      	bne.n	80072a4 <_fx_media_open+0x220>
    cache_entry_ptr -> fx_cached_sector_next_used =  FX_NULL;
 80072ca:	3301      	adds	r3, #1
    if ((media_ptr -> fx_media_sector_cache_size >= FX_SECTOR_CACHE_HASH_ENABLE) &&
 80072cc:	6961      	ldr	r1, [r4, #20]
    media_ptr -> fx_media_sector_cache_end =  ((UCHAR *)memory_ptr) - 1;
 80072ce:	f109 32ff 	add.w	r2, r9, #4294967295
    cache_entry_ptr -> fx_cached_sector_next_used =  FX_NULL;
 80072d2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    if ((media_ptr -> fx_media_sector_cache_size >= FX_SECTOR_CACHE_HASH_ENABLE) &&
 80072d6:	290f      	cmp	r1, #15
    cache_entry_ptr -> fx_cached_sector_next_used =  FX_NULL;
 80072d8:	eb0e 03c3 	add.w	r3, lr, r3, lsl #3
 80072dc:	f843 cc04 	str.w	ip, [r3, #-4]
    media_ptr -> fx_media_sector_cache_list_ptr =  media_ptr -> fx_media_sector_cache;
 80072e0:	e9c4 2e06 	strd	r2, lr, [r4, #24]
    media_ptr -> fx_media_sector_cache_dirty_count =  0;
 80072e4:	e9c4 cc08 	strd	ip, ip, [r4, #32]
    if ((media_ptr -> fx_media_sector_cache_size >= FX_SECTOR_CACHE_HASH_ENABLE) &&
 80072e8:	d906      	bls.n	80072f8 <_fx_media_open+0x274>
        ((media_ptr -> fx_media_sector_cache_size ^ (media_ptr -> fx_media_sector_cache_size - 1)) ==
 80072ea:	1e4b      	subs	r3, r1, #1
 80072ec:	ea81 0203 	eor.w	r2, r1, r3
         (media_ptr -> fx_media_sector_cache_size | (media_ptr -> fx_media_sector_cache_size - 1))))
 80072f0:	430b      	orrs	r3, r1
    if ((media_ptr -> fx_media_sector_cache_size >= FX_SECTOR_CACHE_HASH_ENABLE) &&
 80072f2:	429a      	cmp	r2, r3
 80072f4:	f000 81cb 	beq.w	800768e <_fx_media_open+0x60a>
        media_ptr -> fx_media_sector_cache_hashed =  FX_FALSE;
 80072f8:	2200      	movs	r2, #0
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 80072fa:	f04f 0900 	mov.w	r9, #0
 80072fe:	6122      	str	r2, [r4, #16]
 8007300:	f604 0018 	addw	r0, r4, #2072	; 0x818
 8007304:	2280      	movs	r2, #128	; 0x80
 8007306:	4649      	mov	r1, r9
 8007308:	f8c4 9758 	str.w	r9, [r4, #1880]	; 0x758
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 800730c:	f8c4 975c 	str.w	r9, [r4, #1884]	; 0x75c
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 8007310:	f8c4 9760 	str.w	r9, [r4, #1888]	; 0x760
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 8007314:	f8c4 9764 	str.w	r9, [r4, #1892]	; 0x764
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 8007318:	f8c4 9768 	str.w	r9, [r4, #1896]	; 0x768
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 800731c:	f8c4 976c 	str.w	r9, [r4, #1900]	; 0x76c
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 8007320:	f8c4 9770 	str.w	r9, [r4, #1904]	; 0x770
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 8007324:	f8c4 9774 	str.w	r9, [r4, #1908]	; 0x774
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 8007328:	f8c4 9778 	str.w	r9, [r4, #1912]	; 0x778
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 800732c:	f8c4 977c 	str.w	r9, [r4, #1916]	; 0x77c
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 8007330:	f8c4 9780 	str.w	r9, [r4, #1920]	; 0x780
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 8007334:	f8c4 9784 	str.w	r9, [r4, #1924]	; 0x784
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 8007338:	f8c4 9788 	str.w	r9, [r4, #1928]	; 0x788
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 800733c:	f8c4 978c 	str.w	r9, [r4, #1932]	; 0x78c
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 8007340:	f8c4 9790 	str.w	r9, [r4, #1936]	; 0x790
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 8007344:	f8c4 9794 	str.w	r9, [r4, #1940]	; 0x794
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 8007348:	f8c4 9798 	str.w	r9, [r4, #1944]	; 0x798
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 800734c:	f8c4 979c 	str.w	r9, [r4, #1948]	; 0x79c
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 8007350:	f8c4 97a0 	str.w	r9, [r4, #1952]	; 0x7a0
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 8007354:	f8c4 97a4 	str.w	r9, [r4, #1956]	; 0x7a4
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 8007358:	f8c4 97a8 	str.w	r9, [r4, #1960]	; 0x7a8
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 800735c:	f8c4 97ac 	str.w	r9, [r4, #1964]	; 0x7ac
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 8007360:	f8c4 97b0 	str.w	r9, [r4, #1968]	; 0x7b0
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 8007364:	f8c4 97b4 	str.w	r9, [r4, #1972]	; 0x7b4
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 8007368:	f8c4 97b8 	str.w	r9, [r4, #1976]	; 0x7b8
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 800736c:	f8c4 97bc 	str.w	r9, [r4, #1980]	; 0x7bc
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 8007370:	f8c4 97c0 	str.w	r9, [r4, #1984]	; 0x7c0
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 8007374:	f8c4 97c4 	str.w	r9, [r4, #1988]	; 0x7c4
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 8007378:	f8c4 97c8 	str.w	r9, [r4, #1992]	; 0x7c8
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 800737c:	f8c4 97cc 	str.w	r9, [r4, #1996]	; 0x7cc
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 8007380:	f8c4 97d0 	str.w	r9, [r4, #2000]	; 0x7d0
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 8007384:	f8c4 97d4 	str.w	r9, [r4, #2004]	; 0x7d4
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 8007388:	f8c4 97d8 	str.w	r9, [r4, #2008]	; 0x7d8
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 800738c:	f8c4 97dc 	str.w	r9, [r4, #2012]	; 0x7dc
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 8007390:	f8c4 97e0 	str.w	r9, [r4, #2016]	; 0x7e0
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 8007394:	f8c4 97e4 	str.w	r9, [r4, #2020]	; 0x7e4
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 8007398:	f8c4 97e8 	str.w	r9, [r4, #2024]	; 0x7e8
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 800739c:	f8c4 97ec 	str.w	r9, [r4, #2028]	; 0x7ec
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 80073a0:	f8c4 97f0 	str.w	r9, [r4, #2032]	; 0x7f0
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 80073a4:	f8c4 97f4 	str.w	r9, [r4, #2036]	; 0x7f4
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 80073a8:	f8c4 97f8 	str.w	r9, [r4, #2040]	; 0x7f8
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 80073ac:	f8c4 97fc 	str.w	r9, [r4, #2044]	; 0x7fc
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 80073b0:	f8c4 9800 	str.w	r9, [r4, #2048]	; 0x800
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 80073b4:	f8c4 9804 	str.w	r9, [r4, #2052]	; 0x804
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 80073b8:	f8c4 9808 	str.w	r9, [r4, #2056]	; 0x808
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster =   0;
 80073bc:	f8c4 980c 	str.w	r9, [r4, #2060]	; 0x80c
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value   =   0;
 80073c0:	f8c4 9810 	str.w	r9, [r4, #2064]	; 0x810
        media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty   =   0;
 80073c4:	f8c4 9814 	str.w	r9, [r4, #2068]	; 0x814
 80073c8:	f006 fc89 	bl	800dcde <memset>
            ((media_ptr -> fx_media_root_directory_entries * FX_DIR_ENTRY_SIZE) +
 80073cc:	6fa2      	ldr	r2, [r4, #120]	; 0x78
        media_ptr -> fx_media_root_sector_start =  media_ptr -> fx_media_reserved_sectors +
 80073ce:	6c60      	ldr	r0, [r4, #68]	; 0x44
        media_ptr -> fx_media_total_clusters =  (ULONG)((media_ptr -> fx_media_total_sectors - media_ptr -> fx_media_data_sector_start) /
 80073d0:	464b      	mov	r3, r9
             media_ptr -> fx_media_bytes_per_sector - 1) /
 80073d2:	eb07 1242 	add.w	r2, r7, r2, lsl #5
            (media_ptr -> fx_media_number_of_FATs *
 80073d6:	6de1      	ldr	r1, [r4, #92]	; 0x5c
                                                            media_ptr -> fx_media_sectors_per_cluster);
 80073d8:	f8d4 a054 	ldr.w	sl, [r4, #84]	; 0x54
             media_ptr -> fx_media_bytes_per_sector - 1) /
 80073dc:	f102 3cff 	add.w	ip, r2, #4294967295
        media_ptr -> fx_media_root_sector_start =  media_ptr -> fx_media_reserved_sectors +
 80073e0:	6da2      	ldr	r2, [r4, #88]	; 0x58
             media_ptr -> fx_media_bytes_per_sector - 1) /
 80073e2:	fbbc f7f7 	udiv	r7, ip, r7
        media_ptr -> fx_media_root_sector_start =  media_ptr -> fx_media_reserved_sectors +
 80073e6:	fb02 0101 	mla	r1, r2, r1, r0
        media_ptr -> fx_media_total_clusters =  (ULONG)((media_ptr -> fx_media_total_sectors - media_ptr -> fx_media_data_sector_start) /
 80073ea:	4652      	mov	r2, sl
        media_ptr -> fx_media_root_sectors =
 80073ec:	64e7      	str	r7, [r4, #76]	; 0x4c
        media_ptr -> fx_media_data_sector_start =  media_ptr -> fx_media_root_sector_start +
 80073ee:	eb01 0b07 	add.w	fp, r1, r7
        media_ptr -> fx_media_root_sector_start =  media_ptr -> fx_media_reserved_sectors +
 80073f2:	64a1      	str	r1, [r4, #72]	; 0x48
        media_ptr -> fx_media_total_clusters =  (ULONG)((media_ptr -> fx_media_total_sectors - media_ptr -> fx_media_data_sector_start) /
 80073f4:	e9d4 010e 	ldrd	r0, r1, [r4, #56]	; 0x38
        media_ptr -> fx_media_data_sector_start =  media_ptr -> fx_media_root_sector_start +
 80073f8:	f8c4 b050 	str.w	fp, [r4, #80]	; 0x50
        media_ptr -> fx_media_total_clusters =  (ULONG)((media_ptr -> fx_media_total_sectors - media_ptr -> fx_media_data_sector_start) /
 80073fc:	ebb0 000b 	subs.w	r0, r0, fp
 8007400:	f161 0100 	sbc.w	r1, r1, #0
 8007404:	f7f9 f850 	bl	80004a8 <__aeabi_uldivmod>
        if (media_ptr -> fx_media_total_clusters < FX_12_BIT_FAT_SIZE)
 8007408:	f640 73f5 	movw	r3, #4085	; 0xff5
        media_ptr -> fx_media_total_clusters =  (ULONG)((media_ptr -> fx_media_total_sectors - media_ptr -> fx_media_data_sector_start) /
 800740c:	6420      	str	r0, [r4, #64]	; 0x40
        if (media_ptr -> fx_media_total_clusters < FX_12_BIT_FAT_SIZE)
 800740e:	4298      	cmp	r0, r3
 8007410:	f200 80b8 	bhi.w	8007584 <_fx_media_open+0x500>
            media_ptr -> fx_media_12_bit_FAT = FX_TRUE;
 8007414:	2201      	movs	r2, #1
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1;
 8007416:	f242 41a8 	movw	r1, #9384	; 0x24a8
 800741a:	f64f 70f0 	movw	r0, #65520	; 0xfff0
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2;
 800741e:	f242 43ac 	movw	r3, #9388	; 0x24ac
            media_ptr -> fx_media_12_bit_FAT = FX_TRUE;
 8007422:	6622      	str	r2, [r4, #96]	; 0x60
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2;
 8007424:	f64f 72ff 	movw	r2, #65535	; 0xffff
            media_ptr -> fx_media_32_bit_FAT = FX_FALSE;
 8007428:	f8c4 9064 	str.w	r9, [r4, #100]	; 0x64
            media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 800742c:	f8c4 9068 	str.w	r9, [r4, #104]	; 0x68
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1;
 8007430:	5060      	str	r0, [r4, r1]
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2;
 8007432:	50e2      	str	r2, [r4, r3]
    media_ptr -> fx_media_available_clusters =  0;
 8007434:	2300      	movs	r3, #0
 8007436:	67e3      	str	r3, [r4, #124]	; 0x7c
    media_ptr -> fx_media_cluster_search_start =  0;
 8007438:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    if (media_ptr -> fx_media_12_bit_FAT)
 800743c:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800743e:	2b00      	cmp	r3, #0
 8007440:	f040 80b3 	bne.w	80075aa <_fx_media_open+0x526>
        _fx_utility_logical_sector_flush(media_ptr, ((ULONG64) 1), (ULONG64) (media_ptr -> fx_media_total_sectors), FX_TRUE);
 8007444:	2101      	movs	r1, #1
 8007446:	2300      	movs	r3, #0
 8007448:	2201      	movs	r2, #1
 800744a:	4620      	mov	r0, r4
 800744c:	9102      	str	r1, [sp, #8]
 800744e:	e9d4 890e 	ldrd	r8, r9, [r4, #56]	; 0x38
 8007452:	e9cd 8900 	strd	r8, r9, [sp]
 8007456:	f000 fd1b 	bl	8007e90 <_fx_utility_logical_sector_flush>
        for (i = 0; i < media_ptr -> fx_media_sectors_per_FAT; i = i + media_ptr -> fx_media_sector_cache_size)
 800745a:	6da3      	ldr	r3, [r4, #88]	; 0x58
        media_ptr -> fx_media_memory_buffer =  original_memory_ptr;
 800745c:	60a6      	str	r6, [r4, #8]
        for (i = 0; i < media_ptr -> fx_media_sectors_per_FAT; i = i + media_ptr -> fx_media_sector_cache_size)
 800745e:	2b00      	cmp	r3, #0
 8007460:	d051      	beq.n	8007506 <_fx_media_open+0x482>
 8007462:	2700      	movs	r7, #0
 8007464:	6960      	ldr	r0, [r4, #20]
            media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8007466:	f04f 0890 	mov.w	r8, #144	; 0x90
            media_ptr -> fx_media_driver_sector_type =      FX_FAT_SECTOR;
 800746a:	f04f 0902 	mov.w	r9, #2
        cluster_number =  0;
 800746e:	463e      	mov	r6, r7
            media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 8007470:	46ba      	mov	sl, r7
            FAT_read_sectors =  media_ptr -> fx_media_sectors_per_FAT - i;
 8007472:	1bd9      	subs	r1, r3, r7
            FAT_sector =  media_ptr -> fx_media_reserved_sectors + i;
 8007474:	6c62      	ldr	r2, [r4, #68]	; 0x44
            media_ptr -> fx_media_driver_buffer =           media_ptr -> fx_media_memory_buffer;
 8007476:	68a3      	ldr	r3, [r4, #8]
 8007478:	4281      	cmp	r1, r0
            FAT_sector =  media_ptr -> fx_media_reserved_sectors + i;
 800747a:	443a      	add	r2, r7
            media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 800747c:	f8c4 a088 	str.w	sl, [r4, #136]	; 0x88
 8007480:	bf28      	it	cs
 8007482:	4601      	movcs	r1, r0
            media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8007484:	f8c4 808c 	str.w	r8, [r4, #140]	; 0x8c
            (media_ptr -> fx_media_driver_entry) (media_ptr);
 8007488:	4620      	mov	r0, r4
            media_ptr -> fx_media_driver_sector_type =      FX_FAT_SECTOR;
 800748a:	f8c4 90b8 	str.w	r9, [r4, #184]	; 0xb8
            media_ptr -> fx_media_driver_sectors =          FAT_read_sectors;
 800748e:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
 8007492:	468b      	mov	fp, r1
            media_ptr -> fx_media_driver_buffer =           media_ptr -> fx_media_memory_buffer;
 8007494:	e9c4 3224 	strd	r3, r2, [r4, #144]	; 0x90
            (media_ptr -> fx_media_driver_entry) (media_ptr);
 8007498:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 800749c:	4798      	blx	r3
            if (media_ptr -> fx_media_driver_status != FX_SUCCESS)
 800749e:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 80074a2:	2b00      	cmp	r3, #0
 80074a4:	f040 80fe 	bne.w	80076a4 <_fx_media_open+0x620>
            bytes_in_buffer =  (media_ptr -> fx_media_bytes_per_sector * FAT_read_sectors);
 80074a8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80074aa:	fb00 f00b 	mul.w	r0, r0, fp
            for (j = 0; j < bytes_in_buffer;)
 80074ae:	2800      	cmp	r0, #0
 80074b0:	f000 80eb 	beq.w	800768a <_fx_media_open+0x606>
                if (cluster_number >= (media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START))
 80074b4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80074b6:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80074b8:	f103 0c02 	add.w	ip, r3, #2
 80074bc:	68a1      	ldr	r1, [r4, #8]
 80074be:	2a00      	cmp	r2, #0
 80074c0:	f040 80cd 	bne.w	800765e <_fx_media_open+0x5da>
            for (j = 0; j < bytes_in_buffer;)
 80074c4:	4696      	mov	lr, r2
 80074c6:	e002      	b.n	80074ce <_fx_media_open+0x44a>
 80074c8:	4570      	cmp	r0, lr
 80074ca:	f240 80de 	bls.w	800768a <_fx_media_open+0x606>
                        ((((ULONG)(media_ptr -> fx_media_memory_buffer[j + 1])) & 0xFF) << 8);
 80074ce:	eb01 020e 	add.w	r2, r1, lr
                    FAT_entry =  (((ULONG)(media_ptr -> fx_media_memory_buffer[j])) & 0xFF) |
 80074d2:	f811 300e 	ldrb.w	r3, [r1, lr]
                        ((((ULONG)(media_ptr -> fx_media_memory_buffer[j + 1])) & 0xFF) << 8);
 80074d6:	f10e 0e02 	add.w	lr, lr, #2
 80074da:	7852      	ldrb	r2, [r2, #1]
                    FAT_entry =  (((ULONG)(media_ptr -> fx_media_memory_buffer[j])) & 0xFF) |
 80074dc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80074e0:	9305      	str	r3, [sp, #20]
                if (FAT_entry == FX_FREE_CLUSTER)
 80074e2:	b93b      	cbnz	r3, 80074f4 <_fx_media_open+0x470>
                    media_ptr -> fx_media_available_clusters++;
 80074e4:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
                    if (media_ptr -> fx_media_cluster_search_start == 0)
 80074e6:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
                    media_ptr -> fx_media_available_clusters++;
 80074ea:	3301      	adds	r3, #1
 80074ec:	67e3      	str	r3, [r4, #124]	; 0x7c
                    if (media_ptr -> fx_media_cluster_search_start == 0)
 80074ee:	b90a      	cbnz	r2, 80074f4 <_fx_media_open+0x470>
                        media_ptr -> fx_media_cluster_search_start =  cluster_number;
 80074f0:	f8c4 6080 	str.w	r6, [r4, #128]	; 0x80
                cluster_number++;
 80074f4:	3601      	adds	r6, #1
                if (cluster_number >= (media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START))
 80074f6:	45b4      	cmp	ip, r6
 80074f8:	d8e6      	bhi.n	80074c8 <_fx_media_open+0x444>
                    i = media_ptr -> fx_media_sectors_per_FAT;
 80074fa:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80074fc:	461f      	mov	r7, r3
        for (i = 0; i < media_ptr -> fx_media_sectors_per_FAT; i = i + media_ptr -> fx_media_sector_cache_size)
 80074fe:	6960      	ldr	r0, [r4, #20]
 8007500:	4407      	add	r7, r0
 8007502:	42bb      	cmp	r3, r7
 8007504:	d8b5      	bhi.n	8007472 <_fx_media_open+0x3ee>
    if (media_ptr -> fx_media_cluster_search_start == 0)
 8007506:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800750a:	b913      	cbnz	r3, 8007512 <_fx_media_open+0x48e>
        media_ptr -> fx_media_cluster_search_start =  FX_FAT_ENTRY_START;
 800750c:	2302      	movs	r3, #2
 800750e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_short_name[0] =  0;
 8007512:	2300      	movs	r3, #0
        media_ptr -> fx_media_default_path.fx_path_name_buffer;
 8007514:	f504 62ca 	add.w	r2, r4, #1616	; 0x650
    tx_mutex_create(&(media_ptr -> fx_media_protect), "FileX Media Mutex", TX_NO_INHERIT);
 8007518:	499d      	ldr	r1, [pc, #628]	; (8007790 <_fx_media_open+0x70c>)
 800751a:	f504 70e4 	add.w	r0, r4, #456	; 0x1c8
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name =
 800751e:	f8c4 24e0 	str.w	r2, [r4, #1248]	; 0x4e0
    tx_mutex_create(&(media_ptr -> fx_media_protect), "FileX Media Mutex", TX_NO_INHERIT);
 8007522:	461a      	mov	r2, r3
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_short_name[0] =  0;
 8007524:	f884 34e4 	strb.w	r3, [r4, #1252]	; 0x4e4
    media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name[0] =        0;
 8007528:	f884 3650 	strb.w	r3, [r4, #1616]	; 0x650
    media_ptr -> fx_media_default_path.fx_path_string[0] =                      (CHAR)0;
 800752c:	f884 3550 	strb.w	r3, [r4, #1360]	; 0x550
    media_ptr -> fx_media_default_path.fx_path_string[FX_MAXIMUM_PATH - 1] =      (CHAR)0;
 8007530:	f884 364f 	strb.w	r3, [r4, #1615]	; 0x64f
    media_ptr -> fx_media_default_path.fx_path_current_entry =                         0;
 8007534:	f8c4 3750 	str.w	r3, [r4, #1872]	; 0x750
    media_ptr -> fx_media_last_found_name[0] =  0;
 8007538:	f884 33e0 	strb.w	r3, [r4, #992]	; 0x3e0
    media_ptr -> fx_media_opened_file_count =     0;
 800753c:	e9c4 3332 	strd	r3, r3, [r4, #200]	; 0xc8
    tx_mutex_create(&(media_ptr -> fx_media_protect), "FileX Media Mutex", TX_NO_INHERIT);
 8007540:	f004 fde0 	bl	800c104 <_tx_mutex_create>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 8007544:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 8007548:	b672      	cpsid	i
    if (_fx_system_media_opened_ptr)
 800754a:	4a92      	ldr	r2, [pc, #584]	; (8007794 <_fx_media_open+0x710>)
    media_ptr -> fx_media_id =  (ULONG)FX_MEDIA_ID;
 800754c:	4992      	ldr	r1, [pc, #584]	; (8007798 <_fx_media_open+0x714>)
    if (_fx_system_media_opened_ptr)
 800754e:	6813      	ldr	r3, [r2, #0]
    media_ptr -> fx_media_id =  (ULONG)FX_MEDIA_ID;
 8007550:	6021      	str	r1, [r4, #0]
    if (_fx_system_media_opened_ptr)
 8007552:	2b00      	cmp	r3, #0
 8007554:	f000 80a2 	beq.w	800769c <_fx_media_open+0x618>
        tail_ptr =  _fx_system_media_opened_ptr -> fx_media_opened_previous;
 8007558:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
        _fx_system_media_opened_ptr -> fx_media_opened_previous =  media_ptr;
 800755c:	f8c3 40d4 	str.w	r4, [r3, #212]	; 0xd4
        tail_ptr -> fx_media_opened_next =  media_ptr;
 8007560:	f8c2 40d0 	str.w	r4, [r2, #208]	; 0xd0
        media_ptr -> fx_media_opened_next =      _fx_system_media_opened_ptr;
 8007564:	e9c4 3234 	strd	r3, r2, [r4, #208]	; 0xd0
    _fx_system_media_opened_count++;
 8007568:	498c      	ldr	r1, [pc, #560]	; (800779c <_fx_media_open+0x718>)
    if (media_ptr -> fx_media_open_notify)
 800756a:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
    _fx_system_media_opened_count++;
 800756e:	680b      	ldr	r3, [r1, #0]
 8007570:	3301      	adds	r3, #1
 8007572:	600b      	str	r3, [r1, #0]
    if (media_ptr -> fx_media_open_notify)
 8007574:	b10a      	cbz	r2, 800757a <_fx_media_open+0x4f6>
        media_ptr -> fx_media_open_notify(media_ptr);
 8007576:	4620      	mov	r0, r4
 8007578:	4790      	blx	r2
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800757a:	f386 8810 	msr	PRIMASK, r6
    return(FX_SUCCESS);
 800757e:	e643      	b.n	8007208 <_fx_media_open+0x184>
 8007580:	3b01      	subs	r3, #1
 8007582:	e683      	b.n	800728c <_fx_media_open+0x208>
        else if (media_ptr -> fx_media_total_clusters < FX_16_BIT_FAT_SIZE)
 8007584:	f64f 73f4 	movw	r3, #65524	; 0xfff4
 8007588:	4298      	cmp	r0, r3
 800758a:	d837      	bhi.n	80075fc <_fx_media_open+0x578>
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1;
 800758c:	f242 41a8 	movw	r1, #9384	; 0x24a8
 8007590:	f64f 70f0 	movw	r0, #65520	; 0xfff0
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2;
 8007594:	f242 43ac 	movw	r3, #9388	; 0x24ac
 8007598:	f64f 72ff 	movw	r2, #65535	; 0xffff
            media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 800759c:	f8c4 9068 	str.w	r9, [r4, #104]	; 0x68
            media_ptr -> fx_media_32_bit_FAT =  FX_FALSE;
 80075a0:	e9c4 9918 	strd	r9, r9, [r4, #96]	; 0x60
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1;
 80075a4:	5060      	str	r0, [r4, r1]
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2;
 80075a6:	50e2      	str	r2, [r4, r3]
 80075a8:	e744      	b.n	8007434 <_fx_media_open+0x3b0>
             cluster_number < (media_ptr -> fx_media_total_clusters) + FX_FAT_ENTRY_START;
 80075aa:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80075ac:	3302      	adds	r3, #2
        for (cluster_number =  FX_FAT_ENTRY_START;
 80075ae:	2b02      	cmp	r3, #2
 80075b0:	d9a9      	bls.n	8007506 <_fx_media_open+0x482>
 80075b2:	2602      	movs	r6, #2
 80075b4:	af05      	add	r7, sp, #20
 80075b6:	e00e      	b.n	80075d6 <_fx_media_open+0x552>
            if (FAT_entry == FX_FREE_CLUSTER)
 80075b8:	9b05      	ldr	r3, [sp, #20]
 80075ba:	b93b      	cbnz	r3, 80075cc <_fx_media_open+0x548>
                media_ptr -> fx_media_available_clusters++;
 80075bc:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
                if (media_ptr -> fx_media_cluster_search_start == 0)
 80075be:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
                media_ptr -> fx_media_available_clusters++;
 80075c2:	3301      	adds	r3, #1
 80075c4:	67e3      	str	r3, [r4, #124]	; 0x7c
                if (media_ptr -> fx_media_cluster_search_start == 0)
 80075c6:	b90a      	cbnz	r2, 80075cc <_fx_media_open+0x548>
                    media_ptr -> fx_media_cluster_search_start =  cluster_number;
 80075c8:	f8c4 6080 	str.w	r6, [r4, #128]	; 0x80
             cluster_number < (media_ptr -> fx_media_total_clusters) + FX_FAT_ENTRY_START;
 80075cc:	6c23      	ldr	r3, [r4, #64]	; 0x40
             cluster_number++)
 80075ce:	3601      	adds	r6, #1
             cluster_number < (media_ptr -> fx_media_total_clusters) + FX_FAT_ENTRY_START;
 80075d0:	3302      	adds	r3, #2
        for (cluster_number =  FX_FAT_ENTRY_START;
 80075d2:	42b3      	cmp	r3, r6
 80075d4:	d997      	bls.n	8007506 <_fx_media_open+0x482>
            status =  _fx_utility_FAT_entry_read(media_ptr, cluster_number, &FAT_entry);
 80075d6:	463a      	mov	r2, r7
 80075d8:	4631      	mov	r1, r6
 80075da:	4620      	mov	r0, r4
 80075dc:	f000 f902 	bl	80077e4 <_fx_utility_FAT_entry_read>
            if (status != FX_SUCCESS)
 80075e0:	2800      	cmp	r0, #0
 80075e2:	d0e9      	beq.n	80075b8 <_fx_media_open+0x534>
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 80075e4:	2108      	movs	r1, #8
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 80075e6:	2290      	movs	r2, #144	; 0x90
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 80075e8:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 80075ec:	4620      	mov	r0, r4
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 80075ee:	f8c4 1088 	str.w	r1, [r4, #136]	; 0x88
                return(FX_FAT_READ_ERROR);
 80075f2:	2503      	movs	r5, #3
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 80075f4:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 80075f8:	4798      	blx	r3
                return(FX_FAT_READ_ERROR);
 80075fa:	e605      	b.n	8007208 <_fx_media_open+0x184>
            media_ptr -> fx_media_FAT32_additional_info_sector =  additional_info_sector;
 80075fc:	f8c4 8068 	str.w	r8, [r4, #104]	; 0x68
            media_ptr -> fx_media_32_bit_FAT =  FX_TRUE;
 8007600:	2201      	movs	r2, #1
            if (media_ptr -> fx_media_root_cluster_32 < FX_FAT_ENTRY_START)
 8007602:	f8d4 8074 	ldr.w	r8, [r4, #116]	; 0x74
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1_32;
 8007606:	f242 43a8 	movw	r3, #9384	; 0x24a8
            media_ptr -> fx_media_32_bit_FAT =  FX_TRUE;
 800760a:	6662      	str	r2, [r4, #100]	; 0x64
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2_32;
 800760c:	f242 41ac 	movw	r1, #9388	; 0x24ac
 8007610:	f06f 4070 	mvn.w	r0, #4026531840	; 0xf0000000
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1_32;
 8007614:	4a62      	ldr	r2, [pc, #392]	; (80077a0 <_fx_media_open+0x71c>)
            if (media_ptr -> fx_media_root_cluster_32 < FX_FAT_ENTRY_START)
 8007616:	f1b8 0f01 	cmp.w	r8, #1
            media_ptr -> fx_media_12_bit_FAT =  FX_FALSE;
 800761a:	f8c4 9060 	str.w	r9, [r4, #96]	; 0x60
            media_ptr -> fx_media_fat_last = FX_LAST_CLUSTER_2_32;
 800761e:	5060      	str	r0, [r4, r1]
            media_ptr -> fx_media_fat_reserved = FX_RESERVED_1_32;
 8007620:	50e2      	str	r2, [r4, r3]
            if (media_ptr -> fx_media_root_cluster_32 < FX_FAT_ENTRY_START)
 8007622:	f240 80b3 	bls.w	800778c <_fx_media_open+0x708>
                (media_ptr -> fx_media_root_cluster_32 - FX_FAT_ENTRY_START) *
 8007626:	f1a8 0302 	sub.w	r3, r8, #2
 800762a:	af05      	add	r7, sp, #20
            media_ptr -> fx_media_root_sector_start = media_ptr -> fx_media_data_sector_start +
 800762c:	fb0a b303 	mla	r3, sl, r3, fp
            if (FAT_entry >= FX_RESERVED_1_32)
 8007630:	f8df a178 	ldr.w	sl, [pc, #376]	; 80077ac <_fx_media_open+0x728>
            media_ptr -> fx_media_root_sector_start = media_ptr -> fx_media_data_sector_start +
 8007634:	64a3      	str	r3, [r4, #72]	; 0x48
 8007636:	e008      	b.n	800764a <_fx_media_open+0x5c6>
            if ((cluster_number == FAT_entry) || (i > media_ptr -> fx_media_total_clusters))
 8007638:	9b05      	ldr	r3, [sp, #20]
 800763a:	4543      	cmp	r3, r8
 800763c:	4698      	mov	r8, r3
 800763e:	d0d1      	beq.n	80075e4 <_fx_media_open+0x560>
 8007640:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8007642:	454b      	cmp	r3, r9
 8007644:	d3ce      	bcc.n	80075e4 <_fx_media_open+0x560>
            if (FAT_entry >= FX_RESERVED_1_32)
 8007646:	45d0      	cmp	r8, sl
 8007648:	d837      	bhi.n	80076ba <_fx_media_open+0x636>
            status =  _fx_utility_FAT_entry_read(media_ptr, cluster_number, &FAT_entry);
 800764a:	463a      	mov	r2, r7
 800764c:	4641      	mov	r1, r8
 800764e:	4620      	mov	r0, r4
            i++;
 8007650:	f109 0901 	add.w	r9, r9, #1
            status =  _fx_utility_FAT_entry_read(media_ptr, cluster_number, &FAT_entry);
 8007654:	f000 f8c6 	bl	80077e4 <_fx_utility_FAT_entry_read>
            if (status != FX_SUCCESS)
 8007658:	2800      	cmp	r0, #0
 800765a:	d0ed      	beq.n	8007638 <_fx_media_open+0x5b4>
 800765c:	e7c2      	b.n	80075e4 <_fx_media_open+0x560>
                if (cluster_number >= (media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START))
 800765e:	468e      	mov	lr, r1
 8007660:	e001      	b.n	8007666 <_fx_media_open+0x5e2>
            for (j = 0; j < bytes_in_buffer;)
 8007662:	4558      	cmp	r0, fp
 8007664:	d911      	bls.n	800768a <_fx_media_open+0x606>
                    FAT_entry =  *((ULONG *)&(media_ptr -> fx_media_memory_buffer[j]));
 8007666:	f85e 3b04 	ldr.w	r3, [lr], #4
            for (j = 0; j < bytes_in_buffer;)
 800766a:	ebae 0b01 	sub.w	fp, lr, r1
 800766e:	9305      	str	r3, [sp, #20]
                if (FAT_entry == FX_FREE_CLUSTER)
 8007670:	b93b      	cbnz	r3, 8007682 <_fx_media_open+0x5fe>
                    media_ptr -> fx_media_available_clusters++;
 8007672:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
                    if (media_ptr -> fx_media_cluster_search_start == 0)
 8007674:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
                    media_ptr -> fx_media_available_clusters++;
 8007678:	3301      	adds	r3, #1
 800767a:	67e3      	str	r3, [r4, #124]	; 0x7c
                    if (media_ptr -> fx_media_cluster_search_start == 0)
 800767c:	b90a      	cbnz	r2, 8007682 <_fx_media_open+0x5fe>
                        media_ptr -> fx_media_cluster_search_start =  cluster_number;
 800767e:	f8c4 6080 	str.w	r6, [r4, #128]	; 0x80
                cluster_number++;
 8007682:	3601      	adds	r6, #1
                if (cluster_number >= (media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START))
 8007684:	45b4      	cmp	ip, r6
 8007686:	d8ec      	bhi.n	8007662 <_fx_media_open+0x5de>
 8007688:	e737      	b.n	80074fa <_fx_media_open+0x476>
 800768a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800768c:	e737      	b.n	80074fe <_fx_media_open+0x47a>
            ((media_ptr -> fx_media_sector_cache_size / FX_SECTOR_CACHE_DEPTH) - 1);
 800768e:	088b      	lsrs	r3, r1, #2
        media_ptr -> fx_media_sector_cache_hash_mask =
 8007690:	f242 41a0 	movw	r1, #9376	; 0x24a0
        media_ptr -> fx_media_sector_cache_hashed =  FX_TRUE;
 8007694:	2201      	movs	r2, #1
            ((media_ptr -> fx_media_sector_cache_size / FX_SECTOR_CACHE_DEPTH) - 1);
 8007696:	3b01      	subs	r3, #1
        media_ptr -> fx_media_sector_cache_hash_mask =
 8007698:	5063      	str	r3, [r4, r1]
 800769a:	e62e      	b.n	80072fa <_fx_media_open+0x276>
        _fx_system_media_opened_ptr =           media_ptr;
 800769c:	6014      	str	r4, [r2, #0]
        media_ptr -> fx_media_opened_previous = media_ptr;
 800769e:	e9c4 4434 	strd	r4, r4, [r4, #208]	; 0xd0
 80076a2:	e761      	b.n	8007568 <_fx_media_open+0x4e4>
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 80076a4:	2208      	movs	r2, #8
                media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 80076a6:	f8c4 808c 	str.w	r8, [r4, #140]	; 0x8c
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 80076aa:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 80076ae:	4620      	mov	r0, r4
                media_ptr -> fx_media_driver_request =      FX_DRIVER_UNINIT;
 80076b0:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
                return(FX_FAT_READ_ERROR);
 80076b4:	2503      	movs	r5, #3
                (media_ptr -> fx_media_driver_entry) (media_ptr);
 80076b6:	4798      	blx	r3
                return(FX_FAT_READ_ERROR);
 80076b8:	e5a6      	b.n	8007208 <_fx_media_open+0x184>
        media_ptr -> fx_media_root_directory_entries =  (i * media_ptr -> fx_media_sectors_per_cluster *
 80076ba:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80076bc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    media_ptr -> fx_media_available_clusters =  0;
 80076be:	67e0      	str	r0, [r4, #124]	; 0x7c
        media_ptr -> fx_media_root_directory_entries =  (i * media_ptr -> fx_media_sectors_per_cluster *
 80076c0:	fb03 f302 	mul.w	r3, r3, r2
 80076c4:	6ea2      	ldr	r2, [r4, #104]	; 0x68
    media_ptr -> fx_media_cluster_search_start =  0;
 80076c6:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
        media_ptr -> fx_media_root_directory_entries =  (i * media_ptr -> fx_media_sectors_per_cluster *
 80076ca:	fb09 f903 	mul.w	r9, r9, r3
                                                         media_ptr -> fx_media_bytes_per_sector) / FX_DIR_ENTRY_SIZE;
 80076ce:	ea4f 1359 	mov.w	r3, r9, lsr #5
        media_ptr -> fx_media_root_directory_entries =  (i * media_ptr -> fx_media_sectors_per_cluster *
 80076d2:	67a3      	str	r3, [r4, #120]	; 0x78
    if (media_ptr -> fx_media_FAT32_additional_info_sector)
 80076d4:	2a00      	cmp	r2, #0
 80076d6:	f43f aeb1 	beq.w	800743c <_fx_media_open+0x3b8>
        buffer_ptr =  (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_memory_buffer;
 80076da:	69e2      	ldr	r2, [r4, #28]
        media_ptr -> fx_media_driver_sectors =          1;
 80076dc:	2101      	movs	r1, #1
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector =  (~((ULONG64) 0));
 80076de:	f04f 38ff 	mov.w	r8, #4294967295
 80076e2:	f04f 39ff 	mov.w	r9, #4294967295
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_valid =  FX_FALSE;
 80076e6:	7450      	strb	r0, [r2, #17]
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80076e8:	2790      	movs	r7, #144	; 0x90
        media_ptr -> fx_media_driver_read_requests++;
 80076ea:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac
        (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector =  (~((ULONG64) 0));
 80076ee:	e9c2 8902 	strd	r8, r9, [r2, #8]
        media_ptr -> fx_media_driver_read_requests++;
 80076f2:	440b      	add	r3, r1
        buffer_ptr =  (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_memory_buffer;
 80076f4:	6812      	ldr	r2, [r2, #0]
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 80076f6:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 80076fa:	4620      	mov	r0, r4
        buffer_ptr =  (media_ptr -> fx_media_sector_cache_list_ptr) -> fx_cached_sector_memory_buffer;
 80076fc:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
        media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 8007700:	2203      	movs	r2, #3
        media_ptr -> fx_media_driver_read_requests++;
 8007702:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
        media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 8007706:	6ea3      	ldr	r3, [r4, #104]	; 0x68
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8007708:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
        media_ptr -> fx_media_driver_logical_sector =   media_ptr -> fx_media_FAT32_additional_info_sector;
 800770c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
        media_ptr -> fx_media_driver_sectors =          1;
 8007710:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8007714:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
        media_ptr -> fx_media_driver_sector_type =      FX_DIRECTORY_SECTOR;
 8007718:	f8c4 20b8 	str.w	r2, [r4, #184]	; 0xb8
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800771c:	4798      	blx	r3
        if (media_ptr -> fx_media_driver_status == FX_SUCCESS)
 800771e:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8007722:	b153      	cbz	r3, 800773a <_fx_media_open+0x6b6>
                    media_ptr -> fx_media_FAT32_additional_info_sector =  0;
 8007724:	2300      	movs	r3, #0
 8007726:	66a3      	str	r3, [r4, #104]	; 0x68
    if (media_ptr -> fx_media_12_bit_FAT)
 8007728:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800772a:	2b00      	cmp	r3, #0
 800772c:	f47f af3d 	bne.w	80075aa <_fx_media_open+0x526>
    else if (media_ptr -> fx_media_available_clusters == 0)
 8007730:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8007732:	2b00      	cmp	r3, #0
 8007734:	f47f aee7 	bne.w	8007506 <_fx_media_open+0x482>
 8007738:	e684      	b.n	8007444 <_fx_media_open+0x3c0>
            buffer_ptr =  media_ptr -> fx_media_driver_buffer;
 800773a:	f8d4 7090 	ldr.w	r7, [r4, #144]	; 0x90
            signature =  _fx_utility_32_unsigned_read(&buffer_ptr[0]);
 800773e:	4638      	mov	r0, r7
 8007740:	f000 f83c 	bl	80077bc <_fx_utility_32_unsigned_read>
            if (signature == 0x41615252)
 8007744:	4b17      	ldr	r3, [pc, #92]	; (80077a4 <_fx_media_open+0x720>)
 8007746:	4298      	cmp	r0, r3
 8007748:	d1ec      	bne.n	8007724 <_fx_media_open+0x6a0>
                signature =  _fx_utility_32_unsigned_read(&buffer_ptr[484]);
 800774a:	f507 70f2 	add.w	r0, r7, #484	; 0x1e4
 800774e:	f000 f835 	bl	80077bc <_fx_utility_32_unsigned_read>
                if (signature == 0x61417272)
 8007752:	4b15      	ldr	r3, [pc, #84]	; (80077a8 <_fx_media_open+0x724>)
 8007754:	4298      	cmp	r0, r3
 8007756:	d1e5      	bne.n	8007724 <_fx_media_open+0x6a0>
                    media_ptr -> fx_media_available_clusters =  _fx_utility_32_unsigned_read(&buffer_ptr[488]);
 8007758:	f507 70f4 	add.w	r0, r7, #488	; 0x1e8
 800775c:	f000 f82e 	bl	80077bc <_fx_utility_32_unsigned_read>
 8007760:	4603      	mov	r3, r0
                    media_ptr -> fx_media_cluster_search_start =  _fx_utility_32_unsigned_read(&buffer_ptr[492]);
 8007762:	f507 70f6 	add.w	r0, r7, #492	; 0x1ec
                    media_ptr -> fx_media_available_clusters =  _fx_utility_32_unsigned_read(&buffer_ptr[488]);
 8007766:	67e3      	str	r3, [r4, #124]	; 0x7c
                    media_ptr -> fx_media_FAT32_additional_info_last_available =  media_ptr -> fx_media_available_clusters;
 8007768:	66e3      	str	r3, [r4, #108]	; 0x6c
                    media_ptr -> fx_media_cluster_search_start =  _fx_utility_32_unsigned_read(&buffer_ptr[492]);
 800776a:	f000 f827 	bl	80077bc <_fx_utility_32_unsigned_read>
                    if ((media_ptr -> fx_media_available_clusters > media_ptr -> fx_media_total_clusters) ||
 800776e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8007770:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
                    media_ptr -> fx_media_cluster_search_start =  _fx_utility_32_unsigned_read(&buffer_ptr[492]);
 8007772:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
                    if ((media_ptr -> fx_media_available_clusters > media_ptr -> fx_media_total_clusters) ||
 8007776:	429a      	cmp	r2, r3
 8007778:	f63f ae5c 	bhi.w	8007434 <_fx_media_open+0x3b0>
                        (media_ptr -> fx_media_cluster_search_start > media_ptr -> fx_media_total_clusters + FX_FAT_ENTRY_START) ||
 800777c:	3302      	adds	r3, #2
 800777e:	4298      	cmp	r0, r3
 8007780:	f63f ae58 	bhi.w	8007434 <_fx_media_open+0x3b0>
 8007784:	2801      	cmp	r0, #1
 8007786:	f67f ae55 	bls.w	8007434 <_fx_media_open+0x3b0>
 800778a:	e7cd      	b.n	8007728 <_fx_media_open+0x6a4>
                return(FX_MEDIA_INVALID);
 800778c:	2502      	movs	r5, #2
 800778e:	e53b      	b.n	8007208 <_fx_media_open+0x184>
 8007790:	0800de74 	.word	0x0800de74
 8007794:	20000e08 	.word	0x20000e08
 8007798:	4d454449 	.word	0x4d454449
 800779c:	20000e00 	.word	0x20000e00
 80077a0:	0ffffff0 	.word	0x0ffffff0
 80077a4:	41615252 	.word	0x41615252
 80077a8:	61417272 	.word	0x61417272
 80077ac:	0fffffef 	.word	0x0fffffef

080077b0 <_fx_utility_16_unsigned_read>:
{

UINT value;

    /* Pickup the UINT from the destination with endian-awareness.  */
    value =  ((((UINT)*(source_ptr + 1)) & 0xFF) << 8) |
 80077b0:	7803      	ldrb	r3, [r0, #0]
 80077b2:	7840      	ldrb	r0, [r0, #1]
              ((UINT)*(source_ptr) & 0xFF);

    /* Return value to caller.  */
    return(value);
}
 80077b4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80077b8:	4770      	bx	lr
 80077ba:	bf00      	nop

080077bc <_fx_utility_32_unsigned_read>:
{

ULONG value;

    /* Pickup the UINT from the destination with endian-awareness.  */
    value =  ((((ULONG) *(source_ptr+3)) & 0xFF) << 24) |
 80077bc:	7803      	ldrb	r3, [r0, #0]
 80077be:	7841      	ldrb	r1, [r0, #1]
 80077c0:	7882      	ldrb	r2, [r0, #2]
 80077c2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80077c6:	78c0      	ldrb	r0, [r0, #3]
 80077c8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
             ((((ULONG) *(source_ptr+1)) & 0xFF) << 8)  |
              (((ULONG) *(source_ptr)) & 0xFF);

    /* Return value to caller.  */
    return(value);
}
 80077cc:	ea43 6000 	orr.w	r0, r3, r0, lsl #24
 80077d0:	4770      	bx	lr
 80077d2:	bf00      	nop

080077d4 <_fx_utility_32_unsigned_write>:
VOID  _fx_utility_32_unsigned_write(UCHAR *dest_ptr, ULONG value)
{

    /* Store the UINT into the destination with endian-awareness.  */
    *(dest_ptr) =       (UCHAR)(value & 0xFF);
    *(dest_ptr + 1) =   (UCHAR)((value >> 8) & 0xFF);
 80077d4:	0a0a      	lsrs	r2, r1, #8
    *(dest_ptr) =       (UCHAR)(value & 0xFF);
 80077d6:	7001      	strb	r1, [r0, #0]
    *(dest_ptr + 2) =   (UCHAR)((value >> 16) & 0xFF);
 80077d8:	0c0b      	lsrs	r3, r1, #16
    *(dest_ptr + 3) =   (UCHAR)((value >> 24) & 0xFF);
 80077da:	0e09      	lsrs	r1, r1, #24
    *(dest_ptr + 1) =   (UCHAR)((value >> 8) & 0xFF);
 80077dc:	7042      	strb	r2, [r0, #1]
    *(dest_ptr + 2) =   (UCHAR)((value >> 16) & 0xFF);
 80077de:	7083      	strb	r3, [r0, #2]
    *(dest_ptr + 3) =   (UCHAR)((value >> 24) & 0xFF);
 80077e0:	70c1      	strb	r1, [r0, #3]
}
 80077e2:	4770      	bx	lr

080077e4 <_fx_utility_FAT_entry_read>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_FAT_entry_read(FX_MEDIA *media_ptr, ULONG cluster, ULONG *entry_ptr)
{
 80077e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_FAT_ENTRY_READ_EXTENSION

    /* Calculate the area of the cache for this FAT entry.  */
    index =  (cluster & FX_FAT_CACHE_HASH_MASK) * FX_FAT_CACHE_DEPTH;
 80077e8:	f001 0403 	and.w	r4, r1, #3
    media_ptr -> fx_media_fat_entry_reads++;
 80077ec:	f8d0 6178 	ldr.w	r6, [r0, #376]	; 0x178
    media_ptr -> fx_media_fat_entry_cache_read_hits++;
 80077f0:	f8d0 3180 	ldr.w	r3, [r0, #384]	; 0x180
{
 80077f4:	b089      	sub	sp, #36	; 0x24
    index =  (cluster & FX_FAT_CACHE_HASH_MASK) * FX_FAT_CACHE_DEPTH;
 80077f6:	00a7      	lsls	r7, r4, #2
    media_ptr -> fx_media_fat_entry_reads++;
 80077f8:	3601      	adds	r6, #1
    media_ptr -> fx_media_fat_entry_cache_read_hits++;
 80077fa:	3301      	adds	r3, #1
    /* Build a pointer to the cache entry.  */
    cache_entry_ptr =  &media_ptr -> fx_media_fat_cache[index];

    /* Determine if the FAT entry is in the cache - assuming the depth of the FAT cache is
       4 entries.  */
    if ((cache_entry_ptr -> fx_fat_cache_entry_cluster) == cluster)
 80077fc:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
    media_ptr -> fx_media_fat_entry_reads++;
 8007800:	f8c0 6178 	str.w	r6, [r0, #376]	; 0x178
    media_ptr -> fx_media_fat_entry_cache_read_hits++;
 8007804:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
    if ((cache_entry_ptr -> fx_fat_cache_entry_cluster) == cluster)
 8007808:	00a4      	lsls	r4, r4, #2
 800780a:	eb00 0c04 	add.w	ip, r0, r4
 800780e:	f8dc 6758 	ldr.w	r6, [ip, #1880]	; 0x758
 8007812:	428e      	cmp	r6, r1
 8007814:	d05f      	beq.n	80078d6 <_fx_utility_FAT_entry_read+0xf2>
    cache_entry_ptr =  &media_ptr -> fx_media_fat_cache[index];
 8007816:	f504 64eb 	add.w	r4, r4, #1880	; 0x758
 800781a:	4605      	mov	r5, r0
 800781c:	f50c 6eeb 	add.w	lr, ip, #1880	; 0x758
 8007820:	4404      	add	r4, r0
        /* Don't move anything since we found the entry.  */

        /* Return a successful status.  */
        return(FX_SUCCESS);
    }
    else if (((cache_entry_ptr + 1) -> fx_fat_cache_entry_cluster) == cluster)
 8007822:	68e6      	ldr	r6, [r4, #12]
 8007824:	428e      	cmp	r6, r1
 8007826:	d041      	beq.n	80078ac <_fx_utility_FAT_entry_read+0xc8>
        *(cache_entry_ptr + 1) =  temp_cache_entry;

        /* Return a successful status.  */
        return(FX_SUCCESS);
    }
    else if (((cache_entry_ptr + 2) -> fx_fat_cache_entry_cluster) == cluster)
 8007828:	69a6      	ldr	r6, [r4, #24]
 800782a:	428e      	cmp	r6, r1
 800782c:	d063      	beq.n	80078f6 <_fx_utility_FAT_entry_read+0x112>
        *(cache_entry_ptr + 1) =  temp_cache_entry;

        /* Return a successful status.  */
        return(FX_SUCCESS);
    }
    else if (((cache_entry_ptr + 3) -> fx_fat_cache_entry_cluster) == cluster)
 800782e:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8007830:	428e      	cmp	r6, r1
 8007832:	d07b      	beq.n	800792c <_fx_utility_FAT_entry_read+0x148>
 8007834:	4690      	mov	r8, r2
        return(FX_SUCCESS);
    }

    /* Determine if the oldest entry was modified, i.e. whether or not it is
       dirty.  */
    if (media_ptr -> fx_media_fat_cache[index + 3].fx_fat_cache_entry_dirty)
 8007836:	1cfa      	adds	r2, r7, #3
 8007838:	460e      	mov	r6, r1
 800783a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800783e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8007842:	f8d2 2760 	ldr.w	r2, [r2, #1888]	; 0x760
 8007846:	2a00      	cmp	r2, #0
 8007848:	d14d      	bne.n	80078e6 <_fx_utility_FAT_entry_read+0x102>

    /* Decrement the number of cache hits.  */
    media_ptr -> fx_media_fat_entry_cache_read_hits--;

    /* Increment the number of cache misses.  */
    media_ptr -> fx_media_fat_entry_cache_read_misses++;
 800784a:	f8d5 1184 	ldr.w	r1, [r5, #388]	; 0x184
    media_ptr -> fx_media_fat_entry_cache_read_hits--;
 800784e:	1e5a      	subs	r2, r3, #1
#endif

    /* Determine which type of FAT is present.  */
    if (media_ptr -> fx_media_12_bit_FAT)
 8007850:	6e2b      	ldr	r3, [r5, #96]	; 0x60
    media_ptr -> fx_media_fat_entry_cache_read_misses++;
 8007852:	3101      	adds	r1, #1
    media_ptr -> fx_media_fat_entry_cache_read_hits--;
 8007854:	f8c5 2180 	str.w	r2, [r5, #384]	; 0x180
 8007858:	f8d5 9028 	ldr.w	r9, [r5, #40]	; 0x28
    media_ptr -> fx_media_fat_entry_cache_read_misses++;
 800785c:	f8c5 1184 	str.w	r1, [r5, #388]	; 0x184
 8007860:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8007862:	68a8      	ldr	r0, [r5, #8]
    if (media_ptr -> fx_media_12_bit_FAT)
 8007864:	2b00      	cmp	r3, #0
 8007866:	f040 809d 	bne.w	80079a4 <_fx_utility_FAT_entry_read+0x1c0>

    /* Check for a 16-bit FAT.  */
#ifdef FX_ENABLE_EXFAT
    else if (FX_FAT16  == media_ptr -> fx_media_FAT_type)
#else
    else if (!media_ptr -> fx_media_32_bit_FAT)
 800786a:	6e69      	ldr	r1, [r5, #100]	; 0x64
 800786c:	2900      	cmp	r1, #0
 800786e:	d17e      	bne.n	800796e <_fx_utility_FAT_entry_read+0x18a>
    {

        /* 16-bit FAT is present.  */

        /* Calculate the byte offset to the cluster entry.  */
        byte_offset =  (((ULONG)cluster) * 2);
 8007870:	ea4f 0a46 	mov.w	sl, r6, lsl #1
        /* Calculate the FAT sector the requested FAT entry resides in.  */
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
            (ULONG)media_ptr -> fx_media_reserved_sectors;

        /* Read the FAT sector.  */
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007874:	460b      	mov	r3, r1
 8007876:	9000      	str	r0, [sp, #0]
 8007878:	2101      	movs	r1, #1
 800787a:	2002      	movs	r0, #2
 800787c:	9101      	str	r1, [sp, #4]
 800787e:	9002      	str	r0, [sp, #8]
 8007880:	4628      	mov	r0, r5
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007882:	fbba f9f9 	udiv	r9, sl, r9
 8007886:	4491      	add	r9, r2
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007888:	464a      	mov	r2, r9
 800788a:	f000 fe25 	bl	80084d8 <_fx_utility_logical_sector_read>
                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);

        /* Determine if an error occurred.  */
        if (status != FX_SUCCESS)
 800788e:	4603      	mov	r3, r0
 8007890:	b9e8      	cbnz	r0, 80078ce <_fx_utility_FAT_entry_read+0xea>
            return(status);
        }

        /* Now calculate the byte offset into this FAT sector.  */
        byte_offset =  byte_offset -
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8007892:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8007894:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8007896:	eba9 0902 	sub.w	r9, r9, r2
             media_ptr -> fx_media_bytes_per_sector);

        /* Setup a pointer into the buffer.  */
        FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 800789a:	68a8      	ldr	r0, [r5, #8]
        byte_offset =  byte_offset -
 800789c:	fb03 aa19 	mls	sl, r3, r9, sl

        /* Pickup the FAT entry.  */
        entry =  _fx_utility_16_unsigned_read(FAT_ptr);
 80078a0:	4450      	add	r0, sl
 80078a2:	f7ff ff85 	bl	80077b0 <_fx_utility_16_unsigned_read>

        *entry_ptr =  entry;
 80078a6:	f8c8 0000 	str.w	r0, [r8]
 80078aa:	e0b2      	b.n	8007a12 <_fx_utility_FAT_entry_read+0x22e>
        *entry_ptr =  (cache_entry_ptr + 1) -> fx_fat_cache_entry_value;
 80078ac:	6921      	ldr	r1, [r4, #16]
        temp_cache_entry =        *(cache_entry_ptr);
 80078ae:	ad05      	add	r5, sp, #20
        *(cache_entry_ptr) =      *(cache_entry_ptr + 1);
 80078b0:	340c      	adds	r4, #12
        return(FX_SUCCESS);
 80078b2:	2300      	movs	r3, #0
        *entry_ptr =  (cache_entry_ptr + 1) -> fx_fat_cache_entry_value;
 80078b4:	6011      	str	r1, [r2, #0]
        temp_cache_entry =        *(cache_entry_ptr);
 80078b6:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
 80078ba:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        *(cache_entry_ptr) =      *(cache_entry_ptr + 1);
 80078be:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 80078c2:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
        *(cache_entry_ptr + 1) =  temp_cache_entry;
 80078c6:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 80078ca:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    cache_entry_ptr -> fx_fat_cache_entry_cluster =  cluster;
    cache_entry_ptr -> fx_fat_cache_entry_value   =  *entry_ptr;

    /* Return success to the caller.  */
    return(FX_SUCCESS);
}
 80078ce:	4618      	mov	r0, r3
 80078d0:	b009      	add	sp, #36	; 0x24
 80078d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return(FX_SUCCESS);
 80078d6:	2300      	movs	r3, #0
        *entry_ptr =  cache_entry_ptr -> fx_fat_cache_entry_value;
 80078d8:	f8dc 175c 	ldr.w	r1, [ip, #1884]	; 0x75c
}
 80078dc:	4618      	mov	r0, r3
        *entry_ptr =  cache_entry_ptr -> fx_fat_cache_entry_value;
 80078de:	6011      	str	r1, [r2, #0]
}
 80078e0:	b009      	add	sp, #36	; 0x24
 80078e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        status = _fx_utility_FAT_flush(media_ptr);
 80078e6:	f000 f8dd 	bl	8007aa4 <_fx_utility_FAT_flush>
        if (status != FX_SUCCESS)
 80078ea:	4603      	mov	r3, r0
 80078ec:	2800      	cmp	r0, #0
 80078ee:	d1ee      	bne.n	80078ce <_fx_utility_FAT_entry_read+0xea>
 80078f0:	f8d5 3180 	ldr.w	r3, [r5, #384]	; 0x180
 80078f4:	e7a9      	b.n	800784a <_fx_utility_FAT_entry_read+0x66>
        *entry_ptr =  (cache_entry_ptr + 2) -> fx_fat_cache_entry_value;
 80078f6:	69e3      	ldr	r3, [r4, #28]
        *(cache_entry_ptr) =      *(cache_entry_ptr + 2);
 80078f8:	f104 0718 	add.w	r7, r4, #24
        temp_cache_entry =        *(cache_entry_ptr);
 80078fc:	ad05      	add	r5, sp, #20
        *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 80078fe:	340c      	adds	r4, #12
        *entry_ptr =  (cache_entry_ptr + 2) -> fx_fat_cache_entry_value;
 8007900:	6013      	str	r3, [r2, #0]
        return(FX_SUCCESS);
 8007902:	2300      	movs	r3, #0
        temp_cache_entry =        *(cache_entry_ptr);
 8007904:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
 8007908:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        *(cache_entry_ptr) =      *(cache_entry_ptr + 2);
 800790c:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 8007910:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
        *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 8007914:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8007918:	e887 0007 	stmia.w	r7, {r0, r1, r2}
        *(cache_entry_ptr + 1) =  temp_cache_entry;
 800791c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8007920:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8007924:	4618      	mov	r0, r3
 8007926:	b009      	add	sp, #36	; 0x24
 8007928:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        *entry_ptr =  (cache_entry_ptr + 3) -> fx_fat_cache_entry_value;
 800792c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
        temp_cache_entry =        *(cache_entry_ptr);
 800792e:	ab05      	add	r3, sp, #20
        *(cache_entry_ptr) =      *(cache_entry_ptr + 3);
 8007930:	f104 0724 	add.w	r7, r4, #36	; 0x24
        *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 8007934:	f104 0518 	add.w	r5, r4, #24
        *entry_ptr =  (cache_entry_ptr + 3) -> fx_fat_cache_entry_value;
 8007938:	6011      	str	r1, [r2, #0]
        *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 800793a:	340c      	adds	r4, #12
        temp_cache_entry =        *(cache_entry_ptr);
 800793c:	e89e 0007 	ldmia.w	lr, {r0, r1, r2}
 8007940:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        *(cache_entry_ptr) =      *(cache_entry_ptr + 3);
 8007944:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 8007948:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
        *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 800794c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 8007950:	e887 0007 	stmia.w	r7, {r0, r1, r2}
        *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 8007954:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8007958:	e885 0007 	stmia.w	r5, {r0, r1, r2}
        *(cache_entry_ptr + 1) =  temp_cache_entry;
 800795c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
        return(FX_SUCCESS);
 8007960:	2300      	movs	r3, #0
        *(cache_entry_ptr + 1) =  temp_cache_entry;
 8007962:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 8007966:	4618      	mov	r0, r3
 8007968:	b009      	add	sp, #36	; 0x24
 800796a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        byte_offset =  (((ULONG)cluster) * 4);
 800796e:	ea4f 0a86 	mov.w	sl, r6, lsl #2
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007972:	f04f 0c02 	mov.w	ip, #2
 8007976:	2101      	movs	r1, #1
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007978:	fbba fbf9 	udiv	fp, sl, r9
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 800797c:	e88d 1003 	stmia.w	sp, {r0, r1, ip}
 8007980:	445a      	add	r2, fp
 8007982:	4628      	mov	r0, r5
 8007984:	f000 fda8 	bl	80084d8 <_fx_utility_logical_sector_read>
        if (status != FX_SUCCESS)
 8007988:	4603      	mov	r3, r0
 800798a:	2800      	cmp	r0, #0
 800798c:	d19f      	bne.n	80078ce <_fx_utility_FAT_entry_read+0xea>
        FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (ULONG)byte_offset;
 800798e:	68a8      	ldr	r0, [r5, #8]
        byte_offset = (byte_offset % media_ptr -> fx_media_bytes_per_sector);
 8007990:	fb09 a91b 	mls	r9, r9, fp, sl
        entry32 =  _fx_utility_32_unsigned_read(FAT_ptr);
 8007994:	4448      	add	r0, r9
 8007996:	f7ff ff11 	bl	80077bc <_fx_utility_32_unsigned_read>
            entry32 = entry32 & 0x0FFFFFFF;
 800799a:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
        *entry_ptr =  entry32;
 800799e:	f8c8 0000 	str.w	r0, [r8]
 80079a2:	e036      	b.n	8007a12 <_fx_utility_FAT_entry_read+0x22e>
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 80079a4:	f04f 0b01 	mov.w	fp, #1
        byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 80079a8:	eb06 0a46 	add.w	sl, r6, r6, lsl #1
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 80079ac:	2302      	movs	r3, #2
 80079ae:	9000      	str	r0, [sp, #0]
        byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 80079b0:	fa2a fa0b 	lsr.w	sl, sl, fp
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 80079b4:	f8cd b004 	str.w	fp, [sp, #4]
 80079b8:	9302      	str	r3, [sp, #8]
 80079ba:	4628      	mov	r0, r5
 80079bc:	2300      	movs	r3, #0
        FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 80079be:	fbba f9f9 	udiv	r9, sl, r9
 80079c2:	4491      	add	r9, r2
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 80079c4:	464a      	mov	r2, r9
 80079c6:	f000 fd87 	bl	80084d8 <_fx_utility_logical_sector_read>
        if (status != FX_SUCCESS)
 80079ca:	4603      	mov	r3, r0
 80079cc:	2800      	cmp	r0, #0
 80079ce:	f47f af7e 	bne.w	80078ce <_fx_utility_FAT_entry_read+0xea>
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 80079d2:	6c6a      	ldr	r2, [r5, #68]	; 0x44
             media_ptr -> fx_media_bytes_per_sector);
 80079d4:	6aa9      	ldr	r1, [r5, #40]	; 0x28
            ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 80079d6:	eba9 0202 	sub.w	r2, r9, r2
        FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 80079da:	68a8      	ldr	r0, [r5, #8]
 80079dc:	f101 3cff 	add.w	ip, r1, #4294967295
        byte_offset =  byte_offset -
 80079e0:	fb01 a212 	mls	r2, r1, r2, sl
        FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 80079e4:	eb00 0e02 	add.w	lr, r0, r2
 80079e8:	f810 a002 	ldrb.w	sl, [r0, r2]
 80079ec:	eb0e 010b 	add.w	r1, lr, fp
        if (cluster & 1)
 80079f0:	ea16 0e0b 	ands.w	lr, r6, fp
 80079f4:	d02c      	beq.n	8007a50 <_fx_utility_FAT_entry_read+0x26c>
            if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 80079f6:	4562      	cmp	r2, ip
            entry =  (((UINT)*FAT_ptr) & 0xF0) >> 4;
 80079f8:	ea4f 1a1a 	mov.w	sl, sl, lsr #4
            if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 80079fc:	d031      	beq.n	8007a62 <_fx_utility_FAT_entry_read+0x27e>
            entry =  entry | (((UINT)*FAT_ptr) << 4);
 80079fe:	780b      	ldrb	r3, [r1, #0]
 8007a00:	ea4a 1303 	orr.w	r3, sl, r3, lsl #4
        if (entry >= FX_MAX_12BIT_CLUST)
 8007a04:	f5b3 6f7f 	cmp.w	r3, #4080	; 0xff0
            entry =  entry | FX_SIGN_EXTEND;
 8007a08:	bf28      	it	cs
 8007a0a:	f443 4370 	orrcs.w	r3, r3, #61440	; 0xf000
        *entry_ptr =  entry;
 8007a0e:	f8c8 3000 	str.w	r3, [r8]
    *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 8007a12:	f104 0c18 	add.w	ip, r4, #24
    *(cache_entry_ptr + 1) =  *(cache_entry_ptr);
 8007a16:	eb07 0747 	add.w	r7, r7, r7, lsl #1
    *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 8007a1a:	f104 0e24 	add.w	lr, r4, #36	; 0x24
    *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 8007a1e:	340c      	adds	r4, #12
    *(cache_entry_ptr + 1) =  *(cache_entry_ptr);
 8007a20:	eb05 0587 	add.w	r5, r5, r7, lsl #2
    return(FX_SUCCESS);
 8007a24:	2300      	movs	r3, #0
    *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 8007a26:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
    *(cache_entry_ptr + 1) =  *(cache_entry_ptr);
 8007a2a:	f505 67eb 	add.w	r7, r5, #1880	; 0x758
    *(cache_entry_ptr + 3) =  *(cache_entry_ptr + 2);
 8007a2e:	e88e 0007 	stmia.w	lr, {r0, r1, r2}
    *(cache_entry_ptr + 2) =  *(cache_entry_ptr + 1);
 8007a32:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8007a36:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
    *(cache_entry_ptr + 1) =  *(cache_entry_ptr);
 8007a3a:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 8007a3e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    cache_entry_ptr -> fx_fat_cache_entry_cluster =  cluster;
 8007a42:	f8c5 6758 	str.w	r6, [r5, #1880]	; 0x758
    cache_entry_ptr -> fx_fat_cache_entry_value   =  *entry_ptr;
 8007a46:	f8d8 2000 	ldr.w	r2, [r8]
 8007a4a:	f8c5 275c 	str.w	r2, [r5, #1884]	; 0x75c
    return(FX_SUCCESS);
 8007a4e:	e73e      	b.n	80078ce <_fx_utility_FAT_entry_read+0xea>
            if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 8007a50:	4562      	cmp	r2, ip
 8007a52:	d015      	beq.n	8007a80 <_fx_utility_FAT_entry_read+0x29c>
            entry =  entry | ((((UINT)*FAT_ptr) & 0x0F) << 8);
 8007a54:	780b      	ldrb	r3, [r1, #0]
 8007a56:	021b      	lsls	r3, r3, #8
 8007a58:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 8007a5c:	ea43 030a 	orr.w	r3, r3, sl
 8007a60:	e7d0      	b.n	8007a04 <_fx_utility_FAT_entry_read+0x220>
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007a62:	2202      	movs	r2, #2
 8007a64:	e9cd 0b00 	strd	r0, fp, [sp]
 8007a68:	9202      	str	r2, [sp, #8]
 8007a6a:	4628      	mov	r0, r5
 8007a6c:	eb09 020b 	add.w	r2, r9, fp
 8007a70:	f000 fd32 	bl	80084d8 <_fx_utility_logical_sector_read>
                if (status != FX_SUCCESS)
 8007a74:	4603      	mov	r3, r0
 8007a76:	2800      	cmp	r0, #0
 8007a78:	f47f af29 	bne.w	80078ce <_fx_utility_FAT_entry_read+0xea>
                FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer;
 8007a7c:	68a9      	ldr	r1, [r5, #8]
 8007a7e:	e7be      	b.n	80079fe <_fx_utility_FAT_entry_read+0x21a>
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007a80:	2302      	movs	r3, #2
 8007a82:	9000      	str	r0, [sp, #0]
 8007a84:	f109 0201 	add.w	r2, r9, #1
 8007a88:	f8cd b004 	str.w	fp, [sp, #4]
 8007a8c:	9302      	str	r3, [sp, #8]
 8007a8e:	4628      	mov	r0, r5
 8007a90:	4673      	mov	r3, lr
 8007a92:	f000 fd21 	bl	80084d8 <_fx_utility_logical_sector_read>
                if (status != FX_SUCCESS)
 8007a96:	4603      	mov	r3, r0
 8007a98:	2800      	cmp	r0, #0
 8007a9a:	f47f af18 	bne.w	80078ce <_fx_utility_FAT_entry_read+0xea>
                FAT_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer;
 8007a9e:	68a9      	ldr	r1, [r5, #8]
 8007aa0:	e7d8      	b.n	8007a54 <_fx_utility_FAT_entry_read+0x270>
 8007aa2:	bf00      	nop

08007aa4 <_fx_utility_FAT_flush>:
INT    multi_sector_entry;
ULONG  sector;

#ifndef FX_MEDIA_STATISTICS_DISABLE
    /* Increment the number of cache flush requests.  */
    media_ptr -> fx_media_fat_cache_flushes++;
 8007aa4:	f8d0 3190 	ldr.w	r3, [r0, #400]	; 0x190
{
 8007aa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    media_ptr -> fx_media_fat_cache_flushes++;
 8007aac:	3301      	adds	r3, #1
{
 8007aae:	b085      	sub	sp, #20
 8007ab0:	4604      	mov	r4, r0
#endif

    /* Loop through the media's FAT cache and flush out dirty entries.  */
    for (index = 0; index < FX_MAX_FAT_CACHE; index++)
 8007ab2:	2700      	movs	r7, #0
 8007ab4:	4606      	mov	r6, r0
    media_ptr -> fx_media_fat_cache_flushes++;
 8007ab6:	f8c0 3190 	str.w	r3, [r0, #400]	; 0x190
    {

        /* Determine if the entry is dirty.  */
        if ((media_ptr -> fx_media_fat_cache[index].fx_fat_cache_entry_dirty) == 0)
 8007aba:	f8d6 3760 	ldr.w	r3, [r6, #1888]	; 0x760
 8007abe:	2b00      	cmp	r3, #0
 8007ac0:	d064      	beq.n	8007b8c <_fx_utility_FAT_flush+0xe8>

        /* Determine which type of FAT is present.  */
#ifdef FX_ENABLE_EXFAT
        if (media_ptr -> fx_media_FAT_type == FX_FAT12)
#else
        if (media_ptr -> fx_media_12_bit_FAT)
 8007ac2:	6e23      	ldr	r3, [r4, #96]	; 0x60
        cluster =       media_ptr -> fx_media_fat_cache[index].fx_fat_cache_entry_cluster;
 8007ac4:	f8d6 2758 	ldr.w	r2, [r6, #1880]	; 0x758
 8007ac8:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
 8007acc:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8007ace:	68a0      	ldr	r0, [r4, #8]
        if (media_ptr -> fx_media_12_bit_FAT)
 8007ad0:	2b00      	cmp	r3, #0
 8007ad2:	d163      	bne.n	8007b9c <_fx_utility_FAT_flush+0xf8>
            }
        }
#ifdef FX_ENABLE_EXFAT
        else if (media_ptr -> fx_media_FAT_type == FX_FAT16)
#else
        else if (!media_ptr -> fx_media_32_bit_FAT)
 8007ad4:	f8d4 e064 	ldr.w	lr, [r4, #100]	; 0x64
 8007ad8:	f1be 0f00 	cmp.w	lr, #0
 8007adc:	f040 8124 	bne.w	8007d28 <_fx_utility_FAT_flush+0x284>
        {

            /* 16-bit FAT is present.  */

            /* Calculate the byte offset to the cluster entry.  */
            byte_offset =  (((ULONG)cluster) << 1);
 8007ae0:	0055      	lsls	r5, r2, #1
            /* Calculate the FAT sector the requested FAT entry resides in.  */
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
                (ULONG)media_ptr -> fx_media_reserved_sectors;

            /* Read the FAT sector.  */
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007ae2:	9000      	str	r0, [sp, #0]
 8007ae4:	2201      	movs	r2, #1
 8007ae6:	2002      	movs	r0, #2
 8007ae8:	4673      	mov	r3, lr
 8007aea:	9002      	str	r0, [sp, #8]
 8007aec:	4620      	mov	r0, r4
 8007aee:	9201      	str	r2, [sp, #4]
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007af0:	fbb5 f5fc 	udiv	r5, r5, ip
 8007af4:	440d      	add	r5, r1
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007af6:	462a      	mov	r2, r5
 8007af8:	f000 fcee 	bl	80084d8 <_fx_utility_logical_sector_read>
                                                      media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 8007afc:	2800      	cmp	r0, #0
 8007afe:	d14a      	bne.n	8007b96 <_fx_utility_FAT_flush+0xf2>
 8007b00:	68a0      	ldr	r0, [r4, #8]
 8007b02:	46b0      	mov	r8, r6
 8007b04:	46b9      	mov	r9, r7
               within the same FAT sector being written out.  */
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
            {

                /* Determine if the entry is dirty.  */
                if (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty == 0)
 8007b06:	f8d8 3760 	ldr.w	r3, [r8, #1888]	; 0x760
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 8007b0a:	f109 0901 	add.w	r9, r9, #1
                if (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty == 0)
 8007b0e:	b1b3      	cbz	r3, 8007b3e <_fx_utility_FAT_flush+0x9a>

                /* Isolate the cluster.  */
                cluster = (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster);

                /* Calculate the byte offset to the cluster entry.  */
                byte_offset =  (((ULONG)cluster) * 2);
 8007b10:	f8d8 3758 	ldr.w	r3, [r8, #1880]	; 0x758

                /* Pickup the sector.  */
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007b14:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
                byte_offset =  (((ULONG)cluster) * 2);
 8007b18:	005b      	lsls	r3, r3, #1
                    (ULONG)media_ptr -> fx_media_reserved_sectors;
 8007b1a:	6c61      	ldr	r1, [r4, #68]	; 0x44
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007b1c:	fbb3 f2fc 	udiv	r2, r3, ip
 8007b20:	440a      	add	r2, r1

                /* Is it the current FAT sector?  */
                if (sector != FAT_sector)
 8007b22:	4295      	cmp	r5, r2
 8007b24:	d10b      	bne.n	8007b3e <_fx_utility_FAT_flush+0x9a>
                    continue;
                }

                /* Now calculate the byte offset into this FAT sector.  */
                byte_offset =  byte_offset -
                    ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8007b26:	1a6a      	subs	r2, r5, r1

                /* Pickup new value for this FAT entry.  */
                next_cluster =  media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value;

                /* Store the FAT entry.  */
                _fx_utility_16_unsigned_write(FAT_ptr, (UINT)next_cluster);
 8007b28:	f8d8 175c 	ldr.w	r1, [r8, #1884]	; 0x75c
                byte_offset =  byte_offset -
 8007b2c:	fb0c 3312 	mls	r3, ip, r2, r3
                _fx_utility_16_unsigned_write(FAT_ptr, (UINT)next_cluster);
 8007b30:	4418      	add	r0, r3
 8007b32:	f002 fc55 	bl	800a3e0 <_fx_utility_16_unsigned_write>

                /* Clear the dirty flag.  */
                media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty = 0;
 8007b36:	2300      	movs	r3, #0
 8007b38:	68a0      	ldr	r0, [r4, #8]
 8007b3a:	f8c8 3760 	str.w	r3, [r8, #1888]	; 0x760
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 8007b3e:	f1b9 0f10 	cmp.w	r9, #16
 8007b42:	f108 080c 	add.w	r8, r8, #12
 8007b46:	d1de      	bne.n	8007b06 <_fx_utility_FAT_flush+0x62>
                /* Clear the dirty flag.  */
                media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty = 0;
            }

            /* Write the last written FAT sector out.  */
            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 8007b48:	2302      	movs	r3, #2
 8007b4a:	2101      	movs	r1, #1
 8007b4c:	9000      	str	r0, [sp, #0]
 8007b4e:	462a      	mov	r2, r5
 8007b50:	9302      	str	r3, [sp, #8]
 8007b52:	4620      	mov	r0, r4
 8007b54:	2300      	movs	r3, #0
 8007b56:	9101      	str	r1, [sp, #4]
 8007b58:	f000 fe6c 	bl	8008834 <_fx_utility_logical_sector_write>
                                                       media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 8007b5c:	b9d8      	cbnz	r0, 8007b96 <_fx_utility_FAT_flush+0xf2>
            {
#endif /* FX_ENABLE_EXFAT */

                /* Mark the FAT sector update bit map to indicate this sector has been
                   written.  */
                if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 8007b5e:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8007b60:	f3c2 0309 	ubfx	r3, r2, #0, #10
 8007b64:	f3c2 2287 	ubfx	r2, r2, #10, #8
 8007b68:	b10b      	cbz	r3, 8007b6e <_fx_utility_FAT_flush+0xca>
                {
                    sectors_per_bit =  (UCHAR)(media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3));
                }
                else
                {
                    sectors_per_bit =  (UCHAR)((media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3)) + 1);
 8007b6a:	3201      	adds	r2, #1
 8007b6c:	b2d2      	uxtb	r2, r2
                }
                ind = ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) >> 3;
 8007b6e:	6c61      	ldr	r1, [r4, #68]	; 0x44
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
                    (UCHAR)((INT)media_ptr -> fx_media_fat_secondary_update_map[ind]
                    | (1 << ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) & 7));
 8007b70:	2301      	movs	r3, #1
                ind = ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) >> 3;
 8007b72:	1a6d      	subs	r5, r5, r1
 8007b74:	fbb5 f5f2 	udiv	r5, r5, r2
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
 8007b78:	eb04 02d5 	add.w	r2, r4, r5, lsr #3
                    | (1 << ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) & 7));
 8007b7c:	40ab      	lsls	r3, r5
 8007b7e:	f892 1818 	ldrb.w	r1, [r2, #2072]	; 0x818
 8007b82:	f003 0307 	and.w	r3, r3, #7
 8007b86:	430b      	orrs	r3, r1
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
 8007b88:	f882 3818 	strb.w	r3, [r2, #2072]	; 0x818
    for (index = 0; index < FX_MAX_FAT_CACHE; index++)
 8007b8c:	3701      	adds	r7, #1
 8007b8e:	360c      	adds	r6, #12
 8007b90:	2f10      	cmp	r7, #16
 8007b92:	d192      	bne.n	8007aba <_fx_utility_FAT_flush+0x16>
        media_ptr -> fx_media_fault_tolerant_cached_FAT_sector = 0;
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Return successful status.  */
    return(FX_SUCCESS);
 8007b94:	2000      	movs	r0, #0
}
 8007b96:	b005      	add	sp, #20
 8007b98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 8007b9c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
            multi_sector_entry = -1;
 8007ba0:	f04f 38ff 	mov.w	r8, #4294967295
            byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 8007ba4:	0855      	lsrs	r5, r2, #1
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007ba6:	fbb5 f5fc 	udiv	r5, r5, ip
 8007baa:	440d      	add	r5, r1
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007bac:	2301      	movs	r3, #1
 8007bae:	2202      	movs	r2, #2
 8007bb0:	9000      	str	r0, [sp, #0]
 8007bb2:	4620      	mov	r0, r4
 8007bb4:	9202      	str	r2, [sp, #8]
 8007bb6:	462a      	mov	r2, r5
 8007bb8:	9301      	str	r3, [sp, #4]
 8007bba:	2300      	movs	r3, #0
 8007bbc:	f000 fc8c 	bl	80084d8 <_fx_utility_logical_sector_read>
                if (status != FX_SUCCESS)
 8007bc0:	2800      	cmp	r0, #0
 8007bc2:	d1e8      	bne.n	8007b96 <_fx_utility_FAT_flush+0xf2>
                if (multi_sector_entry != -1)
 8007bc4:	f1b8 3fff 	cmp.w	r8, #4294967295
 8007bc8:	f8d4 e008 	ldr.w	lr, [r4, #8]
 8007bcc:	d00f      	beq.n	8007bee <_fx_utility_FAT_flush+0x14a>
                    next_cluster = media_ptr -> fx_media_fat_cache[multi_sector_entry].fx_fat_cache_entry_value;
 8007bce:	eb08 0848 	add.w	r8, r8, r8, lsl #1
 8007bd2:	eb04 0888 	add.w	r8, r4, r8, lsl #2
                    if (cluster & 1)
 8007bd6:	f8d8 2758 	ldr.w	r2, [r8, #1880]	; 0x758
                    next_cluster = media_ptr -> fx_media_fat_cache[multi_sector_entry].fx_fat_cache_entry_value;
 8007bda:	f8d8 375c 	ldr.w	r3, [r8, #1884]	; 0x75c
                    if (cluster & 1)
 8007bde:	07d2      	lsls	r2, r2, #31
 8007be0:	f140 808a 	bpl.w	8007cf8 <_fx_utility_FAT_flush+0x254>
                        *FAT_ptr =  (UCHAR)((next_cluster >> 4) & 0xFF);
 8007be4:	091b      	lsrs	r3, r3, #4
 8007be6:	f88e 3000 	strb.w	r3, [lr]
 8007bea:	f8d4 e008 	ldr.w	lr, [r4, #8]
            multi_sector_entry = -1;
 8007bee:	4631      	mov	r1, r6
 8007bf0:	4638      	mov	r0, r7
 8007bf2:	f04f 38ff 	mov.w	r8, #4294967295
                    if ((media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty) == 0)
 8007bf6:	f8d1 3760 	ldr.w	r3, [r1, #1888]	; 0x760
 8007bfa:	b38b      	cbz	r3, 8007c60 <_fx_utility_FAT_flush+0x1bc>
                    cluster = (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_cluster);
 8007bfc:	f8d1 2758 	ldr.w	r2, [r1, #1880]	; 0x758
                    sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007c00:	f8d4 a028 	ldr.w	sl, [r4, #40]	; 0x28
                    byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 8007c04:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
                        (ULONG)media_ptr -> fx_media_reserved_sectors;
 8007c08:	6c63      	ldr	r3, [r4, #68]	; 0x44
                    byte_offset =  (((ULONG)cluster << 1) + cluster) >> 1;
 8007c0a:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
                    sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007c0e:	fbbc f9fa 	udiv	r9, ip, sl
 8007c12:	4499      	add	r9, r3
                    if (sector != FAT_sector)
 8007c14:	454d      	cmp	r5, r9
 8007c16:	d123      	bne.n	8007c60 <_fx_utility_FAT_flush+0x1bc>
                        ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8007c18:	1aeb      	subs	r3, r5, r3
                    if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 8007c1a:	f10a 3bff 	add.w	fp, sl, #4294967295
                    next_cluster =  media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_value;
 8007c1e:	f8d1 975c 	ldr.w	r9, [r1, #1884]	; 0x75c
 8007c22:	f002 0201 	and.w	r2, r2, #1
                    byte_offset =  byte_offset -
 8007c26:	fb0a c313 	mls	r3, sl, r3, ip
 8007c2a:	fa5f fc89 	uxtb.w	ip, r9
 8007c2e:	449e      	add	lr, r3
                    if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 8007c30:	459b      	cmp	fp, r3
                    media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty = 0;
 8007c32:	f04f 0300 	mov.w	r3, #0
 8007c36:	f8c1 3760 	str.w	r3, [r1, #1888]	; 0x760
                    if (byte_offset == (ULONG)(media_ptr -> fx_media_bytes_per_sector - 1))
 8007c3a:	d056      	beq.n	8007cea <_fx_utility_FAT_flush+0x246>
                    if (cluster & 1)
 8007c3c:	2a00      	cmp	r2, #0
 8007c3e:	d043      	beq.n	8007cc8 <_fx_utility_FAT_flush+0x224>
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster << 4) & 0xF0));
 8007c40:	f89e 3000 	ldrb.w	r3, [lr]
                        if ((multi_sector_entry) == (INT)i)
 8007c44:	4580      	cmp	r8, r0
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster << 4) & 0xF0));
 8007c46:	f003 030f 	and.w	r3, r3, #15
 8007c4a:	ea43 130c 	orr.w	r3, r3, ip, lsl #4
 8007c4e:	f88e 3000 	strb.w	r3, [lr]
                        if ((multi_sector_entry) == (INT)i)
 8007c52:	d047      	beq.n	8007ce4 <_fx_utility_FAT_flush+0x240>
                        *FAT_ptr =  (UCHAR)((next_cluster >> 4) & 0xFF);
 8007c54:	ea4f 1919 	mov.w	r9, r9, lsr #4
 8007c58:	f88e 9001 	strb.w	r9, [lr, #1]
 8007c5c:	f8d4 e008 	ldr.w	lr, [r4, #8]
                for (i = index; i < FX_MAX_FAT_CACHE; i++)
 8007c60:	3001      	adds	r0, #1
 8007c62:	310c      	adds	r1, #12
 8007c64:	2810      	cmp	r0, #16
 8007c66:	d1c6      	bne.n	8007bf6 <_fx_utility_FAT_flush+0x152>
                status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) FAT_sector,
 8007c68:	2301      	movs	r3, #1
 8007c6a:	2202      	movs	r2, #2
 8007c6c:	f8cd e000 	str.w	lr, [sp]
 8007c70:	4620      	mov	r0, r4
 8007c72:	9202      	str	r2, [sp, #8]
 8007c74:	462a      	mov	r2, r5
 8007c76:	9301      	str	r3, [sp, #4]
 8007c78:	2300      	movs	r3, #0
 8007c7a:	f000 fddb 	bl	8008834 <_fx_utility_logical_sector_write>
                if (status != FX_SUCCESS)
 8007c7e:	2800      	cmp	r0, #0
 8007c80:	d189      	bne.n	8007b96 <_fx_utility_FAT_flush+0xf2>
                if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 8007c82:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007c84:	f3c3 0209 	ubfx	r2, r3, #0, #10
 8007c88:	f3c3 2387 	ubfx	r3, r3, #10, #8
 8007c8c:	b10a      	cbz	r2, 8007c92 <_fx_utility_FAT_flush+0x1ee>
                    sectors_per_bit =  (UCHAR)((UINT)media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3) + 1);
 8007c8e:	3301      	adds	r3, #1
 8007c90:	b2db      	uxtb	r3, r3
                if (sectors_per_bit == 0)
 8007c92:	2b00      	cmp	r3, #0
 8007c94:	d07d      	beq.n	8007d92 <_fx_utility_FAT_flush+0x2ee>
                ind = ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) >> 3;
 8007c96:	6c61      	ldr	r1, [r4, #68]	; 0x44
                    | (1 << ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) & 7));
 8007c98:	2201      	movs	r2, #1
                if (multi_sector_entry != -1)
 8007c9a:	f1b8 3fff 	cmp.w	r8, #4294967295
                ind = ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) >> 3;
 8007c9e:	eba5 0101 	sub.w	r1, r5, r1
 8007ca2:	fbb1 f3f3 	udiv	r3, r1, r3
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
 8007ca6:	eb04 01d3 	add.w	r1, r4, r3, lsr #3
                    | (1 << ((FAT_sector - media_ptr -> fx_media_reserved_sectors) / sectors_per_bit) & 7));
 8007caa:	fa02 f303 	lsl.w	r3, r2, r3
 8007cae:	f891 2818 	ldrb.w	r2, [r1, #2072]	; 0x818
 8007cb2:	f003 0307 	and.w	r3, r3, #7
 8007cb6:	ea43 0302 	orr.w	r3, r3, r2
                media_ptr -> fx_media_fat_secondary_update_map[ind] = 
 8007cba:	f881 3818 	strb.w	r3, [r1, #2072]	; 0x818
                if (multi_sector_entry != -1)
 8007cbe:	f43f af65 	beq.w	8007b8c <_fx_utility_FAT_flush+0xe8>
                    FAT_sector++;
 8007cc2:	3501      	adds	r5, #1
 8007cc4:	68a0      	ldr	r0, [r4, #8]
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007cc6:	e771      	b.n	8007bac <_fx_utility_FAT_flush+0x108>
                        if ((multi_sector_entry) == (INT)i)
 8007cc8:	4580      	cmp	r8, r0
                        *FAT_ptr =  (UCHAR)(next_cluster & 0xFF);
 8007cca:	f88e c000 	strb.w	ip, [lr]
                        if ((multi_sector_entry) == (INT)i)
 8007cce:	d00f      	beq.n	8007cf0 <_fx_utility_FAT_flush+0x24c>
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster >> 8) & 0xF));
 8007cd0:	f89e 3001 	ldrb.w	r3, [lr, #1]
 8007cd4:	f3c9 2903 	ubfx	r9, r9, #8, #4
 8007cd8:	f023 030f 	bic.w	r3, r3, #15
 8007cdc:	ea49 0903 	orr.w	r9, r9, r3
 8007ce0:	f88e 9001 	strb.w	r9, [lr, #1]
 8007ce4:	f8d4 e008 	ldr.w	lr, [r4, #8]
 8007ce8:	e7ba      	b.n	8007c60 <_fx_utility_FAT_flush+0x1bc>
                    if (cluster & 1)
 8007cea:	b98a      	cbnz	r2, 8007d10 <_fx_utility_FAT_flush+0x26c>
                        *FAT_ptr =  (UCHAR)(next_cluster & 0xFF);
 8007cec:	f88e c000 	strb.w	ip, [lr]
 8007cf0:	f8d4 e008 	ldr.w	lr, [r4, #8]
                        if ((multi_sector_entry) == (INT)i)
 8007cf4:	4680      	mov	r8, r0
 8007cf6:	e7b3      	b.n	8007c60 <_fx_utility_FAT_flush+0x1bc>
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster >> 8) & 0xF));
 8007cf8:	f89e 2000 	ldrb.w	r2, [lr]
 8007cfc:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8007d00:	f022 020f 	bic.w	r2, r2, #15
 8007d04:	4313      	orrs	r3, r2
 8007d06:	f88e 3000 	strb.w	r3, [lr]
 8007d0a:	f8d4 e008 	ldr.w	lr, [r4, #8]
 8007d0e:	e76e      	b.n	8007bee <_fx_utility_FAT_flush+0x14a>
                        *FAT_ptr =  (UCHAR)(temp | ((next_cluster << 4) & 0xF0));
 8007d10:	f89e 3000 	ldrb.w	r3, [lr]
 8007d14:	4680      	mov	r8, r0
 8007d16:	f003 030f 	and.w	r3, r3, #15
 8007d1a:	ea43 130c 	orr.w	r3, r3, ip, lsl #4
 8007d1e:	f88e 3000 	strb.w	r3, [lr]
 8007d22:	f8d4 e008 	ldr.w	lr, [r4, #8]
 8007d26:	e79b      	b.n	8007c60 <_fx_utility_FAT_flush+0x1bc>
            byte_offset =  (((ULONG)cluster) * 4);
 8007d28:	0092      	lsls	r2, r2, #2
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007d2a:	2501      	movs	r5, #1
 8007d2c:	9000      	str	r0, [sp, #0]
 8007d2e:	2002      	movs	r0, #2
 8007d30:	9501      	str	r5, [sp, #4]
 8007d32:	9002      	str	r0, [sp, #8]
 8007d34:	4620      	mov	r0, r4
            FAT_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007d36:	fbb2 f5fc 	udiv	r5, r2, ip
 8007d3a:	440d      	add	r5, r1
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007d3c:	462a      	mov	r2, r5
 8007d3e:	f000 fbcb 	bl	80084d8 <_fx_utility_logical_sector_read>
            if (status != FX_SUCCESS)
 8007d42:	2800      	cmp	r0, #0
 8007d44:	f47f af27 	bne.w	8007b96 <_fx_utility_FAT_flush+0xf2>
 8007d48:	68a0      	ldr	r0, [r4, #8]
 8007d4a:	46b0      	mov	r8, r6
 8007d4c:	46b9      	mov	r9, r7
                if (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty == 0)
 8007d4e:	f8d8 3760 	ldr.w	r3, [r8, #1888]	; 0x760
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 8007d52:	f109 0901 	add.w	r9, r9, #1
                if (media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty == 0)
 8007d56:	b1b3      	cbz	r3, 8007d86 <_fx_utility_FAT_flush+0x2e2>
                byte_offset =  (((ULONG)cluster) * 4);
 8007d58:	f8d8 3758 	ldr.w	r3, [r8, #1880]	; 0x758
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007d5c:	f8d4 c028 	ldr.w	ip, [r4, #40]	; 0x28
                byte_offset =  (((ULONG)cluster) * 4);
 8007d60:	009b      	lsls	r3, r3, #2
                    (ULONG)media_ptr -> fx_media_reserved_sectors;
 8007d62:	6c61      	ldr	r1, [r4, #68]	; 0x44
                sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8007d64:	fbb3 f2fc 	udiv	r2, r3, ip
 8007d68:	440a      	add	r2, r1
                if (sector != FAT_sector)
 8007d6a:	4295      	cmp	r5, r2
 8007d6c:	d10b      	bne.n	8007d86 <_fx_utility_FAT_flush+0x2e2>
                    ((FAT_sector - (ULONG)media_ptr -> fx_media_reserved_sectors) *
 8007d6e:	1a6a      	subs	r2, r5, r1
                _fx_utility_32_unsigned_write(FAT_ptr, next_cluster);
 8007d70:	f8d8 175c 	ldr.w	r1, [r8, #1884]	; 0x75c
                byte_offset =  byte_offset -
 8007d74:	fb0c 3312 	mls	r3, ip, r2, r3
                _fx_utility_32_unsigned_write(FAT_ptr, next_cluster);
 8007d78:	4418      	add	r0, r3
 8007d7a:	f7ff fd2b 	bl	80077d4 <_fx_utility_32_unsigned_write>
                media_ptr -> fx_media_fat_cache[i].fx_fat_cache_entry_dirty = 0;
 8007d7e:	2300      	movs	r3, #0
 8007d80:	68a0      	ldr	r0, [r4, #8]
 8007d82:	f8c8 3760 	str.w	r3, [r8, #1888]	; 0x760
            for (i = index; i < FX_MAX_FAT_CACHE; i++)
 8007d86:	f1b9 0f10 	cmp.w	r9, #16
 8007d8a:	f108 080c 	add.w	r8, r8, #12
 8007d8e:	d1de      	bne.n	8007d4e <_fx_utility_FAT_flush+0x2aa>
 8007d90:	e6da      	b.n	8007b48 <_fx_utility_FAT_flush+0xa4>
                    return(FX_MEDIA_INVALID);
 8007d92:	2002      	movs	r0, #2
}
 8007d94:	b005      	add	sp, #20
 8007d96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007d9a:	bf00      	nop

08007d9c <_fx_utility_FAT_map_flush>:
       or more primary FAT sectors. Because of this, it is possible some FAT sectors that
       were not changed may get flushed out to the secondary FAT.  However, this method
       provides very nice performance benefits during normal operation and is much more
       reasonable than performing a total copy of the primary FAT to each secondary FAT
       on media flush and media close.  */
    if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 8007d9c:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
 8007d9e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 8007da2:	f3c3 0209 	ubfx	r2, r3, #0, #10
{
 8007da6:	b08b      	sub	sp, #44	; 0x2c
 8007da8:	f3c3 2387 	ubfx	r3, r3, #10, #8
 8007dac:	4682      	mov	sl, r0
 8007dae:	9308      	str	r3, [sp, #32]
    if (media_ptr -> fx_media_sectors_per_FAT % (FX_FAT_MAP_SIZE << 3) == 0)
 8007db0:	b112      	cbz	r2, 8007db8 <_fx_utility_FAT_map_flush+0x1c>
    {
        sectors_per_bit =  (UCHAR)(media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3));
    }
    else
    {
        sectors_per_bit =  (UCHAR)(media_ptr -> fx_media_sectors_per_FAT / (FX_FAT_MAP_SIZE << 3) + 1);
 8007db2:	3301      	adds	r3, #1
 8007db4:	b2db      	uxtb	r3, r3
 8007db6:	9308      	str	r3, [sp, #32]
{
 8007db8:	2300      	movs	r3, #0
        /* Loop to mirror primary FAT sectors to secondary FAT(s).  */
        for (; FAT_sector < last_sector; FAT_sector++)
        {

            /* Read the FAT sector.  */
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007dba:	f04f 0902 	mov.w	r9, #2
 8007dbe:	f04f 0801 	mov.w	r8, #1
    for (i = 0; i < FX_FAT_MAP_SIZE << 3; i++)
 8007dc2:	469b      	mov	fp, r3
{
 8007dc4:	9307      	str	r3, [sp, #28]
        if ((media_ptr -> fx_media_fat_secondary_update_map[i >> 3] & (1 << (i & 7))) == 0)
 8007dc6:	eb0a 02db 	add.w	r2, sl, fp, lsr #3
 8007dca:	f00b 0307 	and.w	r3, fp, #7
 8007dce:	f892 2818 	ldrb.w	r2, [r2, #2072]	; 0x818
 8007dd2:	fa42 f303 	asr.w	r3, r2, r3
 8007dd6:	07db      	lsls	r3, r3, #31
 8007dd8:	d548      	bpl.n	8007e6c <_fx_utility_FAT_map_flush+0xd0>
        FAT_sector =    i * sectors_per_bit + media_ptr -> fx_media_reserved_sectors;
 8007dda:	f8da 3044 	ldr.w	r3, [sl, #68]	; 0x44
        if (last_sector > (media_ptr -> fx_media_sectors_per_FAT + media_ptr -> fx_media_reserved_sectors))
 8007dde:	f8da 2058 	ldr.w	r2, [sl, #88]	; 0x58
        FAT_sector =    i * sectors_per_bit + media_ptr -> fx_media_reserved_sectors;
 8007de2:	9907      	ldr	r1, [sp, #28]
        if (last_sector > (media_ptr -> fx_media_sectors_per_FAT + media_ptr -> fx_media_reserved_sectors))
 8007de4:	441a      	add	r2, r3
        FAT_sector =    i * sectors_per_bit + media_ptr -> fx_media_reserved_sectors;
 8007de6:	185e      	adds	r6, r3, r1
        last_sector =   FAT_sector + sectors_per_bit;
 8007de8:	9b08      	ldr	r3, [sp, #32]
 8007dea:	18f3      	adds	r3, r6, r3
 8007dec:	429a      	cmp	r2, r3
 8007dee:	bf28      	it	cs
 8007df0:	461a      	movcs	r2, r3
        for (; FAT_sector < last_sector; FAT_sector++)
 8007df2:	4296      	cmp	r6, r2
 8007df4:	9209      	str	r2, [sp, #36]	; 0x24
 8007df6:	d239      	bcs.n	8007e6c <_fx_utility_FAT_map_flush+0xd0>
 8007df8:	2700      	movs	r7, #0
            status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) FAT_sector,
 8007dfa:	f8da 1008 	ldr.w	r1, [sl, #8]
 8007dfe:	4632      	mov	r2, r6
 8007e00:	463b      	mov	r3, r7
 8007e02:	f8cd 9008 	str.w	r9, [sp, #8]
 8007e06:	4650      	mov	r0, sl
 8007e08:	e9cd 1800 	strd	r1, r8, [sp]
 8007e0c:	f000 fb64 	bl	80084d8 <_fx_utility_logical_sector_read>
                                                      media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);

            /* Determine if an error occurred.  */
            if (status != FX_SUCCESS)
 8007e10:	bb18      	cbnz	r0, 8007e5a <_fx_utility_FAT_map_flush+0xbe>
                /* Return the error status.  */
                return(status);
            }

            /* Pickup how many secondary FATs there are.  */
            FATs =  media_ptr -> fx_media_number_of_FATs - 1;
 8007e12:	f8da 405c 	ldr.w	r4, [sl, #92]	; 0x5c

            /* Loop to update additional FAT entries.  */
            while (FATs)
 8007e16:	3c01      	subs	r4, #1
 8007e18:	d022      	beq.n	8007e60 <_fx_utility_FAT_map_flush+0xc4>
 8007e1a:	2500      	movs	r5, #0
 8007e1c:	e000      	b.n	8007e20 <_fx_utility_FAT_map_flush+0x84>
 8007e1e:	b1fc      	cbz	r4, 8007e60 <_fx_utility_FAT_map_flush+0xc4>
            {

                /* Mirror main FAT sector write into the additional FATs.  */
                status =  _fx_utility_logical_sector_write(media_ptr,
                                                           ((ULONG64) FAT_sector) + ((ULONG64)FATs * (ULONG64)(media_ptr -> fx_media_sectors_per_FAT)),
 8007e20:	f8da 1058 	ldr.w	r1, [sl, #88]	; 0x58
                status =  _fx_utility_logical_sector_write(media_ptr,
 8007e24:	4650      	mov	r0, sl
 8007e26:	f8cd 9008 	str.w	r9, [sp, #8]
                                                           ((ULONG64) FAT_sector) + ((ULONG64)FATs * (ULONG64)(media_ptr -> fx_media_sectors_per_FAT)),
 8007e2a:	fba1 2304 	umull	r2, r3, r1, r4
 8007e2e:	f114 34ff 	adds.w	r4, r4, #4294967295
 8007e32:	e9cd 2304 	strd	r2, r3, [sp, #16]
                status =  _fx_utility_logical_sector_write(media_ptr,
 8007e36:	f8da 3008 	ldr.w	r3, [sl, #8]
 8007e3a:	e9cd 3800 	strd	r3, r8, [sp]
                                                           ((ULONG64) FAT_sector) + ((ULONG64)FATs * (ULONG64)(media_ptr -> fx_media_sectors_per_FAT)),
 8007e3e:	9b05      	ldr	r3, [sp, #20]
 8007e40:	fb01 3305 	mla	r3, r1, r5, r3
 8007e44:	f145 35ff 	adc.w	r5, r5, #4294967295
 8007e48:	9305      	str	r3, [sp, #20]
                status =  _fx_utility_logical_sector_write(media_ptr,
 8007e4a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8007e4e:	1992      	adds	r2, r2, r6
 8007e50:	417b      	adcs	r3, r7
 8007e52:	f000 fcef 	bl	8008834 <_fx_utility_logical_sector_write>
                                                           media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_FAT_SECTOR);

                /* Determine if an error occurred.  */
                if (status != FX_SUCCESS)
 8007e56:	2800      	cmp	r0, #0
 8007e58:	d0e1      	beq.n	8007e1e <_fx_utility_FAT_map_flush+0x82>
        media_ptr -> fx_media_fat_secondary_update_map[i] =  0;
    }

    /* Return a successful completion.  */
    return(FX_SUCCESS);
}
 8007e5a:	b00b      	add	sp, #44	; 0x2c
 8007e5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007e60:	3601      	adds	r6, #1
        for (; FAT_sector < last_sector; FAT_sector++)
 8007e62:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007e64:	f147 0700 	adc.w	r7, r7, #0
 8007e68:	42b3      	cmp	r3, r6
 8007e6a:	d8c6      	bhi.n	8007dfa <_fx_utility_FAT_map_flush+0x5e>
 8007e6c:	9b07      	ldr	r3, [sp, #28]
    for (i = 0; i < FX_FAT_MAP_SIZE << 3; i++)
 8007e6e:	f10b 0b01 	add.w	fp, fp, #1
 8007e72:	9a08      	ldr	r2, [sp, #32]
 8007e74:	f5bb 6f80 	cmp.w	fp, #1024	; 0x400
 8007e78:	4413      	add	r3, r2
 8007e7a:	9307      	str	r3, [sp, #28]
 8007e7c:	d1a3      	bne.n	8007dc6 <_fx_utility_FAT_map_flush+0x2a>
 8007e7e:	f60a 0018 	addw	r0, sl, #2072	; 0x818
 8007e82:	2280      	movs	r2, #128	; 0x80
 8007e84:	2100      	movs	r1, #0
 8007e86:	f005 ff2a 	bl	800dcde <memset>
    return(FX_SUCCESS);
 8007e8a:	2000      	movs	r0, #0
 8007e8c:	e7e5      	b.n	8007e5a <_fx_utility_FAT_map_flush+0xbe>
 8007e8e:	bf00      	nop

08007e90 <_fx_utility_logical_sector_flush>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_logical_sector_flush(FX_MEDIA *media_ptr, ULONG64 starting_sector, ULONG64 sectors, UINT invalidate)
{
 8007e90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007e94:	b08b      	sub	sp, #44	; 0x2c
 8007e96:	461e      	mov	r6, r3
 8007e98:	4615      	mov	r5, r2
 8007e9a:	4681      	mov	r9, r0
 8007e9c:	2000      	movs	r0, #0
 8007e9e:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58

    /* Calculate the ending sector.  */
    ending_sector =  starting_sector + sectors - 1;

    /* Pickup the number of dirty sectors currently in the cache.  */
    remaining_dirty =  media_ptr -> fx_media_sector_cache_dirty_count;
 8007ea2:	f8d9 a024 	ldr.w	sl, [r9, #36]	; 0x24
 8007ea6:	4601      	mov	r1, r0
 8007ea8:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
{
 8007eac:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8007eb0:	f113 33ff 	adds.w	r3, r3, #4294967295
 8007eb4:	f144 34ff 	adc.w	r4, r4, #4294967295
 8007eb8:	18ef      	adds	r7, r5, r3

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_MEDIA_FLUSH, media_ptr, media_ptr -> fx_media_sector_cache_dirty_count, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Determine what type of cache configuration we have.  */
    if (media_ptr -> fx_media_sector_cache_hashed == FX_FALSE)
 8007eba:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8007ebe:	eb56 0804 	adcs.w	r8, r6, r4
 8007ec2:	bf28      	it	cs
 8007ec4:	2001      	movcs	r0, #1
 8007ec6:	4602      	mov	r2, r0
 8007ec8:	f8d9 0014 	ldr.w	r0, [r9, #20]
 8007ecc:	e9cd 7804 	strd	r7, r8, [sp, #16]
 8007ed0:	9007      	str	r0, [sp, #28]
 8007ed2:	2b00      	cmp	r3, #0
 8007ed4:	f040 8097 	bne.w	8008006 <_fx_utility_logical_sector_flush+0x176>
        /* Linear cache present, simply walk through the search list until
           an unused cache entry is present.  */

        /* Flush and invalidate the internal logical sector cache.  */
        cache_size =            media_ptr -> fx_media_sector_cache_size;
        cache_entry =           media_ptr -> fx_media_sector_cache_list_ptr;
 8007ed8:	f8d9 401c 	ldr.w	r4, [r9, #28]

        /* Look at the cache entries that have been written to.  */
        while ((cache_size--) && (cache_entry -> fx_cached_sector))
 8007edc:	1e45      	subs	r5, r0, #1
 8007ede:	2800      	cmp	r0, #0
 8007ee0:	f000 808d 	beq.w	8007ffe <_fx_utility_logical_sector_flush+0x16e>
 8007ee4:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8007ee8:	ea52 0103 	orrs.w	r1, r2, r3
 8007eec:	f000 8087 	beq.w	8007ffe <_fx_utility_logical_sector_flush+0x16e>
                /* Yes, nothing left to do.  */
                break;
            }

            /* Determine if there are any more sectors to process.  */
            if (sectors == 0)
 8007ef0:	ea5a 010b 	orrs.w	r1, sl, fp
 8007ef4:	f000 8083 	beq.w	8007ffe <_fx_utility_logical_sector_flush+0x16e>
 8007ef8:	e9dd 1014 	ldrd	r1, r0, [sp, #80]	; 0x50
 8007efc:	4301      	orrs	r1, r0
 8007efe:	bf0c      	ite	eq
 8007f00:	2601      	moveq	r6, #1
 8007f02:	2600      	movne	r6, #0
 8007f04:	2e00      	cmp	r6, #0
 8007f06:	d17a      	bne.n	8007ffe <_fx_utility_logical_sector_flush+0x16e>
                /* Determine if the invalidate option is specified.  */
                if (invalidate)
                {

                    /* Invalidate the cache entry.  */
                    cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 8007f08:	9600      	str	r6, [sp, #0]
 8007f0a:	4649      	mov	r1, r9
 8007f0c:	4616      	mov	r6, r2
 8007f0e:	461f      	mov	r7, r3
 8007f10:	e9dd 8914 	ldrd	r8, r9, [sp, #80]	; 0x50
 8007f14:	e00f      	b.n	8007f36 <_fx_utility_logical_sector_flush+0xa6>
        while ((cache_size--) && (cache_entry -> fx_cached_sector))
 8007f16:	3d01      	subs	r5, #1
                /* Decrement the number of sectors in the range that have been processed.  */
                sectors--;
            }

            /* Move to the next entry in the sector cache.  */
            cache_entry =  cache_entry -> fx_cached_sector_next_used;
 8007f18:	6964      	ldr	r4, [r4, #20]
        while ((cache_size--) && (cache_entry -> fx_cached_sector))
 8007f1a:	1c6e      	adds	r6, r5, #1
 8007f1c:	d06f      	beq.n	8007ffe <_fx_utility_logical_sector_flush+0x16e>
 8007f1e:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8007f22:	461f      	mov	r7, r3
 8007f24:	4313      	orrs	r3, r2
 8007f26:	4616      	mov	r6, r2
 8007f28:	d069      	beq.n	8007ffe <_fx_utility_logical_sector_flush+0x16e>
            if (sectors == 0)
 8007f2a:	ea5a 030b 	orrs.w	r3, sl, fp
 8007f2e:	d066      	beq.n	8007ffe <_fx_utility_logical_sector_flush+0x16e>
 8007f30:	ea58 0309 	orrs.w	r3, r8, r9
 8007f34:	d063      	beq.n	8007ffe <_fx_utility_logical_sector_flush+0x16e>
            if ((cache_entry -> fx_cached_sector_valid) &&
 8007f36:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8007f3a:	429f      	cmp	r7, r3
 8007f3c:	bf08      	it	eq
 8007f3e:	4296      	cmpeq	r6, r2
                (cache_entry -> fx_cached_sector >= starting_sector) &&
 8007f40:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
            if ((cache_entry -> fx_cached_sector_valid) &&
 8007f44:	bf2c      	ite	cs
 8007f46:	2001      	movcs	r0, #1
 8007f48:	2000      	movcc	r0, #0
                (cache_entry -> fx_cached_sector >= starting_sector) &&
 8007f4a:	42bb      	cmp	r3, r7
 8007f4c:	f000 0001 	and.w	r0, r0, #1
 8007f50:	bf08      	it	eq
 8007f52:	42b2      	cmpeq	r2, r6
 8007f54:	bf38      	it	cc
 8007f56:	2000      	movcc	r0, #0
 8007f58:	2800      	cmp	r0, #0
 8007f5a:	d0dc      	beq.n	8007f16 <_fx_utility_logical_sector_flush+0x86>
            if ((cache_entry -> fx_cached_sector_valid) &&
 8007f5c:	7c60      	ldrb	r0, [r4, #17]
                (cache_entry -> fx_cached_sector >= starting_sector) &&
 8007f5e:	2800      	cmp	r0, #0
 8007f60:	d0d9      	beq.n	8007f16 <_fx_utility_logical_sector_flush+0x86>
                if (cache_entry -> fx_cached_sector_buffer_dirty)
 8007f62:	7c20      	ldrb	r0, [r4, #16]
 8007f64:	b370      	cbz	r0, 8007fc4 <_fx_utility_logical_sector_flush+0x134>
                    if (media_ptr -> fx_media_driver_write_protect == FX_FALSE)
 8007f66:	f8d1 00a8 	ldr.w	r0, [r1, #168]	; 0xa8
 8007f6a:	bb58      	cbnz	r0, 8007fc4 <_fx_utility_logical_sector_flush+0x134>
                        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 8007f6c:	2201      	movs	r2, #1
                        media_ptr -> fx_media_driver_write_requests++;
 8007f6e:	f8d1 31b0 	ldr.w	r3, [r1, #432]	; 0x1b0
                        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8007f72:	2090      	movs	r0, #144	; 0x90
                        media_ptr -> fx_media_driver_write_requests++;
 8007f74:	4413      	add	r3, r2
                        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 8007f76:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
                        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8007f7a:	f8c1 008c 	str.w	r0, [r1, #140]	; 0x8c
                        media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8007f7e:	6820      	ldr	r0, [r4, #0]
                        media_ptr -> fx_media_driver_write_requests++;
 8007f80:	f8c1 31b0 	str.w	r3, [r1, #432]	; 0x1b0
                        media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8007f84:	f8c1 0090 	str.w	r0, [r1, #144]	; 0x90
                        media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 8007f88:	f8c1 6094 	str.w	r6, [r1, #148]	; 0x94
                        media_ptr -> fx_media_driver_sectors =          1;
 8007f8c:	f8c1 2098 	str.w	r2, [r1, #152]	; 0x98
                        media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 8007f90:	7ca3      	ldrb	r3, [r4, #18]
 8007f92:	f8c1 30b8 	str.w	r3, [r1, #184]	; 0xb8
                        if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 8007f96:	7ca3      	ldrb	r3, [r4, #18]
 8007f98:	2b04      	cmp	r3, #4
 8007f9a:	d001      	beq.n	8007fa0 <_fx_utility_logical_sector_flush+0x110>
                            media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 8007f9c:	f8c1 20b0 	str.w	r2, [r1, #176]	; 0xb0
                        (media_ptr -> fx_media_driver_entry) (media_ptr);
 8007fa0:	f8d1 30bc 	ldr.w	r3, [r1, #188]	; 0xbc
 8007fa4:	4608      	mov	r0, r1
 8007fa6:	9106      	str	r1, [sp, #24]
 8007fa8:	4798      	blx	r3
                        if (media_ptr -> fx_media_driver_status)
 8007faa:	9906      	ldr	r1, [sp, #24]
                        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 8007fac:	9b00      	ldr	r3, [sp, #0]
                        if (media_ptr -> fx_media_driver_status)
 8007fae:	f8d1 008c 	ldr.w	r0, [r1, #140]	; 0x8c
                        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 8007fb2:	f8c1 30b0 	str.w	r3, [r1, #176]	; 0xb0
                        if (media_ptr -> fx_media_driver_status)
 8007fb6:	bb18      	cbnz	r0, 8008000 <_fx_utility_logical_sector_flush+0x170>
                        cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 8007fb8:	7420      	strb	r0, [r4, #16]
                        remaining_dirty--;
 8007fba:	f10a 3aff 	add.w	sl, sl, #4294967295
                        media_ptr -> fx_media_sector_cache_dirty_count--;
 8007fbe:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8007fc0:	3b01      	subs	r3, #1
 8007fc2:	624b      	str	r3, [r1, #36]	; 0x24
                if (invalidate)
 8007fc4:	f1bb 0f00 	cmp.w	fp, #0
 8007fc8:	d010      	beq.n	8007fec <_fx_utility_logical_sector_flush+0x15c>
                    cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 8007fca:	9b00      	ldr	r3, [sp, #0]
                    cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 8007fcc:	f04f 32ff 	mov.w	r2, #4294967295
                    if (cache_entry -> fx_cached_sector_buffer_dirty)
 8007fd0:	7c20      	ldrb	r0, [r4, #16]
                    cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 8007fd2:	7463      	strb	r3, [r4, #17]
                    cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 8007fd4:	f04f 33ff 	mov.w	r3, #4294967295
 8007fd8:	e9c4 2302 	strd	r2, r3, [r4, #8]
                    if (cache_entry -> fx_cached_sector_buffer_dirty)
 8007fdc:	b130      	cbz	r0, 8007fec <_fx_utility_logical_sector_flush+0x15c>
                        cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 8007fde:	9b00      	ldr	r3, [sp, #0]
                        remaining_dirty--;
 8007fe0:	f10a 3aff 	add.w	sl, sl, #4294967295
                        cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 8007fe4:	7423      	strb	r3, [r4, #16]
                        media_ptr -> fx_media_sector_cache_dirty_count--;
 8007fe6:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8007fe8:	3b01      	subs	r3, #1
 8007fea:	624b      	str	r3, [r1, #36]	; 0x24
                sectors--;
 8007fec:	f118 38ff 	adds.w	r8, r8, #4294967295
        while ((cache_size--) && (cache_entry -> fx_cached_sector))
 8007ff0:	f105 35ff 	add.w	r5, r5, #4294967295
            cache_entry =  cache_entry -> fx_cached_sector_next_used;
 8007ff4:	6964      	ldr	r4, [r4, #20]
                sectors--;
 8007ff6:	f149 39ff 	adc.w	r9, r9, #4294967295
        while ((cache_size--) && (cache_entry -> fx_cached_sector))
 8007ffa:	1c6e      	adds	r6, r5, #1
 8007ffc:	d18f      	bne.n	8007f1e <_fx_utility_logical_sector_flush+0x8e>
            }
        }
    }

    /* If we get here, return successful status to the caller.  */
    return(FX_SUCCESS);
 8007ffe:	2000      	movs	r0, #0
}
 8008000:	b00b      	add	sp, #44	; 0x2c
 8008002:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        valid_bit_map =  media_ptr -> fx_media_sector_cache_hashed_sector_valid;
 8008006:	f8d9 3020 	ldr.w	r3, [r9, #32]
 800800a:	9309      	str	r3, [sp, #36]	; 0x24
        while (valid_bit_map)
 800800c:	2b00      	cmp	r3, #0
 800800e:	d0f6      	beq.n	8007ffe <_fx_utility_logical_sector_flush+0x16e>
            if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 8008010:	fabb f38b 	clz	r3, fp
 8008014:	095b      	lsrs	r3, r3, #5
 8008016:	9306      	str	r3, [sp, #24]
 8008018:	ea5a 030b 	orrs.w	r3, sl, fp
 800801c:	d0ef      	beq.n	8007ffe <_fx_utility_logical_sector_flush+0x16e>
            if ((sectors == 0) || (starting_sector > ending_sector))
 800801e:	e9dd 3014 	ldrd	r3, r0, [sp, #80]	; 0x50
 8008022:	4303      	orrs	r3, r0
 8008024:	d0eb      	beq.n	8007ffe <_fx_utility_logical_sector_flush+0x16e>
 8008026:	ea52 0301 	orrs.w	r3, r2, r1
 800802a:	bf14      	ite	ne
 800802c:	2301      	movne	r3, #1
 800802e:	2300      	moveq	r3, #0
 8008030:	2b00      	cmp	r3, #0
 8008032:	d1e4      	bne.n	8007ffe <_fx_utility_logical_sector_flush+0x16e>
 8008034:	9308      	str	r3, [sp, #32]
            if (use_starting_sector)
 8008036:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
            if ((sectors == 0) || (starting_sector > ending_sector))
 800803a:	e9dd 7814 	ldrd	r7, r8, [sp, #80]	; 0x50
            if (use_starting_sector)
 800803e:	2c00      	cmp	r4, #0
 8008040:	bf08      	it	eq
 8008042:	2b20      	cmpeq	r3, #32
 8008044:	f080 80b4 	bcs.w	80081b0 <_fx_utility_logical_sector_flush+0x320>
                bit_set =  (index % 32);
 8008048:	f242 43a0 	movw	r3, #9376	; 0x24a0
 800804c:	9a02      	ldr	r2, [sp, #8]
 800804e:	f859 3003 	ldr.w	r3, [r9, r3]
 8008052:	f003 031f 	and.w	r3, r3, #31
 8008056:	4013      	ands	r3, r2
                index =  (bit_set * FX_SECTOR_CACHE_DEPTH);
 8008058:	009e      	lsls	r6, r3, #2
                bit_set =  (index % 32);
 800805a:	9308      	str	r3, [sp, #32]
 800805c:	eb06 0446 	add.w	r4, r6, r6, lsl #1
            remaining_valid =  0;
 8008060:	2500      	movs	r5, #0
 8008062:	eb09 04c4 	add.w	r4, r9, r4, lsl #3
 8008066:	f504 644a 	add.w	r4, r4, #3232	; 0xca0
 800806a:	e9cd 7800 	strd	r7, r8, [sp]
                    if ((cache_entry -> fx_cached_sector_valid) &&
 800806e:	7c63      	ldrb	r3, [r4, #17]
 8008070:	b183      	cbz	r3, 8008094 <_fx_utility_logical_sector_flush+0x204>
                        (cache_entry -> fx_cached_sector >= starting_sector) &&
 8008072:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8008076:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800807a:	4607      	mov	r7, r0
 800807c:	4299      	cmp	r1, r3
 800807e:	bf08      	it	eq
 8008080:	4290      	cmpeq	r0, r2
 8008082:	d306      	bcc.n	8008092 <_fx_utility_logical_sector_flush+0x202>
 8008084:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8008088:	428b      	cmp	r3, r1
 800808a:	bf08      	it	eq
 800808c:	4282      	cmpeq	r2, r0
 800808e:	f080 809f 	bcs.w	80081d0 <_fx_utility_logical_sector_flush+0x340>
                            remaining_valid++;
 8008092:	3501      	adds	r5, #1
 8008094:	ea4b 030a 	orr.w	r3, fp, sl
 8008098:	4619      	mov	r1, r3
                    if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 800809a:	2b00      	cmp	r3, #0
 800809c:	f000 8096 	beq.w	80081cc <_fx_utility_logical_sector_flush+0x33c>
                    if ((sectors == 0) && (invalidate == FX_FALSE))
 80080a0:	e9dd 2000 	ldrd	r2, r0, [sp]
 80080a4:	4310      	orrs	r0, r2
 80080a6:	d103      	bne.n	80080b0 <_fx_utility_logical_sector_flush+0x220>
 80080a8:	9a06      	ldr	r2, [sp, #24]
 80080aa:	2a00      	cmp	r2, #0
 80080ac:	f040 81a6 	bne.w	80083fc <_fx_utility_logical_sector_flush+0x56c>
                    if ((cache_entry -> fx_cached_sector_valid) &&
 80080b0:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 80080b4:	b17b      	cbz	r3, 80080d6 <_fx_utility_logical_sector_flush+0x246>
                        (cache_entry -> fx_cached_sector >= starting_sector) &&
 80080b6:	e9d4 7808 	ldrd	r7, r8, [r4, #32]
 80080ba:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80080be:	4598      	cmp	r8, r3
 80080c0:	bf08      	it	eq
 80080c2:	4297      	cmpeq	r7, r2
 80080c4:	d306      	bcc.n	80080d4 <_fx_utility_logical_sector_flush+0x244>
 80080c6:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80080ca:	4543      	cmp	r3, r8
 80080cc:	bf08      	it	eq
 80080ce:	42ba      	cmpeq	r2, r7
 80080d0:	f080 80d0 	bcs.w	8008274 <_fx_utility_logical_sector_flush+0x3e4>
                            remaining_valid++;
 80080d4:	3501      	adds	r5, #1
 80080d6:	460b      	mov	r3, r1
                    if ((sectors == 0) && (invalidate == FX_FALSE))
 80080d8:	b918      	cbnz	r0, 80080e2 <_fx_utility_logical_sector_flush+0x252>
 80080da:	9a06      	ldr	r2, [sp, #24]
 80080dc:	2a00      	cmp	r2, #0
 80080de:	f040 818d 	bne.w	80083fc <_fx_utility_logical_sector_flush+0x56c>
                    if ((cache_entry -> fx_cached_sector_valid) &&
 80080e2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80080e6:	b17b      	cbz	r3, 8008108 <_fx_utility_logical_sector_flush+0x278>
                        (cache_entry -> fx_cached_sector >= starting_sector) &&
 80080e8:	e9d4 780e 	ldrd	r7, r8, [r4, #56]	; 0x38
 80080ec:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80080f0:	4598      	cmp	r8, r3
 80080f2:	bf08      	it	eq
 80080f4:	4297      	cmpeq	r7, r2
 80080f6:	d306      	bcc.n	8008106 <_fx_utility_logical_sector_flush+0x276>
 80080f8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80080fc:	4543      	cmp	r3, r8
 80080fe:	bf08      	it	eq
 8008100:	42ba      	cmpeq	r2, r7
 8008102:	f080 8119 	bcs.w	8008338 <_fx_utility_logical_sector_flush+0x4a8>
                            remaining_valid++;
 8008106:	3501      	adds	r5, #1
 8008108:	460b      	mov	r3, r1
                    if ((sectors == 0) && (invalidate == FX_FALSE))
 800810a:	b918      	cbnz	r0, 8008114 <_fx_utility_logical_sector_flush+0x284>
 800810c:	9a06      	ldr	r2, [sp, #24]
 800810e:	2a00      	cmp	r2, #0
 8008110:	f040 8174 	bne.w	80083fc <_fx_utility_logical_sector_flush+0x56c>
                    if ((cache_entry -> fx_cached_sector_valid) &&
 8008114:	f894 3059 	ldrb.w	r3, [r4, #89]	; 0x59
 8008118:	b17b      	cbz	r3, 800813a <_fx_utility_logical_sector_flush+0x2aa>
                        (cache_entry -> fx_cached_sector >= starting_sector) &&
 800811a:	e9d4 7814 	ldrd	r7, r8, [r4, #80]	; 0x50
 800811e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008122:	4598      	cmp	r8, r3
 8008124:	bf08      	it	eq
 8008126:	4297      	cmpeq	r7, r2
 8008128:	d306      	bcc.n	8008138 <_fx_utility_logical_sector_flush+0x2a8>
 800812a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 800812e:	4543      	cmp	r3, r8
 8008130:	bf08      	it	eq
 8008132:	42ba      	cmpeq	r2, r7
 8008134:	f080 8167 	bcs.w	8008406 <_fx_utility_logical_sector_flush+0x576>
                            remaining_valid++;
 8008138:	3501      	adds	r5, #1
 800813a:	460b      	mov	r3, r1
                index =  index + (32 * FX_SECTOR_CACHE_DEPTH);
 800813c:	3680      	adds	r6, #128	; 0x80
            } while (index < cache_size);
 800813e:	9a07      	ldr	r2, [sp, #28]
 8008140:	f504 6440 	add.w	r4, r4, #3072	; 0xc00
 8008144:	4296      	cmp	r6, r2
 8008146:	d392      	bcc.n	800806e <_fx_utility_logical_sector_flush+0x1de>
 8008148:	e9dd 7800 	ldrd	r7, r8, [sp]
            if ((invalidate) && (remaining_valid == 0))
 800814c:	f1bb 0f00 	cmp.w	fp, #0
 8008150:	d009      	beq.n	8008166 <_fx_utility_logical_sector_flush+0x2d6>
 8008152:	b945      	cbnz	r5, 8008166 <_fx_utility_logical_sector_flush+0x2d6>
                media_ptr -> fx_media_sector_cache_hashed_sector_valid &=  ~(((ULONG)1) << bit_set);
 8008154:	2101      	movs	r1, #1
 8008156:	9808      	ldr	r0, [sp, #32]
 8008158:	f8d9 2020 	ldr.w	r2, [r9, #32]
 800815c:	4081      	lsls	r1, r0
 800815e:	ea22 0201 	bic.w	r2, r2, r1
 8008162:	f8c9 2020 	str.w	r2, [r9, #32]
            if (use_starting_sector)
 8008166:	e9dd 1214 	ldrd	r1, r2, [sp, #80]	; 0x50
 800816a:	2a00      	cmp	r2, #0
 800816c:	bf08      	it	eq
 800816e:	2920      	cmpeq	r1, #32
 8008170:	f080 81a6 	bcs.w	80084c0 <_fx_utility_logical_sector_flush+0x630>
                starting_sector++;
 8008174:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
 8008178:	3101      	adds	r1, #1
 800817a:	f142 0200 	adc.w	r2, r2, #0
 800817e:	e9cd 1202 	strd	r1, r2, [sp, #8]
            if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 8008182:	2b00      	cmp	r3, #0
 8008184:	f43f af3b 	beq.w	8007ffe <_fx_utility_logical_sector_flush+0x16e>
            if ((sectors == 0) || (starting_sector > ending_sector))
 8008188:	ea57 0308 	orrs.w	r3, r7, r8
 800818c:	f43f af37 	beq.w	8007ffe <_fx_utility_logical_sector_flush+0x16e>
 8008190:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
 8008194:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
 8008198:	4294      	cmp	r4, r2
 800819a:	bf08      	it	eq
 800819c:	428b      	cmpeq	r3, r1
 800819e:	f4ff af2e 	bcc.w	8007ffe <_fx_utility_logical_sector_flush+0x16e>
            if (use_starting_sector)
 80081a2:	e9dd 3414 	ldrd	r3, r4, [sp, #80]	; 0x50
 80081a6:	2c00      	cmp	r4, #0
 80081a8:	bf08      	it	eq
 80081aa:	2b20      	cmpeq	r3, #32
 80081ac:	f4ff af4c 	bcc.w	8008048 <_fx_utility_logical_sector_flush+0x1b8>
                while ((valid_bit_map & 1) == 0)
 80081b0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80081b2:	07d8      	lsls	r0, r3, #31
 80081b4:	f100 818d 	bmi.w	80084d2 <_fx_utility_logical_sector_flush+0x642>
 80081b8:	9a08      	ldr	r2, [sp, #32]
                    valid_bit_map =  valid_bit_map >> 1;
 80081ba:	085b      	lsrs	r3, r3, #1
                    bit_set++;
 80081bc:	3201      	adds	r2, #1
                while ((valid_bit_map & 1) == 0)
 80081be:	07d9      	lsls	r1, r3, #31
 80081c0:	d5fb      	bpl.n	80081ba <_fx_utility_logical_sector_flush+0x32a>
 80081c2:	9309      	str	r3, [sp, #36]	; 0x24
 80081c4:	4613      	mov	r3, r2
 80081c6:	9208      	str	r2, [sp, #32]
                index =  (bit_set * FX_SECTOR_CACHE_DEPTH);
 80081c8:	009e      	lsls	r6, r3, #2
 80081ca:	e747      	b.n	800805c <_fx_utility_logical_sector_flush+0x1cc>
                    if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 80081cc:	469a      	mov	sl, r3
 80081ce:	e7b5      	b.n	800813c <_fx_utility_logical_sector_flush+0x2ac>
                        if (cache_entry -> fx_cached_sector_buffer_dirty)
 80081d0:	7c21      	ldrb	r1, [r4, #16]
 80081d2:	b389      	cbz	r1, 8008238 <_fx_utility_logical_sector_flush+0x3a8>
                            if (media_ptr -> fx_media_driver_write_protect == FX_FALSE)
 80081d4:	f8d9 10a8 	ldr.w	r1, [r9, #168]	; 0xa8
 80081d8:	bb71      	cbnz	r1, 8008238 <_fx_utility_logical_sector_flush+0x3a8>
                                media_ptr -> fx_media_driver_write_requests++;
 80081da:	f8d9 31b0 	ldr.w	r3, [r9, #432]	; 0x1b0
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80081de:	f04f 0801 	mov.w	r8, #1
                                media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 80081e2:	6821      	ldr	r1, [r4, #0]
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80081e4:	2290      	movs	r2, #144	; 0x90
                                media_ptr -> fx_media_driver_write_requests++;
 80081e6:	3301      	adds	r3, #1
                                media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 80081e8:	f8c9 7094 	str.w	r7, [r9, #148]	; 0x94
                                media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 80081ec:	f8c9 1090 	str.w	r1, [r9, #144]	; 0x90
                                media_ptr -> fx_media_driver_write_requests++;
 80081f0:	f8c9 31b0 	str.w	r3, [r9, #432]	; 0x1b0
                                media_ptr -> fx_media_driver_sectors =          1;
 80081f4:	2301      	movs	r3, #1
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80081f6:	e9c9 8222 	strd	r8, r2, [r9, #136]	; 0x88
                                media_ptr -> fx_media_driver_sectors =          1;
 80081fa:	f8c9 3098 	str.w	r3, [r9, #152]	; 0x98
                                media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 80081fe:	7ca3      	ldrb	r3, [r4, #18]
 8008200:	f8c9 30b8 	str.w	r3, [r9, #184]	; 0xb8
                                if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 8008204:	7ca3      	ldrb	r3, [r4, #18]
 8008206:	2b04      	cmp	r3, #4
 8008208:	d002      	beq.n	8008210 <_fx_utility_logical_sector_flush+0x380>
                                    media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 800820a:	2301      	movs	r3, #1
 800820c:	f8c9 30b0 	str.w	r3, [r9, #176]	; 0xb0
                                (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008210:	f8d9 30bc 	ldr.w	r3, [r9, #188]	; 0xbc
 8008214:	4648      	mov	r0, r9
 8008216:	4798      	blx	r3
                                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 8008218:	2300      	movs	r3, #0
                                if (media_ptr -> fx_media_driver_status)
 800821a:	f8d9 008c 	ldr.w	r0, [r9, #140]	; 0x8c
                                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800821e:	f8c9 30b0 	str.w	r3, [r9, #176]	; 0xb0
                                if (media_ptr -> fx_media_driver_status)
 8008222:	2800      	cmp	r0, #0
 8008224:	f47f aeec 	bne.w	8008000 <_fx_utility_logical_sector_flush+0x170>
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 8008228:	7420      	strb	r0, [r4, #16]
                                remaining_dirty--;
 800822a:	f10a 3aff 	add.w	sl, sl, #4294967295
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 800822e:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8008232:	3b01      	subs	r3, #1
 8008234:	f8c9 3024 	str.w	r3, [r9, #36]	; 0x24
                        if (invalidate)
 8008238:	f1bb 0f00 	cmp.w	fp, #0
 800823c:	d011      	beq.n	8008262 <_fx_utility_logical_sector_flush+0x3d2>
                            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 800823e:	2300      	movs	r3, #0
                            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 8008240:	f04f 30ff 	mov.w	r0, #4294967295
 8008244:	f04f 31ff 	mov.w	r1, #4294967295
                            if (cache_entry -> fx_cached_sector_buffer_dirty)
 8008248:	7c22      	ldrb	r2, [r4, #16]
                            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 800824a:	7463      	strb	r3, [r4, #17]
                            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 800824c:	e9c4 0102 	strd	r0, r1, [r4, #8]
                            if (cache_entry -> fx_cached_sector_buffer_dirty)
 8008250:	b13a      	cbz	r2, 8008262 <_fx_utility_logical_sector_flush+0x3d2>
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 8008252:	7423      	strb	r3, [r4, #16]
                                remaining_dirty--;
 8008254:	f10a 3aff 	add.w	sl, sl, #4294967295
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 8008258:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800825c:	3b01      	subs	r3, #1
 800825e:	f8c9 3024 	str.w	r3, [r9, #36]	; 0x24
                        sectors--;
 8008262:	e9dd 2300 	ldrd	r2, r3, [sp]
 8008266:	f112 32ff 	adds.w	r2, r2, #4294967295
 800826a:	f143 33ff 	adc.w	r3, r3, #4294967295
 800826e:	e9cd 2300 	strd	r2, r3, [sp]
 8008272:	e70f      	b.n	8008094 <_fx_utility_logical_sector_flush+0x204>
                        if (cache_entry -> fx_cached_sector_buffer_dirty)
 8008274:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 8008278:	b3a1      	cbz	r1, 80082e4 <_fx_utility_logical_sector_flush+0x454>
                            if (media_ptr -> fx_media_driver_write_protect == FX_FALSE)
 800827a:	f8d9 10a8 	ldr.w	r1, [r9, #168]	; 0xa8
 800827e:	bb89      	cbnz	r1, 80082e4 <_fx_utility_logical_sector_flush+0x454>
                                media_ptr -> fx_media_driver_write_requests++;
 8008280:	f8d9 31b0 	ldr.w	r3, [r9, #432]	; 0x1b0
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8008284:	f04f 0e01 	mov.w	lr, #1
                                media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8008288:	69a1      	ldr	r1, [r4, #24]
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800828a:	2290      	movs	r2, #144	; 0x90
                                media_ptr -> fx_media_driver_write_requests++;
 800828c:	3301      	adds	r3, #1
                                media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 800828e:	f8c9 7094 	str.w	r7, [r9, #148]	; 0x94
                                media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8008292:	f8c9 1090 	str.w	r1, [r9, #144]	; 0x90
                                media_ptr -> fx_media_driver_write_requests++;
 8008296:	f8c9 31b0 	str.w	r3, [r9, #432]	; 0x1b0
                                media_ptr -> fx_media_driver_sectors =          1;
 800829a:	2301      	movs	r3, #1
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800829c:	e9c9 e222 	strd	lr, r2, [r9, #136]	; 0x88
                                media_ptr -> fx_media_driver_sectors =          1;
 80082a0:	f8c9 3098 	str.w	r3, [r9, #152]	; 0x98
                                media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 80082a4:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80082a8:	f8c9 30b8 	str.w	r3, [r9, #184]	; 0xb8
                                if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 80082ac:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80082b0:	2b04      	cmp	r3, #4
 80082b2:	d002      	beq.n	80082ba <_fx_utility_logical_sector_flush+0x42a>
                                    media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 80082b4:	2301      	movs	r3, #1
 80082b6:	f8c9 30b0 	str.w	r3, [r9, #176]	; 0xb0
                                (media_ptr -> fx_media_driver_entry) (media_ptr);
 80082ba:	f8d9 30bc 	ldr.w	r3, [r9, #188]	; 0xbc
 80082be:	4648      	mov	r0, r9
 80082c0:	4798      	blx	r3
                                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 80082c2:	2300      	movs	r3, #0
                                if (media_ptr -> fx_media_driver_status)
 80082c4:	f8d9 008c 	ldr.w	r0, [r9, #140]	; 0x8c
                                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 80082c8:	f8c9 30b0 	str.w	r3, [r9, #176]	; 0xb0
                                if (media_ptr -> fx_media_driver_status)
 80082cc:	2800      	cmp	r0, #0
 80082ce:	f47f ae97 	bne.w	8008000 <_fx_utility_logical_sector_flush+0x170>
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 80082d2:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
                                remaining_dirty--;
 80082d6:	f10a 3aff 	add.w	sl, sl, #4294967295
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 80082da:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 80082de:	3b01      	subs	r3, #1
 80082e0:	f8c9 3024 	str.w	r3, [r9, #36]	; 0x24
                        if (invalidate)
 80082e4:	f1bb 0f00 	cmp.w	fp, #0
 80082e8:	d014      	beq.n	8008314 <_fx_utility_logical_sector_flush+0x484>
                            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 80082ea:	2300      	movs	r3, #0
                            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 80082ec:	f04f 30ff 	mov.w	r0, #4294967295
 80082f0:	f04f 31ff 	mov.w	r1, #4294967295
                            if (cache_entry -> fx_cached_sector_buffer_dirty)
 80082f4:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
                            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 80082f8:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
                            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 80082fc:	e9c4 0108 	strd	r0, r1, [r4, #32]
                            if (cache_entry -> fx_cached_sector_buffer_dirty)
 8008300:	b142      	cbz	r2, 8008314 <_fx_utility_logical_sector_flush+0x484>
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 8008302:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
                                remaining_dirty--;
 8008306:	f10a 3aff 	add.w	sl, sl, #4294967295
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 800830a:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800830e:	3b01      	subs	r3, #1
 8008310:	f8c9 3024 	str.w	r3, [r9, #36]	; 0x24
 8008314:	ea4b 030a 	orr.w	r3, fp, sl
                        sectors--;
 8008318:	e9dd 1200 	ldrd	r1, r2, [sp]
 800831c:	f111 31ff 	adds.w	r1, r1, #4294967295
 8008320:	f142 32ff 	adc.w	r2, r2, #4294967295
 8008324:	e9cd 1200 	strd	r1, r2, [sp]
 8008328:	4619      	mov	r1, r3
                    if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 800832a:	2b00      	cmp	r3, #0
 800832c:	f43f af4e 	beq.w	80081cc <_fx_utility_logical_sector_flush+0x33c>
 8008330:	e9dd 2000 	ldrd	r2, r0, [sp]
 8008334:	4310      	orrs	r0, r2
 8008336:	e6cf      	b.n	80080d8 <_fx_utility_logical_sector_flush+0x248>
                        if (cache_entry -> fx_cached_sector_buffer_dirty)
 8008338:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
 800833c:	b3a1      	cbz	r1, 80083a8 <_fx_utility_logical_sector_flush+0x518>
                            if (media_ptr -> fx_media_driver_write_protect == FX_FALSE)
 800833e:	f8d9 10a8 	ldr.w	r1, [r9, #168]	; 0xa8
 8008342:	bb89      	cbnz	r1, 80083a8 <_fx_utility_logical_sector_flush+0x518>
                                media_ptr -> fx_media_driver_write_requests++;
 8008344:	f8d9 31b0 	ldr.w	r3, [r9, #432]	; 0x1b0
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8008348:	f04f 0c01 	mov.w	ip, #1
                                media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 800834c:	6b21      	ldr	r1, [r4, #48]	; 0x30
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800834e:	2290      	movs	r2, #144	; 0x90
                                media_ptr -> fx_media_driver_write_requests++;
 8008350:	3301      	adds	r3, #1
                                media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 8008352:	f8c9 7094 	str.w	r7, [r9, #148]	; 0x94
                                media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8008356:	f8c9 1090 	str.w	r1, [r9, #144]	; 0x90
                                media_ptr -> fx_media_driver_write_requests++;
 800835a:	f8c9 31b0 	str.w	r3, [r9, #432]	; 0x1b0
                                media_ptr -> fx_media_driver_sectors =          1;
 800835e:	2301      	movs	r3, #1
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8008360:	e9c9 c222 	strd	ip, r2, [r9, #136]	; 0x88
                                media_ptr -> fx_media_driver_sectors =          1;
 8008364:	f8c9 3098 	str.w	r3, [r9, #152]	; 0x98
                                media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 8008368:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 800836c:	f8c9 30b8 	str.w	r3, [r9, #184]	; 0xb8
                                if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 8008370:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8008374:	2b04      	cmp	r3, #4
 8008376:	d002      	beq.n	800837e <_fx_utility_logical_sector_flush+0x4ee>
                                    media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 8008378:	2301      	movs	r3, #1
 800837a:	f8c9 30b0 	str.w	r3, [r9, #176]	; 0xb0
                                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800837e:	f8d9 30bc 	ldr.w	r3, [r9, #188]	; 0xbc
 8008382:	4648      	mov	r0, r9
 8008384:	4798      	blx	r3
                                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 8008386:	2300      	movs	r3, #0
                                if (media_ptr -> fx_media_driver_status)
 8008388:	f8d9 008c 	ldr.w	r0, [r9, #140]	; 0x8c
                                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800838c:	f8c9 30b0 	str.w	r3, [r9, #176]	; 0xb0
                                if (media_ptr -> fx_media_driver_status)
 8008390:	2800      	cmp	r0, #0
 8008392:	f47f ae35 	bne.w	8008000 <_fx_utility_logical_sector_flush+0x170>
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 8008396:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
                                remaining_dirty--;
 800839a:	f10a 3aff 	add.w	sl, sl, #4294967295
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 800839e:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 80083a2:	3b01      	subs	r3, #1
 80083a4:	f8c9 3024 	str.w	r3, [r9, #36]	; 0x24
                        if (invalidate)
 80083a8:	f1bb 0f00 	cmp.w	fp, #0
 80083ac:	d014      	beq.n	80083d8 <_fx_utility_logical_sector_flush+0x548>
                            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 80083ae:	2300      	movs	r3, #0
                            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 80083b0:	f04f 30ff 	mov.w	r0, #4294967295
 80083b4:	f04f 31ff 	mov.w	r1, #4294967295
                            if (cache_entry -> fx_cached_sector_buffer_dirty)
 80083b8:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
                            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 80083bc:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
                            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 80083c0:	e9c4 010e 	strd	r0, r1, [r4, #56]	; 0x38
                            if (cache_entry -> fx_cached_sector_buffer_dirty)
 80083c4:	b142      	cbz	r2, 80083d8 <_fx_utility_logical_sector_flush+0x548>
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 80083c6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
                                remaining_dirty--;
 80083ca:	f10a 3aff 	add.w	sl, sl, #4294967295
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 80083ce:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 80083d2:	3b01      	subs	r3, #1
 80083d4:	f8c9 3024 	str.w	r3, [r9, #36]	; 0x24
 80083d8:	ea4a 030b 	orr.w	r3, sl, fp
                        sectors--;
 80083dc:	e9dd 1200 	ldrd	r1, r2, [sp]
 80083e0:	f111 31ff 	adds.w	r1, r1, #4294967295
 80083e4:	f142 32ff 	adc.w	r2, r2, #4294967295
 80083e8:	e9cd 1200 	strd	r1, r2, [sp]
 80083ec:	4619      	mov	r1, r3
                    if ((remaining_dirty == 0) && (invalidate == FX_FALSE))
 80083ee:	2b00      	cmp	r3, #0
 80083f0:	f43f aeec 	beq.w	80081cc <_fx_utility_logical_sector_flush+0x33c>
 80083f4:	e9dd 2000 	ldrd	r2, r0, [sp]
 80083f8:	4310      	orrs	r0, r2
 80083fa:	e686      	b.n	800810a <_fx_utility_logical_sector_flush+0x27a>
                    if ((sectors == 0) && (invalidate == FX_FALSE))
 80083fc:	2100      	movs	r1, #0
 80083fe:	2200      	movs	r2, #0
 8008400:	e9cd 1200 	strd	r1, r2, [sp]
 8008404:	e69a      	b.n	800813c <_fx_utility_logical_sector_flush+0x2ac>
                        if (cache_entry -> fx_cached_sector_buffer_dirty)
 8008406:	f894 1058 	ldrb.w	r1, [r4, #88]	; 0x58
 800840a:	b399      	cbz	r1, 8008474 <_fx_utility_logical_sector_flush+0x5e4>
                            if (media_ptr -> fx_media_driver_write_protect == FX_FALSE)
 800840c:	f8d9 10a8 	ldr.w	r1, [r9, #168]	; 0xa8
 8008410:	bb81      	cbnz	r1, 8008474 <_fx_utility_logical_sector_flush+0x5e4>
                                media_ptr -> fx_media_driver_write_requests++;
 8008412:	f8d9 31b0 	ldr.w	r3, [r9, #432]	; 0x1b0
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8008416:	2001      	movs	r0, #1
                                media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8008418:	6ca1      	ldr	r1, [r4, #72]	; 0x48
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800841a:	2290      	movs	r2, #144	; 0x90
                                media_ptr -> fx_media_driver_write_requests++;
 800841c:	3301      	adds	r3, #1
                                media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 800841e:	f8c9 7094 	str.w	r7, [r9, #148]	; 0x94
                                media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8008422:	f8c9 1090 	str.w	r1, [r9, #144]	; 0x90
                                media_ptr -> fx_media_driver_write_requests++;
 8008426:	f8c9 31b0 	str.w	r3, [r9, #432]	; 0x1b0
                                media_ptr -> fx_media_driver_sectors =          1;
 800842a:	2301      	movs	r3, #1
                                media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800842c:	e9c9 0222 	strd	r0, r2, [r9, #136]	; 0x88
                                media_ptr -> fx_media_driver_sectors =          1;
 8008430:	f8c9 3098 	str.w	r3, [r9, #152]	; 0x98
                                media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 8008434:	f894 305a 	ldrb.w	r3, [r4, #90]	; 0x5a
 8008438:	f8c9 30b8 	str.w	r3, [r9, #184]	; 0xb8
                                if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 800843c:	f894 305a 	ldrb.w	r3, [r4, #90]	; 0x5a
 8008440:	2b04      	cmp	r3, #4
 8008442:	d002      	beq.n	800844a <_fx_utility_logical_sector_flush+0x5ba>
                                    media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 8008444:	2301      	movs	r3, #1
 8008446:	f8c9 30b0 	str.w	r3, [r9, #176]	; 0xb0
                                (media_ptr -> fx_media_driver_entry) (media_ptr);
 800844a:	f8d9 30bc 	ldr.w	r3, [r9, #188]	; 0xbc
 800844e:	4648      	mov	r0, r9
 8008450:	4798      	blx	r3
                                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 8008452:	2300      	movs	r3, #0
                                if (media_ptr -> fx_media_driver_status)
 8008454:	f8d9 008c 	ldr.w	r0, [r9, #140]	; 0x8c
                                media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 8008458:	f8c9 30b0 	str.w	r3, [r9, #176]	; 0xb0
                                if (media_ptr -> fx_media_driver_status)
 800845c:	2800      	cmp	r0, #0
 800845e:	f47f adcf 	bne.w	8008000 <_fx_utility_logical_sector_flush+0x170>
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 8008462:	f884 0058 	strb.w	r0, [r4, #88]	; 0x58
                                remaining_dirty--;
 8008466:	f10a 3aff 	add.w	sl, sl, #4294967295
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 800846a:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800846e:	3b01      	subs	r3, #1
 8008470:	f8c9 3024 	str.w	r3, [r9, #36]	; 0x24
                        if (invalidate)
 8008474:	f1bb 0f00 	cmp.w	fp, #0
 8008478:	d014      	beq.n	80084a4 <_fx_utility_logical_sector_flush+0x614>
                            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 800847a:	2300      	movs	r3, #0
                            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 800847c:	f04f 30ff 	mov.w	r0, #4294967295
 8008480:	f04f 31ff 	mov.w	r1, #4294967295
                            if (cache_entry -> fx_cached_sector_buffer_dirty)
 8008484:	f894 2058 	ldrb.w	r2, [r4, #88]	; 0x58
                            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 8008488:	f884 3059 	strb.w	r3, [r4, #89]	; 0x59
                            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 800848c:	e9c4 0114 	strd	r0, r1, [r4, #80]	; 0x50
                            if (cache_entry -> fx_cached_sector_buffer_dirty)
 8008490:	b142      	cbz	r2, 80084a4 <_fx_utility_logical_sector_flush+0x614>
                                cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 8008492:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
                                remaining_dirty--;
 8008496:	f10a 3aff 	add.w	sl, sl, #4294967295
                                media_ptr -> fx_media_sector_cache_dirty_count--;
 800849a:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800849e:	3b01      	subs	r3, #1
 80084a0:	f8c9 3024 	str.w	r3, [r9, #36]	; 0x24
                        sectors--;
 80084a4:	e9dd 2300 	ldrd	r2, r3, [sp]
 80084a8:	f112 32ff 	adds.w	r2, r2, #4294967295
 80084ac:	f143 33ff 	adc.w	r3, r3, #4294967295
 80084b0:	e9cd 2300 	strd	r2, r3, [sp]
 80084b4:	ea5a 030b 	orrs.w	r3, sl, fp
 80084b8:	bf08      	it	eq
 80084ba:	f04f 0a00 	moveq.w	sl, #0
 80084be:	e63d      	b.n	800813c <_fx_utility_logical_sector_flush+0x2ac>
                bit_set++;
 80084c0:	9a08      	ldr	r2, [sp, #32]
 80084c2:	3201      	adds	r2, #1
 80084c4:	9208      	str	r2, [sp, #32]
        while (valid_bit_map)
 80084c6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80084c8:	0852      	lsrs	r2, r2, #1
 80084ca:	9209      	str	r2, [sp, #36]	; 0x24
 80084cc:	f47f ae59 	bne.w	8008182 <_fx_utility_logical_sector_flush+0x2f2>
 80084d0:	e595      	b.n	8007ffe <_fx_utility_logical_sector_flush+0x16e>
 80084d2:	9b08      	ldr	r3, [sp, #32]
 80084d4:	e678      	b.n	80081c8 <_fx_utility_logical_sector_flush+0x338>
 80084d6:	bf00      	nop

080084d8 <_fx_utility_logical_sector_read>:
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_logical_sector_read(FX_MEDIA *media_ptr, ULONG64 logical_sector,
                                      VOID *buffer_ptr, ULONG sectors, UCHAR sector_type)
{
 80084d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80084dc:	b08b      	sub	sp, #44	; 0x2c
 80084de:	4604      	mov	r4, r0
 80084e0:	4616      	mov	r6, r2
 80084e2:	461f      	mov	r7, r3
 80084e4:	f89d 1058 	ldrb.w	r1, [sp, #88]	; 0x58
 80084e8:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Determine if the request is for FAT sector.  */
    if (sector_type == FX_FAT_SECTOR)
 80084ec:	2902      	cmp	r1, #2
{
 80084ee:	9106      	str	r1, [sp, #24]
 80084f0:	9d15      	ldr	r5, [sp, #84]	; 0x54
    if (sector_type == FX_FAT_SECTOR)
 80084f2:	d104      	bne.n	80084fe <_fx_utility_logical_sector_read+0x26>
    {

        /* Increment the number of FAT sector reads.  */
        media_ptr -> fx_media_fat_sector_reads++;
 80084f4:	f8d0 3194 	ldr.w	r3, [r0, #404]	; 0x194
 80084f8:	3301      	adds	r3, #1
 80084fa:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194
    }

    /* Increment the number of logical sectors read.  */
    media_ptr -> fx_media_logical_sector_reads++;
 80084fe:	f8d4 319c 	ldr.w	r3, [r4, #412]	; 0x19c

    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_LOGICAL_SECTOR_READ_EXTENSION

    /* Determine if the request is for the internal media buffer area.  */
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 8008502:	68a2      	ldr	r2, [r4, #8]
    media_ptr -> fx_media_logical_sector_reads++;
 8008504:	3301      	adds	r3, #1
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 8008506:	4552      	cmp	r2, sl
    media_ptr -> fx_media_logical_sector_reads++;
 8008508:	f8c4 319c 	str.w	r3, [r4, #412]	; 0x19c
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 800850c:	d803      	bhi.n	8008516 <_fx_utility_logical_sector_read+0x3e>
 800850e:	69a3      	ldr	r3, [r4, #24]
 8008510:	4553      	cmp	r3, sl
 8008512:	f080 80fa 	bcs.w	800870a <_fx_utility_logical_sector_read+0x232>
    {

        /* Direct I/O to application buffer area.  */

        /* Compare against logical sector to make sure it is valid.  */
        if ((logical_sector + sectors - 1) > (ULONG)media_ptr -> fx_media_total_sectors)
 8008516:	eb16 0805 	adds.w	r8, r6, r5
 800851a:	f147 0900 	adc.w	r9, r7, #0
 800851e:	f118 30ff 	adds.w	r0, r8, #4294967295
 8008522:	f149 31ff 	adc.w	r1, r9, #4294967295
 8008526:	f04f 0900 	mov.w	r9, #0
 800852a:	e9d4 230e 	ldrd	r2, r3, [r4, #56]	; 0x38
 800852e:	4589      	cmp	r9, r1
 8008530:	bf08      	it	eq
 8008532:	4282      	cmpeq	r2, r0
 8008534:	f0c0 80e5 	bcc.w	8008702 <_fx_utility_logical_sector_read+0x22a>
        {
            return(FX_SECTOR_INVALID);
        }

        /* Attempt to fill the beginning of the buffer from cached sectors.  */
        while (sectors)
 8008538:	2d00      	cmp	r5, #0
 800853a:	f000 80de 	beq.w	80086fa <_fx_utility_logical_sector_read+0x222>
 800853e:	f10d 0b24 	add.w	fp, sp, #36	; 0x24
 8008542:	e00b      	b.n	800855c <_fx_utility_logical_sector_read+0x84>

            /* Advance the destination buffer.  */
            buffer_ptr =  ((UCHAR *)buffer_ptr) + media_ptr -> fx_media_bytes_per_sector;

            /* Advance the sector and decrement the number of sectors left.  */
            logical_sector++;
 8008544:	3601      	adds	r6, #1
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, buffer_ptr, media_ptr -> fx_media_bytes_per_sector);
 8008546:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8008548:	68a0      	ldr	r0, [r4, #8]
            logical_sector++;
 800854a:	f147 0700 	adc.w	r7, r7, #0
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, buffer_ptr, media_ptr -> fx_media_bytes_per_sector);
 800854e:	f000 fa5f 	bl	8008a10 <_fx_utility_memory_copy>
            buffer_ptr =  ((UCHAR *)buffer_ptr) + media_ptr -> fx_media_bytes_per_sector;
 8008552:	6aa3      	ldr	r3, [r4, #40]	; 0x28
        while (sectors)
 8008554:	3d01      	subs	r5, #1
            buffer_ptr =  ((UCHAR *)buffer_ptr) + media_ptr -> fx_media_bytes_per_sector;
 8008556:	449a      	add	sl, r3
        while (sectors)
 8008558:	f000 80cf 	beq.w	80086fa <_fx_utility_logical_sector_read+0x222>
            if (_fx_utility_logical_sector_cache_entry_read(media_ptr, logical_sector, &previous_cache_entry))
 800855c:	f8cd b000 	str.w	fp, [sp]
 8008560:	4632      	mov	r2, r6
 8008562:	463b      	mov	r3, r7
 8008564:	4620      	mov	r0, r4
 8008566:	f001 ff3f 	bl	800a3e8 <_fx_utility_logical_sector_cache_entry_read>
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer, buffer_ptr, media_ptr -> fx_media_bytes_per_sector);
 800856a:	4651      	mov	r1, sl
            if (_fx_utility_logical_sector_cache_entry_read(media_ptr, logical_sector, &previous_cache_entry))
 800856c:	2800      	cmp	r0, #0
 800856e:	d0e9      	beq.n	8008544 <_fx_utility_logical_sector_read+0x6c>
            sectors--;
        }

        /* Calculate the end sector.  */
        end_sector = logical_sector + sectors - 1;
 8008570:	f116 38ff 	adds.w	r8, r6, #4294967295
 8008574:	f147 39ff 	adc.w	r9, r7, #4294967295
 8008578:	eb18 0205 	adds.w	r2, r8, r5
 800857c:	f149 0300 	adc.w	r3, r9, #0
 8008580:	4690      	mov	r8, r2
 8008582:	4699      	mov	r9, r3
 8008584:	e009      	b.n	800859a <_fx_utility_logical_sector_read+0xc2>
                break;
            }

            /* Yes, sector is in the cache. Copy the data from the cache to the destination buffer.  */
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer,
                                    ((UCHAR *)buffer_ptr) + ((sectors - 1) * media_ptr -> fx_media_bytes_per_sector),
 8008586:	3d01      	subs	r5, #1
 8008588:	6aa2      	ldr	r2, [r4, #40]	; 0x28
            _fx_utility_memory_copy(media_ptr -> fx_media_memory_buffer,
 800858a:	68a0      	ldr	r0, [r4, #8]
 800858c:	fb02 a105 	mla	r1, r2, r5, sl
 8008590:	f000 fa3e 	bl	8008a10 <_fx_utility_memory_copy>
        while (sectors)
 8008594:	2d00      	cmp	r5, #0
 8008596:	f000 80b0 	beq.w	80086fa <_fx_utility_logical_sector_read+0x222>
            if (_fx_utility_logical_sector_cache_entry_read(media_ptr, end_sector, &previous_cache_entry))
 800859a:	4642      	mov	r2, r8
                                    media_ptr -> fx_media_bytes_per_sector);

            /* Move sector to previous sector and decrement the number of sectors left.  */
            end_sector--;
 800859c:	f118 38ff 	adds.w	r8, r8, #4294967295
            if (_fx_utility_logical_sector_cache_entry_read(media_ptr, end_sector, &previous_cache_entry))
 80085a0:	464b      	mov	r3, r9
 80085a2:	f8cd b000 	str.w	fp, [sp]
 80085a6:	4620      	mov	r0, r4
            end_sector--;
 80085a8:	f149 39ff 	adc.w	r9, r9, #4294967295
            if (_fx_utility_logical_sector_cache_entry_read(media_ptr, end_sector, &previous_cache_entry))
 80085ac:	f001 ff1c 	bl	800a3e8 <_fx_utility_logical_sector_cache_entry_read>
 80085b0:	2800      	cmp	r0, #0
 80085b2:	d0e8      	beq.n	8008586 <_fx_utility_logical_sector_read+0xae>
            /* No more sectors to read - return success!  */
            return(FX_SUCCESS);
        }

        /* Flush and invalidate any entries in the cache that are in this direct I/O read request range.  */
        _fx_utility_logical_sector_flush(media_ptr, logical_sector, (ULONG64) sectors, FX_TRUE);
 80085b4:	f04f 0901 	mov.w	r9, #1
 80085b8:	f04f 0800 	mov.w	r8, #0
 80085bc:	4632      	mov	r2, r6
 80085be:	463b      	mov	r3, r7
 80085c0:	9500      	str	r5, [sp, #0]
 80085c2:	4620      	mov	r0, r4
 80085c4:	f8cd 9008 	str.w	r9, [sp, #8]
 80085c8:	f8cd 8004 	str.w	r8, [sp, #4]
 80085cc:	f7ff fc60 	bl	8007e90 <_fx_utility_logical_sector_flush>

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver read sector(s) requests.  */
        media_ptr -> fx_media_driver_read_requests++;
 80085d0:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac
        media_ptr -> fx_media_driver_logical_sector =   logical_sector;
#else
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
#endif
        media_ptr -> fx_media_driver_sectors =          sectors;
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 80085d4:	9906      	ldr	r1, [sp, #24]
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80085d6:	2290      	movs	r2, #144	; 0x90
        media_ptr -> fx_media_driver_read_requests++;
 80085d8:	444b      	add	r3, r9
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 80085da:	f8c4 8088 	str.w	r8, [r4, #136]	; 0x88

        /* Determine if the sector is a data sector or a system sector.  */
        if (sector_type == FX_DATA_SECTOR)
 80085de:	2904      	cmp	r1, #4
        media_ptr -> fx_media_driver_sectors =          sectors;
 80085e0:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 80085e4:	f8c4 10b8 	str.w	r1, [r4, #184]	; 0xb8
        media_ptr -> fx_media_driver_read_requests++;
 80085e8:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80085ec:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 80085f0:	e9c4 a624 	strd	sl, r6, [r4, #144]	; 0x90
        if (sector_type == FX_DATA_SECTOR)
 80085f4:	f000 80fc 	beq.w	80087f0 <_fx_utility_logical_sector_read+0x318>

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_READ, media_ptr, logical_sector, sectors, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to read the sector.  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 80085f8:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 80085fc:	4620      	mov	r0, r4
 80085fe:	4798      	blx	r3

        /* Clear data sector is present flag.  */
        media_ptr -> fx_media_driver_data_sector_read =  FX_FALSE;
 8008600:	2300      	movs	r3, #0

#ifndef FX_DISABLE_DIRECT_DATA_READ_CACHE_FILL

        /* Determine if the read was successful and if number of sectors just read will
           reasonably fit into the cache.  */
        if ((media_ptr -> fx_media_driver_status == FX_SUCCESS) && (sectors < (media_ptr -> fx_media_sector_cache_size / 4)))
 8008602:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
        media_ptr -> fx_media_driver_data_sector_read =  FX_FALSE;
 8008606:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
        if ((media_ptr -> fx_media_driver_status == FX_SUCCESS) && (sectors < (media_ptr -> fx_media_sector_cache_size / 4)))
 800860a:	2800      	cmp	r0, #0
 800860c:	d176      	bne.n	80086fc <_fx_utility_logical_sector_read+0x224>
 800860e:	6963      	ldr	r3, [r4, #20]
 8008610:	ebb5 0f93 	cmp.w	r5, r3, lsr #2
 8008614:	d272      	bcs.n	80086fc <_fx_utility_logical_sector_read+0x224>
 8008616:	f116 0801 	adds.w	r8, r6, #1
 800861a:	f105 31ff 	add.w	r1, r5, #4294967295

                    /* Invoke the driver to write the sector.  */
                    (media_ptr -> fx_media_driver_entry) (media_ptr);

                    /* Clear the system write flag.  */
                    media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800861e:	9007      	str	r0, [sp, #28]
 8008620:	f147 0900 	adc.w	r9, r7, #0
 8008624:	eb18 0201 	adds.w	r2, r8, r1
 8008628:	f149 0300 	adc.w	r3, r9, #0
                    media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800862c:	46d1      	mov	r9, sl
 800862e:	46a2      	mov	sl, r4
 8008630:	e9cd 2304 	strd	r2, r3, [sp, #16]
                cache_entry =  _fx_utility_logical_sector_cache_entry_read(media_ptr, logical_sector, &previous_cache_entry);
 8008634:	f8cd b000 	str.w	fp, [sp]
 8008638:	4632      	mov	r2, r6
 800863a:	463b      	mov	r3, r7
 800863c:	4650      	mov	r0, sl
 800863e:	f001 fed3 	bl	800a3e8 <_fx_utility_logical_sector_cache_entry_read>
                if (cache_entry == FX_NULL)
 8008642:	4604      	mov	r4, r0
 8008644:	2800      	cmp	r0, #0
 8008646:	d058      	beq.n	80086fa <_fx_utility_logical_sector_read+0x222>
                if ((cache_entry -> fx_cached_sector_valid) &&
 8008648:	7c42      	ldrb	r2, [r0, #17]
 800864a:	6803      	ldr	r3, [r0, #0]
 800864c:	b372      	cbz	r2, 80086ac <_fx_utility_logical_sector_read+0x1d4>
 800864e:	7c22      	ldrb	r2, [r4, #16]
                    (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008650:	4650      	mov	r0, sl
                if ((cache_entry -> fx_cached_sector_valid) &&
 8008652:	b35a      	cbz	r2, 80086ac <_fx_utility_logical_sector_read+0x1d4>
                    media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 8008654:	2101      	movs	r1, #1
                    media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8008656:	f8ca 3090 	str.w	r3, [sl, #144]	; 0x90
                    media_ptr -> fx_media_driver_write_requests++;
 800865a:	f8da 21b0 	ldr.w	r2, [sl, #432]	; 0x1b0
                    media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 800865e:	68a3      	ldr	r3, [r4, #8]
                    media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 8008660:	f8ca 1088 	str.w	r1, [sl, #136]	; 0x88
                    media_ptr -> fx_media_driver_write_requests++;
 8008664:	440a      	add	r2, r1
                    media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 8008666:	f8ca 3094 	str.w	r3, [sl, #148]	; 0x94
                    media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800866a:	2190      	movs	r1, #144	; 0x90
                    media_ptr -> fx_media_driver_sectors =          1;
 800866c:	2301      	movs	r3, #1
                    media_ptr -> fx_media_driver_write_requests++;
 800866e:	f8ca 21b0 	str.w	r2, [sl, #432]	; 0x1b0
                    media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8008672:	f8ca 108c 	str.w	r1, [sl, #140]	; 0x8c
                    media_ptr -> fx_media_driver_sectors =          1;
 8008676:	f8ca 3098 	str.w	r3, [sl, #152]	; 0x98
                    media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 800867a:	7ca3      	ldrb	r3, [r4, #18]
 800867c:	f8ca 30b8 	str.w	r3, [sl, #184]	; 0xb8
                    if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 8008680:	7ca3      	ldrb	r3, [r4, #18]
 8008682:	2b04      	cmp	r3, #4
 8008684:	d002      	beq.n	800868c <_fx_utility_logical_sector_read+0x1b4>
                        media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 8008686:	2301      	movs	r3, #1
 8008688:	f8ca 30b0 	str.w	r3, [sl, #176]	; 0xb0
                    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800868c:	f8da 30bc 	ldr.w	r3, [sl, #188]	; 0xbc
 8008690:	4798      	blx	r3
                    media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 8008692:	9b07      	ldr	r3, [sp, #28]

                    /* Check for successful completion.  */
                    if (media_ptr -> fx_media_driver_status)
 8008694:	f8da 008c 	ldr.w	r0, [sl, #140]	; 0x8c
                    media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 8008698:	f8ca 30b0 	str.w	r3, [sl, #176]	; 0xb0
                    if (media_ptr -> fx_media_driver_status)
 800869c:	bb70      	cbnz	r0, 80086fc <_fx_utility_logical_sector_read+0x224>
                        return(media_ptr -> fx_media_driver_status);
                    }

                    /* Clear the buffer dirty flag since it has been flushed
                       out.  */
                    cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 800869e:	7420      	strb	r0, [r4, #16]

                    /* Decrement the number of outstanding dirty cache entries.  */
                    media_ptr -> fx_media_sector_cache_dirty_count--;
 80086a0:	f8da 2024 	ldr.w	r2, [sl, #36]	; 0x24
 80086a4:	6823      	ldr	r3, [r4, #0]
 80086a6:	3a01      	subs	r2, #1
 80086a8:	f8ca 2024 	str.w	r2, [sl, #36]	; 0x24

                /* Remember the sector number.  */
                cache_entry -> fx_cached_sector =  logical_sector;

                /* Make the cache entry valid.  */
                cache_entry -> fx_cached_sector_valid =  FX_TRUE;
 80086ac:	f04f 0501 	mov.w	r5, #1

                /* Place this entry that the head of the cached sector
                   list.  */

                /* Determine if we need to update the last used list.  */
                if (previous_cache_entry)
 80086b0:	9a09      	ldr	r2, [sp, #36]	; 0x24
                        media_ptr -> fx_media_sector_cache_list_ptr;
                    media_ptr -> fx_media_sector_cache_list_ptr =  cache_entry;
                }

                /* Copy the data from the destination buffer to the cache entry.  */
                _fx_utility_memory_copy(buffer_ptr,
 80086b2:	4648      	mov	r0, r9
 80086b4:	4619      	mov	r1, r3
                cache_entry -> fx_cached_sector_valid =  FX_TRUE;
 80086b6:	7465      	strb	r5, [r4, #17]
                cache_entry -> fx_cached_sector_type =  sector_type;
 80086b8:	9d06      	ldr	r5, [sp, #24]
                cache_entry -> fx_cached_sector =  logical_sector;
 80086ba:	e9c4 6702 	strd	r6, r7, [r4, #8]
                cache_entry -> fx_cached_sector_type =  sector_type;
 80086be:	74a5      	strb	r5, [r4, #18]
                if (previous_cache_entry)
 80086c0:	2a00      	cmp	r2, #0
 80086c2:	f000 8098 	beq.w	80087f6 <_fx_utility_logical_sector_read+0x31e>
                    cache_entry -> fx_cached_sector_next_used =
 80086c6:	f8da 301c 	ldr.w	r3, [sl, #28]

                /* Advance the destination buffer.  */
                buffer_ptr =  ((UCHAR *)buffer_ptr) + media_ptr -> fx_media_bytes_per_sector;

                /* Advance the source sector and decrement the sector count.  */
                logical_sector++;
 80086ca:	3601      	adds	r6, #1
                    previous_cache_entry -> fx_cached_sector_next_used =
 80086cc:	6965      	ldr	r5, [r4, #20]
                logical_sector++;
 80086ce:	f147 0700 	adc.w	r7, r7, #0
                    previous_cache_entry -> fx_cached_sector_next_used =
 80086d2:	6155      	str	r5, [r2, #20]
                _fx_utility_memory_copy(buffer_ptr,
 80086d4:	f8da 2028 	ldr.w	r2, [sl, #40]	; 0x28
                    cache_entry -> fx_cached_sector_next_used =
 80086d8:	6163      	str	r3, [r4, #20]
                    media_ptr -> fx_media_sector_cache_list_ptr =  cache_entry;
 80086da:	f8ca 401c 	str.w	r4, [sl, #28]
                _fx_utility_memory_copy(buffer_ptr,
 80086de:	f000 f997 	bl	8008a10 <_fx_utility_memory_copy>
                buffer_ptr =  ((UCHAR *)buffer_ptr) + media_ptr -> fx_media_bytes_per_sector;
 80086e2:	f8da 3028 	ldr.w	r3, [sl, #40]	; 0x28
 80086e6:	4499      	add	r9, r3
            while (sectors)
 80086e8:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
 80086ec:	42a7      	cmp	r7, r4
 80086ee:	bf08      	it	eq
 80086f0:	429e      	cmpeq	r6, r3
 80086f2:	d19f      	bne.n	8008634 <_fx_utility_logical_sector_read+0x15c>
 80086f4:	f8da 008c 	ldr.w	r0, [sl, #140]	; 0x8c
            }
        }
#endif

        /* Return the driver status.  */
        return(media_ptr -> fx_media_driver_status);
 80086f8:	e000      	b.n	80086fc <_fx_utility_logical_sector_read+0x224>
            return(FX_SUCCESS);
 80086fa:	2000      	movs	r0, #0
    }
}
 80086fc:	b00b      	add	sp, #44	; 0x2c
 80086fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return(FX_SECTOR_INVALID);
 8008702:	2089      	movs	r0, #137	; 0x89
}
 8008704:	b00b      	add	sp, #44	; 0x2c
 8008706:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        cache_entry = _fx_utility_logical_sector_cache_entry_read(media_ptr, logical_sector, &previous_cache_entry);
 800870a:	a909      	add	r1, sp, #36	; 0x24
 800870c:	4632      	mov	r2, r6
 800870e:	463b      	mov	r3, r7
 8008710:	4620      	mov	r0, r4
 8008712:	9100      	str	r1, [sp, #0]
 8008714:	f001 fe68 	bl	800a3e8 <_fx_utility_logical_sector_cache_entry_read>
        if (cache_entry == FX_NULL)
 8008718:	4605      	mov	r5, r0
 800871a:	2800      	cmp	r0, #0
 800871c:	d0ed      	beq.n	80086fa <_fx_utility_logical_sector_read+0x222>
        media_ptr -> fx_media_logical_sector_cache_read_misses++;
 800871e:	f8d4 31a8 	ldr.w	r3, [r4, #424]	; 0x1a8
 8008722:	3301      	adds	r3, #1
 8008724:	f8c4 31a8 	str.w	r3, [r4, #424]	; 0x1a8
        if ((cache_entry -> fx_cached_sector_valid) &&
 8008728:	7c43      	ldrb	r3, [r0, #17]
 800872a:	b35b      	cbz	r3, 8008784 <_fx_utility_logical_sector_read+0x2ac>
 800872c:	7c03      	ldrb	r3, [r0, #16]
 800872e:	b34b      	cbz	r3, 8008784 <_fx_utility_logical_sector_read+0x2ac>
            media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 8008730:	2101      	movs	r1, #1
            media_ptr -> fx_media_driver_write_requests++;
 8008732:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
            media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8008736:	6802      	ldr	r2, [r0, #0]
            media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8008738:	2090      	movs	r0, #144	; 0x90
            media_ptr -> fx_media_driver_write_requests++;
 800873a:	440b      	add	r3, r1
            media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 800873c:	f8c4 1088 	str.w	r1, [r4, #136]	; 0x88
            media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 8008740:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
            media_ptr -> fx_media_driver_write_requests++;
 8008744:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
            media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 8008748:	68ab      	ldr	r3, [r5, #8]
            media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 800874a:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
            (media_ptr -> fx_media_driver_entry) (media_ptr);
 800874e:	4620      	mov	r0, r4
            media_ptr -> fx_media_driver_sectors =          1;
 8008750:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
            media_ptr -> fx_media_driver_logical_sector =   (ULONG)cache_entry -> fx_cached_sector;
 8008754:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
            media_ptr -> fx_media_driver_sector_type =      cache_entry -> fx_cached_sector_type;
 8008758:	7cab      	ldrb	r3, [r5, #18]
 800875a:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
            if (cache_entry -> fx_cached_sector_type != FX_DATA_SECTOR)
 800875e:	7cab      	ldrb	r3, [r5, #18]
 8008760:	2b04      	cmp	r3, #4
            (media_ptr -> fx_media_driver_entry) (media_ptr);
 8008762:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
                media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 8008766:	bf18      	it	ne
 8008768:	f8c4 10b0 	strne.w	r1, [r4, #176]	; 0xb0
            (media_ptr -> fx_media_driver_entry) (media_ptr);
 800876c:	4798      	blx	r3
            media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 800876e:	2300      	movs	r3, #0
            if (media_ptr -> fx_media_driver_status)
 8008770:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
            media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 8008774:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
            if (media_ptr -> fx_media_driver_status)
 8008778:	2800      	cmp	r0, #0
 800877a:	d1bf      	bne.n	80086fc <_fx_utility_logical_sector_read+0x224>
            cache_entry -> fx_cached_sector_buffer_dirty =  FX_FALSE;
 800877c:	7428      	strb	r0, [r5, #16]
            media_ptr -> fx_media_sector_cache_dirty_count--;
 800877e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008780:	3b01      	subs	r3, #1
 8008782:	6263      	str	r3, [r4, #36]	; 0x24
        if (logical_sector >= (ULONG)media_ptr -> fx_media_total_sectors)
 8008784:	2100      	movs	r1, #0
 8008786:	e9d4 230e 	ldrd	r2, r3, [r4, #56]	; 0x38
 800878a:	428f      	cmp	r7, r1
 800878c:	bf08      	it	eq
 800878e:	4296      	cmpeq	r6, r2
 8008790:	d2b7      	bcs.n	8008702 <_fx_utility_logical_sector_read+0x22a>
        media_ptr -> fx_media_driver_read_requests++;
 8008792:	f8d4 31ac 	ldr.w	r3, [r4, #428]	; 0x1ac
        media_ptr -> fx_media_driver_request =          FX_DRIVER_READ;
 8008796:	2100      	movs	r1, #0
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 8008798:	2290      	movs	r2, #144	; 0x90
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 800879a:	4620      	mov	r0, r4
        media_ptr -> fx_media_driver_read_requests++;
 800879c:	3301      	adds	r3, #1
 800879e:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
        media_ptr -> fx_media_driver_buffer =           cache_entry -> fx_cached_sector_memory_buffer;
 80087a2:	682b      	ldr	r3, [r5, #0]
 80087a4:	e9c4 3624 	strd	r3, r6, [r4, #144]	; 0x90
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 80087a8:	9b06      	ldr	r3, [sp, #24]
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80087aa:	e9c4 1222 	strd	r1, r2, [r4, #136]	; 0x88
        if (sector_type == FX_DATA_SECTOR)
 80087ae:	2b04      	cmp	r3, #4
        media_ptr -> fx_media_driver_sectors =          1;
 80087b0:	f04f 0201 	mov.w	r2, #1
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 80087b4:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
        media_ptr -> fx_media_driver_sectors =          1;
 80087b8:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
            media_ptr -> fx_media_driver_data_sector_read =  FX_TRUE;
 80087bc:	bf08      	it	eq
 80087be:	f8c4 20b4 	streq.w	r2, [r4, #180]	; 0xb4
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 80087c2:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 80087c6:	4798      	blx	r3
        media_ptr -> fx_media_driver_data_sector_read =  FX_FALSE;
 80087c8:	2300      	movs	r3, #0
        if (media_ptr -> fx_media_driver_status == FX_SUCCESS)
 80087ca:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
        media_ptr -> fx_media_driver_data_sector_read =  FX_FALSE;
 80087ce:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
        if (media_ptr -> fx_media_driver_status == FX_SUCCESS)
 80087d2:	bb12      	cbnz	r2, 800881a <_fx_utility_logical_sector_read+0x342>
            cache_entry -> fx_cached_sector_type =  sector_type;
 80087d4:	9b06      	ldr	r3, [sp, #24]
            cache_entry -> fx_cached_sector_valid =  FX_TRUE;
 80087d6:	2201      	movs	r2, #1
            cache_entry -> fx_cached_sector_type =  sector_type;
 80087d8:	74ab      	strb	r3, [r5, #18]
            if (previous_cache_entry)
 80087da:	9b09      	ldr	r3, [sp, #36]	; 0x24
            cache_entry -> fx_cached_sector_valid =  FX_TRUE;
 80087dc:	746a      	strb	r2, [r5, #17]
            cache_entry -> fx_cached_sector =  logical_sector;
 80087de:	e9c5 6702 	strd	r6, r7, [r5, #8]
            if (previous_cache_entry)
 80087e2:	b30b      	cbz	r3, 8008828 <_fx_utility_logical_sector_read+0x350>
                    cache_entry -> fx_cached_sector_next_used;
 80087e4:	6969      	ldr	r1, [r5, #20]
                cache_entry -> fx_cached_sector_next_used =
 80087e6:	69e2      	ldr	r2, [r4, #28]
                previous_cache_entry -> fx_cached_sector_next_used =
 80087e8:	6159      	str	r1, [r3, #20]
                cache_entry -> fx_cached_sector_next_used =
 80087ea:	616a      	str	r2, [r5, #20]
                media_ptr -> fx_media_sector_cache_list_ptr =  cache_entry;
 80087ec:	61e5      	str	r5, [r4, #28]
 80087ee:	e01b      	b.n	8008828 <_fx_utility_logical_sector_read+0x350>
            media_ptr -> fx_media_driver_data_sector_read =  FX_TRUE;
 80087f0:	f8c4 90b4 	str.w	r9, [r4, #180]	; 0xb4
 80087f4:	e700      	b.n	80085f8 <_fx_utility_logical_sector_read+0x120>
                logical_sector++;
 80087f6:	3601      	adds	r6, #1
                _fx_utility_memory_copy(buffer_ptr,
 80087f8:	f8da 2028 	ldr.w	r2, [sl, #40]	; 0x28
                logical_sector++;
 80087fc:	f147 0700 	adc.w	r7, r7, #0
                _fx_utility_memory_copy(buffer_ptr,
 8008800:	f000 f906 	bl	8008a10 <_fx_utility_memory_copy>
                buffer_ptr =  ((UCHAR *)buffer_ptr) + media_ptr -> fx_media_bytes_per_sector;
 8008804:	f8da 3028 	ldr.w	r3, [sl, #40]	; 0x28
 8008808:	4499      	add	r9, r3
            while (sectors)
 800880a:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
 800880e:	42bc      	cmp	r4, r7
 8008810:	bf08      	it	eq
 8008812:	42b3      	cmpeq	r3, r6
 8008814:	f47f af0e 	bne.w	8008634 <_fx_utility_logical_sector_read+0x15c>
 8008818:	e76c      	b.n	80086f4 <_fx_utility_logical_sector_read+0x21c>
            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 800881a:	f04f 30ff 	mov.w	r0, #4294967295
 800881e:	f04f 31ff 	mov.w	r1, #4294967295
            cache_entry -> fx_cached_sector_valid =  FX_FALSE;
 8008822:	746b      	strb	r3, [r5, #17]
            cache_entry -> fx_cached_sector =  (~(ULONG64)0);
 8008824:	e9c5 0102 	strd	r0, r1, [r5, #8]
        media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 8008828:	682b      	ldr	r3, [r5, #0]
        return(media_ptr -> fx_media_driver_status);
 800882a:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
        media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 800882e:	60a3      	str	r3, [r4, #8]
        return(media_ptr -> fx_media_driver_status);
 8008830:	e764      	b.n	80086fc <_fx_utility_logical_sector_read+0x224>
 8008832:	bf00      	nop

08008834 <_fx_utility_logical_sector_write>:
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_utility_logical_sector_write(FX_MEDIA *media_ptr, ULONG64 logical_sector,
                                       VOID *buffer_ptr, ULONG sectors, UCHAR sector_type)
{
 8008834:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008838:	b085      	sub	sp, #20
 800883a:	4604      	mov	r4, r0
 800883c:	4616      	mov	r6, r2
 800883e:	461f      	mov	r7, r3
 8008840:	f89d 5040 	ldrb.w	r5, [sp, #64]	; 0x40
 8008844:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Determine if the request is for FAT sector.  */
    if (sector_type == FX_FAT_SECTOR)
 8008848:	2d02      	cmp	r5, #2
 800884a:	d104      	bne.n	8008856 <_fx_utility_logical_sector_write+0x22>
    {

        /* Increment the number of FAT sector writes.  */
        media_ptr -> fx_media_fat_sector_writes++;
 800884c:	f8d0 3198 	ldr.w	r3, [r0, #408]	; 0x198
 8008850:	3301      	adds	r3, #1
 8008852:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
    }

    /* Increment the number of logical sectors written.  */
    media_ptr -> fx_media_logical_sector_writes++;
 8008856:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0

    /* Extended port-specific processing macro, which is by default defined to white space.  */
    FX_UTILITY_LOGICAL_SECTOR_WRITE_EXTENSION

    /* Determine if the request is from the internal media buffer area.  */
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 800885a:	68a2      	ldr	r2, [r4, #8]
    media_ptr -> fx_media_logical_sector_writes++;
 800885c:	3301      	adds	r3, #1
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 800885e:	4552      	cmp	r2, sl
    media_ptr -> fx_media_logical_sector_writes++;
 8008860:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
    if ((((UCHAR *)buffer_ptr) >= media_ptr -> fx_media_memory_buffer) &&
 8008864:	d802      	bhi.n	800886c <_fx_utility_logical_sector_write+0x38>
 8008866:	69a3      	ldr	r3, [r4, #24]
 8008868:	4553      	cmp	r3, sl
 800886a:	d24b      	bcs.n	8008904 <_fx_utility_logical_sector_write+0xd0>

        /* Otherwise, the write request is being made directly from an application
           buffer. Determine if the logical sector is valid.  */

        /* Is the logical sector valid? */
        if ((logical_sector == 0) || (logical_sector == ((ULONG)0xFFFFFFFF)))
 800886c:	ea56 0307 	orrs.w	r3, r6, r7
 8008870:	d044      	beq.n	80088fc <_fx_utility_logical_sector_write+0xc8>
 8008872:	2f00      	cmp	r7, #0
 8008874:	bf08      	it	eq
 8008876:	f1b6 3fff 	cmpeq.w	r6, #4294967295
 800887a:	d03f      	beq.n	80088fc <_fx_utility_logical_sector_write+0xc8>
        {
            return(FX_SECTOR_INVALID);
        }

        /* Compare logical sector against total sectors to make sure it is valid.  */
        if ((logical_sector + sectors - 1) >= (ULONG)media_ptr -> fx_media_total_sectors)
 800887c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800887e:	f04f 0900 	mov.w	r9, #0
 8008882:	2100      	movs	r1, #0
 8008884:	4698      	mov	r8, r3
 8008886:	eb18 0b06 	adds.w	fp, r8, r6
 800888a:	eb49 0c07 	adc.w	ip, r9, r7
 800888e:	f11b 30ff 	adds.w	r0, fp, #4294967295
 8008892:	e9d4 230e 	ldrd	r2, r3, [r4, #56]	; 0x38
 8008896:	460b      	mov	r3, r1
 8008898:	f14c 31ff 	adc.w	r1, ip, #4294967295
 800889c:	4299      	cmp	r1, r3
 800889e:	bf08      	it	eq
 80088a0:	4290      	cmpeq	r0, r2
 80088a2:	d22b      	bcs.n	80088fc <_fx_utility_logical_sector_write+0xc8>
        {
            return(FX_SECTOR_INVALID);
        }

        /* Flush and invalidate for any entries in the cache that are in this direct I/O read request range.  */
        _fx_utility_logical_sector_flush(media_ptr, logical_sector, (ULONG64) sectors, FX_TRUE);
 80088a4:	f04f 0b01 	mov.w	fp, #1
 80088a8:	4632      	mov	r2, r6
 80088aa:	463b      	mov	r3, r7
 80088ac:	4620      	mov	r0, r4
 80088ae:	f8cd b008 	str.w	fp, [sp, #8]
 80088b2:	e9cd 8900 	strd	r8, r9, [sp]
 80088b6:	f7ff faeb 	bl	8007e90 <_fx_utility_logical_sector_flush>

#ifndef FX_MEDIA_STATISTICS_DISABLE

        /* Increment the number of driver write sector(s) requests.  */
        media_ptr -> fx_media_driver_write_requests++;
 80088ba:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
#endif

        /* Build request to the driver.  */
        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80088be:	2290      	movs	r2, #144	; 0x90
#ifdef FX_DRIVER_USE_64BIT_LBA
        media_ptr -> fx_media_driver_logical_sector =   logical_sector;
#else
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
#endif
        media_ptr -> fx_media_driver_sectors =          sectors;
 80088c0:	990f      	ldr	r1, [sp, #60]	; 0x3c
        media_ptr -> fx_media_driver_write_requests++;
 80088c2:	445b      	add	r3, fp
        media_ptr -> fx_media_driver_sector_type =      sector_type;

        /* Determine if the system write flag needs to be set.  */
        if (sector_type != FX_DATA_SECTOR)
 80088c4:	2d04      	cmp	r5, #4
        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 80088c6:	f8c4 b088 	str.w	fp, [r4, #136]	; 0x88
        media_ptr -> fx_media_driver_sectors =          sectors;
 80088ca:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 80088ce:	f8c4 50b8 	str.w	r5, [r4, #184]	; 0xb8
        media_ptr -> fx_media_driver_write_requests++;
 80088d2:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80088d6:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        {

            /* Yes, a system sector write is present so set the flag.  The driver
               can use this flag to make extra safeguards in writing the sector
               out, yielding more fault tolerance.  */
            media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 80088da:	bf18      	it	ne
 80088dc:	f8c4 b0b0 	strne.w	fp, [r4, #176]	; 0xb0
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 80088e0:	e9c4 a624 	strd	sl, r6, [r4, #144]	; 0x90

        /* If trace is enabled, insert this event into the trace buffer.  */
        FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_IO_DRIVER_WRITE, media_ptr, logical_sector, sectors, buffer_ptr, FX_TRACE_INTERNAL_EVENTS, 0, 0)

        /* Invoke the driver to write the sector(s).  */
        (media_ptr -> fx_media_driver_entry) (media_ptr);
 80088e4:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 80088e8:	4620      	mov	r0, r4
 80088ea:	4798      	blx	r3

        /* Clear the system write flag.  */
        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 80088ec:	2300      	movs	r3, #0

        /* Return driver status.  */
        return(media_ptr -> fx_media_driver_status);
 80088ee:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
        media_ptr -> fx_media_driver_system_write =  FX_FALSE;
 80088f2:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
    }
}
 80088f6:	b005      	add	sp, #20
 80088f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            return(FX_SECTOR_INVALID);
 80088fc:	2089      	movs	r0, #137	; 0x89
}
 80088fe:	b005      	add	sp, #20
 8008900:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (media_ptr -> fx_media_sector_cache_hashed)
 8008904:	6923      	ldr	r3, [r4, #16]
 8008906:	2b00      	cmp	r3, #0
 8008908:	d062      	beq.n	80089d0 <_fx_utility_logical_sector_write+0x19c>
            index =  (ULONG)(logical_sector & media_ptr -> fx_media_sector_cache_hash_mask) * FX_SECTOR_CACHE_DEPTH;
 800890a:	f242 43a0 	movw	r3, #9376	; 0x24a0
 800890e:	58e1      	ldr	r1, [r4, r3]
 8008910:	4031      	ands	r1, r6
            cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 8008912:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8008916:	eb04 1141 	add.w	r1, r4, r1, lsl #5
 800891a:	f501 614a 	add.w	r1, r1, #3232	; 0xca0
                if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800891e:	7c4b      	ldrb	r3, [r1, #17]
 8008920:	b12b      	cbz	r3, 800892e <_fx_utility_logical_sector_write+0xfa>
 8008922:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 8008926:	429f      	cmp	r7, r3
 8008928:	bf08      	it	eq
 800892a:	4296      	cmpeq	r6, r2
 800892c:	d063      	beq.n	80089f6 <_fx_utility_logical_sector_write+0x1c2>
 800892e:	f891 3029 	ldrb.w	r3, [r1, #41]	; 0x29
            for (i = 0; i < FX_SECTOR_CACHE_DEPTH; i++, cache_entry++)
 8008932:	f101 0018 	add.w	r0, r1, #24
                if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 8008936:	b12b      	cbz	r3, 8008944 <_fx_utility_logical_sector_write+0x110>
 8008938:	e9d1 2308 	ldrd	r2, r3, [r1, #32]
 800893c:	429f      	cmp	r7, r3
 800893e:	bf08      	it	eq
 8008940:	4296      	cmpeq	r6, r2
 8008942:	d062      	beq.n	8008a0a <_fx_utility_logical_sector_write+0x1d6>
 8008944:	f891 3041 	ldrb.w	r3, [r1, #65]	; 0x41
            for (i = 0; i < FX_SECTOR_CACHE_DEPTH; i++, cache_entry++)
 8008948:	f101 0030 	add.w	r0, r1, #48	; 0x30
                if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800894c:	b12b      	cbz	r3, 800895a <_fx_utility_logical_sector_write+0x126>
 800894e:	e9d1 230e 	ldrd	r2, r3, [r1, #56]	; 0x38
 8008952:	429f      	cmp	r7, r3
 8008954:	bf08      	it	eq
 8008956:	4296      	cmpeq	r6, r2
 8008958:	d057      	beq.n	8008a0a <_fx_utility_logical_sector_write+0x1d6>
 800895a:	f891 3059 	ldrb.w	r3, [r1, #89]	; 0x59
            for (i = 0; i < FX_SECTOR_CACHE_DEPTH; i++, cache_entry++)
 800895e:	f101 0248 	add.w	r2, r1, #72	; 0x48
                if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 8008962:	b12b      	cbz	r3, 8008970 <_fx_utility_logical_sector_write+0x13c>
 8008964:	e9d1 0114 	ldrd	r0, r1, [r1, #80]	; 0x50
 8008968:	42b9      	cmp	r1, r7
 800896a:	bf08      	it	eq
 800896c:	42b0      	cmpeq	r0, r6
 800896e:	d041      	beq.n	80089f4 <_fx_utility_logical_sector_write+0x1c0>
        if ((logical_sector == 0) || (logical_sector == ((ULONG)0xFFFFFFFF)))
 8008970:	ea56 0307 	orrs.w	r3, r6, r7
 8008974:	d0c2      	beq.n	80088fc <_fx_utility_logical_sector_write+0xc8>
 8008976:	2f00      	cmp	r7, #0
 8008978:	bf08      	it	eq
 800897a:	f1b6 3fff 	cmpeq.w	r6, #4294967295
 800897e:	d0bd      	beq.n	80088fc <_fx_utility_logical_sector_write+0xc8>
        if ((logical_sector + sectors - 1) >= (ULONG)media_ptr -> fx_media_total_sectors)
 8008980:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008982:	eb16 0803 	adds.w	r8, r6, r3
 8008986:	f147 0900 	adc.w	r9, r7, #0
 800898a:	f118 30ff 	adds.w	r0, r8, #4294967295
 800898e:	f149 31ff 	adc.w	r1, r9, #4294967295
 8008992:	f04f 0900 	mov.w	r9, #0
 8008996:	e9d4 230e 	ldrd	r2, r3, [r4, #56]	; 0x38
 800899a:	4549      	cmp	r1, r9
 800899c:	bf08      	it	eq
 800899e:	4290      	cmpeq	r0, r2
 80089a0:	d2ac      	bcs.n	80088fc <_fx_utility_logical_sector_write+0xc8>
        media_ptr -> fx_media_driver_write_requests++;
 80089a2:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
        media_ptr -> fx_media_driver_request =          FX_DRIVER_WRITE;
 80089a6:	2201      	movs	r2, #1
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80089a8:	2190      	movs	r1, #144	; 0x90
        media_ptr -> fx_media_driver_sectors =          sectors;
 80089aa:	980f      	ldr	r0, [sp, #60]	; 0x3c
        media_ptr -> fx_media_driver_write_requests++;
 80089ac:	4413      	add	r3, r2
        if (sector_type != FX_DATA_SECTOR)
 80089ae:	2d04      	cmp	r5, #4
        media_ptr -> fx_media_driver_buffer =           buffer_ptr;
 80089b0:	f8c4 a090 	str.w	sl, [r4, #144]	; 0x90
        media_ptr -> fx_media_driver_logical_sector =   (ULONG)logical_sector;
 80089b4:	f8c4 6094 	str.w	r6, [r4, #148]	; 0x94
        media_ptr -> fx_media_driver_sectors =          sectors;
 80089b8:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
        media_ptr -> fx_media_driver_sector_type =      sector_type;
 80089bc:	f8c4 50b8 	str.w	r5, [r4, #184]	; 0xb8
        media_ptr -> fx_media_driver_write_requests++;
 80089c0:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
        media_ptr -> fx_media_driver_status =           FX_IO_ERROR;
 80089c4:	e9c4 2122 	strd	r2, r1, [r4, #136]	; 0x88
        if (sector_type != FX_DATA_SECTOR)
 80089c8:	d08c      	beq.n	80088e4 <_fx_utility_logical_sector_write+0xb0>
            media_ptr -> fx_media_driver_system_write =  FX_TRUE;
 80089ca:	f8c4 20b0 	str.w	r2, [r4, #176]	; 0xb0
 80089ce:	e789      	b.n	80088e4 <_fx_utility_logical_sector_write+0xb0>
            cache_size =            media_ptr -> fx_media_sector_cache_size;
 80089d0:	6960      	ldr	r0, [r4, #20]
            cache_entry =           media_ptr -> fx_media_sector_cache_list_ptr;
 80089d2:	69e1      	ldr	r1, [r4, #28]
            while (cache_size--)
 80089d4:	2800      	cmp	r0, #0
 80089d6:	d0cb      	beq.n	8008970 <_fx_utility_logical_sector_write+0x13c>
                if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 80089d8:	7c4b      	ldrb	r3, [r1, #17]
 80089da:	3801      	subs	r0, #1
 80089dc:	b12b      	cbz	r3, 80089ea <_fx_utility_logical_sector_write+0x1b6>
 80089de:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 80089e2:	42bb      	cmp	r3, r7
 80089e4:	bf08      	it	eq
 80089e6:	42b2      	cmpeq	r2, r6
 80089e8:	d005      	beq.n	80089f6 <_fx_utility_logical_sector_write+0x1c2>
                if (cache_entry -> fx_cached_sector_next_used)
 80089ea:	694b      	ldr	r3, [r1, #20]
 80089ec:	2b00      	cmp	r3, #0
 80089ee:	bf18      	it	ne
 80089f0:	4619      	movne	r1, r3
 80089f2:	e7ef      	b.n	80089d4 <_fx_utility_logical_sector_write+0x1a0>
 80089f4:	4611      	mov	r1, r2
            if (cache_entry -> fx_cached_sector_buffer_dirty == FX_FALSE)
 80089f6:	7c08      	ldrb	r0, [r1, #16]
 80089f8:	b108      	cbz	r0, 80089fe <_fx_utility_logical_sector_write+0x1ca>
            return(FX_SUCCESS);
 80089fa:	2000      	movs	r0, #0
 80089fc:	e77f      	b.n	80088fe <_fx_utility_logical_sector_write+0xca>
                media_ptr -> fx_media_sector_cache_dirty_count++;
 80089fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
                cache_entry -> fx_cached_sector_buffer_dirty =  FX_TRUE;
 8008a00:	2201      	movs	r2, #1
                media_ptr -> fx_media_sector_cache_dirty_count++;
 8008a02:	4413      	add	r3, r2
 8008a04:	6263      	str	r3, [r4, #36]	; 0x24
                cache_entry -> fx_cached_sector_buffer_dirty =  FX_TRUE;
 8008a06:	740a      	strb	r2, [r1, #16]
 8008a08:	e779      	b.n	80088fe <_fx_utility_logical_sector_write+0xca>
                if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 8008a0a:	4601      	mov	r1, r0
 8008a0c:	e7f3      	b.n	80089f6 <_fx_utility_logical_sector_write+0x1c2>
 8008a0e:	bf00      	nop

08008a10 <_fx_utility_memory_copy>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _fx_utility_memory_copy(UCHAR *source_ptr, UCHAR *dest_ptr, ULONG size)
{
 8008a10:	460b      	mov	r3, r1

    /* Copy the memory.  */
    memcpy(dest_ptr, source_ptr, size);
 8008a12:	4601      	mov	r1, r0
 8008a14:	4618      	mov	r0, r3
 8008a16:	f005 b957 	b.w	800dcc8 <memcpy>
 8008a1a:	bf00      	nop

08008a1c <_fx_directory_entry_read>:
                                   ULONG *entry_ptr, FX_DIR_ENTRY *destination_ptr)
#else
UINT  _fx_directory_entry_read(FX_MEDIA *media_ptr, FX_DIR_ENTRY *source_dir,
                               ULONG *entry_ptr, FX_DIR_ENTRY *destination_ptr)
#endif /* FX_ENABLE_EXFAT */
{
 8008a1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008a20:	461f      	mov	r7, r3


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of directory entry read requests.  */
    media_ptr -> fx_media_directory_entry_reads++;
 8008a22:	f8d0 3168 	ldr.w	r3, [r0, #360]	; 0x168
{
 8008a26:	b091      	sub	sp, #68	; 0x44
ULONG  cluster, next_cluster = 0;
 8008a28:	f04f 0c00 	mov.w	ip, #0

    /* Determine if a sub-directory or FAT32 root directory is specified.  */
#ifdef FX_ENABLE_EXFAT
    if ((source_dir) || (media_ptr -> fx_media_FAT_type == FX_FAT32))
#else
    if ((source_dir) || (media_ptr -> fx_media_32_bit_FAT))
 8008a2c:	468b      	mov	fp, r1
    media_ptr -> fx_media_directory_entry_reads++;
 8008a2e:	3301      	adds	r3, #1
ULONG  entry = *entry_ptr;
 8008a30:	6811      	ldr	r1, [r2, #0]
{
 8008a32:	4606      	mov	r6, r0
 8008a34:	9207      	str	r2, [sp, #28]
ULONG  entry = *entry_ptr;
 8008a36:	9106      	str	r1, [sp, #24]
    byte_offset =  entry * FX_DIR_ENTRY_SIZE;
 8008a38:	ea4f 1841 	mov.w	r8, r1, lsl #5
 8008a3c:	6a82      	ldr	r2, [r0, #40]	; 0x28
ULONG  cluster, next_cluster = 0;
 8008a3e:	f8cd c03c 	str.w	ip, [sp, #60]	; 0x3c
    media_ptr -> fx_media_directory_entry_reads++;
 8008a42:	f8c0 3168 	str.w	r3, [r0, #360]	; 0x168
    if ((source_dir) || (media_ptr -> fx_media_32_bit_FAT))
 8008a46:	f1bb 0f00 	cmp.w	fp, #0
 8008a4a:	f000 8098 	beq.w	8008b7e <_fx_directory_entry_read+0x162>

        /* Yes, a sub-directory is present.  */

        /* Calculate the number of bytes per cluster.  */
        bytes_per_cluster =  ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
            ((ULONG)media_ptr -> fx_media_sectors_per_cluster);
 8008a4e:	6d40      	ldr	r0, [r0, #84]	; 0x54
        bytes_per_cluster =  ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 8008a50:	fb00 f302 	mul.w	r3, r0, r2

        /* Check for invalid value.  */
        if (bytes_per_cluster == 0)
 8008a54:	2b00      	cmp	r3, #0
 8008a56:	f000 809a 	beq.w	8008b8e <_fx_directory_entry_read+0x172>
        /* Determine if there is a sub-directory.  */
        if (source_dir)
        {

            /* Determine if this source directory has valid information from the previous call.  */
            if ((source_dir -> fx_dir_entry_last_search_cluster) &&
 8008a5a:	f8db 1050 	ldr.w	r1, [fp, #80]	; 0x50
        relative_cluster =   (UINT)(byte_offset / bytes_per_cluster);
 8008a5e:	fbb8 faf3 	udiv	sl, r8, r3
        byte_offset =  byte_offset % bytes_per_cluster;
 8008a62:	fb03 881a 	mls	r8, r3, sl, r8
        relative_sector =    (UINT)(byte_offset / ((ULONG)media_ptr -> fx_media_bytes_per_sector));
 8008a66:	fbb8 f3f2 	udiv	r3, r8, r2
 8008a6a:	9305      	str	r3, [sp, #20]
            if ((source_dir -> fx_dir_entry_last_search_cluster) &&
 8008a6c:	b121      	cbz	r1, 8008a78 <_fx_directory_entry_read+0x5c>
                (source_dir -> fx_dir_entry_last_search_relative_cluster <= relative_cluster) &&
 8008a6e:	f8db 9054 	ldr.w	r9, [fp, #84]	; 0x54
            if ((source_dir -> fx_dir_entry_last_search_cluster) &&
 8008a72:	45d1      	cmp	r9, sl
 8008a74:	f240 80a9 	bls.w	8008bca <_fx_directory_entry_read+0x1ae>
            else
            {

                /* Nothing from the previous directory read, just setup the starting cluster to the
                   beginning of the sub-directory.  */
                cluster =  source_dir -> fx_dir_entry_cluster;
 8008a78:	f8db 1034 	ldr.w	r1, [fp, #52]	; 0x34

                /* Setup the relative cluster index to zero.  */
                i =  0;
 8008a7c:	f04f 0900 	mov.w	r9, #0
            /* Setup the relative cluster index to zero.  */
            i =  0;
        }

        /* Loop to position to the appropriate cluster.  */
        while (i < relative_cluster)
 8008a80:	45d1      	cmp	r9, sl
 8008a82:	d21d      	bcs.n	8008ac0 <_fx_directory_entry_read+0xa4>
        {

            /* Check the value of the new cluster - it must be a valid cluster number
               or something is really wrong!  */
            if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8008a84:	2901      	cmp	r1, #1
 8008a86:	f240 8092 	bls.w	8008bae <_fx_directory_entry_read+0x192>
 8008a8a:	f242 45a8 	movw	r5, #9384	; 0x24a8
 8008a8e:	5973      	ldr	r3, [r6, r5]
 8008a90:	428b      	cmp	r3, r1
 8008a92:	f240 808c 	bls.w	8008bae <_fx_directory_entry_read+0x192>
 8008a96:	4435      	add	r5, r6
 8008a98:	e006      	b.n	8008aa8 <_fx_directory_entry_read+0x8c>
 8008a9a:	2901      	cmp	r1, #1
 8008a9c:	f240 8087 	bls.w	8008bae <_fx_directory_entry_read+0x192>
 8008aa0:	682b      	ldr	r3, [r5, #0]
 8008aa2:	428b      	cmp	r3, r1
 8008aa4:	f240 8083 	bls.w	8008bae <_fx_directory_entry_read+0x192>
                /* Send error message back to caller.  */
                return(FX_FILE_CORRUPT);
            }

            /* Read the next cluster.  */
            status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8008aa8:	aa0f      	add	r2, sp, #60	; 0x3c
 8008aaa:	4630      	mov	r0, r6

            /* Setup the actual cluster.  */
            cluster = next_cluster;

            /* Increment the relative cluster number.  */
            i++;
 8008aac:	f109 0901 	add.w	r9, r9, #1
            status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8008ab0:	f7fe fe98 	bl	80077e4 <_fx_utility_FAT_entry_read>
            if (status != FX_SUCCESS)
 8008ab4:	2800      	cmp	r0, #0
 8008ab6:	d16b      	bne.n	8008b90 <_fx_directory_entry_read+0x174>
        while (i < relative_cluster)
 8008ab8:	45d1      	cmp	r9, sl
            cluster = next_cluster;
 8008aba:	990f      	ldr	r1, [sp, #60]	; 0x3c
        while (i < relative_cluster)
 8008abc:	d1ed      	bne.n	8008a9a <_fx_directory_entry_read+0x7e>
 8008abe:	6d70      	ldr	r0, [r6, #84]	; 0x54
        }

        /* At this point, the directory data sector needs to be read.  */
        logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8008ac0:	6d32      	ldr	r2, [r6, #80]	; 0x50
            (((ULONG)cluster - FX_FAT_ENTRY_START) *
 8008ac2:	1e8c      	subs	r4, r1, #2
 8008ac4:	9108      	str	r1, [sp, #32]
             ((ULONG)media_ptr -> fx_media_sectors_per_cluster)) +
            relative_sector;

        /* Read the logical directory sector.  */
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008ac6:	2303      	movs	r3, #3
        logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8008ac8:	9905      	ldr	r1, [sp, #20]
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008aca:	2500      	movs	r5, #0
 8008acc:	9302      	str	r3, [sp, #8]
 8008ace:	f04f 0c01 	mov.w	ip, #1
        logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8008ad2:	440a      	add	r2, r1
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008ad4:	462b      	mov	r3, r5
        logical_sector =    ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8008ad6:	fb00 2904 	mla	r9, r0, r4, r2
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008ada:	68b4      	ldr	r4, [r6, #8]
 8008adc:	4630      	mov	r0, r6
 8008ade:	f8cd c004 	str.w	ip, [sp, #4]
 8008ae2:	464a      	mov	r2, r9
 8008ae4:	9400      	str	r4, [sp, #0]
 8008ae6:	f7ff fcf7 	bl	80084d8 <_fx_utility_logical_sector_read>
                                                  media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DIRECTORY_SECTOR);

        /* Determine if an error occurred.  */
        if (status != FX_SUCCESS)
 8008aea:	2800      	cmp	r0, #0
 8008aec:	d150      	bne.n	8008b90 <_fx_directory_entry_read+0x174>
            /* Return error code.  */
            return(status);
        }

        /* Calculate the byte offset within this sector.  */
        byte_offset =  byte_offset % media_ptr -> fx_media_bytes_per_sector;
 8008aee:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8008af0:	9908      	ldr	r1, [sp, #32]
 8008af2:	fbb8 f0f3 	udiv	r0, r8, r3
 8008af6:	fb03 8010 	mls	r0, r3, r0, r8
            ((logical_sector - (ULONG)media_ptr -> fx_media_root_sector_start) *
             media_ptr -> fx_media_bytes_per_sector);
    }

    /* Setup a pointer into the buffer.  */
    read_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 8008afa:	68b3      	ldr	r3, [r6, #8]
    /* Save the logical sector and byte offset in the returned directory entry.  */
    destination_ptr -> fx_dir_entry_log_sector =       logical_sector;
    destination_ptr -> fx_dir_entry_byte_offset =      byte_offset;

    /* Clear the short file name information.  */
    destination_ptr -> fx_dir_entry_long_name_shorted =  0;
 8008afc:	f04f 0e00 	mov.w	lr, #0
    destination_ptr -> fx_dir_entry_log_sector =       logical_sector;
 8008b00:	647d      	str	r5, [r7, #68]	; 0x44
    read_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT)byte_offset;
 8008b02:	181c      	adds	r4, r3, r0
    destination_ptr -> fx_dir_entry_log_sector =       logical_sector;
 8008b04:	f8c7 9040 	str.w	r9, [r7, #64]	; 0x40
    destination_ptr -> fx_dir_entry_byte_offset =      byte_offset;
 8008b08:	64b8      	str	r0, [r7, #72]	; 0x48
    destination_ptr -> fx_dir_entry_long_name_shorted =  0;
 8008b0a:	f8c7 e018 	str.w	lr, [r7, #24]
    destination_ptr -> fx_dir_entry_short_name[0]     =  0;
 8008b0e:	f887 e004 	strb.w	lr, [r7, #4]
    /* Setup short name pointer.  */
    short_name_ptr =  destination_ptr -> fx_dir_entry_name;

    /* Check if long file name exists.  */
    get_short_name =  0;
    if ((*(read_ptr + 11) == (UCHAR)FX_LONG_NAME) && (*read_ptr != (UCHAR)FX_DIR_ENTRY_FREE))
 8008b12:	f894 c00b 	ldrb.w	ip, [r4, #11]
    short_name_ptr =  destination_ptr -> fx_dir_entry_name;
 8008b16:	683d      	ldr	r5, [r7, #0]
    if ((*(read_ptr + 11) == (UCHAR)FX_LONG_NAME) && (*read_ptr != (UCHAR)FX_DIR_ENTRY_FREE))
 8008b18:	f1bc 0f0f 	cmp.w	ip, #15
 8008b1c:	f000 8174 	beq.w	8008e08 <_fx_directory_entry_read+0x3ec>
    /* Determine if we need to clear the long name flag.  */
    if (get_short_name == 1)
    {

        /* Clear the long name flag.  */
        destination_ptr -> fx_dir_entry_long_name_present =  0;
 8008b20:	2300      	movs	r3, #0
 8008b22:	2201      	movs	r2, #1
 8008b24:	617b      	str	r3, [r7, #20]
 8008b26:	920b      	str	r2, [sp, #44]	; 0x2c
    }

    /* Pickup the short file name.  */
    short_name_ptr[0] =  0;
 8008b28:	2300      	movs	r3, #0
 8008b2a:	1e62      	subs	r2, r4, #1
 8008b2c:	f104 0e0a 	add.w	lr, r4, #10

        /* Check to see if we need to add a dot.  */
        if (dotflag == 1)
        {
            /* Add dot to short file name.  */
            short_name_ptr[j++] =  '.';
 8008b30:	f04f 092e 	mov.w	r9, #46	; 0x2e
    dotflag =  0;
 8008b34:	469c      	mov	ip, r3
    short_name_ptr[0] =  0;
 8008b36:	702b      	strb	r3, [r5, #0]
    for (i = 0, j = 0; i < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); i++)
 8008b38:	4618      	mov	r0, r3
 8008b3a:	e017      	b.n	8008b6c <_fx_directory_entry_read+0x150>
        if ((CHAR)read_ptr[i] == ' ')
 8008b3c:	2b20      	cmp	r3, #32
 8008b3e:	f000 813b 	beq.w	8008db8 <_fx_directory_entry_read+0x39c>
        if (i == FX_DIR_NAME_SIZE)
 8008b42:	eba2 0804 	sub.w	r8, r2, r4
            if (dotflag == 0)
 8008b46:	f1b8 0f08 	cmp.w	r8, #8
 8008b4a:	d102      	bne.n	8008b52 <_fx_directory_entry_read+0x136>
 8008b4c:	f1bc 0f00 	cmp.w	ip, #0
 8008b50:	d002      	beq.n	8008b58 <_fx_directory_entry_read+0x13c>
        if (dotflag == 1)
 8008b52:	f1bc 0f01 	cmp.w	ip, #1
 8008b56:	d105      	bne.n	8008b64 <_fx_directory_entry_read+0x148>
            short_name_ptr[j++] =  '.';
 8008b58:	f805 9000 	strb.w	r9, [r5, r0]
            dotflag =  2;    /* no more dot for spaces */
 8008b5c:	f04f 0c02 	mov.w	ip, #2
            short_name_ptr[j++] =  '.';
 8008b60:	3001      	adds	r0, #1
 8008b62:	7813      	ldrb	r3, [r2, #0]
        }

        /* Copy a character.  */
        short_name_ptr[j] =  (CHAR)read_ptr[i];
 8008b64:	542b      	strb	r3, [r5, r0]

        /* Increment size.  */
        j++;
 8008b66:	3001      	adds	r0, #1
    for (i = 0, j = 0; i < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); i++)
 8008b68:	4572      	cmp	r2, lr
 8008b6a:	d041      	beq.n	8008bf0 <_fx_directory_entry_read+0x1d4>
        if ((CHAR)read_ptr[i] == 0)
 8008b6c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8008b70:	2b00      	cmp	r3, #0
 8008b72:	d03d      	beq.n	8008bf0 <_fx_directory_entry_read+0x1d4>
        if ((CHAR)read_ptr[i] == '.')
 8008b74:	2b2e      	cmp	r3, #46	; 0x2e
 8008b76:	d1e1      	bne.n	8008b3c <_fx_directory_entry_read+0x120>
            dotflag =  2;
 8008b78:	f04f 0c02 	mov.w	ip, #2
 8008b7c:	e7f2      	b.n	8008b64 <_fx_directory_entry_read+0x148>
    if ((source_dir) || (media_ptr -> fx_media_32_bit_FAT))
 8008b7e:	6e43      	ldr	r3, [r0, #100]	; 0x64
 8008b80:	2b00      	cmp	r3, #0
 8008b82:	f000 80fb 	beq.w	8008d7c <_fx_directory_entry_read+0x360>
            ((ULONG)media_ptr -> fx_media_sectors_per_cluster);
 8008b86:	6d40      	ldr	r0, [r0, #84]	; 0x54
        bytes_per_cluster =  ((ULONG)media_ptr -> fx_media_bytes_per_sector) *
 8008b88:	fb02 f300 	mul.w	r3, r2, r0
        if (bytes_per_cluster == 0)
 8008b8c:	b99b      	cbnz	r3, 8008bb6 <_fx_directory_entry_read+0x19a>
            return(FX_MEDIA_INVALID);
 8008b8e:	2002      	movs	r0, #2
    }
#endif /* FX_ENABLE_EXFAT */

    /* Return success to the caller.  */
    return(FX_SUCCESS);
}
 8008b90:	b011      	add	sp, #68	; 0x44
 8008b92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if ((source_dir) || (media_ptr -> fx_media_32_bit_FAT))
 8008b96:	6e73      	ldr	r3, [r6, #100]	; 0x64
 8008b98:	2b00      	cmp	r3, #0
 8008b9a:	f040 815b 	bne.w	8008e54 <_fx_directory_entry_read+0x438>
                    if (logical_sector >= (ULONG)(media_ptr -> fx_media_root_sector_start + media_ptr -> fx_media_root_sectors))
 8008b9e:	6cb3      	ldr	r3, [r6, #72]	; 0x48
                    logical_sector++;
 8008ba0:	f109 0901 	add.w	r9, r9, #1
                    if (logical_sector >= (ULONG)(media_ptr -> fx_media_root_sector_start + media_ptr -> fx_media_root_sectors))
 8008ba4:	6cf2      	ldr	r2, [r6, #76]	; 0x4c
 8008ba6:	4413      	add	r3, r2
 8008ba8:	454b      	cmp	r3, r9
 8008baa:	f200 815c 	bhi.w	8008e66 <_fx_directory_entry_read+0x44a>
                return(FX_FILE_CORRUPT);
 8008bae:	2008      	movs	r0, #8
}
 8008bb0:	b011      	add	sp, #68	; 0x44
 8008bb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        relative_cluster =   (UINT)(byte_offset / bytes_per_cluster);
 8008bb6:	fbb8 faf3 	udiv	sl, r8, r3
        byte_offset =  byte_offset % bytes_per_cluster;
 8008bba:	fb03 881a 	mls	r8, r3, sl, r8
            cluster =  media_ptr -> fx_media_root_cluster_32;
 8008bbe:	6f71      	ldr	r1, [r6, #116]	; 0x74
            i =  0;
 8008bc0:	46d9      	mov	r9, fp
        relative_sector =    (UINT)(byte_offset / ((ULONG)media_ptr -> fx_media_bytes_per_sector));
 8008bc2:	fbb8 f3f2 	udiv	r3, r8, r2
 8008bc6:	9305      	str	r3, [sp, #20]
 8008bc8:	e75a      	b.n	8008a80 <_fx_directory_entry_read+0x64>
                (source_dir -> fx_dir_entry_last_search_relative_cluster <= relative_cluster) &&
 8008bca:	e9db 2310 	ldrd	r2, r3, [fp, #64]	; 0x40
 8008bce:	e9db 4516 	ldrd	r4, r5, [fp, #88]	; 0x58
 8008bd2:	429d      	cmp	r5, r3
 8008bd4:	bf08      	it	eq
 8008bd6:	4294      	cmpeq	r4, r2
 8008bd8:	f47f af4e 	bne.w	8008a78 <_fx_directory_entry_read+0x5c>
                (source_dir -> fx_dir_entry_last_search_log_sector == source_dir -> fx_dir_entry_log_sector) &&
 8008bdc:	f8db 2060 	ldr.w	r2, [fp, #96]	; 0x60
 8008be0:	f8db 3048 	ldr.w	r3, [fp, #72]	; 0x48
 8008be4:	429a      	cmp	r2, r3
 8008be6:	f47f af47 	bne.w	8008a78 <_fx_directory_entry_read+0x5c>
                source_dir -> fx_dir_entry_last_search_cluster =  0;
 8008bea:	f8cb c050 	str.w	ip, [fp, #80]	; 0x50
 8008bee:	e747      	b.n	8008a80 <_fx_directory_entry_read+0x64>
    if ((destination_ptr -> fx_dir_entry_long_name_present) && (((UCHAR)short_name_ptr[0]) == (UCHAR)FX_DIR_ENTRY_FREE))
 8008bf0:	697b      	ldr	r3, [r7, #20]
 8008bf2:	782a      	ldrb	r2, [r5, #0]
 8008bf4:	b113      	cbz	r3, 8008bfc <_fx_directory_entry_read+0x1e0>
 8008bf6:	2ae5      	cmp	r2, #229	; 0xe5
 8008bf8:	f000 80e4 	beq.w	8008dc4 <_fx_directory_entry_read+0x3a8>
    if ((short_name_ptr[0] == 0) && (read_ptr[0] == ' '))
 8008bfc:	2a00      	cmp	r2, #0
 8008bfe:	f000 80e7 	beq.w	8008dd0 <_fx_directory_entry_read+0x3b4>
    short_name_ptr[j] = 0;
 8008c02:	2300      	movs	r3, #0
    if ((get_short_name) && (destination_ptr -> fx_dir_entry_reserved & 0x08))
 8008c04:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    short_name_ptr[j] = 0;
 8008c06:	542b      	strb	r3, [r5, r0]
    destination_ptr -> fx_dir_entry_attributes =  *read_ptr++;
 8008c08:	7ae3      	ldrb	r3, [r4, #11]
 8008c0a:	773b      	strb	r3, [r7, #28]
    destination_ptr -> fx_dir_entry_reserved =  *read_ptr++;
 8008c0c:	7b23      	ldrb	r3, [r4, #12]
 8008c0e:	777b      	strb	r3, [r7, #29]
    if ((get_short_name) && (destination_ptr -> fx_dir_entry_reserved & 0x08))
 8008c10:	2a00      	cmp	r2, #0
 8008c12:	d066      	beq.n	8008ce2 <_fx_directory_entry_read+0x2c6>
 8008c14:	071b      	lsls	r3, r3, #28
 8008c16:	d564      	bpl.n	8008ce2 <_fx_directory_entry_read+0x2c6>
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008c18:	782b      	ldrb	r3, [r5, #0]
 8008c1a:	2b00      	cmp	r3, #0
 8008c1c:	d061      	beq.n	8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008c1e:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008c22:	2a19      	cmp	r2, #25
 8008c24:	d801      	bhi.n	8008c2a <_fx_directory_entry_read+0x20e>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008c26:	3320      	adds	r3, #32
 8008c28:	702b      	strb	r3, [r5, #0]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008c2a:	786b      	ldrb	r3, [r5, #1]
 8008c2c:	2b00      	cmp	r3, #0
 8008c2e:	d058      	beq.n	8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008c30:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008c34:	2a19      	cmp	r2, #25
 8008c36:	d801      	bhi.n	8008c3c <_fx_directory_entry_read+0x220>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008c38:	3320      	adds	r3, #32
 8008c3a:	706b      	strb	r3, [r5, #1]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008c3c:	78ab      	ldrb	r3, [r5, #2]
 8008c3e:	2b00      	cmp	r3, #0
 8008c40:	d04f      	beq.n	8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008c42:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008c46:	2a19      	cmp	r2, #25
 8008c48:	d801      	bhi.n	8008c4e <_fx_directory_entry_read+0x232>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008c4a:	3320      	adds	r3, #32
 8008c4c:	70ab      	strb	r3, [r5, #2]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008c4e:	78eb      	ldrb	r3, [r5, #3]
 8008c50:	2b00      	cmp	r3, #0
 8008c52:	d046      	beq.n	8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008c54:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008c58:	2a19      	cmp	r2, #25
 8008c5a:	d801      	bhi.n	8008c60 <_fx_directory_entry_read+0x244>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008c5c:	3320      	adds	r3, #32
 8008c5e:	70eb      	strb	r3, [r5, #3]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008c60:	792b      	ldrb	r3, [r5, #4]
 8008c62:	2b00      	cmp	r3, #0
 8008c64:	d03d      	beq.n	8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008c66:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008c6a:	2a19      	cmp	r2, #25
 8008c6c:	d801      	bhi.n	8008c72 <_fx_directory_entry_read+0x256>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008c6e:	3320      	adds	r3, #32
 8008c70:	712b      	strb	r3, [r5, #4]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008c72:	796b      	ldrb	r3, [r5, #5]
 8008c74:	b3ab      	cbz	r3, 8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008c76:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008c7a:	2a19      	cmp	r2, #25
 8008c7c:	d801      	bhi.n	8008c82 <_fx_directory_entry_read+0x266>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008c7e:	3320      	adds	r3, #32
 8008c80:	716b      	strb	r3, [r5, #5]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008c82:	79ab      	ldrb	r3, [r5, #6]
 8008c84:	b36b      	cbz	r3, 8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008c86:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008c8a:	2a19      	cmp	r2, #25
 8008c8c:	d801      	bhi.n	8008c92 <_fx_directory_entry_read+0x276>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008c8e:	3320      	adds	r3, #32
 8008c90:	71ab      	strb	r3, [r5, #6]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008c92:	79eb      	ldrb	r3, [r5, #7]
 8008c94:	b32b      	cbz	r3, 8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008c96:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008c9a:	2a19      	cmp	r2, #25
 8008c9c:	d801      	bhi.n	8008ca2 <_fx_directory_entry_read+0x286>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008c9e:	3320      	adds	r3, #32
 8008ca0:	71eb      	strb	r3, [r5, #7]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008ca2:	7a2b      	ldrb	r3, [r5, #8]
 8008ca4:	b1eb      	cbz	r3, 8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008ca6:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008caa:	2a19      	cmp	r2, #25
 8008cac:	d801      	bhi.n	8008cb2 <_fx_directory_entry_read+0x296>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008cae:	3320      	adds	r3, #32
 8008cb0:	722b      	strb	r3, [r5, #8]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008cb2:	7a6b      	ldrb	r3, [r5, #9]
 8008cb4:	b1ab      	cbz	r3, 8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008cb6:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008cba:	2a19      	cmp	r2, #25
 8008cbc:	d801      	bhi.n	8008cc2 <_fx_directory_entry_read+0x2a6>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008cbe:	3320      	adds	r3, #32
 8008cc0:	726b      	strb	r3, [r5, #9]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008cc2:	7aab      	ldrb	r3, [r5, #10]
 8008cc4:	b16b      	cbz	r3, 8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008cc6:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008cca:	2a19      	cmp	r2, #25
 8008ccc:	d801      	bhi.n	8008cd2 <_fx_directory_entry_read+0x2b6>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008cce:	3320      	adds	r3, #32
 8008cd0:	72ab      	strb	r3, [r5, #10]
        for (j = 0; j <= (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE) && (short_name_ptr[j] != 0x00); j++)
 8008cd2:	7aeb      	ldrb	r3, [r5, #11]
 8008cd4:	b12b      	cbz	r3, 8008ce2 <_fx_directory_entry_read+0x2c6>
            if ((short_name_ptr[j] >= 'A') && (short_name_ptr[j] <= 'Z'))
 8008cd6:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 8008cda:	2a19      	cmp	r2, #25
 8008cdc:	d801      	bhi.n	8008ce2 <_fx_directory_entry_read+0x2c6>
                short_name_ptr[j] =  (CHAR)(short_name_ptr[j] + 32);
 8008cde:	3320      	adds	r3, #32
 8008ce0:	72eb      	strb	r3, [r5, #11]
    destination_ptr -> fx_dir_entry_created_time_ms =  *read_ptr++;
 8008ce2:	7b63      	ldrb	r3, [r4, #13]
    destination_ptr -> fx_dir_entry_created_time =  _fx_utility_16_unsigned_read(read_ptr);
 8008ce4:	f104 000e 	add.w	r0, r4, #14
 8008ce8:	9105      	str	r1, [sp, #20]
    destination_ptr -> fx_dir_entry_created_time_ms =  *read_ptr++;
 8008cea:	77bb      	strb	r3, [r7, #30]
    destination_ptr -> fx_dir_entry_created_time =  _fx_utility_16_unsigned_read(read_ptr);
 8008cec:	f7fe fd60 	bl	80077b0 <_fx_utility_16_unsigned_read>
 8008cf0:	6238      	str	r0, [r7, #32]
    destination_ptr -> fx_dir_entry_created_date =  _fx_utility_16_unsigned_read(read_ptr);
 8008cf2:	f104 0010 	add.w	r0, r4, #16
 8008cf6:	f7fe fd5b 	bl	80077b0 <_fx_utility_16_unsigned_read>
 8008cfa:	6278      	str	r0, [r7, #36]	; 0x24
    destination_ptr -> fx_dir_entry_last_accessed_date =  _fx_utility_16_unsigned_read(read_ptr);
 8008cfc:	f104 0012 	add.w	r0, r4, #18
 8008d00:	f7fe fd56 	bl	80077b0 <_fx_utility_16_unsigned_read>
    if (media_ptr -> fx_media_32_bit_FAT)
 8008d04:	6e73      	ldr	r3, [r6, #100]	; 0x64
 8008d06:	9905      	ldr	r1, [sp, #20]
    destination_ptr -> fx_dir_entry_last_accessed_date =  _fx_utility_16_unsigned_read(read_ptr);
 8008d08:	62b8      	str	r0, [r7, #40]	; 0x28
    if (media_ptr -> fx_media_32_bit_FAT)
 8008d0a:	2b00      	cmp	r3, #0
 8008d0c:	f040 8125 	bne.w	8008f5a <_fx_directory_entry_read+0x53e>
        destination_ptr -> fx_dir_entry_cluster =  0;
 8008d10:	637b      	str	r3, [r7, #52]	; 0x34
    destination_ptr -> fx_dir_entry_time =  _fx_utility_16_unsigned_read(read_ptr);
 8008d12:	f104 0016 	add.w	r0, r4, #22
 8008d16:	9105      	str	r1, [sp, #20]
 8008d18:	f7fe fd4a 	bl	80077b0 <_fx_utility_16_unsigned_read>
 8008d1c:	62f8      	str	r0, [r7, #44]	; 0x2c
    destination_ptr -> fx_dir_entry_date =  _fx_utility_16_unsigned_read(read_ptr);
 8008d1e:	f104 0018 	add.w	r0, r4, #24
 8008d22:	f7fe fd45 	bl	80077b0 <_fx_utility_16_unsigned_read>
 8008d26:	6338      	str	r0, [r7, #48]	; 0x30
    destination_ptr -> fx_dir_entry_cluster +=  _fx_utility_16_unsigned_read(read_ptr);
 8008d28:	f104 001a 	add.w	r0, r4, #26
 8008d2c:	f7fe fd40 	bl	80077b0 <_fx_utility_16_unsigned_read>
 8008d30:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008d32:	4403      	add	r3, r0
    destination_ptr -> fx_dir_entry_file_size =  _fx_utility_32_unsigned_read(read_ptr);
 8008d34:	f104 001c 	add.w	r0, r4, #28
 8008d38:	2400      	movs	r4, #0
    destination_ptr -> fx_dir_entry_cluster +=  _fx_utility_16_unsigned_read(read_ptr);
 8008d3a:	637b      	str	r3, [r7, #52]	; 0x34
    destination_ptr -> fx_dir_entry_file_size =  _fx_utility_32_unsigned_read(read_ptr);
 8008d3c:	f7fe fd3e 	bl	80077bc <_fx_utility_32_unsigned_read>
    destination_ptr -> fx_dir_entry_last_search_log_sector =        0;
 8008d40:	2300      	movs	r3, #0
 8008d42:	2200      	movs	r2, #0
    destination_ptr -> fx_dir_entry_number =  entry;
 8008d44:	9906      	ldr	r1, [sp, #24]
    destination_ptr -> fx_dir_entry_file_size =  _fx_utility_32_unsigned_read(read_ptr);
 8008d46:	63b8      	str	r0, [r7, #56]	; 0x38
    destination_ptr -> fx_dir_entry_number =  entry;
 8008d48:	64f9      	str	r1, [r7, #76]	; 0x4c
    destination_ptr -> fx_dir_entry_file_size =  _fx_utility_32_unsigned_read(read_ptr);
 8008d4a:	63fc      	str	r4, [r7, #60]	; 0x3c
    destination_ptr -> fx_dir_entry_last_search_byte_offset =       0;
 8008d4c:	663c      	str	r4, [r7, #96]	; 0x60
    destination_ptr -> fx_dir_entry_last_search_log_sector =        0;
 8008d4e:	e9c7 2316 	strd	r2, r3, [r7, #88]	; 0x58
    *entry_ptr =  entry;
 8008d52:	9b07      	ldr	r3, [sp, #28]
    destination_ptr -> fx_dir_entry_last_search_relative_cluster =  0;
 8008d54:	e9c7 4414 	strd	r4, r4, [r7, #80]	; 0x50
    *entry_ptr =  entry;
 8008d58:	6019      	str	r1, [r3, #0]
    if (source_dir)
 8008d5a:	f1bb 0f00 	cmp.w	fp, #0
 8008d5e:	f000 8105 	beq.w	8008f6c <_fx_directory_entry_read+0x550>
        source_dir -> fx_dir_entry_last_search_byte_offset =       source_dir -> fx_dir_entry_byte_offset;
 8008d62:	f8db 3048 	ldr.w	r3, [fp, #72]	; 0x48
    return(FX_SUCCESS);
 8008d66:	4620      	mov	r0, r4
        source_dir -> fx_dir_entry_last_search_cluster =           cluster;
 8008d68:	9905      	ldr	r1, [sp, #20]
        source_dir -> fx_dir_entry_last_search_byte_offset =       source_dir -> fx_dir_entry_byte_offset;
 8008d6a:	f8cb 3060 	str.w	r3, [fp, #96]	; 0x60
        source_dir -> fx_dir_entry_last_search_log_sector =        source_dir -> fx_dir_entry_log_sector;
 8008d6e:	e9db 2310 	ldrd	r2, r3, [fp, #64]	; 0x40
        source_dir -> fx_dir_entry_last_search_relative_cluster =  relative_cluster;
 8008d72:	e9cb 1a14 	strd	r1, sl, [fp, #80]	; 0x50
        source_dir -> fx_dir_entry_last_search_log_sector =        source_dir -> fx_dir_entry_log_sector;
 8008d76:	e9cb 2316 	strd	r2, r3, [fp, #88]	; 0x58
 8008d7a:	e709      	b.n	8008b90 <_fx_directory_entry_read+0x174>
        logical_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8008d7c:	fbb8 f1f2 	udiv	r1, r8, r2
 8008d80:	6c83      	ldr	r3, [r0, #72]	; 0x48
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008d82:	2203      	movs	r2, #3
 8008d84:	2501      	movs	r5, #1
        logical_sector =  (byte_offset / media_ptr -> fx_media_bytes_per_sector) +
 8008d86:	eb01 0903 	add.w	r9, r1, r3
        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008d8a:	6881      	ldr	r1, [r0, #8]
 8008d8c:	465b      	mov	r3, fp
 8008d8e:	9202      	str	r2, [sp, #8]
 8008d90:	464a      	mov	r2, r9
 8008d92:	e9cd 1500 	strd	r1, r5, [sp]
 8008d96:	465d      	mov	r5, fp
 8008d98:	f7ff fb9e 	bl	80084d8 <_fx_utility_logical_sector_read>
        if (status != FX_SUCCESS)
 8008d9c:	2800      	cmp	r0, #0
 8008d9e:	f47f aef7 	bne.w	8008b90 <_fx_directory_entry_read+0x174>
            ((logical_sector - (ULONG)media_ptr -> fx_media_root_sector_start) *
 8008da2:	6cb3      	ldr	r3, [r6, #72]	; 0x48
        relative_cluster =  relative_sector =  cluster =  0;
 8008da4:	46da      	mov	sl, fp
            ((logical_sector - (ULONG)media_ptr -> fx_media_root_sector_start) *
 8008da6:	6ab0      	ldr	r0, [r6, #40]	; 0x28
        relative_cluster =  relative_sector =  cluster =  0;
 8008da8:	4659      	mov	r1, fp
            ((logical_sector - (ULONG)media_ptr -> fx_media_root_sector_start) *
 8008daa:	eba9 0303 	sub.w	r3, r9, r3
        relative_cluster =  relative_sector =  cluster =  0;
 8008dae:	f8cd b014 	str.w	fp, [sp, #20]
        byte_offset =  byte_offset -
 8008db2:	fb00 8013 	mls	r0, r0, r3, r8
 8008db6:	e6a0      	b.n	8008afa <_fx_directory_entry_read+0xde>
                dotflag =  1;
 8008db8:	f1bc 0f00 	cmp.w	ip, #0
 8008dbc:	bf08      	it	eq
 8008dbe:	f04f 0c01 	moveq.w	ip, #1
 8008dc2:	e6d1      	b.n	8008b68 <_fx_directory_entry_read+0x14c>
        destination_ptr -> fx_dir_entry_name[0] =  (CHAR)FX_DIR_ENTRY_FREE;
 8008dc4:	683b      	ldr	r3, [r7, #0]
        short_name_ptr[0] =  (CHAR)0;
 8008dc6:	f04f 0c00 	mov.w	ip, #0
        destination_ptr -> fx_dir_entry_name[0] =  (CHAR)FX_DIR_ENTRY_FREE;
 8008dca:	701a      	strb	r2, [r3, #0]
        short_name_ptr[0] =  (CHAR)0;
 8008dcc:	f885 c000 	strb.w	ip, [r5]
    if ((short_name_ptr[0] == 0) && (read_ptr[0] == ' '))
 8008dd0:	7823      	ldrb	r3, [r4, #0]
 8008dd2:	2b20      	cmp	r3, #32
 8008dd4:	f47f af15 	bne.w	8008c02 <_fx_directory_entry_read+0x1e6>
 8008dd8:	1d2b      	adds	r3, r5, #4
 8008dda:	1d22      	adds	r2, r4, #4
 8008ddc:	4295      	cmp	r5, r2
 8008dde:	bf38      	it	cc
 8008de0:	429c      	cmpcc	r4, r3
 8008de2:	f0c0 80e8 	bcc.w	8008fb6 <_fx_directory_entry_read+0x59a>
 8008de6:	ea45 0304 	orr.w	r3, r5, r4
 8008dea:	079a      	lsls	r2, r3, #30
 8008dec:	f040 80e3 	bne.w	8008fb6 <_fx_directory_entry_read+0x59a>
            short_name_ptr[j] =  (CHAR)read_ptr[j];
 8008df0:	6823      	ldr	r3, [r4, #0]
 8008df2:	602b      	str	r3, [r5, #0]
 8008df4:	6863      	ldr	r3, [r4, #4]
 8008df6:	606b      	str	r3, [r5, #4]
 8008df8:	7a23      	ldrb	r3, [r4, #8]
                dotflag =  1;
 8008dfa:	200b      	movs	r0, #11
            short_name_ptr[j] =  (CHAR)read_ptr[j];
 8008dfc:	722b      	strb	r3, [r5, #8]
 8008dfe:	7a63      	ldrb	r3, [r4, #9]
 8008e00:	726b      	strb	r3, [r5, #9]
 8008e02:	7aa3      	ldrb	r3, [r4, #10]
 8008e04:	72ab      	strb	r3, [r5, #10]
 8008e06:	e6fc      	b.n	8008c02 <_fx_directory_entry_read+0x1e6>
    if ((*(read_ptr + 11) == (UCHAR)FX_LONG_NAME) && (*read_ptr != (UCHAR)FX_DIR_ENTRY_FREE))
 8008e08:	5c1b      	ldrb	r3, [r3, r0]
 8008e0a:	2be5      	cmp	r3, #229	; 0xe5
 8008e0c:	f43f ae88 	beq.w	8008b20 <_fx_directory_entry_read+0x104>
 8008e10:	f003 031f 	and.w	r3, r3, #31
        i = (((UINT)(*read_ptr & (UCHAR)0x1f) - 1) * FX_LONG_NAME_ENTRY_LEN) & 0xFFFFFFFF;
 8008e14:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
 8008e18:	9309      	str	r3, [sp, #36]	; 0x24
 8008e1a:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
 8008e1e:	f1ac 080d 	sub.w	r8, ip, #13
        if (i >= (FX_MAX_LONG_NAME_LEN - 1))
 8008e22:	f1b8 0ffe 	cmp.w	r8, #254	; 0xfe
 8008e26:	f240 80b4 	bls.w	8008f92 <_fx_directory_entry_read+0x576>
            destination_ptr -> fx_dir_entry_long_name_shorted =  (UINT)(*read_ptr & (UCHAR)0x1f);
 8008e2a:	61bb      	str	r3, [r7, #24]
            get_short_name = 1;
 8008e2c:	2301      	movs	r3, #1
    short_name_ptr =  destination_ptr -> fx_dir_entry_name;
 8008e2e:	9508      	str	r5, [sp, #32]
 8008e30:	4698      	mov	r8, r3
            get_short_name = 1;
 8008e32:	930b      	str	r3, [sp, #44]	; 0x2c
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008e34:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8008e38:	910c      	str	r1, [sp, #48]	; 0x30
 8008e3a:	f8dd a018 	ldr.w	sl, [sp, #24]
 8008e3e:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 8008e42:	e024      	b.n	8008e8e <_fx_directory_entry_read+0x472>
            if (byte_offset + FX_DIR_ENTRY_SIZE >= media_ptr -> fx_media_bytes_per_sector)
 8008e44:	3020      	adds	r0, #32
 8008e46:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8008e48:	4298      	cmp	r0, r3
 8008e4a:	d31a      	bcc.n	8008e82 <_fx_directory_entry_read+0x466>
                if ((source_dir) || (media_ptr -> fx_media_32_bit_FAT))
 8008e4c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008e4e:	2b00      	cmp	r3, #0
 8008e50:	f43f aea1 	beq.w	8008b96 <_fx_directory_entry_read+0x17a>
                    if (relative_sector < (media_ptr -> fx_media_sectors_per_cluster - 1))
 8008e54:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8008e56:	9a05      	ldr	r2, [sp, #20]
 8008e58:	3b01      	subs	r3, #1
 8008e5a:	4293      	cmp	r3, r2
 8008e5c:	d957      	bls.n	8008f0e <_fx_directory_entry_read+0x4f2>
                        relative_sector++;
 8008e5e:	3201      	adds	r2, #1
                        logical_sector++;
 8008e60:	f109 0901 	add.w	r9, r9, #1
                        relative_sector++;
 8008e64:	9205      	str	r2, [sp, #20]
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 8008e66:	68b1      	ldr	r1, [r6, #8]
 8008e68:	2303      	movs	r3, #3
 8008e6a:	2001      	movs	r0, #1
 8008e6c:	464a      	mov	r2, r9
 8008e6e:	9302      	str	r3, [sp, #8]
 8008e70:	2300      	movs	r3, #0
 8008e72:	9001      	str	r0, [sp, #4]
 8008e74:	4630      	mov	r0, r6
 8008e76:	9100      	str	r1, [sp, #0]
 8008e78:	f7ff fb2e 	bl	80084d8 <_fx_utility_logical_sector_read>
                if (status != FX_SUCCESS)
 8008e7c:	2800      	cmp	r0, #0
 8008e7e:	f47f ae87 	bne.w	8008b90 <_fx_directory_entry_read+0x174>
            read_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT) byte_offset;
 8008e82:	68b4      	ldr	r4, [r6, #8]
            entry++;
 8008e84:	f10a 0a01 	add.w	sl, sl, #1
            read_ptr =  (UCHAR *)media_ptr -> fx_media_memory_buffer + (UINT) byte_offset;
 8008e88:	4404      	add	r4, r0
        } while (card > 0);
 8008e8a:	2d00      	cmp	r5, #0
 8008e8c:	d070      	beq.n	8008f70 <_fx_directory_entry_read+0x554>
            card = (UINT)(*read_ptr & (UCHAR)0x1f) - 1;
 8008e8e:	7825      	ldrb	r5, [r4, #0]
 8008e90:	f005 051f 	and.w	r5, r5, #31
 8008e94:	3d01      	subs	r5, #1
            if (get_short_name == 0)
 8008e96:	f1b8 0f00 	cmp.w	r8, #0
 8008e9a:	d1d3      	bne.n	8008e44 <_fx_directory_entry_read+0x428>
                    if ((card * 13 + j) >= (FX_MAX_LONG_NAME_LEN - 1))
 8008e9c:	eb05 0e45 	add.w	lr, r5, r5, lsl #1
                for (i = 1, j = 0; i < FX_DIR_ENTRY_SIZE; i += 2)
 8008ea0:	4641      	mov	r1, r8
 8008ea2:	2301      	movs	r3, #1
 8008ea4:	9006      	str	r0, [sp, #24]
                    if ((card * 13 + j) >= (FX_MAX_LONG_NAME_LEN - 1))
 8008ea6:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2
                    if ((i == 11) || (i == 26))
 8008eaa:	2b0b      	cmp	r3, #11
 8008eac:	d022      	beq.n	8008ef4 <_fx_directory_entry_read+0x4d8>
 8008eae:	2b1a      	cmp	r3, #26
 8008eb0:	d020      	beq.n	8008ef4 <_fx_directory_entry_read+0x4d8>
                    if (i == 13)
 8008eb2:	2b0d      	cmp	r3, #13
 8008eb4:	d023      	beq.n	8008efe <_fx_directory_entry_read+0x4e2>
                    if (read_ptr[i + 1])
 8008eb6:	18e2      	adds	r2, r4, r3
 8008eb8:	f892 c001 	ldrb.w	ip, [r2, #1]
 8008ebc:	f1bc 0f00 	cmp.w	ip, #0
 8008ec0:	d008      	beq.n	8008ed4 <_fx_directory_entry_read+0x4b8>
                        if ((read_ptr[i + 1] != (UCHAR)0xFF) || (read_ptr[i] != (UCHAR)0xFF))
 8008ec2:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 8008ec6:	d01c      	beq.n	8008f02 <_fx_directory_entry_read+0x4e6>
                            short_name_ptr =  destination_ptr -> fx_dir_entry_name;
 8008ec8:	6838      	ldr	r0, [r7, #0]
                            get_short_name = 1;
 8008eca:	f04f 0801 	mov.w	r8, #1
                            short_name_ptr =  destination_ptr -> fx_dir_entry_name;
 8008ece:	9008      	str	r0, [sp, #32]
                            destination_ptr -> fx_dir_entry_long_name_shorted =  number_of_lfns;
 8008ed0:	9809      	ldr	r0, [sp, #36]	; 0x24
 8008ed2:	61b8      	str	r0, [r7, #24]
                    if ((read_ptr[i] == FX_NULL) || (read_ptr[i] == (UCHAR)0xFF))
 8008ed4:	f892 c000 	ldrb.w	ip, [r2]
 8008ed8:	f10c 32ff 	add.w	r2, ip, #4294967295
 8008edc:	b2d2      	uxtb	r2, r2
 8008ede:	2afd      	cmp	r2, #253	; 0xfd
 8008ee0:	d808      	bhi.n	8008ef4 <_fx_directory_entry_read+0x4d8>
                    if ((card * 13 + j) >= (FX_MAX_LONG_NAME_LEN - 1))
 8008ee2:	eb0e 0201 	add.w	r2, lr, r1
 8008ee6:	f8d7 b000 	ldr.w	fp, [r7]
 8008eea:	2afe      	cmp	r2, #254	; 0xfe
 8008eec:	d82d      	bhi.n	8008f4a <_fx_directory_entry_read+0x52e>
                    j++;
 8008eee:	3101      	adds	r1, #1
                    destination_ptr -> fx_dir_entry_name[13 * card + j] = (CHAR)read_ptr[i];
 8008ef0:	f80b c002 	strb.w	ip, [fp, r2]
                for (i = 1, j = 0; i < FX_DIR_ENTRY_SIZE; i += 2)
 8008ef4:	3302      	adds	r3, #2
 8008ef6:	2b1f      	cmp	r3, #31
 8008ef8:	d9d7      	bls.n	8008eaa <_fx_directory_entry_read+0x48e>
 8008efa:	9806      	ldr	r0, [sp, #24]
 8008efc:	e7a2      	b.n	8008e44 <_fx_directory_entry_read+0x428>
 8008efe:	230e      	movs	r3, #14
 8008f00:	e7d3      	b.n	8008eaa <_fx_directory_entry_read+0x48e>
                        if ((read_ptr[i + 1] != (UCHAR)0xFF) || (read_ptr[i] != (UCHAR)0xFF))
 8008f02:	f892 c000 	ldrb.w	ip, [r2]
 8008f06:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 8008f0a:	d1dd      	bne.n	8008ec8 <_fx_directory_entry_read+0x4ac>
 8008f0c:	e7f2      	b.n	8008ef4 <_fx_directory_entry_read+0x4d8>
                        status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8008f0e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8008f10:	aa0f      	add	r2, sp, #60	; 0x3c
 8008f12:	4630      	mov	r0, r6
 8008f14:	f7fe fc66 	bl	80077e4 <_fx_utility_FAT_entry_read>
                        if (status != FX_SUCCESS)
 8008f18:	9005      	str	r0, [sp, #20]
 8008f1a:	2800      	cmp	r0, #0
 8008f1c:	f47f ae38 	bne.w	8008b90 <_fx_directory_entry_read+0x174>
                        cluster =  next_cluster;
 8008f20:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
                        if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8008f22:	2a01      	cmp	r2, #1
                        cluster =  next_cluster;
 8008f24:	920c      	str	r2, [sp, #48]	; 0x30
                        if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8008f26:	f67f ae42 	bls.w	8008bae <_fx_directory_entry_read+0x192>
 8008f2a:	f242 43a8 	movw	r3, #9384	; 0x24a8
 8008f2e:	58f3      	ldr	r3, [r6, r3]
 8008f30:	4293      	cmp	r3, r2
 8008f32:	f67f ae3c 	bls.w	8008bae <_fx_directory_entry_read+0x192>
                        relative_cluster++;
 8008f36:	990d      	ldr	r1, [sp, #52]	; 0x34
                            (((ULONG)cluster - FX_FAT_ENTRY_START) *
 8008f38:	f1a2 0902 	sub.w	r9, r2, #2
                        relative_cluster++;
 8008f3c:	3101      	adds	r1, #1
                        logical_sector =   ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8008f3e:	e9d6 3214 	ldrd	r3, r2, [r6, #80]	; 0x50
                        relative_cluster++;
 8008f42:	910d      	str	r1, [sp, #52]	; 0x34
                        logical_sector =   ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8008f44:	fb02 3909 	mla	r9, r2, r9, r3
 8008f48:	e78d      	b.n	8008e66 <_fx_directory_entry_read+0x44a>
                        destination_ptr -> fx_dir_entry_long_name_shorted =  number_of_lfns;
 8008f4a:	9b09      	ldr	r3, [sp, #36]	; 0x24
                        get_short_name =  1;
 8008f4c:	f04f 0801 	mov.w	r8, #1
 8008f50:	9806      	ldr	r0, [sp, #24]
                        destination_ptr -> fx_dir_entry_long_name_shorted =  number_of_lfns;
 8008f52:	61bb      	str	r3, [r7, #24]
                        break;
 8008f54:	f8cd b020 	str.w	fp, [sp, #32]
 8008f58:	e774      	b.n	8008e44 <_fx_directory_entry_read+0x428>
        destination_ptr -> fx_dir_entry_cluster =  _fx_utility_16_unsigned_read(read_ptr);
 8008f5a:	f104 0014 	add.w	r0, r4, #20
 8008f5e:	9105      	str	r1, [sp, #20]
 8008f60:	f7fe fc26 	bl	80077b0 <_fx_utility_16_unsigned_read>
 8008f64:	9905      	ldr	r1, [sp, #20]
        destination_ptr -> fx_dir_entry_cluster <<= 16;
 8008f66:	0400      	lsls	r0, r0, #16
 8008f68:	6378      	str	r0, [r7, #52]	; 0x34
 8008f6a:	e6d2      	b.n	8008d12 <_fx_directory_entry_read+0x2f6>
    return(FX_SUCCESS);
 8008f6c:	4658      	mov	r0, fp
 8008f6e:	e60f      	b.n	8008b90 <_fx_directory_entry_read+0x174>
        destination_ptr -> fx_dir_entry_long_name_present = 1;
 8008f70:	2301      	movs	r3, #1
 8008f72:	f8cd a018 	str.w	sl, [sp, #24]
 8008f76:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
 8008f7a:	617b      	str	r3, [r7, #20]
    if (get_short_name == 1)
 8008f7c:	4643      	mov	r3, r8
 8008f7e:	990c      	ldr	r1, [sp, #48]	; 0x30
 8008f80:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
 8008f84:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 8008f88:	9d08      	ldr	r5, [sp, #32]
 8008f8a:	2b00      	cmp	r3, #0
 8008f8c:	f43f adcc 	beq.w	8008b28 <_fx_directory_entry_read+0x10c>
 8008f90:	e5c6      	b.n	8008b20 <_fx_directory_entry_read+0x104>
            short_name_ptr = destination_ptr -> fx_dir_entry_short_name;
 8008f92:	1d3b      	adds	r3, r7, #4
            j = i + FX_LONG_NAME_ENTRY_LEN + 1;
 8008f94:	f10c 0c01 	add.w	ip, ip, #1
                destination_ptr -> fx_dir_entry_name[i] =  0;
 8008f98:	4672      	mov	r2, lr
            short_name_ptr = destination_ptr -> fx_dir_entry_short_name;
 8008f9a:	9308      	str	r3, [sp, #32]
 8008f9c:	4643      	mov	r3, r8
 8008f9e:	e002      	b.n	8008fa6 <_fx_directory_entry_read+0x58a>
            } while ((i < j) && (i < FX_MAX_LONG_NAME_LEN));
 8008fa0:	2bff      	cmp	r3, #255	; 0xff
 8008fa2:	d804      	bhi.n	8008fae <_fx_directory_entry_read+0x592>
 8008fa4:	683d      	ldr	r5, [r7, #0]
                destination_ptr -> fx_dir_entry_name[i] =  0;
 8008fa6:	54ea      	strb	r2, [r5, r3]
                i++;
 8008fa8:	3301      	adds	r3, #1
            } while ((i < j) && (i < FX_MAX_LONG_NAME_LEN));
 8008faa:	459c      	cmp	ip, r3
 8008fac:	d8f8      	bhi.n	8008fa0 <_fx_directory_entry_read+0x584>
    get_short_name =  0;
 8008fae:	2300      	movs	r3, #0
 8008fb0:	930b      	str	r3, [sp, #44]	; 0x2c
 8008fb2:	4698      	mov	r8, r3
 8008fb4:	e73e      	b.n	8008e34 <_fx_directory_entry_read+0x418>
            short_name_ptr[j] =  (CHAR)read_ptr[j];
 8008fb6:	2320      	movs	r3, #32
 8008fb8:	702b      	strb	r3, [r5, #0]
 8008fba:	7863      	ldrb	r3, [r4, #1]
 8008fbc:	706b      	strb	r3, [r5, #1]
 8008fbe:	78a3      	ldrb	r3, [r4, #2]
 8008fc0:	70ab      	strb	r3, [r5, #2]
 8008fc2:	78e3      	ldrb	r3, [r4, #3]
 8008fc4:	70eb      	strb	r3, [r5, #3]
 8008fc6:	7923      	ldrb	r3, [r4, #4]
 8008fc8:	712b      	strb	r3, [r5, #4]
 8008fca:	7963      	ldrb	r3, [r4, #5]
 8008fcc:	716b      	strb	r3, [r5, #5]
 8008fce:	79a3      	ldrb	r3, [r4, #6]
 8008fd0:	71ab      	strb	r3, [r5, #6]
 8008fd2:	79e3      	ldrb	r3, [r4, #7]
 8008fd4:	71eb      	strb	r3, [r5, #7]
 8008fd6:	e70f      	b.n	8008df8 <_fx_directory_entry_read+0x3dc>

08008fd8 <_fx_directory_entry_write>:


#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of directory entry write requests.  */
    media_ptr -> fx_media_directory_entry_writes++;
 8008fd8:	f8d0 316c 	ldr.w	r3, [r0, #364]	; 0x16c

    /* If trace is enabled, insert this event into the trace buffer.  */
    FX_TRACE_IN_LINE_INSERT(FX_TRACE_INTERNAL_DIR_ENTRY_WRITE, media_ptr, 0, 0, 0, FX_TRACE_INTERNAL_EVENTS, 0, 0)

    /* Determine if this is entry is being deleted.  */
    if (((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) &&
 8008fdc:	680a      	ldr	r2, [r1, #0]
    media_ptr -> fx_media_directory_entry_writes++;
 8008fde:	3301      	adds	r3, #1
{
 8008fe0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    media_ptr -> fx_media_directory_entry_writes++;
 8008fe4:	f8c0 316c 	str.w	r3, [r0, #364]	; 0x16c
{
 8008fe8:	b095      	sub	sp, #84	; 0x54
    if (((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) &&
 8008fea:	7813      	ldrb	r3, [r2, #0]
{
 8008fec:	4606      	mov	r6, r0
 8008fee:	460d      	mov	r5, r1
    if (((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) &&
 8008ff0:	2be5      	cmp	r3, #229	; 0xe5
 8008ff2:	f000 848c 	beq.w	800990e <_fx_directory_entry_write+0x936>
 8008ff6:	2301      	movs	r3, #1
 8008ff8:	9307      	str	r3, [sp, #28]

    /* Pickup the logical sector of the entry.  */
    logical_sector = (ULONG)entry_ptr -> fx_dir_entry_log_sector;

    /* Figure out where what cluster we are in.  */
    if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 8008ffa:	6d33      	ldr	r3, [r6, #80]	; 0x50
    byte_offset = entry_ptr -> fx_dir_entry_byte_offset;
 8008ffc:	f8d5 b048 	ldr.w	fp, [r5, #72]	; 0x48
    logical_sector = (ULONG)entry_ptr -> fx_dir_entry_log_sector;
 8009000:	e9d5 8910 	ldrd	r8, r9, [r5, #64]	; 0x40
    if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 8009004:	4543      	cmp	r3, r8
    logical_sector = (ULONG)entry_ptr -> fx_dir_entry_log_sector;
 8009006:	f8cd 8018 	str.w	r8, [sp, #24]
    if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 800900a:	f200 8388 	bhi.w	800971e <_fx_directory_entry_write+0x746>
    {

        /* Calculate the cluster that this logical sector is in.  */
        cluster =  (logical_sector - media_ptr -> fx_media_data_sector_start) / (media_ptr -> fx_media_sectors_per_cluster) + FX_FAT_ENTRY_START;
 800900e:	eba8 0303 	sub.w	r3, r8, r3
 8009012:	6d71      	ldr	r1, [r6, #84]	; 0x54
 8009014:	fbb3 f2f1 	udiv	r2, r3, r1
 8009018:	fb01 3312 	mls	r3, r1, r2, r3
 800901c:	9309      	str	r3, [sp, #36]	; 0x24
 800901e:	1c93      	adds	r3, r2, #2
 8009020:	930b      	str	r3, [sp, #44]	; 0x2c
        cluster =  0;
        relative_sector =  0;
    }

    /* Read the logical directory sector.  */
    status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) entry_ptr -> fx_dir_entry_log_sector,
 8009022:	68b4      	ldr	r4, [r6, #8]
 8009024:	2101      	movs	r1, #1
 8009026:	f04f 0a03 	mov.w	sl, #3
 800902a:	4642      	mov	r2, r8
 800902c:	4630      	mov	r0, r6
 800902e:	464b      	mov	r3, r9
 8009030:	f8cd a008 	str.w	sl, [sp, #8]
 8009034:	9101      	str	r1, [sp, #4]
 8009036:	9400      	str	r4, [sp, #0]
 8009038:	f7ff fa4e 	bl	80084d8 <_fx_utility_logical_sector_read>
                                              media_ptr -> fx_media_memory_buffer, ((ULONG) 1), FX_DIRECTORY_SECTOR);

    /* Determine if an error occurred.  */
    if (status != FX_SUCCESS)
 800903c:	4602      	mov	r2, r0
 800903e:	900a      	str	r0, [sp, #40]	; 0x28
 8009040:	2800      	cmp	r0, #0
 8009042:	f040 8368 	bne.w	8009716 <_fx_directory_entry_write+0x73e>
        /* Return the error status.  */
        return(status);
    }

    /* Setup a pointer into the buffer.  */
    sector_base_ptr = (UCHAR *)media_ptr -> fx_media_memory_buffer;
 8009046:	68b3      	ldr	r3, [r6, #8]
 8009048:	4640      	mov	r0, r8
 800904a:	2100      	movs	r1, #0
    work_ptr =  sector_base_ptr + (UINT)entry_ptr -> fx_dir_entry_byte_offset;
 800904c:	6cac      	ldr	r4, [r5, #72]	; 0x48
    changed_size = 0;
    changed_offset = entry_ptr -> fx_dir_entry_byte_offset;
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Determine if a long file name is present.  */
    if (entry_ptr -> fx_dir_entry_long_name_present)
 800904e:	696f      	ldr	r7, [r5, #20]
    sector_base_ptr = (UCHAR *)media_ptr -> fx_media_memory_buffer;
 8009050:	9308      	str	r3, [sp, #32]
    work_ptr =  sector_base_ptr + (UINT)entry_ptr -> fx_dir_entry_byte_offset;
 8009052:	441c      	add	r4, r3
 8009054:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
    if (entry_ptr -> fx_dir_entry_long_name_present)
 8009058:	2f00      	cmp	r7, #0
 800905a:	f000 8364 	beq.w	8009726 <_fx_directory_entry_write+0x74e>
    {

        /* Yes, long name is present - prepare short name and write out this name.  */
        for (len = 0, i = 0, dotpos = 0, dotfound = 0; entry_ptr -> fx_dir_entry_name[len]; len++)
 800905e:	682b      	ldr	r3, [r5, #0]
 8009060:	f893 9000 	ldrb.w	r9, [r3]
 8009064:	f1b9 0f00 	cmp.w	r9, #0
 8009068:	f000 85a5 	beq.w	8009bb6 <_fx_directory_entry_write+0xbde>
 800906c:	9205      	str	r2, [sp, #20]
 800906e:	4611      	mov	r1, r2
 8009070:	920e      	str	r2, [sp, #56]	; 0x38
 8009072:	4690      	mov	r8, r2
 8009074:	1c5f      	adds	r7, r3, #1
 8009076:	464a      	mov	r2, r9
 8009078:	e00e      	b.n	8009098 <_fx_directory_entry_write+0xc0>
                dotpos   = len + 1;
                continue;
            }

            /* Check for non-space and within the short file name length.  */
            if ((entry_ptr -> fx_dir_entry_name[len] != ' ') && (i < 8))
 800907a:	f1b8 0f07 	cmp.w	r8, #7
 800907e:	d807      	bhi.n	8009090 <_fx_directory_entry_write+0xb8>
            {

                /* Copy characters into the short file name area.  */
                shortname[i] = entry_ptr -> fx_dir_entry_name[len];
 8009080:	a914      	add	r1, sp, #80	; 0x50
            if ((entry_ptr -> fx_dir_entry_name[len] != ' ') && (i < 8))
 8009082:	2a20      	cmp	r2, #32
                shortname[i] = entry_ptr -> fx_dir_entry_name[len];
 8009084:	4441      	add	r1, r8
            if ((entry_ptr -> fx_dir_entry_name[len] != ' ') && (i < 8))
 8009086:	d003      	beq.n	8009090 <_fx_directory_entry_write+0xb8>
                i++;
 8009088:	f108 0801 	add.w	r8, r8, #1
                shortname[i] = entry_ptr -> fx_dir_entry_name[len];
 800908c:	f801 2c0c 	strb.w	r2, [r1, #-12]
        for (len = 0, i = 0, dotpos = 0, dotfound = 0; entry_ptr -> fx_dir_entry_name[len]; len++)
 8009090:	f817 2b01 	ldrb.w	r2, [r7], #1
 8009094:	4601      	mov	r1, r0
 8009096:	b16a      	cbz	r2, 80090b4 <_fx_directory_entry_write+0xdc>
            if (entry_ptr -> fx_dir_entry_name[len] == '.')
 8009098:	2a2e      	cmp	r2, #46	; 0x2e
 800909a:	f101 0001 	add.w	r0, r1, #1
 800909e:	d1ec      	bne.n	800907a <_fx_directory_entry_write+0xa2>
                if (len == 0)
 80090a0:	2900      	cmp	r1, #0
 80090a2:	d0f5      	beq.n	8009090 <_fx_directory_entry_write+0xb8>
        for (len = 0, i = 0, dotpos = 0, dotfound = 0; entry_ptr -> fx_dir_entry_name[len]; len++)
 80090a4:	f817 2b01 	ldrb.w	r2, [r7], #1
 80090a8:	4601      	mov	r1, r0
 80090aa:	9005      	str	r0, [sp, #20]
 80090ac:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
 80090b0:	2a00      	cmp	r2, #0
 80090b2:	d1f1      	bne.n	8009098 <_fx_directory_entry_write+0xc0>
 80090b4:	4abc      	ldr	r2, [pc, #752]	; (80093a8 <_fx_directory_entry_write+0x3d0>)
            }
        }

        /* Fill remaining short file name with spaces.  */
        for (j = i; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; j++)
 80090b6:	f1b8 0f0a 	cmp.w	r8, #10
 80090ba:	fba2 2a00 	umull	r2, sl, r2, r0
 80090be:	ea4f 0a9a 	mov.w	sl, sl, lsr #2
 80090c2:	eb0a 024a 	add.w	r2, sl, sl, lsl #1
 80090c6:	4657      	mov	r7, sl
 80090c8:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
 80090cc:	eba0 0a02 	sub.w	sl, r0, r2
 80090d0:	d80f      	bhi.n	80090f2 <_fx_directory_entry_write+0x11a>
        {
            shortname[j] =  ' ';
 80090d2:	f108 0001 	add.w	r0, r8, #1
 80090d6:	930f      	str	r3, [sp, #60]	; 0x3c
 80090d8:	ab11      	add	r3, sp, #68	; 0x44
 80090da:	f1c8 020b 	rsb	r2, r8, #11
 80090de:	280b      	cmp	r0, #11
 80090e0:	f04f 0120 	mov.w	r1, #32
 80090e4:	eb03 0008 	add.w	r0, r3, r8
 80090e8:	bf88      	it	hi
 80090ea:	2201      	movhi	r2, #1
 80090ec:	f004 fdf7 	bl	800dcde <memset>
 80090f0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
        }

        /* Determine if a dot was encountered.  */
        if (dotpos)
 80090f2:	9905      	ldr	r1, [sp, #20]
 80090f4:	b331      	cbz	r1, 8009144 <_fx_directory_entry_write+0x16c>
        {

            /* Process relative to the dot position.  */
            if (entry_ptr -> fx_dir_entry_name[dotpos])
 80090f6:	5c5a      	ldrb	r2, [r3, r1]
 80090f8:	b19a      	cbz	r2, 8009122 <_fx_directory_entry_write+0x14a>
            {
                shortname[8] = entry_ptr -> fx_dir_entry_name[dotpos++];
 80090fa:	3101      	adds	r1, #1
 80090fc:	f88d 204c 	strb.w	r2, [sp, #76]	; 0x4c
            }
            if (entry_ptr -> fx_dir_entry_name[dotpos])
 8009100:	5c58      	ldrb	r0, [r3, r1]
 8009102:	2800      	cmp	r0, #0
 8009104:	f000 85dc 	beq.w	8009cc0 <_fx_directory_entry_write+0xce8>
            {
                shortname[9] = entry_ptr -> fx_dir_entry_name[dotpos++];
 8009108:	9905      	ldr	r1, [sp, #20]
 800910a:	f88d 004d 	strb.w	r0, [sp, #77]	; 0x4d
 800910e:	1c8a      	adds	r2, r1, #2
 8009110:	5c99      	ldrb	r1, [r3, r2]
            }
            if (entry_ptr -> fx_dir_entry_name[dotpos])
 8009112:	2900      	cmp	r1, #0
 8009114:	f000 85d1 	beq.w	8009cba <_fx_directory_entry_write+0xce2>
            {
                shortname[10] = entry_ptr -> fx_dir_entry_name[dotpos++];
 8009118:	9a05      	ldr	r2, [sp, #20]
 800911a:	f88d 104e 	strb.w	r1, [sp, #78]	; 0x4e
 800911e:	3203      	adds	r2, #3
 8009120:	9205      	str	r2, [sp, #20]
            }

            /* Determine if additional spaces are needed.  */
            i = dotfound;

            for (; dotfound <= 7; dotfound++)
 8009122:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8009124:	f893 9000 	ldrb.w	r9, [r3]
 8009128:	2a07      	cmp	r2, #7
 800912a:	f200 8552 	bhi.w	8009bd2 <_fx_directory_entry_write+0xbfa>
 800912e:	930e      	str	r3, [sp, #56]	; 0x38
 8009130:	a811      	add	r0, sp, #68	; 0x44
 8009132:	4613      	mov	r3, r2
 8009134:	2120      	movs	r1, #32
 8009136:	f1c2 0208 	rsb	r2, r2, #8
 800913a:	4418      	add	r0, r3
            {
                /* Add space...  */
                shortname[dotfound] = ' ';
 800913c:	4698      	mov	r8, r3
 800913e:	f004 fdce 	bl	800dcde <memset>
 8009142:	9b0e      	ldr	r3, [sp, #56]	; 0x38
            }
        }

        /* Each entry contains 13 unicode entries.  Calculate the remainder.  */
        if (len % 13 == 0)
 8009144:	f1ba 0f00 	cmp.w	sl, #0
 8009148:	f040 846b 	bne.w	8009a22 <_fx_directory_entry_write+0xa4a>
        /* Default the name match to true.  */
        match =  TX_TRUE;

        /* Loop through the newly derived short name and the original name and look
           for a non-matching character.  */
        l =  0;
 800914c:	2100      	movs	r1, #0
        while (k < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE)
        {

            /* Determine if a space is detected in the short name. If so,
               advance to the extension index.  */
            if (shortname[k] == ' ')
 800914e:	f89d 004c 	ldrb.w	r0, [sp, #76]	; 0x4c
        k =  0;
 8009152:	460a      	mov	r2, r1
            if (shortname[k] == ' ')
 8009154:	f10d 0c50 	add.w	ip, sp, #80	; 0x50
 8009158:	4494      	add	ip, r2
 800915a:	f81c cc0c 	ldrb.w	ip, [ip, #-12]
 800915e:	f1bc 0f20 	cmp.w	ip, #32
 8009162:	f040 853c 	bne.w	8009bde <_fx_directory_entry_write+0xc06>
            {

                /* The first pad space was detected. First, check for a name
                   without an extension.  */
                if (entry_ptr -> fx_dir_entry_name[l] == FX_NULL)
 8009166:	f1b9 0f00 	cmp.w	r9, #0
 800916a:	f000 8548 	beq.w	8009bfe <_fx_directory_entry_write+0xc26>
                    /* All is okay, get out of the loop!  */
                    break;
                }

                /* Now check for a period in the long name... if not, there is a non-match!  */
                if (entry_ptr -> fx_dir_entry_name[l] != '.')
 800916e:	f1b9 0f2e 	cmp.w	r9, #46	; 0x2e
 8009172:	f000 84fd 	beq.w	8009b70 <_fx_directory_entry_write+0xb98>
            l++;
        }

        /* Check if there is a dot in the name, but no extension in the short name.  In this case, 
           we should create a mangled short name.  */
        if ((dotpos) && (shortname[8] == ' '))
 8009176:	9a05      	ldr	r2, [sp, #20]
 8009178:	2a00      	cmp	r2, #0
 800917a:	f040 8457 	bne.w	8009a2c <_fx_directory_entry_write+0xa54>
 800917e:	f1b8 0f03 	cmp.w	r8, #3
        {

            /* Name does not match, create a mangled name.  */

            /* Generate short file name from LFN.  */
            entry = entry_ptr -> fx_dir_entry_number;
 8009182:	f8d5 904c 	ldr.w	r9, [r5, #76]	; 0x4c
            /* Build short name of the format xxx~NNNN.ext.  */
            if (i > 3)
            {
                i = 3;
            }
            shortname[i++] = '~';
 8009186:	aa14      	add	r2, sp, #80	; 0x50
 8009188:	f04f 0e7e 	mov.w	lr, #126	; 0x7e
 800918c:	bf28      	it	cs
 800918e:	f04f 0803 	movcs.w	r8, #3
            entry = entry % 0x10000;
 8009192:	fa1f f389 	uxth.w	r3, r9
                {
                     temp = ((entry >> 4) & 0xf);
                }
                else
                {
                     temp = ((entry) & 0xf);
 8009196:	f009 090f 	and.w	r9, r9, #15
            shortname[i++] = '~';
 800919a:	eb02 0108 	add.w	r1, r2, r8
                    temp =  ((entry >> 12) & 0xf);
 800919e:	0b18      	lsrs	r0, r3, #12
                     temp = ((entry >> 4) & 0xf);
 80091a0:	f3c3 1c03 	ubfx	ip, r3, #4, #4
            shortname[i++] = '~';
 80091a4:	f108 0201 	add.w	r2, r8, #1
 80091a8:	f801 ec0c 	strb.w	lr, [r1, #-12]
                }
                
                /* Now build hex value.  */
                if (temp > 9)
 80091ac:	2809      	cmp	r0, #9
 80091ae:	fa5f fe80 	uxtb.w	lr, r0
                     temp = ((entry >> 8) & 0xf);
 80091b2:	f3c3 2303 	ubfx	r3, r3, #8, #4
 80091b6:	a814      	add	r0, sp, #80	; 0x50
 80091b8:	f108 0102 	add.w	r1, r8, #2
                    shortname[i++] =  (CHAR)('A' + (temp - 10));
 80091bc:	bf8c      	ite	hi
 80091be:	f10e 0e37 	addhi.w	lr, lr, #55	; 0x37
                else
                    shortname[i++] =  (CHAR)('0' + temp);
 80091c2:	f10e 0e30 	addls.w	lr, lr, #48	; 0x30
 80091c6:	4402      	add	r2, r0
                if (temp > 9)
 80091c8:	2b09      	cmp	r3, #9
 80091ca:	b2d8      	uxtb	r0, r3
 80091cc:	ab14      	add	r3, sp, #80	; 0x50
 80091ce:	f802 ec0c 	strb.w	lr, [r2, #-12]
 80091d2:	f108 0203 	add.w	r2, r8, #3
                    shortname[i++] =  (CHAR)('A' + (temp - 10));
 80091d6:	bf8c      	ite	hi
 80091d8:	3037      	addhi	r0, #55	; 0x37
                    shortname[i++] =  (CHAR)('0' + temp);
 80091da:	3030      	addls	r0, #48	; 0x30
 80091dc:	4419      	add	r1, r3
                if (temp > 9)
 80091de:	f1bc 0f09 	cmp.w	ip, #9
 80091e2:	fa5f f38c 	uxtb.w	r3, ip
 80091e6:	f108 0804 	add.w	r8, r8, #4
 80091ea:	f801 0c0c 	strb.w	r0, [r1, #-12]
 80091ee:	a914      	add	r1, sp, #80	; 0x50
                    shortname[i++] =  (CHAR)('A' + (temp - 10));
 80091f0:	bf8c      	ite	hi
 80091f2:	3337      	addhi	r3, #55	; 0x37
                    shortname[i++] =  (CHAR)('0' + temp);
 80091f4:	3330      	addls	r3, #48	; 0x30
 80091f6:	440a      	add	r2, r1
                if (temp > 9)
 80091f8:	f1b9 0f09 	cmp.w	r9, #9
 80091fc:	f802 3c0c 	strb.w	r3, [r2, #-12]
 8009200:	fa5f f389 	uxtb.w	r3, r9
 8009204:	aa14      	add	r2, sp, #80	; 0x50
                    shortname[i++] =  (CHAR)('A' + (temp - 10));
 8009206:	bf8c      	ite	hi
 8009208:	3337      	addhi	r3, #55	; 0x37
                    shortname[i++] =  (CHAR)('0' + temp);
 800920a:	3330      	addls	r3, #48	; 0x30
 800920c:	4490      	add	r8, r2
 800920e:	f808 3c0c 	strb.w	r3, [r8, #-12]
 8009212:	f89d 004c 	ldrb.w	r0, [sp, #76]	; 0x4c
        /* Set end of short string to NULL.   */
        shortname[11] = 0;

        /* Determine if the first character of the short file name is the directory free
           value. If so, it must be changed.  */
        if (((UCHAR)shortname[0] == (UCHAR)FX_DIR_ENTRY_FREE) && (delete_flag == FX_FALSE))
 8009216:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
        shortname[11] = 0;
 800921a:	2200      	movs	r2, #0
        if (((UCHAR)shortname[0] == (UCHAR)FX_DIR_ENTRY_FREE) && (delete_flag == FX_FALSE))
 800921c:	2be5      	cmp	r3, #229	; 0xe5
        shortname[11] = 0;
 800921e:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
        if (((UCHAR)shortname[0] == (UCHAR)FX_DIR_ENTRY_FREE) && (delete_flag == FX_FALSE))
 8009222:	f040 837d 	bne.w	8009920 <_fx_directory_entry_write+0x948>
 8009226:	9a07      	ldr	r2, [sp, #28]
 8009228:	2a00      	cmp	r2, #0
 800922a:	f000 8379 	beq.w	8009920 <_fx_directory_entry_write+0x948>
        /* Loop to convert the new short file name to upper case.  */
        for (i = 0; i < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); i++)
        {

            /* Pickup shortname character.  */
            alpha = shortname[i];
 800922e:	238f      	movs	r3, #143	; 0x8f
 8009230:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
                /* Store the character - converted to upper case.  */
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
            }

            /* Now store the short name character.  */
            shortname[i] =  alpha;
 8009234:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
            if ((alpha >= 'a') && (alpha <= 'z'))
 8009238:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 800923c:	2b19      	cmp	r3, #25
 800923e:	d801      	bhi.n	8009244 <_fx_directory_entry_write+0x26c>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009240:	3a20      	subs	r2, #32
 8009242:	b2d2      	uxtb	r2, r2
            alpha = shortname[i];
 8009244:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
            shortname[i] =  alpha;
 8009248:	f88d 2045 	strb.w	r2, [sp, #69]	; 0x45
            if ((alpha >= 'a') && (alpha <= 'z'))
 800924c:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 8009250:	2a19      	cmp	r2, #25
 8009252:	d801      	bhi.n	8009258 <_fx_directory_entry_write+0x280>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009254:	3b20      	subs	r3, #32
 8009256:	b2db      	uxtb	r3, r3
            alpha = shortname[i];
 8009258:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
            shortname[i] =  alpha;
 800925c:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
            if ((alpha >= 'a') && (alpha <= 'z'))
 8009260:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 8009264:	2b19      	cmp	r3, #25
 8009266:	d801      	bhi.n	800926c <_fx_directory_entry_write+0x294>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009268:	3a20      	subs	r2, #32
 800926a:	b2d2      	uxtb	r2, r2
            alpha = shortname[i];
 800926c:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
            shortname[i] =  alpha;
 8009270:	f88d 2047 	strb.w	r2, [sp, #71]	; 0x47
            if ((alpha >= 'a') && (alpha <= 'z'))
 8009274:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 8009278:	2a19      	cmp	r2, #25
 800927a:	d801      	bhi.n	8009280 <_fx_directory_entry_write+0x2a8>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 800927c:	3b20      	subs	r3, #32
 800927e:	b2db      	uxtb	r3, r3
            alpha = shortname[i];
 8009280:	f89d 2049 	ldrb.w	r2, [sp, #73]	; 0x49
            shortname[i] =  alpha;
 8009284:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
            if ((alpha >= 'a') && (alpha <= 'z'))
 8009288:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 800928c:	2b19      	cmp	r3, #25
 800928e:	d801      	bhi.n	8009294 <_fx_directory_entry_write+0x2bc>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009290:	3a20      	subs	r2, #32
 8009292:	b2d2      	uxtb	r2, r2
            alpha = shortname[i];
 8009294:	f89d 304a 	ldrb.w	r3, [sp, #74]	; 0x4a
            shortname[i] =  alpha;
 8009298:	f88d 2049 	strb.w	r2, [sp, #73]	; 0x49
            if ((alpha >= 'a') && (alpha <= 'z'))
 800929c:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 80092a0:	2a19      	cmp	r2, #25
 80092a2:	d801      	bhi.n	80092a8 <_fx_directory_entry_write+0x2d0>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 80092a4:	3b20      	subs	r3, #32
 80092a6:	b2db      	uxtb	r3, r3
            alpha = shortname[i];
 80092a8:	f89d 204b 	ldrb.w	r2, [sp, #75]	; 0x4b
            shortname[i] =  alpha;
 80092ac:	f88d 304a 	strb.w	r3, [sp, #74]	; 0x4a
            if ((alpha >= 'a') && (alpha <= 'z'))
 80092b0:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 80092b4:	2b19      	cmp	r3, #25
 80092b6:	d801      	bhi.n	80092bc <_fx_directory_entry_write+0x2e4>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 80092b8:	3a20      	subs	r2, #32
 80092ba:	b2d2      	uxtb	r2, r2
            shortname[i] =  alpha;
 80092bc:	f88d 204b 	strb.w	r2, [sp, #75]	; 0x4b
            if ((alpha >= 'a') && (alpha <= 'z'))
 80092c0:	f1a0 0261 	sub.w	r2, r0, #97	; 0x61
            alpha = shortname[i];
 80092c4:	4603      	mov	r3, r0
            if ((alpha >= 'a') && (alpha <= 'z'))
 80092c6:	2a19      	cmp	r2, #25
 80092c8:	d802      	bhi.n	80092d0 <_fx_directory_entry_write+0x2f8>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 80092ca:	f1a0 0320 	sub.w	r3, r0, #32
 80092ce:	b2db      	uxtb	r3, r3
            alpha = shortname[i];
 80092d0:	f89d 204d 	ldrb.w	r2, [sp, #77]	; 0x4d
            shortname[i] =  alpha;
 80092d4:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
            if ((alpha >= 'a') && (alpha <= 'z'))
 80092d8:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 80092dc:	2b19      	cmp	r3, #25
 80092de:	d801      	bhi.n	80092e4 <_fx_directory_entry_write+0x30c>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 80092e0:	3a20      	subs	r2, #32
 80092e2:	b2d2      	uxtb	r2, r2
            alpha = shortname[i];
 80092e4:	f89d 304e 	ldrb.w	r3, [sp, #78]	; 0x4e
            shortname[i] =  alpha;
 80092e8:	f88d 204d 	strb.w	r2, [sp, #77]	; 0x4d
            if ((alpha >= 'a') && (alpha <= 'z'))
 80092ec:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 80092f0:	2a19      	cmp	r2, #25
 80092f2:	d801      	bhi.n	80092f8 <_fx_directory_entry_write+0x320>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 80092f4:	3b20      	subs	r3, #32
 80092f6:	b2db      	uxtb	r3, r3
        }

        /* Determine if there already is a short name and we are not deleting the entry.  */
        if (entry_ptr -> fx_dir_entry_short_name[0] != 0)
 80092f8:	792a      	ldrb	r2, [r5, #4]
            shortname[i] =  alpha;
 80092fa:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
        if (entry_ptr -> fx_dir_entry_short_name[0] != 0)
 80092fe:	2a00      	cmp	r2, #0
 8009300:	f000 80c7 	beq.w	8009492 <_fx_directory_entry_write+0x4ba>
 8009304:	f04f 3320 	mov.w	r3, #538976288	; 0x20202020
                /* Check for end of copy conditions.  */
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
                {
                    break;
                }
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009308:	2a2e      	cmp	r2, #46	; 0x2e
 800930a:	9312      	str	r3, [sp, #72]	; 0x48
 800930c:	9311      	str	r3, [sp, #68]	; 0x44
 800930e:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
 8009312:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
 8009316:	f000 83fd 	beq.w	8009b14 <_fx_directory_entry_write+0xb3c>
 800931a:	796b      	ldrb	r3, [r5, #5]

                /* Pickup the character.  */
                alpha =  entry_ptr -> fx_dir_entry_short_name[i];

                /* Copy file name character.  */
                shortname[j] =  alpha;
 800931c:	f88d 2044 	strb.w	r2, [sp, #68]	; 0x44
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009320:	2b00      	cmp	r3, #0
 8009322:	f000 8475 	beq.w	8009c10 <_fx_directory_entry_write+0xc38>
 8009326:	2b2e      	cmp	r3, #46	; 0x2e
 8009328:	f000 8472 	beq.w	8009c10 <_fx_directory_entry_write+0xc38>
                shortname[j] =  alpha;
 800932c:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
 8009330:	79ab      	ldrb	r3, [r5, #6]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009332:	2b00      	cmp	r3, #0
 8009334:	f000 8469 	beq.w	8009c0a <_fx_directory_entry_write+0xc32>
 8009338:	2b2e      	cmp	r3, #46	; 0x2e
 800933a:	f000 8466 	beq.w	8009c0a <_fx_directory_entry_write+0xc32>
                shortname[j] =  alpha;
 800933e:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
 8009342:	79eb      	ldrb	r3, [r5, #7]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009344:	2b00      	cmp	r3, #0
 8009346:	f000 846a 	beq.w	8009c1e <_fx_directory_entry_write+0xc46>
 800934a:	2b2e      	cmp	r3, #46	; 0x2e
 800934c:	f000 8467 	beq.w	8009c1e <_fx_directory_entry_write+0xc46>
                shortname[j] =  alpha;
 8009350:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
 8009354:	7a2b      	ldrb	r3, [r5, #8]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009356:	2b00      	cmp	r3, #0
 8009358:	f000 8484 	beq.w	8009c64 <_fx_directory_entry_write+0xc8c>
 800935c:	2b2e      	cmp	r3, #46	; 0x2e
 800935e:	f000 8481 	beq.w	8009c64 <_fx_directory_entry_write+0xc8c>
                shortname[j] =  alpha;
 8009362:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 8009366:	7a6b      	ldrb	r3, [r5, #9]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009368:	2b00      	cmp	r3, #0
 800936a:	f000 8478 	beq.w	8009c5e <_fx_directory_entry_write+0xc86>
 800936e:	2b2e      	cmp	r3, #46	; 0x2e
 8009370:	f000 8475 	beq.w	8009c5e <_fx_directory_entry_write+0xc86>
                shortname[j] =  alpha;
 8009374:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
 8009378:	7aab      	ldrb	r3, [r5, #10]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 800937a:	2b00      	cmp	r3, #0
 800937c:	f000 846c 	beq.w	8009c58 <_fx_directory_entry_write+0xc80>
 8009380:	2b2e      	cmp	r3, #46	; 0x2e
 8009382:	f000 8469 	beq.w	8009c58 <_fx_directory_entry_write+0xc80>
                shortname[j] =  alpha;
 8009386:	f88d 304a 	strb.w	r3, [sp, #74]	; 0x4a
 800938a:	7aeb      	ldrb	r3, [r5, #11]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 800938c:	2b2e      	cmp	r3, #46	; 0x2e
 800938e:	f000 8460 	beq.w	8009c52 <_fx_directory_entry_write+0xc7a>
 8009392:	2b00      	cmp	r3, #0
 8009394:	f000 845d 	beq.w	8009c52 <_fx_directory_entry_write+0xc7a>
                shortname[j] =  alpha;
 8009398:	f88d 304b 	strb.w	r3, [sp, #75]	; 0x4b
 800939c:	2208      	movs	r2, #8
 800939e:	7b2b      	ldrb	r3, [r5, #12]
            }

            /* Determine if there is anything left in the short file name.  */
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 80093a0:	2b00      	cmp	r3, #0
 80093a2:	f040 83b8 	bne.w	8009b16 <_fx_directory_entry_write+0xb3e>
 80093a6:	e001      	b.n	80093ac <_fx_directory_entry_write+0x3d4>
 80093a8:	4ec4ec4f 	.word	0x4ec4ec4f
            /* Loop to make sure the short name is upper case.  */
            for (j = 0; j < (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE); j++)
            {

                /* Pickup the character.  */
                alpha =  shortname[j];
 80093ac:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44

                /* Determine if character is lower case.  */
                if ((alpha >= 'a') && (alpha <= 'z'))
 80093b0:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 80093b4:	2a19      	cmp	r2, #25
 80093b6:	d801      	bhi.n	80093bc <_fx_directory_entry_write+0x3e4>
                {

                    /* Store the character - converted to upper case.  */
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 80093b8:	3b20      	subs	r3, #32
 80093ba:	b2db      	uxtb	r3, r3
                alpha =  shortname[j];
 80093bc:	f89d 1045 	ldrb.w	r1, [sp, #69]	; 0x45
                }

                /* Copy file name character.  */
                shortname[j] =  alpha;
 80093c0:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
                if ((alpha >= 'a') && (alpha <= 'z'))
 80093c4:	f1a1 0261 	sub.w	r2, r1, #97	; 0x61
 80093c8:	2a19      	cmp	r2, #25
 80093ca:	d801      	bhi.n	80093d0 <_fx_directory_entry_write+0x3f8>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 80093cc:	3920      	subs	r1, #32
 80093ce:	b2c9      	uxtb	r1, r1
                alpha =  shortname[j];
 80093d0:	f89d 2046 	ldrb.w	r2, [sp, #70]	; 0x46
                shortname[j] =  alpha;
 80093d4:	f88d 1045 	strb.w	r1, [sp, #69]	; 0x45
                if ((alpha >= 'a') && (alpha <= 'z'))
 80093d8:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
 80093dc:	2919      	cmp	r1, #25
 80093de:	d801      	bhi.n	80093e4 <_fx_directory_entry_write+0x40c>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 80093e0:	3a20      	subs	r2, #32
 80093e2:	b2d2      	uxtb	r2, r2
                alpha =  shortname[j];
 80093e4:	f89d 1047 	ldrb.w	r1, [sp, #71]	; 0x47
                shortname[j] =  alpha;
 80093e8:	f88d 2046 	strb.w	r2, [sp, #70]	; 0x46
                if ((alpha >= 'a') && (alpha <= 'z'))
 80093ec:	f1a1 0261 	sub.w	r2, r1, #97	; 0x61
 80093f0:	2a19      	cmp	r2, #25
 80093f2:	d801      	bhi.n	80093f8 <_fx_directory_entry_write+0x420>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 80093f4:	3920      	subs	r1, #32
 80093f6:	b2c9      	uxtb	r1, r1
                alpha =  shortname[j];
 80093f8:	f89d 2048 	ldrb.w	r2, [sp, #72]	; 0x48
                shortname[j] =  alpha;
 80093fc:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009400:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
 8009404:	2919      	cmp	r1, #25
 8009406:	d801      	bhi.n	800940c <_fx_directory_entry_write+0x434>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009408:	3a20      	subs	r2, #32
 800940a:	b2d2      	uxtb	r2, r2
                alpha =  shortname[j];
 800940c:	f89d 1049 	ldrb.w	r1, [sp, #73]	; 0x49
                shortname[j] =  alpha;
 8009410:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009414:	f1a1 0261 	sub.w	r2, r1, #97	; 0x61
 8009418:	2a19      	cmp	r2, #25
 800941a:	d801      	bhi.n	8009420 <_fx_directory_entry_write+0x448>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 800941c:	3920      	subs	r1, #32
 800941e:	b2c9      	uxtb	r1, r1
                alpha =  shortname[j];
 8009420:	f89d 204a 	ldrb.w	r2, [sp, #74]	; 0x4a
                shortname[j] =  alpha;
 8009424:	f88d 1049 	strb.w	r1, [sp, #73]	; 0x49
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009428:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
 800942c:	2919      	cmp	r1, #25
 800942e:	d801      	bhi.n	8009434 <_fx_directory_entry_write+0x45c>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009430:	3a20      	subs	r2, #32
 8009432:	b2d2      	uxtb	r2, r2
                alpha =  shortname[j];
 8009434:	f89d 104b 	ldrb.w	r1, [sp, #75]	; 0x4b
                shortname[j] =  alpha;
 8009438:	f88d 204a 	strb.w	r2, [sp, #74]	; 0x4a
                if ((alpha >= 'a') && (alpha <= 'z'))
 800943c:	f1a1 0261 	sub.w	r2, r1, #97	; 0x61
 8009440:	2a19      	cmp	r2, #25
 8009442:	d801      	bhi.n	8009448 <_fx_directory_entry_write+0x470>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009444:	3920      	subs	r1, #32
 8009446:	b2c9      	uxtb	r1, r1
                alpha =  shortname[j];
 8009448:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
                shortname[j] =  alpha;
 800944c:	f88d 104b 	strb.w	r1, [sp, #75]	; 0x4b
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009450:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
 8009454:	2919      	cmp	r1, #25
 8009456:	d801      	bhi.n	800945c <_fx_directory_entry_write+0x484>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009458:	3a20      	subs	r2, #32
 800945a:	b2d2      	uxtb	r2, r2
                alpha =  shortname[j];
 800945c:	f89d 104d 	ldrb.w	r1, [sp, #77]	; 0x4d
                shortname[j] =  alpha;
 8009460:	f88d 204c 	strb.w	r2, [sp, #76]	; 0x4c
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009464:	f1a1 0261 	sub.w	r2, r1, #97	; 0x61
 8009468:	2a19      	cmp	r2, #25
 800946a:	d801      	bhi.n	8009470 <_fx_directory_entry_write+0x498>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 800946c:	3920      	subs	r1, #32
 800946e:	b2c9      	uxtb	r1, r1
                alpha =  shortname[j];
 8009470:	f89d 204e 	ldrb.w	r2, [sp, #78]	; 0x4e
                shortname[j] =  alpha;
 8009474:	f88d 104d 	strb.w	r1, [sp, #77]	; 0x4d
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009478:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
 800947c:	2919      	cmp	r1, #25
 800947e:	d801      	bhi.n	8009484 <_fx_directory_entry_write+0x4ac>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009480:	3a20      	subs	r2, #32
 8009482:	b2d2      	uxtb	r2, r2
            }

            /* Determine if the first character of the short file name is the directory free
               value. If so, it must be changed.  */
            if (((UCHAR)shortname[0]) == ((UCHAR)FX_DIR_ENTRY_FREE))
 8009484:	2be5      	cmp	r3, #229	; 0xe5
                shortname[j] =  alpha;
 8009486:	f88d 204e 	strb.w	r2, [sp, #78]	; 0x4e
            if (((UCHAR)shortname[0]) == ((UCHAR)FX_DIR_ENTRY_FREE))
 800948a:	d102      	bne.n	8009492 <_fx_directory_entry_write+0x4ba>
            {

                /* Change to 0x8F to be compatible with what DOS does.  */
                shortname[0] =  (CHAR)0x8F;
 800948c:	238f      	movs	r3, #143	; 0x8f
 800948e:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
        /* Loop to calculate the checksum.  */
        for (i = checksum = 0; i < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++)
        {

            /* Calculate the checksum.  */
            checksum = (UCHAR)((UCHAR)(((checksum & 1) << 7) | ((checksum & (UCHAR)0xfe) >> 1)) + shortname[i]);
 8009492:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
        }

        /* Set the last entry mark.  */
        work_ptr[0] =  (UCHAR)(0x40 | card);
 8009496:	f047 0040 	orr.w	r0, r7, #64	; 0x40
            checksum = (UCHAR)((UCHAR)(((checksum & 1) << 7) | ((checksum & (UCHAR)0xfe) >> 1)) + shortname[i]);
 800949a:	f89d 1045 	ldrb.w	r1, [sp, #69]	; 0x45
 800949e:	01da      	lsls	r2, r3, #7
 80094a0:	f89d c046 	ldrb.w	ip, [sp, #70]	; 0x46
        work_ptr[0] =  (UCHAR)(0x40 | card);
 80094a4:	7020      	strb	r0, [r4, #0]
            checksum = (UCHAR)((UCHAR)(((checksum & 1) << 7) | ((checksum & (UCHAR)0xfe) >> 1)) + shortname[i]);
 80094a6:	ea42 0253 	orr.w	r2, r2, r3, lsr #1
 80094aa:	f89d 0047 	ldrb.w	r0, [sp, #71]	; 0x47
 80094ae:	440a      	add	r2, r1
 80094b0:	b2d1      	uxtb	r1, r2
 80094b2:	01ca      	lsls	r2, r1, #7
 80094b4:	ea42 0251 	orr.w	r2, r2, r1, lsr #1
 80094b8:	f89d 1048 	ldrb.w	r1, [sp, #72]	; 0x48
 80094bc:	fa5c f282 	uxtab	r2, ip, r2
 80094c0:	fa5f fc82 	uxtb.w	ip, r2
 80094c4:	ea4f 12cc 	mov.w	r2, ip, lsl #7
 80094c8:	ea42 025c 	orr.w	r2, r2, ip, lsr #1
 80094cc:	f89d c049 	ldrb.w	ip, [sp, #73]	; 0x49
 80094d0:	fa50 f282 	uxtab	r2, r0, r2
 80094d4:	b2d0      	uxtb	r0, r2
 80094d6:	01c2      	lsls	r2, r0, #7
 80094d8:	ea42 0250 	orr.w	r2, r2, r0, lsr #1
 80094dc:	f89d 004a 	ldrb.w	r0, [sp, #74]	; 0x4a
 80094e0:	fa51 f282 	uxtab	r2, r1, r2
 80094e4:	b2d1      	uxtb	r1, r2
 80094e6:	01ca      	lsls	r2, r1, #7
 80094e8:	ea42 0251 	orr.w	r2, r2, r1, lsr #1
 80094ec:	f89d 104b 	ldrb.w	r1, [sp, #75]	; 0x4b
 80094f0:	fa5c f282 	uxtab	r2, ip, r2
 80094f4:	fa5f fc82 	uxtb.w	ip, r2
 80094f8:	ea4f 025c 	mov.w	r2, ip, lsr #1
 80094fc:	ea42 12cc 	orr.w	r2, r2, ip, lsl #7
 8009500:	f89d c04c 	ldrb.w	ip, [sp, #76]	; 0x4c
 8009504:	fa50 f282 	uxtab	r2, r0, r2
 8009508:	b2d0      	uxtb	r0, r2
 800950a:	0842      	lsrs	r2, r0, #1
 800950c:	ea42 12c0 	orr.w	r2, r2, r0, lsl #7
 8009510:	f89d 004d 	ldrb.w	r0, [sp, #77]	; 0x4d
 8009514:	fa51 f282 	uxtab	r2, r1, r2
 8009518:	b2d1      	uxtb	r1, r2
 800951a:	084a      	lsrs	r2, r1, #1
 800951c:	ea42 12c1 	orr.w	r2, r2, r1, lsl #7
 8009520:	f89d 104e 	ldrb.w	r1, [sp, #78]	; 0x4e
 8009524:	fa5c f282 	uxtab	r2, ip, r2
 8009528:	fa5f fc82 	uxtb.w	ip, r2
 800952c:	ea4f 025c 	mov.w	r2, ip, lsr #1
 8009530:	ea42 12cc 	orr.w	r2, r2, ip, lsl #7
 8009534:	fa50 f282 	uxtab	r2, r0, r2
 8009538:	b2d2      	uxtb	r2, r2
 800953a:	0850      	lsrs	r0, r2, #1
 800953c:	ea40 12c2 	orr.w	r2, r0, r2, lsl #7
 8009540:	fa51 f182 	uxtab	r1, r1, r2
 8009544:	b2ca      	uxtb	r2, r1
 8009546:	9207      	str	r2, [sp, #28]

        /* Loop to process remainder of long file name entry.  */
        while (card > 0)
 8009548:	2f00      	cmp	r7, #0
 800954a:	f000 8241 	beq.w	80099d0 <_fx_directory_entry_write+0x9f8>
 800954e:	eb07 0847 	add.w	r8, r7, r7, lsl #1
 8009552:	9906      	ldr	r1, [sp, #24]
 8009554:	f04f 0a00 	mov.w	sl, #0
 8009558:	4622      	mov	r2, r4
 800955a:	eb07 0888 	add.w	r8, r7, r8, lsl #2
 800955e:	460c      	mov	r4, r1

                /* Determine if the EOF marker is present.  */
                if (eof_marker)
                {

                    work_ptr[i] = eof_marker;
 8009560:	f04f 09ff 	mov.w	r9, #255	; 0xff
 8009564:	4658      	mov	r0, fp
 8009566:	f1a8 080d 	sub.w	r8, r8, #13
 800956a:	4651      	mov	r1, sl
            if ((UCHAR)shortname[0] == (UCHAR)FX_DIR_ENTRY_FREE)
 800956c:	2be5      	cmp	r3, #229	; 0xe5
            work_ptr[12] = 0;
 800956e:	f04f 0a00 	mov.w	sl, #0
            for (i = 1, j = 13 * (card - 1); i < FX_DIR_ENTRY_SIZE; i += 2)
 8009572:	46c6      	mov	lr, r8
 8009574:	9105      	str	r1, [sp, #20]
                work_ptr[0] =  (UCHAR)FX_DIR_ENTRY_FREE;
 8009576:	bf08      	it	eq
 8009578:	7013      	strbeq	r3, [r2, #0]
            work_ptr[11] = FX_LONG_NAME;
 800957a:	f04f 030f 	mov.w	r3, #15
            eof_marker = 0;
 800957e:	46d4      	mov	ip, sl
            work_ptr[12] = 0;
 8009580:	f882 a00c 	strb.w	sl, [r2, #12]
            work_ptr[11] = FX_LONG_NAME;
 8009584:	72d3      	strb	r3, [r2, #11]
            work_ptr[13] = checksum;
 8009586:	9b07      	ldr	r3, [sp, #28]
            work_ptr[26] = 0;
 8009588:	f882 a01a 	strb.w	sl, [r2, #26]
            work_ptr[13] = checksum;
 800958c:	7353      	strb	r3, [r2, #13]
            for (i = 1, j = 13 * (card - 1); i < FX_DIR_ENTRY_SIZE; i += 2)
 800958e:	2301      	movs	r3, #1
            work_ptr[27] = 0;
 8009590:	f882 a01b 	strb.w	sl, [r2, #27]
                if ((i == 11) || (i == 26))
 8009594:	2b0b      	cmp	r3, #11
 8009596:	f103 0a01 	add.w	sl, r3, #1
 800959a:	d016      	beq.n	80095ca <_fx_directory_entry_write+0x5f2>
 800959c:	2b1a      	cmp	r3, #26
 800959e:	d014      	beq.n	80095ca <_fx_directory_entry_write+0x5f2>
                if (i == 13)
 80095a0:	2b0d      	cmp	r3, #13
 80095a2:	f000 81d6 	beq.w	8009952 <_fx_directory_entry_write+0x97a>
                if (eof_marker)
 80095a6:	f1bc 0f00 	cmp.w	ip, #0
 80095aa:	f000 81ca 	beq.w	8009942 <_fx_directory_entry_write+0x96a>
                    work_ptr[i] = eof_marker;
 80095ae:	f802 9003 	strb.w	r9, [r2, r3]
                    work_ptr[i + 1] = eof_marker;
 80095b2:	f802 900a 	strb.w	r9, [r2, sl]
                {
                    work_ptr[i] = (UCHAR)entry_ptr -> fx_dir_entry_name[j];
                    work_ptr[i + 1] = 0;
                }

                if (entry_ptr -> fx_dir_entry_name[j] == 0)
 80095b6:	6829      	ldr	r1, [r5, #0]
 80095b8:	f811 a00e 	ldrb.w	sl, [r1, lr]

                    /* end of name, pad with 0xff.  */
                    eof_marker =  (UCHAR)0xff;
                }

                j++;
 80095bc:	f10e 0e01 	add.w	lr, lr, #1
                    eof_marker =  (UCHAR)0xff;
 80095c0:	f1ba 0f00 	cmp.w	sl, #0
 80095c4:	bf08      	it	eq
 80095c6:	f04f 0cff 	moveq.w	ip, #255	; 0xff
            for (i = 1, j = 13 * (card - 1); i < FX_DIR_ENTRY_SIZE; i += 2)
 80095ca:	3302      	adds	r3, #2
 80095cc:	2b1f      	cmp	r3, #31
 80095ce:	d9e1      	bls.n	8009594 <_fx_directory_entry_write+0x5bc>
            }

            /* Move to the next directory entry.  */
            work_ptr += FX_DIR_ENTRY_SIZE;
            byte_offset += FX_DIR_ENTRY_SIZE;
 80095d0:	3020      	adds	r0, #32
            /* Update changed_size. */
            changed_size += FX_DIR_ENTRY_SIZE;
#endif /* FX_ENABLE_FAULT_TOLERANT */

            /* Determine if the entry overlaps into the next sector.  */
            if (byte_offset >= media_ptr -> fx_media_bytes_per_sector)
 80095d2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80095d4:	9905      	ldr	r1, [sp, #20]
 80095d6:	46a2      	mov	sl, r4
 80095d8:	4283      	cmp	r3, r0
 80095da:	468b      	mov	fp, r1
 80095dc:	f240 81bb 	bls.w	8009956 <_fx_directory_entry_write+0x97e>
            work_ptr += FX_DIR_ENTRY_SIZE;
 80095e0:	3220      	adds	r2, #32
                changed_offset = 0;
#endif /* FX_ENABLE_FAULT_TOLERANT */
            }

            /* Decrement loop control.  */
            card--;
 80095e2:	3f01      	subs	r7, #1
 80095e4:	f1a8 080d 	sub.w	r8, r8, #13
            work_ptr[0] = (UCHAR)card;
 80095e8:	7017      	strb	r7, [r2, #0]
        while (card > 0)
 80095ea:	2f00      	cmp	r7, #0
 80095ec:	f000 81ed 	beq.w	80099ca <_fx_directory_entry_write+0x9f2>
 80095f0:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
 80095f4:	e7ba      	b.n	800956c <_fx_directory_entry_write+0x594>
        /* Determine if there are more characters to copy.  */
        if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] != 0)
        {

            /* Copy directory name.  */
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 80095f6:	2304      	movs	r3, #4
                work_ptr[j] =  (UCHAR)alpha;
            }
        }

        /* Determine if there are more characters in the name.  */
        if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] != 0)
 80095f8:	b1f9      	cbz	r1, 800963a <_fx_directory_entry_write+0x662>
            /* Loop to copy the remainder of the name.  */
            for (i++, j = FX_DIR_NAME_SIZE; j < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE; i++, j++)
            {

                /* Check for end of copy conditions.  */
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 80095fa:	441a      	add	r2, r3
 80095fc:	7852      	ldrb	r2, [r2, #1]
 80095fe:	b1e2      	cbz	r2, 800963a <_fx_directory_entry_write+0x662>

                /* Pickup shortname character.  */
                alpha = entry_ptr -> fx_dir_entry_name[i];

                /* Determine if character is lower case.  */
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009600:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
 8009604:	2919      	cmp	r1, #25
 8009606:	d801      	bhi.n	800960c <_fx_directory_entry_write+0x634>
                {

                    /* Store the character - converted to upper case.  */
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009608:	3a20      	subs	r2, #32
 800960a:	b2d2      	uxtb	r2, r2
                }

                /* Copy a name character.  */
                work_ptr[j] =  (UCHAR)alpha;
 800960c:	7222      	strb	r2, [r4, #8]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 800960e:	682a      	ldr	r2, [r5, #0]
 8009610:	441a      	add	r2, r3
 8009612:	7892      	ldrb	r2, [r2, #2]
 8009614:	b18a      	cbz	r2, 800963a <_fx_directory_entry_write+0x662>
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009616:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
 800961a:	2919      	cmp	r1, #25
 800961c:	d801      	bhi.n	8009622 <_fx_directory_entry_write+0x64a>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 800961e:	3a20      	subs	r2, #32
 8009620:	b2d2      	uxtb	r2, r2
                work_ptr[j] =  (UCHAR)alpha;
 8009622:	7262      	strb	r2, [r4, #9]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 8009624:	682a      	ldr	r2, [r5, #0]
 8009626:	4413      	add	r3, r2
 8009628:	78db      	ldrb	r3, [r3, #3]
 800962a:	b133      	cbz	r3, 800963a <_fx_directory_entry_write+0x662>
                if ((alpha >= 'a') && (alpha <= 'z'))
 800962c:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 8009630:	2a19      	cmp	r2, #25
 8009632:	d801      	bhi.n	8009638 <_fx_directory_entry_write+0x660>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009634:	3b20      	subs	r3, #32
 8009636:	b2db      	uxtb	r3, r3
                work_ptr[j] =  (UCHAR)alpha;
 8009638:	72a3      	strb	r3, [r4, #10]
            }
        }

        /* Move to the next entry.  */
        work_ptr += (FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE);
 800963a:	340b      	adds	r4, #11
    }

    /* Write out the 8.3 part of the name. */

    /* Copy the attribute into the destination.  */
    *work_ptr++ =  entry_ptr -> fx_dir_entry_attributes;
 800963c:	7f2b      	ldrb	r3, [r5, #28]

    /* Copy the created time in milliseconds.  */
    *work_ptr++ =  entry_ptr -> fx_dir_entry_created_time_ms;

    /* Copy the created time.  */
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_created_time);
 800963e:	1ce0      	adds	r0, r4, #3
    *work_ptr++ =  entry_ptr -> fx_dir_entry_attributes;
 8009640:	7023      	strb	r3, [r4, #0]
    *work_ptr++ =  entry_ptr -> fx_dir_entry_reserved;
 8009642:	7f6b      	ldrb	r3, [r5, #29]
 8009644:	7063      	strb	r3, [r4, #1]
    *work_ptr++ =  entry_ptr -> fx_dir_entry_created_time_ms;
 8009646:	7fab      	ldrb	r3, [r5, #30]
 8009648:	70a3      	strb	r3, [r4, #2]
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_created_time);
 800964a:	6a29      	ldr	r1, [r5, #32]
 800964c:	f000 fec8 	bl	800a3e0 <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */

    /* Copy the created date.  */
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_created_date);
 8009650:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8009652:	1d60      	adds	r0, r4, #5
 8009654:	f000 fec4 	bl	800a3e0 <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */

    /* Copy the last accessed date.  */
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_last_accessed_date);
 8009658:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800965a:	1de0      	adds	r0, r4, #7
 800965c:	f000 fec0 	bl	800a3e0 <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */

    /* Determine if a FAT32 entry is present.  */
    if (media_ptr -> fx_media_32_bit_FAT)
 8009660:	6e71      	ldr	r1, [r6, #100]	; 0x64
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */
 8009662:	f104 0009 	add.w	r0, r4, #9
    if (media_ptr -> fx_media_32_bit_FAT)
 8009666:	2900      	cmp	r1, #0
 8009668:	f000 81ef 	beq.w	8009a4a <_fx_directory_entry_write+0xa72>
    {

        /* Yes, FAT32 is present, store upper half of cluster.  */
        temp = (entry_ptr -> fx_dir_entry_cluster >> 16);
        _fx_utility_16_unsigned_write(work_ptr, temp);
 800966c:	8ee9      	ldrh	r1, [r5, #54]	; 0x36
 800966e:	f000 feb7 	bl	800a3e0 <_fx_utility_16_unsigned_write>

    /* Advance the entry pointer.  */
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */

    /* Copy the time into the destination.  */
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_time);
 8009672:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8009674:	f104 000b 	add.w	r0, r4, #11
 8009678:	f000 feb2 	bl	800a3e0 <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */

    /* Copy the date into the destination.  */
    _fx_utility_16_unsigned_write(work_ptr, entry_ptr -> fx_dir_entry_date);
 800967c:	6b29      	ldr	r1, [r5, #48]	; 0x30
 800967e:	f104 000d 	add.w	r0, r4, #13
 8009682:	f000 fead 	bl	800a3e0 <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */

    /* Copy the starting cluster into the destination.  */
    _fx_utility_16_unsigned_write(work_ptr, (UINT)entry_ptr -> fx_dir_entry_cluster);
 8009686:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8009688:	f104 000f 	add.w	r0, r4, #15
 800968c:	f000 fea8 	bl	800a3e0 <_fx_utility_16_unsigned_write>
    work_ptr =  work_ptr + 2;  /* Always 2 bytes  */

    /* Copy the file size into the destination.  */
    _fx_utility_32_unsigned_write(work_ptr, (ULONG)entry_ptr -> fx_dir_entry_file_size);
 8009690:	f104 0011 	add.w	r0, r4, #17
 8009694:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 8009696:	f7fe f89d 	bl	80077d4 <_fx_utility_32_unsigned_write>
    else
    {
#endif /* FX_ENABLE_FAULT_TOLERANT */

        /* Write the directory sector to the media.  */
        status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) logical_sector,
 800969a:	9b08      	ldr	r3, [sp, #32]
 800969c:	2003      	movs	r0, #3
 800969e:	2101      	movs	r1, #1
 80096a0:	9300      	str	r3, [sp, #0]
 80096a2:	9002      	str	r0, [sp, #8]
 80096a4:	4630      	mov	r0, r6
 80096a6:	9101      	str	r1, [sp, #4]
 80096a8:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 80096ac:	f7ff f8c2 	bl	8008834 <_fx_utility_logical_sector_write>
#ifdef FX_ENABLE_FAULT_TOLERANT
    }
#endif /* FX_ENABLE_FAULT_TOLERANT */

    /* Determine if an error occurred.  */
    if (status != FX_SUCCESS)
 80096b0:	900a      	str	r0, [sp, #40]	; 0x28
 80096b2:	2800      	cmp	r0, #0
 80096b4:	d12f      	bne.n	8009716 <_fx_directory_entry_write+0x73e>

#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE

    /* Determine if there is a previously found directory entry in the directory
       search cache.  */
    if (media_ptr -> fx_media_last_found_name[0])
 80096b6:	f896 33e0 	ldrb.w	r3, [r6, #992]	; 0x3e0
 80096ba:	b363      	cbz	r3, 8009716 <_fx_directory_entry_write+0x73e>
    {

        /* Determine if the cached search directory entry matches the directory entry being
           written.  */
        if ((entry_ptr -> fx_dir_entry_log_sector == media_ptr -> fx_media_last_found_entry.fx_dir_entry_log_sector) &&
 80096bc:	f506 712c 	add.w	r1, r6, #688	; 0x2b0
 80096c0:	e9d5 2310 	ldrd	r2, r3, [r5, #64]	; 0x40
 80096c4:	e9d1 0100 	ldrd	r0, r1, [r1]
 80096c8:	428b      	cmp	r3, r1
 80096ca:	bf08      	it	eq
 80096cc:	4282      	cmpeq	r2, r0
 80096ce:	d122      	bne.n	8009716 <_fx_directory_entry_write+0x73e>
 80096d0:	6caa      	ldr	r2, [r5, #72]	; 0x48
 80096d2:	f8d6 32b8 	ldr.w	r3, [r6, #696]	; 0x2b8
 80096d6:	429a      	cmp	r2, r3
 80096d8:	d11d      	bne.n	8009716 <_fx_directory_entry_write+0x73e>
        {

            /* Yes, this entry is the same as the one currently in the directory search cache.
               Update various fields in the directory search cache with the information being
               written now.  */
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_cluster =         entry_ptr -> fx_dir_entry_cluster;
 80096da:	6b6b      	ldr	r3, [r5, #52]	; 0x34
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_file_size =       entry_ptr -> fx_dir_entry_file_size;
 80096dc:	f506 702a 	add.w	r0, r6, #680	; 0x2a8
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_attributes =      entry_ptr -> fx_dir_entry_attributes;
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_time =            entry_ptr -> fx_dir_entry_time;
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_date =            entry_ptr -> fx_dir_entry_date;
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_reserved =        entry_ptr -> fx_dir_entry_reserved;
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_created_time_ms = entry_ptr -> fx_dir_entry_created_time_ms;
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_created_time =    entry_ptr -> fx_dir_entry_created_time;
 80096e0:	f506 7124 	add.w	r1, r6, #656	; 0x290
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_cluster =         entry_ptr -> fx_dir_entry_cluster;
 80096e4:	f8c6 32a4 	str.w	r3, [r6, #676]	; 0x2a4
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_file_size =       entry_ptr -> fx_dir_entry_file_size;
 80096e8:	e9d5 230e 	ldrd	r2, r3, [r5, #56]	; 0x38
 80096ec:	e9c0 2300 	strd	r2, r3, [r0]
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_attributes =      entry_ptr -> fx_dir_entry_attributes;
 80096f0:	7f2b      	ldrb	r3, [r5, #28]
 80096f2:	f886 328c 	strb.w	r3, [r6, #652]	; 0x28c
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_time =            entry_ptr -> fx_dir_entry_time;
 80096f6:	6aea      	ldr	r2, [r5, #44]	; 0x2c
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_date =            entry_ptr -> fx_dir_entry_date;
 80096f8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_time =            entry_ptr -> fx_dir_entry_time;
 80096fa:	f8c6 229c 	str.w	r2, [r6, #668]	; 0x29c
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_date =            entry_ptr -> fx_dir_entry_date;
 80096fe:	f8c6 32a0 	str.w	r3, [r6, #672]	; 0x2a0
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_reserved =        entry_ptr -> fx_dir_entry_reserved;
 8009702:	7f6b      	ldrb	r3, [r5, #29]
 8009704:	f886 328d 	strb.w	r3, [r6, #653]	; 0x28d
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_created_time_ms = entry_ptr -> fx_dir_entry_created_time_ms;
 8009708:	7fab      	ldrb	r3, [r5, #30]
 800970a:	f886 328e 	strb.w	r3, [r6, #654]	; 0x28e
            media_ptr -> fx_media_last_found_entry.fx_dir_entry_created_time =    entry_ptr -> fx_dir_entry_created_time;
 800970e:	e9d5 2308 	ldrd	r2, r3, [r5, #32]
 8009712:	e9c1 2300 	strd	r2, r3, [r1]
    }
#endif

    /* Return success to the caller.  */
    return(FX_SUCCESS);
}
 8009716:	980a      	ldr	r0, [sp, #40]	; 0x28
 8009718:	b015      	add	sp, #84	; 0x54
 800971a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        cluster =  0;
 800971e:	2300      	movs	r3, #0
 8009720:	930b      	str	r3, [sp, #44]	; 0x2c
        relative_sector =  0;
 8009722:	9309      	str	r3, [sp, #36]	; 0x24
 8009724:	e47d      	b.n	8009022 <_fx_directory_entry_write+0x4a>
        if (entry_ptr -> fx_dir_entry_long_name_shorted > 0)
 8009726:	69ab      	ldr	r3, [r5, #24]
 8009728:	2b00      	cmp	r3, #0
 800972a:	d062      	beq.n	80097f2 <_fx_directory_entry_write+0x81a>
            if ((UCHAR)(0x40 | entry_ptr -> fx_dir_entry_long_name_shorted) == (UCHAR)(*work_ptr))
 800972c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009730:	7822      	ldrb	r2, [r4, #0]
 8009732:	b2db      	uxtb	r3, r3
 8009734:	429a      	cmp	r2, r3
 8009736:	d15c      	bne.n	80097f2 <_fx_directory_entry_write+0x81a>
                                if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8009738:	f242 49a8 	movw	r9, #9384	; 0x24a8
 800973c:	9a06      	ldr	r2, [sp, #24]
                            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) logical_sector,
 800973e:	46d0      	mov	r8, sl
 8009740:	f04f 0a00 	mov.w	sl, #0
                                if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8009744:	44b1      	add	r9, r6
 8009746:	4658      	mov	r0, fp
 8009748:	4651      	mov	r1, sl
 800974a:	4623      	mov	r3, r4
 800974c:	f8cd 9018 	str.w	r9, [sp, #24]
 8009750:	4693      	mov	fp, r2
 8009752:	f8dd c020 	ldr.w	ip, [sp, #32]
 8009756:	4691      	mov	r9, r2
 8009758:	46aa      	mov	sl, r5
 800975a:	e005      	b.n	8009768 <_fx_directory_entry_write+0x790>
                    work_ptr += FX_DIR_ENTRY_SIZE;
 800975c:	3320      	adds	r3, #32
                for (j = 0; j < entry_ptr -> fx_dir_entry_long_name_shorted; j++)
 800975e:	3701      	adds	r7, #1
 8009760:	f8da 2018 	ldr.w	r2, [sl, #24]
 8009764:	42ba      	cmp	r2, r7
 8009766:	d93e      	bls.n	80097e6 <_fx_directory_entry_write+0x80e>
                    if ((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE)
 8009768:	f8da 2000 	ldr.w	r2, [sl]
                    byte_offset += FX_DIR_ENTRY_SIZE;
 800976c:	3020      	adds	r0, #32
 800976e:	464c      	mov	r4, r9
 8009770:	460d      	mov	r5, r1
                    if ((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE)
 8009772:	7812      	ldrb	r2, [r2, #0]
 8009774:	2ae5      	cmp	r2, #229	; 0xe5
                        work_ptr[0] =  (UCHAR)FX_DIR_ENTRY_FREE;
 8009776:	bf08      	it	eq
 8009778:	701a      	strbeq	r2, [r3, #0]
                    if (byte_offset >= media_ptr -> fx_media_bytes_per_sector)
 800977a:	6ab2      	ldr	r2, [r6, #40]	; 0x28
 800977c:	4282      	cmp	r2, r0
 800977e:	d8ed      	bhi.n	800975c <_fx_directory_entry_write+0x784>
                            status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) logical_sector,
 8009780:	2001      	movs	r0, #1
 8009782:	f8cd 8008 	str.w	r8, [sp, #8]
 8009786:	f8cd c000 	str.w	ip, [sp]
 800978a:	464a      	mov	r2, r9
 800978c:	9001      	str	r0, [sp, #4]
 800978e:	460b      	mov	r3, r1
 8009790:	4630      	mov	r0, r6
 8009792:	f7ff f84f 	bl	8008834 <_fx_utility_logical_sector_write>
                        if (status != FX_SUCCESS)
 8009796:	2800      	cmp	r0, #0
 8009798:	f040 8160 	bne.w	8009a5c <_fx_directory_entry_write+0xa84>
                        if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 800979c:	6d33      	ldr	r3, [r6, #80]	; 0x50
 800979e:	455b      	cmp	r3, fp
 80097a0:	f200 8156 	bhi.w	8009a50 <_fx_directory_entry_write+0xa78>
                            if (relative_sector < (media_ptr -> fx_media_sectors_per_cluster - 1))
 80097a4:	6d73      	ldr	r3, [r6, #84]	; 0x54
 80097a6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80097a8:	3b01      	subs	r3, #1
 80097aa:	4293      	cmp	r3, r2
 80097ac:	f240 81c7 	bls.w	8009b3e <_fx_directory_entry_write+0xb66>
                                relative_sector++;
 80097b0:	3201      	adds	r2, #1
                                logical_sector++;
 80097b2:	f10b 0b01 	add.w	fp, fp, #1
                                relative_sector++;
 80097b6:	9209      	str	r2, [sp, #36]	; 0x24
                        status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 80097b8:	68b3      	ldr	r3, [r6, #8]
 80097ba:	2100      	movs	r1, #0
 80097bc:	2001      	movs	r0, #1
 80097be:	f8cd 8008 	str.w	r8, [sp, #8]
 80097c2:	9300      	str	r3, [sp, #0]
 80097c4:	465a      	mov	r2, fp
 80097c6:	9001      	str	r0, [sp, #4]
 80097c8:	460b      	mov	r3, r1
 80097ca:	4630      	mov	r0, r6
 80097cc:	46d9      	mov	r9, fp
 80097ce:	465c      	mov	r4, fp
 80097d0:	460d      	mov	r5, r1
 80097d2:	9105      	str	r1, [sp, #20]
 80097d4:	f7fe fe80 	bl	80084d8 <_fx_utility_logical_sector_read>
                        if (status != FX_SUCCESS)
 80097d8:	2800      	cmp	r0, #0
 80097da:	f040 813f 	bne.w	8009a5c <_fx_directory_entry_write+0xa84>
                        sector_base_ptr = media_ptr -> fx_media_memory_buffer;
 80097de:	68b3      	ldr	r3, [r6, #8]
 80097e0:	9905      	ldr	r1, [sp, #20]
 80097e2:	469c      	mov	ip, r3
 80097e4:	e7bb      	b.n	800975e <_fx_directory_entry_write+0x786>
 80097e6:	e9cd 450c 	strd	r4, r5, [sp, #48]	; 0x30
 80097ea:	461c      	mov	r4, r3
 80097ec:	4655      	mov	r5, sl
 80097ee:	f8cd c020 	str.w	ip, [sp, #32]
 80097f2:	220b      	movs	r2, #11
 80097f4:	2120      	movs	r1, #32
 80097f6:	4620      	mov	r0, r4
 80097f8:	f004 fa71 	bl	800dcde <memset>
        for (i = 0; (UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.'; i++)
 80097fc:	682a      	ldr	r2, [r5, #0]
 80097fe:	7811      	ldrb	r1, [r2, #0]
 8009800:	292e      	cmp	r1, #46	; 0x2e
 8009802:	f040 81e1 	bne.w	8009bc8 <_fx_directory_entry_write+0xbf0>
            work_ptr[i] = '.';
 8009806:	460f      	mov	r7, r1
 8009808:	1e60      	subs	r0, r4, #1
        for (i = 0; (UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.'; i++)
 800980a:	2300      	movs	r3, #0
            work_ptr[i] = '.';
 800980c:	f800 7f01 	strb.w	r7, [r0, #1]!
        for (i = 0; (UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.'; i++)
 8009810:	3301      	adds	r3, #1
 8009812:	682a      	ldr	r2, [r5, #0]
 8009814:	5cd1      	ldrb	r1, [r2, r3]
 8009816:	292e      	cmp	r1, #46	; 0x2e
 8009818:	d0f8      	beq.n	800980c <_fx_directory_entry_write+0x834>
        if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] != 0)
 800981a:	2900      	cmp	r1, #0
 800981c:	f000 8104 	beq.w	8009a28 <_fx_directory_entry_write+0xa50>
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.')
 8009820:	7811      	ldrb	r1, [r2, #0]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 8009822:	2900      	cmp	r1, #0
 8009824:	f000 81f9 	beq.w	8009c1a <_fx_directory_entry_write+0xc42>
 8009828:	292e      	cmp	r1, #46	; 0x2e
 800982a:	f000 81f6 	beq.w	8009c1a <_fx_directory_entry_write+0xc42>
                if ((alpha >= 'a') && (alpha <= 'z'))
 800982e:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
 8009832:	2b19      	cmp	r3, #25
 8009834:	d801      	bhi.n	800983a <_fx_directory_entry_write+0x862>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009836:	3920      	subs	r1, #32
 8009838:	b2c9      	uxtb	r1, r1
                work_ptr[j] =  (UCHAR)alpha;
 800983a:	7021      	strb	r1, [r4, #0]
 800983c:	682a      	ldr	r2, [r5, #0]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.')
 800983e:	7851      	ldrb	r1, [r2, #1]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 8009840:	2900      	cmp	r1, #0
 8009842:	f000 81e8 	beq.w	8009c16 <_fx_directory_entry_write+0xc3e>
 8009846:	292e      	cmp	r1, #46	; 0x2e
 8009848:	f000 81e5 	beq.w	8009c16 <_fx_directory_entry_write+0xc3e>
                if ((alpha >= 'a') && (alpha <= 'z'))
 800984c:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
 8009850:	2b19      	cmp	r3, #25
 8009852:	d801      	bhi.n	8009858 <_fx_directory_entry_write+0x880>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009854:	3920      	subs	r1, #32
 8009856:	b2c9      	uxtb	r1, r1
                work_ptr[j] =  (UCHAR)alpha;
 8009858:	7061      	strb	r1, [r4, #1]
 800985a:	682a      	ldr	r2, [r5, #0]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.')
 800985c:	7891      	ldrb	r1, [r2, #2]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 800985e:	2900      	cmp	r1, #0
 8009860:	f000 81e2 	beq.w	8009c28 <_fx_directory_entry_write+0xc50>
 8009864:	292e      	cmp	r1, #46	; 0x2e
 8009866:	f000 81df 	beq.w	8009c28 <_fx_directory_entry_write+0xc50>
                if ((alpha >= 'a') && (alpha <= 'z'))
 800986a:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
 800986e:	2b19      	cmp	r3, #25
 8009870:	d801      	bhi.n	8009876 <_fx_directory_entry_write+0x89e>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009872:	3920      	subs	r1, #32
 8009874:	b2c9      	uxtb	r1, r1
                work_ptr[j] =  (UCHAR)alpha;
 8009876:	70a1      	strb	r1, [r4, #2]
 8009878:	682a      	ldr	r2, [r5, #0]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.')
 800987a:	78d1      	ldrb	r1, [r2, #3]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 800987c:	2900      	cmp	r1, #0
 800987e:	f000 81d1 	beq.w	8009c24 <_fx_directory_entry_write+0xc4c>
 8009882:	292e      	cmp	r1, #46	; 0x2e
 8009884:	f000 81ce 	beq.w	8009c24 <_fx_directory_entry_write+0xc4c>
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009888:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
 800988c:	2b19      	cmp	r3, #25
 800988e:	f240 8180 	bls.w	8009b92 <_fx_directory_entry_write+0xbba>
                work_ptr[j] =  (UCHAR)alpha;
 8009892:	70e1      	strb	r1, [r4, #3]
 8009894:	682a      	ldr	r2, [r5, #0]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.')
 8009896:	7911      	ldrb	r1, [r2, #4]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 8009898:	2900      	cmp	r1, #0
 800989a:	f43f aeac 	beq.w	80095f6 <_fx_directory_entry_write+0x61e>
 800989e:	292e      	cmp	r1, #46	; 0x2e
 80098a0:	f43f aea9 	beq.w	80095f6 <_fx_directory_entry_write+0x61e>
                if ((alpha >= 'a') && (alpha <= 'z'))
 80098a4:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
 80098a8:	2b19      	cmp	r3, #25
 80098aa:	f240 8175 	bls.w	8009b98 <_fx_directory_entry_write+0xbc0>
                work_ptr[j] =  (UCHAR)alpha;
 80098ae:	7121      	strb	r1, [r4, #4]
 80098b0:	682a      	ldr	r2, [r5, #0]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.')
 80098b2:	7951      	ldrb	r1, [r2, #5]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 80098b4:	2900      	cmp	r1, #0
 80098b6:	f000 81b9 	beq.w	8009c2c <_fx_directory_entry_write+0xc54>
 80098ba:	292e      	cmp	r1, #46	; 0x2e
 80098bc:	f000 81b6 	beq.w	8009c2c <_fx_directory_entry_write+0xc54>
                if ((alpha >= 'a') && (alpha <= 'z'))
 80098c0:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
 80098c4:	2b19      	cmp	r3, #25
 80098c6:	f240 816a 	bls.w	8009b9e <_fx_directory_entry_write+0xbc6>
                work_ptr[j] =  (UCHAR)alpha;
 80098ca:	7161      	strb	r1, [r4, #5]
 80098cc:	682a      	ldr	r2, [r5, #0]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.')
 80098ce:	7991      	ldrb	r1, [r2, #6]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 80098d0:	2900      	cmp	r1, #0
 80098d2:	f000 81ad 	beq.w	8009c30 <_fx_directory_entry_write+0xc58>
 80098d6:	292e      	cmp	r1, #46	; 0x2e
 80098d8:	f000 81aa 	beq.w	8009c30 <_fx_directory_entry_write+0xc58>
                if ((alpha >= 'a') && (alpha <= 'z'))
 80098dc:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
 80098e0:	2b19      	cmp	r3, #25
 80098e2:	f240 815f 	bls.w	8009ba4 <_fx_directory_entry_write+0xbcc>
                work_ptr[j] =  (UCHAR)alpha;
 80098e6:	71a1      	strb	r1, [r4, #6]
 80098e8:	682a      	ldr	r2, [r5, #0]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.')
 80098ea:	79d1      	ldrb	r1, [r2, #7]
                if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] == 0)
 80098ec:	292e      	cmp	r1, #46	; 0x2e
 80098ee:	f000 81bc 	beq.w	8009c6a <_fx_directory_entry_write+0xc92>
 80098f2:	2900      	cmp	r1, #0
 80098f4:	f000 81b9 	beq.w	8009c6a <_fx_directory_entry_write+0xc92>
                if ((alpha >= 'a') && (alpha <= 'z'))
 80098f8:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
 80098fc:	2b19      	cmp	r3, #25
 80098fe:	d801      	bhi.n	8009904 <_fx_directory_entry_write+0x92c>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009900:	3920      	subs	r1, #32
 8009902:	b2c9      	uxtb	r1, r1
                work_ptr[j] =  (UCHAR)alpha;
 8009904:	71e1      	strb	r1, [r4, #7]
 8009906:	2308      	movs	r3, #8
 8009908:	682a      	ldr	r2, [r5, #0]
 800990a:	7a11      	ldrb	r1, [r2, #8]
 800990c:	e674      	b.n	80095f8 <_fx_directory_entry_write+0x620>
    if (((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) &&
 800990e:	790b      	ldrb	r3, [r1, #4]
 8009910:	2be5      	cmp	r3, #229	; 0xe5
 8009912:	f47f ab70 	bne.w	8008ff6 <_fx_directory_entry_write+0x1e>
        entry_ptr -> fx_dir_entry_short_name[0] =  0;
 8009916:	2300      	movs	r3, #0
 8009918:	710b      	strb	r3, [r1, #4]
 800991a:	9307      	str	r3, [sp, #28]
 800991c:	f7ff bb6d 	b.w	8008ffa <_fx_directory_entry_write+0x22>
            if ((alpha >= 'a') && (alpha <= 'z'))
 8009920:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
 8009924:	2a19      	cmp	r2, #25
 8009926:	f63f ac83 	bhi.w	8009230 <_fx_directory_entry_write+0x258>
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 800992a:	3b20      	subs	r3, #32
            alpha = shortname[i];
 800992c:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
                alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009930:	b2db      	uxtb	r3, r3
            shortname[i] =  alpha;
 8009932:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
            if ((alpha >= 'a') && (alpha <= 'z'))
 8009936:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 800993a:	2b19      	cmp	r3, #25
 800993c:	f63f ac82 	bhi.w	8009244 <_fx_directory_entry_write+0x26c>
 8009940:	e47e      	b.n	8009240 <_fx_directory_entry_write+0x268>
                    work_ptr[i] = (UCHAR)entry_ptr -> fx_dir_entry_name[j];
 8009942:	6829      	ldr	r1, [r5, #0]
 8009944:	f811 b00e 	ldrb.w	fp, [r1, lr]
 8009948:	f802 b003 	strb.w	fp, [r2, r3]
                    work_ptr[i + 1] = 0;
 800994c:	f802 c00a 	strb.w	ip, [r2, sl]
 8009950:	e631      	b.n	80095b6 <_fx_directory_entry_write+0x5de>
            for (i = 1, j = 13 * (card - 1); i < FX_DIR_ENTRY_SIZE; i += 2)
 8009952:	230e      	movs	r3, #14
 8009954:	e61e      	b.n	8009594 <_fx_directory_entry_write+0x5bc>
                    status =  _fx_utility_logical_sector_write(media_ptr, (ULONG64) logical_sector,
 8009956:	9b08      	ldr	r3, [sp, #32]
 8009958:	2001      	movs	r0, #1
 800995a:	f04f 0c03 	mov.w	ip, #3
 800995e:	4622      	mov	r2, r4
 8009960:	9300      	str	r3, [sp, #0]
 8009962:	460b      	mov	r3, r1
 8009964:	9001      	str	r0, [sp, #4]
 8009966:	4630      	mov	r0, r6
 8009968:	f8cd c008 	str.w	ip, [sp, #8]
 800996c:	f7fe ff62 	bl	8008834 <_fx_utility_logical_sector_write>
                if (status != FX_SUCCESS)
 8009970:	2800      	cmp	r0, #0
 8009972:	d173      	bne.n	8009a5c <_fx_directory_entry_write+0xa84>
                if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 8009974:	6d33      	ldr	r3, [r6, #80]	; 0x50
 8009976:	9a06      	ldr	r2, [sp, #24]
 8009978:	4293      	cmp	r3, r2
 800997a:	d833      	bhi.n	80099e4 <_fx_directory_entry_write+0xa0c>
                    if (relative_sector < (media_ptr -> fx_media_sectors_per_cluster - 1))
 800997c:	6d73      	ldr	r3, [r6, #84]	; 0x54
 800997e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009980:	3b01      	subs	r3, #1
 8009982:	428b      	cmp	r3, r1
 8009984:	d935      	bls.n	80099f2 <_fx_directory_entry_write+0xa1a>
                        logical_sector++;
 8009986:	3201      	adds	r2, #1
                        relative_sector++;
 8009988:	3101      	adds	r1, #1
                        logical_sector++;
 800998a:	9206      	str	r2, [sp, #24]
                        relative_sector++;
 800998c:	9109      	str	r1, [sp, #36]	; 0x24
                status =  _fx_utility_logical_sector_read(media_ptr, (ULONG64) logical_sector,
 800998e:	68b3      	ldr	r3, [r6, #8]
 8009990:	2100      	movs	r1, #0
 8009992:	9c06      	ldr	r4, [sp, #24]
 8009994:	2001      	movs	r0, #1
 8009996:	f04f 0c03 	mov.w	ip, #3
 800999a:	9300      	str	r3, [sp, #0]
 800999c:	9001      	str	r0, [sp, #4]
 800999e:	4622      	mov	r2, r4
 80099a0:	460b      	mov	r3, r1
 80099a2:	f8cd c008 	str.w	ip, [sp, #8]
 80099a6:	4630      	mov	r0, r6
 80099a8:	46a2      	mov	sl, r4
 80099aa:	468b      	mov	fp, r1
 80099ac:	9105      	str	r1, [sp, #20]
 80099ae:	f7fe fd93 	bl	80084d8 <_fx_utility_logical_sector_read>
                if (status != FX_SUCCESS)
 80099b2:	2800      	cmp	r0, #0
 80099b4:	d152      	bne.n	8009a5c <_fx_directory_entry_write+0xa84>
                sector_base_ptr = media_ptr -> fx_media_memory_buffer;
 80099b6:	68b2      	ldr	r2, [r6, #8]
            card--;
 80099b8:	3f01      	subs	r7, #1
                sector_base_ptr = media_ptr -> fx_media_memory_buffer;
 80099ba:	9905      	ldr	r1, [sp, #20]
 80099bc:	f1a8 080d 	sub.w	r8, r8, #13
 80099c0:	9208      	str	r2, [sp, #32]
            work_ptr[0] = (UCHAR)card;
 80099c2:	7017      	strb	r7, [r2, #0]
        while (card > 0)
 80099c4:	2f00      	cmp	r7, #0
 80099c6:	f47f ae13 	bne.w	80095f0 <_fx_directory_entry_write+0x618>
 80099ca:	4614      	mov	r4, r2
 80099cc:	e9cd ab0c 	strd	sl, fp, [sp, #48]	; 0x30
        if (entry_ptr -> fx_dir_entry_short_name[0] == 0)
 80099d0:	792b      	ldrb	r3, [r5, #4]
 80099d2:	220b      	movs	r2, #11
 80099d4:	2b00      	cmp	r3, #0
 80099d6:	d146      	bne.n	8009a66 <_fx_directory_entry_write+0xa8e>
 80099d8:	a911      	add	r1, sp, #68	; 0x44
 80099da:	4620      	mov	r0, r4
 80099dc:	4414      	add	r4, r2
 80099de:	f004 f973 	bl	800dcc8 <memcpy>
 80099e2:	e62b      	b.n	800963c <_fx_directory_entry_write+0x664>
                    logical_sector++;
 80099e4:	3201      	adds	r2, #1
                    if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 80099e6:	4293      	cmp	r3, r2
                    logical_sector++;
 80099e8:	9206      	str	r2, [sp, #24]
                    if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 80099ea:	d8d0      	bhi.n	800998e <_fx_directory_entry_write+0x9b6>
                            return(FX_FILE_CORRUPT);
 80099ec:	2308      	movs	r3, #8
 80099ee:	930a      	str	r3, [sp, #40]	; 0x28
 80099f0:	e691      	b.n	8009716 <_fx_directory_entry_write+0x73e>
                        status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 80099f2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80099f4:	aa10      	add	r2, sp, #64	; 0x40
 80099f6:	4630      	mov	r0, r6
 80099f8:	f7fd fef4 	bl	80077e4 <_fx_utility_FAT_entry_read>
                        if (status != FX_SUCCESS)
 80099fc:	bb70      	cbnz	r0, 8009a5c <_fx_directory_entry_write+0xa84>
                        cluster =  next_cluster;
 80099fe:	9b10      	ldr	r3, [sp, #64]	; 0x40
                        if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8009a00:	2b01      	cmp	r3, #1
                        cluster =  next_cluster;
 8009a02:	930b      	str	r3, [sp, #44]	; 0x2c
                        if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8009a04:	d9f2      	bls.n	80099ec <_fx_directory_entry_write+0xa14>
 8009a06:	461a      	mov	r2, r3
 8009a08:	f242 43a8 	movw	r3, #9384	; 0x24a8
 8009a0c:	58f3      	ldr	r3, [r6, r3]
 8009a0e:	4293      	cmp	r3, r2
 8009a10:	d9ec      	bls.n	80099ec <_fx_directory_entry_write+0xa14>
                            (((ULONG)cluster - FX_FAT_ENTRY_START) *
 8009a12:	1e93      	subs	r3, r2, #2
                        relative_sector =  0;
 8009a14:	9009      	str	r0, [sp, #36]	; 0x24
                        logical_sector =   ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8009a16:	e9d6 2114 	ldrd	r2, r1, [r6, #80]	; 0x50
 8009a1a:	fb01 2303 	mla	r3, r1, r3, r2
 8009a1e:	9306      	str	r3, [sp, #24]
 8009a20:	e7b5      	b.n	800998e <_fx_directory_entry_write+0x9b6>
            card =  len / 13 + 1;
 8009a22:	3701      	adds	r7, #1
 8009a24:	f7ff bb92 	b.w	800914c <_fx_directory_entry_write+0x174>
 8009a28:	5cd1      	ldrb	r1, [r2, r3]
 8009a2a:	e5e5      	b.n	80095f8 <_fx_directory_entry_write+0x620>
        if ((dotpos) && (shortname[8] == ' '))
 8009a2c:	f04f 0c01 	mov.w	ip, #1
 8009a30:	2820      	cmp	r0, #32
 8009a32:	f43f aba4 	beq.w	800917e <_fx_directory_entry_write+0x1a6>
 8009a36:	5c5b      	ldrb	r3, [r3, r1]
        if (match == FX_FALSE)
 8009a38:	2b00      	cmp	r3, #0
 8009a3a:	f47f aba0 	bne.w	800917e <_fx_directory_entry_write+0x1a6>
 8009a3e:	f1bc 0f00 	cmp.w	ip, #0
 8009a42:	f43f abe8 	beq.w	8009216 <_fx_directory_entry_write+0x23e>
 8009a46:	f7ff bb9a 	b.w	800917e <_fx_directory_entry_write+0x1a6>
        _fx_utility_16_unsigned_write(work_ptr, 0);
 8009a4a:	f000 fcc9 	bl	800a3e0 <_fx_utility_16_unsigned_write>
 8009a4e:	e610      	b.n	8009672 <_fx_directory_entry_write+0x69a>
                            logical_sector++;
 8009a50:	f10b 0b01 	add.w	fp, fp, #1
                            if (logical_sector >= (ULONG)(media_ptr -> fx_media_data_sector_start))
 8009a54:	455b      	cmp	r3, fp
 8009a56:	f63f aeaf 	bhi.w	80097b8 <_fx_directory_entry_write+0x7e0>
 8009a5a:	e7c7      	b.n	80099ec <_fx_directory_entry_write+0xa14>
 8009a5c:	900a      	str	r0, [sp, #40]	; 0x28
}
 8009a5e:	980a      	ldr	r0, [sp, #40]	; 0x28
 8009a60:	b015      	add	sp, #84	; 0x54
 8009a62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009a66:	2120      	movs	r1, #32
 8009a68:	4620      	mov	r0, r4
 8009a6a:	f004 f938 	bl	800dcde <memset>
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
 8009a6e:	792b      	ldrb	r3, [r5, #4]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009a70:	2b2e      	cmp	r3, #46	; 0x2e
 8009a72:	d03b      	beq.n	8009aec <_fx_directory_entry_write+0xb14>
 8009a74:	2b00      	cmp	r3, #0
 8009a76:	d039      	beq.n	8009aec <_fx_directory_entry_write+0xb14>
                work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009a78:	7023      	strb	r3, [r4, #0]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
 8009a7a:	796b      	ldrb	r3, [r5, #5]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009a7c:	2b2e      	cmp	r3, #46	; 0x2e
 8009a7e:	f000 80fc 	beq.w	8009c7a <_fx_directory_entry_write+0xca2>
 8009a82:	2b00      	cmp	r3, #0
 8009a84:	f000 80f9 	beq.w	8009c7a <_fx_directory_entry_write+0xca2>
                work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009a88:	7063      	strb	r3, [r4, #1]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
 8009a8a:	79ab      	ldrb	r3, [r5, #6]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009a8c:	2b2e      	cmp	r3, #46	; 0x2e
 8009a8e:	f000 8102 	beq.w	8009c96 <_fx_directory_entry_write+0xcbe>
 8009a92:	2b00      	cmp	r3, #0
 8009a94:	f000 80ff 	beq.w	8009c96 <_fx_directory_entry_write+0xcbe>
                work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009a98:	70a3      	strb	r3, [r4, #2]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
 8009a9a:	79eb      	ldrb	r3, [r5, #7]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009a9c:	2b2e      	cmp	r3, #46	; 0x2e
 8009a9e:	f000 80f4 	beq.w	8009c8a <_fx_directory_entry_write+0xcb2>
 8009aa2:	2b00      	cmp	r3, #0
 8009aa4:	f000 80f1 	beq.w	8009c8a <_fx_directory_entry_write+0xcb2>
                work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009aa8:	70e3      	strb	r3, [r4, #3]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
 8009aaa:	7a2b      	ldrb	r3, [r5, #8]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009aac:	2b2e      	cmp	r3, #46	; 0x2e
 8009aae:	d07c      	beq.n	8009baa <_fx_directory_entry_write+0xbd2>
 8009ab0:	2b00      	cmp	r3, #0
 8009ab2:	d07a      	beq.n	8009baa <_fx_directory_entry_write+0xbd2>
                work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009ab4:	7123      	strb	r3, [r4, #4]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
 8009ab6:	7a6b      	ldrb	r3, [r5, #9]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009ab8:	2b2e      	cmp	r3, #46	; 0x2e
 8009aba:	f000 80f8 	beq.w	8009cae <_fx_directory_entry_write+0xcd6>
 8009abe:	2b00      	cmp	r3, #0
 8009ac0:	f000 80f5 	beq.w	8009cae <_fx_directory_entry_write+0xcd6>
                work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009ac4:	7163      	strb	r3, [r4, #5]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
 8009ac6:	7aab      	ldrb	r3, [r5, #10]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009ac8:	2b2e      	cmp	r3, #46	; 0x2e
 8009aca:	f000 80ea 	beq.w	8009ca2 <_fx_directory_entry_write+0xcca>
 8009ace:	2b00      	cmp	r3, #0
 8009ad0:	f000 80e7 	beq.w	8009ca2 <_fx_directory_entry_write+0xcca>
                work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009ad4:	71a3      	strb	r3, [r4, #6]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == '.')
 8009ad6:	7aeb      	ldrb	r3, [r5, #11]
                if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009ad8:	2b2e      	cmp	r3, #46	; 0x2e
 8009ada:	f000 80c8 	beq.w	8009c6e <_fx_directory_entry_write+0xc96>
 8009ade:	2b00      	cmp	r3, #0
 8009ae0:	f000 80c5 	beq.w	8009c6e <_fx_directory_entry_write+0xc96>
                work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009ae4:	71e3      	strb	r3, [r4, #7]
 8009ae6:	2308      	movs	r3, #8
 8009ae8:	930a      	str	r3, [sp, #40]	; 0x28
 8009aea:	7b2b      	ldrb	r3, [r5, #12]
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 8009aec:	2b00      	cmp	r3, #0
 8009aee:	f43f ada4 	beq.w	800963a <_fx_directory_entry_write+0x662>
                    if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009af2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009af4:	442b      	add	r3, r5
 8009af6:	795a      	ldrb	r2, [r3, #5]
 8009af8:	2a00      	cmp	r2, #0
 8009afa:	f43f ad9e 	beq.w	800963a <_fx_directory_entry_write+0x662>
                    work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009afe:	7222      	strb	r2, [r4, #8]
                    if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009b00:	799a      	ldrb	r2, [r3, #6]
 8009b02:	2a00      	cmp	r2, #0
 8009b04:	f43f ad99 	beq.w	800963a <_fx_directory_entry_write+0x662>
                    work_ptr[j] =  (UCHAR)entry_ptr -> fx_dir_entry_short_name[i];
 8009b08:	7262      	strb	r2, [r4, #9]
                    if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009b0a:	79db      	ldrb	r3, [r3, #7]
 8009b0c:	2b00      	cmp	r3, #0
 8009b0e:	f47f ad93 	bne.w	8009638 <_fx_directory_entry_write+0x660>
 8009b12:	e592      	b.n	800963a <_fx_directory_entry_write+0x662>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009b14:	2200      	movs	r2, #0
                    if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009b16:	442a      	add	r2, r5
 8009b18:	7953      	ldrb	r3, [r2, #5]
 8009b1a:	2b00      	cmp	r3, #0
 8009b1c:	f43f ac46 	beq.w	80093ac <_fx_directory_entry_write+0x3d4>
 8009b20:	7991      	ldrb	r1, [r2, #6]
                    shortname[j] =  alpha;
 8009b22:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
                    if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009b26:	2900      	cmp	r1, #0
 8009b28:	f43f ac40 	beq.w	80093ac <_fx_directory_entry_write+0x3d4>
 8009b2c:	79d3      	ldrb	r3, [r2, #7]
                    shortname[j] =  alpha;
 8009b2e:	f88d 104d 	strb.w	r1, [sp, #77]	; 0x4d
                    if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] == 0)
 8009b32:	2b00      	cmp	r3, #0
 8009b34:	f43f ac3a 	beq.w	80093ac <_fx_directory_entry_write+0x3d4>
                    shortname[j] =  alpha;
 8009b38:	f88d 304e 	strb.w	r3, [sp, #78]	; 0x4e
 8009b3c:	e436      	b.n	80093ac <_fx_directory_entry_write+0x3d4>
                                status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8009b3e:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8009b40:	aa10      	add	r2, sp, #64	; 0x40
 8009b42:	4630      	mov	r0, r6
 8009b44:	f7fd fe4e 	bl	80077e4 <_fx_utility_FAT_entry_read>
                                if (status != FX_SUCCESS)
 8009b48:	2800      	cmp	r0, #0
 8009b4a:	d187      	bne.n	8009a5c <_fx_directory_entry_write+0xa84>
                                cluster =  next_cluster;
 8009b4c:	9a10      	ldr	r2, [sp, #64]	; 0x40
                                if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8009b4e:	2a01      	cmp	r2, #1
                                cluster =  next_cluster;
 8009b50:	920b      	str	r2, [sp, #44]	; 0x2c
                                if ((cluster < FX_FAT_ENTRY_START) || (cluster >= media_ptr -> fx_media_fat_reserved))
 8009b52:	f67f af4b 	bls.w	80099ec <_fx_directory_entry_write+0xa14>
 8009b56:	9b06      	ldr	r3, [sp, #24]
 8009b58:	681b      	ldr	r3, [r3, #0]
 8009b5a:	4293      	cmp	r3, r2
 8009b5c:	f67f af46 	bls.w	80099ec <_fx_directory_entry_write+0xa14>
                                    (((ULONG)cluster - FX_FAT_ENTRY_START) *
 8009b60:	f1a2 0b02 	sub.w	fp, r2, #2
                                relative_sector =  0;
 8009b64:	9009      	str	r0, [sp, #36]	; 0x24
                                logical_sector =   ((ULONG)media_ptr -> fx_media_data_sector_start) +
 8009b66:	e9d6 3214 	ldrd	r3, r2, [r6, #80]	; 0x50
 8009b6a:	fb02 3b0b 	mla	fp, r2, fp, r3
 8009b6e:	e623      	b.n	80097b8 <_fx_directory_entry_write+0x7e0>
 8009b70:	2820      	cmp	r0, #32
 8009b72:	d15f      	bne.n	8009c34 <_fx_directory_entry_write+0xc5c>
 8009b74:	4419      	add	r1, r3
 8009b76:	f811 3f01 	ldrb.w	r3, [r1, #1]!
                if (entry_ptr -> fx_dir_entry_name[l] == FX_NULL)
 8009b7a:	2b00      	cmp	r3, #0
 8009b7c:	f000 8083 	beq.w	8009c86 <_fx_directory_entry_write+0xcae>
                if (entry_ptr -> fx_dir_entry_name[l] != '.')
 8009b80:	2b2e      	cmp	r3, #46	; 0x2e
 8009b82:	d0f8      	beq.n	8009b76 <_fx_directory_entry_write+0xb9e>
 8009b84:	f04f 0c01 	mov.w	ip, #1
        if ((dotpos) && (shortname[8] == ' '))
 8009b88:	9a05      	ldr	r2, [sp, #20]
 8009b8a:	2a00      	cmp	r2, #0
 8009b8c:	f47f aaf7 	bne.w	800917e <_fx_directory_entry_write+0x1a6>
 8009b90:	e752      	b.n	8009a38 <_fx_directory_entry_write+0xa60>
                    alpha =  (CHAR)(alpha - ((CHAR)0x20));
 8009b92:	3920      	subs	r1, #32
 8009b94:	b2c9      	uxtb	r1, r1
 8009b96:	e67c      	b.n	8009892 <_fx_directory_entry_write+0x8ba>
 8009b98:	3920      	subs	r1, #32
 8009b9a:	b2c9      	uxtb	r1, r1
 8009b9c:	e687      	b.n	80098ae <_fx_directory_entry_write+0x8d6>
 8009b9e:	3920      	subs	r1, #32
 8009ba0:	b2c9      	uxtb	r1, r1
 8009ba2:	e692      	b.n	80098ca <_fx_directory_entry_write+0x8f2>
 8009ba4:	3920      	subs	r1, #32
 8009ba6:	b2c9      	uxtb	r1, r1
 8009ba8:	e69d      	b.n	80098e6 <_fx_directory_entry_write+0x90e>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009baa:	2204      	movs	r2, #4
 8009bac:	920a      	str	r2, [sp, #40]	; 0x28
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 8009bae:	2b00      	cmp	r3, #0
 8009bb0:	f43f ad43 	beq.w	800963a <_fx_directory_entry_write+0x662>
 8009bb4:	e79d      	b.n	8009af2 <_fx_directory_entry_write+0xb1a>
        for (len = 0, i = 0, dotpos = 0, dotfound = 0; entry_ptr -> fx_dir_entry_name[len]; len++)
 8009bb6:	464f      	mov	r7, r9
 8009bb8:	46ca      	mov	sl, r9
 8009bba:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
 8009bbe:	46c8      	mov	r8, r9
 8009bc0:	f8cd 9014 	str.w	r9, [sp, #20]
 8009bc4:	f7ff ba85 	b.w	80090d2 <_fx_directory_entry_write+0xfa>
        for (i = 0; (UCHAR)entry_ptr -> fx_dir_entry_name[i] == '.'; i++)
 8009bc8:	2300      	movs	r3, #0
        if ((UCHAR)entry_ptr -> fx_dir_entry_name[i] != 0)
 8009bca:	2900      	cmp	r1, #0
 8009bcc:	f43f af2c 	beq.w	8009a28 <_fx_directory_entry_write+0xa50>
 8009bd0:	e626      	b.n	8009820 <_fx_directory_entry_write+0x848>
 8009bd2:	4690      	mov	r8, r2
        if (len % 13 == 0)
 8009bd4:	f1ba 0f00 	cmp.w	sl, #0
 8009bd8:	f43f aab8 	beq.w	800914c <_fx_directory_entry_write+0x174>
 8009bdc:	e721      	b.n	8009a22 <_fx_directory_entry_write+0xa4a>
            if ((k == 8) && (entry_ptr -> fx_dir_entry_name[l] == '.'))
 8009bde:	2a08      	cmp	r2, #8
 8009be0:	d02c      	beq.n	8009c3c <_fx_directory_entry_write+0xc64>
            if (shortname[k] != entry_ptr -> fx_dir_entry_name[l])
 8009be2:	45cc      	cmp	ip, r9
 8009be4:	f47f aac7 	bne.w	8009176 <_fx_directory_entry_write+0x19e>
            k++;
 8009be8:	3201      	adds	r2, #1
            l++;
 8009bea:	3101      	adds	r1, #1
        while (k < FX_DIR_NAME_SIZE + FX_DIR_EXT_SIZE)
 8009bec:	2a0b      	cmp	r2, #11
 8009bee:	d12c      	bne.n	8009c4a <_fx_directory_entry_write+0xc72>
 8009bf0:	f04f 0c00 	mov.w	ip, #0
        if ((dotpos) && (shortname[8] == ' '))
 8009bf4:	9a05      	ldr	r2, [sp, #20]
 8009bf6:	2a00      	cmp	r2, #0
 8009bf8:	f47f af1a 	bne.w	8009a30 <_fx_directory_entry_write+0xa58>
 8009bfc:	e71b      	b.n	8009a36 <_fx_directory_entry_write+0xa5e>
 8009bfe:	9a05      	ldr	r2, [sp, #20]
 8009c00:	2a00      	cmp	r2, #0
 8009c02:	f43f ab08 	beq.w	8009216 <_fx_directory_entry_write+0x23e>
 8009c06:	46cc      	mov	ip, r9
 8009c08:	e712      	b.n	8009a30 <_fx_directory_entry_write+0xa58>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009c0a:	2202      	movs	r2, #2
 8009c0c:	f7ff bbc8 	b.w	80093a0 <_fx_directory_entry_write+0x3c8>
 8009c10:	2201      	movs	r2, #1
 8009c12:	f7ff bbc5 	b.w	80093a0 <_fx_directory_entry_write+0x3c8>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009c16:	2301      	movs	r3, #1
 8009c18:	e4ee      	b.n	80095f8 <_fx_directory_entry_write+0x620>
 8009c1a:	2300      	movs	r3, #0
 8009c1c:	e4ec      	b.n	80095f8 <_fx_directory_entry_write+0x620>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009c1e:	2203      	movs	r2, #3
 8009c20:	f7ff bbbe 	b.w	80093a0 <_fx_directory_entry_write+0x3c8>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009c24:	2303      	movs	r3, #3
 8009c26:	e4e7      	b.n	80095f8 <_fx_directory_entry_write+0x620>
 8009c28:	2302      	movs	r3, #2
 8009c2a:	e4e5      	b.n	80095f8 <_fx_directory_entry_write+0x620>
 8009c2c:	2305      	movs	r3, #5
 8009c2e:	e4e3      	b.n	80095f8 <_fx_directory_entry_write+0x620>
 8009c30:	2306      	movs	r3, #6
 8009c32:	e4e1      	b.n	80095f8 <_fx_directory_entry_write+0x620>
                l++;
 8009c34:	3101      	adds	r1, #1
 8009c36:	4684      	mov	ip, r0
 8009c38:	f813 9001 	ldrb.w	r9, [r3, r1]
            if ((k == 8) && (entry_ptr -> fx_dir_entry_name[l] == '.'))
 8009c3c:	f1b9 0f2e 	cmp.w	r9, #46	; 0x2e
 8009c40:	d044      	beq.n	8009ccc <_fx_directory_entry_write+0xcf4>
            if (shortname[k] != entry_ptr -> fx_dir_entry_name[l])
 8009c42:	45cc      	cmp	ip, r9
 8009c44:	d13f      	bne.n	8009cc6 <_fx_directory_entry_write+0xcee>
            l++;
 8009c46:	3101      	adds	r1, #1
            k++;
 8009c48:	2209      	movs	r2, #9
 8009c4a:	f813 9001 	ldrb.w	r9, [r3, r1]
 8009c4e:	f7ff ba81 	b.w	8009154 <_fx_directory_entry_write+0x17c>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009c52:	2207      	movs	r2, #7
 8009c54:	f7ff bba4 	b.w	80093a0 <_fx_directory_entry_write+0x3c8>
 8009c58:	2206      	movs	r2, #6
 8009c5a:	f7ff bba1 	b.w	80093a0 <_fx_directory_entry_write+0x3c8>
 8009c5e:	2205      	movs	r2, #5
 8009c60:	f7ff bb9e 	b.w	80093a0 <_fx_directory_entry_write+0x3c8>
 8009c64:	2204      	movs	r2, #4
 8009c66:	f7ff bb9b 	b.w	80093a0 <_fx_directory_entry_write+0x3c8>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009c6a:	2307      	movs	r3, #7
 8009c6c:	e4c4      	b.n	80095f8 <_fx_directory_entry_write+0x620>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009c6e:	2207      	movs	r2, #7
 8009c70:	920a      	str	r2, [sp, #40]	; 0x28
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 8009c72:	2b00      	cmp	r3, #0
 8009c74:	f43f ace1 	beq.w	800963a <_fx_directory_entry_write+0x662>
 8009c78:	e73b      	b.n	8009af2 <_fx_directory_entry_write+0xb1a>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009c7a:	2201      	movs	r2, #1
 8009c7c:	920a      	str	r2, [sp, #40]	; 0x28
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 8009c7e:	2b00      	cmp	r3, #0
 8009c80:	f43f acdb 	beq.w	800963a <_fx_directory_entry_write+0x662>
 8009c84:	e735      	b.n	8009af2 <_fx_directory_entry_write+0xb1a>
 8009c86:	469c      	mov	ip, r3
 8009c88:	e77e      	b.n	8009b88 <_fx_directory_entry_write+0xbb0>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009c8a:	2203      	movs	r2, #3
 8009c8c:	920a      	str	r2, [sp, #40]	; 0x28
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 8009c8e:	2b00      	cmp	r3, #0
 8009c90:	f43f acd3 	beq.w	800963a <_fx_directory_entry_write+0x662>
 8009c94:	e72d      	b.n	8009af2 <_fx_directory_entry_write+0xb1a>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009c96:	2202      	movs	r2, #2
 8009c98:	920a      	str	r2, [sp, #40]	; 0x28
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 8009c9a:	2b00      	cmp	r3, #0
 8009c9c:	f43f accd 	beq.w	800963a <_fx_directory_entry_write+0x662>
 8009ca0:	e727      	b.n	8009af2 <_fx_directory_entry_write+0xb1a>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009ca2:	2206      	movs	r2, #6
 8009ca4:	920a      	str	r2, [sp, #40]	; 0x28
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 8009ca6:	2b00      	cmp	r3, #0
 8009ca8:	f43f acc7 	beq.w	800963a <_fx_directory_entry_write+0x662>
 8009cac:	e721      	b.n	8009af2 <_fx_directory_entry_write+0xb1a>
            for (i = 0, j = 0; j < FX_DIR_NAME_SIZE; i++, j++)
 8009cae:	2205      	movs	r2, #5
 8009cb0:	920a      	str	r2, [sp, #40]	; 0x28
            if ((UCHAR)entry_ptr -> fx_dir_entry_short_name[i] != 0)
 8009cb2:	2b00      	cmp	r3, #0
 8009cb4:	f43f acc1 	beq.w	800963a <_fx_directory_entry_write+0x662>
 8009cb8:	e71b      	b.n	8009af2 <_fx_directory_entry_write+0xb1a>
                shortname[9] = entry_ptr -> fx_dir_entry_name[dotpos++];
 8009cba:	9205      	str	r2, [sp, #20]
 8009cbc:	f7ff ba31 	b.w	8009122 <_fx_directory_entry_write+0x14a>
                shortname[8] = entry_ptr -> fx_dir_entry_name[dotpos++];
 8009cc0:	9105      	str	r1, [sp, #20]
 8009cc2:	f7ff ba2e 	b.w	8009122 <_fx_directory_entry_write+0x14a>
            if (shortname[k] != entry_ptr -> fx_dir_entry_name[l])
 8009cc6:	f04f 0c01 	mov.w	ip, #1
 8009cca:	e793      	b.n	8009bf4 <_fx_directory_entry_write+0xc1c>
                l++;
 8009ccc:	3101      	adds	r1, #1
 8009cce:	f813 9001 	ldrb.w	r9, [r3, r1]
 8009cd2:	e7b6      	b.n	8009c42 <_fx_directory_entry_write+0xc6a>

08009cd4 <_fx_directory_search>:
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_directory_search(FX_MEDIA *media_ptr, CHAR *name_ptr, FX_DIR_ENTRY *entry_ptr,
                           FX_DIR_ENTRY *last_dir_ptr, CHAR **last_name_ptr)
{
 8009cd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009cd8:	4607      	mov	r7, r0
 8009cda:	b0ab      	sub	sp, #172	; 0xac

ULONG         i, n;
UINT          found;
UINT          status;
UINT          v, j;
ULONG         cluster, next_cluster = 0;
 8009cdc:	2000      	movs	r0, #0
{
 8009cde:	9208      	str	r2, [sp, #32]
#endif /* FX_ENABLE_EXFAT */

#ifndef FX_MEDIA_STATISTICS_DISABLE

    /* Increment the number of directory search requests.  */
    media_ptr -> fx_media_directory_searches++;
 8009ce0:	f8d7 2170 	ldr.w	r2, [r7, #368]	; 0x170
{
 8009ce4:	9107      	str	r1, [sp, #28]
#endif

    /* Setup pointer to media name buffer.  */
    name =  media_ptr -> fx_media_name_buffer;
 8009ce6:	f607 019c 	addw	r1, r7, #2204	; 0x89c
    media_ptr -> fx_media_directory_searches++;
 8009cea:	3201      	adds	r2, #1
ULONG         cluster, next_cluster = 0;
 8009cec:	900d      	str	r0, [sp, #52]	; 0x34
    name =  media_ptr -> fx_media_name_buffer;
 8009cee:	9103      	str	r1, [sp, #12]

    /* Setup the last directory, if required.  */
    if (last_dir_ptr)
 8009cf0:	930a      	str	r3, [sp, #40]	; 0x28
    media_ptr -> fx_media_directory_searches++;
 8009cf2:	f8c7 2170 	str.w	r2, [r7, #368]	; 0x170
    if (last_dir_ptr)
 8009cf6:	b10b      	cbz	r3, 8009cfc <_fx_directory_search+0x28>
    {

        /* Set the first character of the directory entry to NULL to
           indicate root or no directory.  */
        last_dir_ptr -> fx_dir_entry_name[0] =  0;
 8009cf8:	681b      	ldr	r3, [r3, #0]
 8009cfa:	7018      	strb	r0, [r3, #0]
    }

    /* Determine if the file name has a full directory path.  */
    if ((*name_ptr == '\\') || (*name_ptr == '/'))
 8009cfc:	9b07      	ldr	r3, [sp, #28]
 8009cfe:	f897 53e0 	ldrb.w	r5, [r7, #992]	; 0x3e0
 8009d02:	781c      	ldrb	r4, [r3, #0]
 8009d04:	2c5c      	cmp	r4, #92	; 0x5c
 8009d06:	d019      	beq.n	8009d3c <_fx_directory_search+0x68>
 8009d08:	2c2f      	cmp	r4, #47	; 0x2f
 8009d0a:	d017      	beq.n	8009d3c <_fx_directory_search+0x68>
           directory - if there is one.  */

        /* First check for a local path pointer stored in the thread control block.  This
           is only available in ThreadX Version 4 and above.  */
#ifndef FX_NO_LOCAL_PATH
        if (_tx_thread_current_ptr -> tx_thread_filex_ptr)
 8009d0c:	4bad      	ldr	r3, [pc, #692]	; (8009fc4 <_fx_directory_search+0x2f0>)
 8009d0e:	681b      	ldr	r3, [r3, #0]
 8009d10:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
 8009d14:	2900      	cmp	r1, #0
 8009d16:	f000 81f1 	beq.w	800a0fc <_fx_directory_search+0x428>
        {

            /* Determine if the local directory is not the root directory.  */
            if (((FX_PATH *)_tx_thread_current_ptr -> tx_thread_filex_ptr) -> fx_path_directory.fx_dir_entry_name[0])
 8009d1a:	680b      	ldr	r3, [r1, #0]
 8009d1c:	781b      	ldrb	r3, [r3, #0]
 8009d1e:	2b00      	cmp	r3, #0
 8009d20:	f000 81b1 	beq.w	800a086 <_fx_directory_search+0x3b2>
            {

                /* Start at the current working directory of the media.  */
                search_dir =   ((FX_PATH *)_tx_thread_current_ptr -> tx_thread_filex_ptr) -> fx_path_directory;
 8009d24:	2270      	movs	r2, #112	; 0x70
 8009d26:	ae0e      	add	r6, sp, #56	; 0x38

#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE

                /* Setup pointer to the path.  */
                path_ptr =  ((FX_PATH *)_tx_thread_current_ptr -> tx_thread_filex_ptr) -> fx_path_string;
 8009d28:	188b      	adds	r3, r1, r2
                search_dir =   ((FX_PATH *)_tx_thread_current_ptr -> tx_thread_filex_ptr) -> fx_path_directory;
 8009d2a:	4630      	mov	r0, r6
                path_ptr =  ((FX_PATH *)_tx_thread_current_ptr -> tx_thread_filex_ptr) -> fx_path_string;
 8009d2c:	930b      	str	r3, [sp, #44]	; 0x2c
                search_dir =   ((FX_PATH *)_tx_thread_current_ptr -> tx_thread_filex_ptr) -> fx_path_directory;
 8009d2e:	f003 ffcb 	bl	800dcc8 <memcpy>
    }

#ifndef FX_MEDIA_DISABLE_SEARCH_CACHE

    /* Determine if there is a previously found directory entry.  */
    if (media_ptr -> fx_media_last_found_name[0])
 8009d32:	2d00      	cmp	r5, #0
 8009d34:	f040 81fe 	bne.w	800a134 <_fx_directory_search+0x460>
 8009d38:	9601      	str	r6, [sp, #4]
 8009d3a:	e005      	b.n	8009d48 <_fx_directory_search+0x74>
 8009d3c:	2d00      	cmp	r5, #0
 8009d3e:	f040 8143 	bne.w	8009fc8 <_fx_directory_search+0x2f4>

                /* Now examine the rest of the last name and the newly supplied
                   input name.  */

                /* Determine if a valid directory separator is present.  */
                if ((media_ptr -> fx_media_last_found_name[v] != '\\') &&
 8009d42:	2300      	movs	r3, #0
 8009d44:	930b      	str	r3, [sp, #44]	; 0x2c
 8009d46:	9301      	str	r3, [sp, #4]
 8009d48:	f242 42a8 	movw	r2, #9384	; 0x24a8
            return(FX_SUCCESS);
        }
    }

    /* Not a sequential search, invalidate the saved information.  */
    media_ptr -> fx_media_last_found_name[0] =  FX_NULL;
 8009d4c:	2300      	movs	r3, #0
 8009d4e:	9907      	ldr	r1, [sp, #28]
 8009d50:	18ba      	adds	r2, r7, r2
 8009d52:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8009d56:	9106      	str	r1, [sp, #24]
 8009d58:	9209      	str	r2, [sp, #36]	; 0x24
 8009d5a:	f887 33e0 	strb.w	r3, [r7, #992]	; 0x3e0
    /* Loop to traverse the directory paths to find the specified file.  */
    do
    {

        /* Remember the last name pointer, if required.  */
        if (last_name_ptr)
 8009d5e:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 8009d60:	b113      	cbz	r3, 8009d68 <_fx_directory_search+0x94>
        {

            /* Just set the last name to initial name string.  */
            *last_name_ptr =  name_ptr;
 8009d62:	461a      	mov	r2, r3
 8009d64:	9b06      	ldr	r3, [sp, #24]
 8009d66:	6013      	str	r3, [r2, #0]
        }

        /* Extract file name.  */
        name_ptr =  _fx_directory_name_extract(name_ptr, name);
 8009d68:	9806      	ldr	r0, [sp, #24]
 8009d6a:	9903      	ldr	r1, [sp, #12]
 8009d6c:	f000 fcda 	bl	800a724 <_fx_directory_name_extract>

        /* Calculate the directory size.  */
        if (search_dir_ptr)
 8009d70:	9a01      	ldr	r2, [sp, #4]
        name_ptr =  _fx_directory_name_extract(name_ptr, name);
 8009d72:	9006      	str	r0, [sp, #24]
        if (search_dir_ptr)
 8009d74:	2a00      	cmp	r2, #0
 8009d76:	d04f      	beq.n	8009e18 <_fx_directory_search+0x144>
            else
            {
#endif /* FX_ENABLE_EXFAT */

                /* Ensure that the search directory's last search cluster is cleared.  */
                search_dir_ptr -> fx_dir_entry_last_search_cluster =  0;
 8009d78:	2300      	movs	r3, #0

                /* Calculate the directory size by counting the allocated
                clusters for it.  */
                i =        0;
                cluster =  search_dir_ptr -> fx_dir_entry_cluster;
 8009d7a:	6b56      	ldr	r6, [r2, #52]	; 0x34
 8009d7c:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
                search_dir_ptr -> fx_dir_entry_last_search_cluster =  0;
 8009d80:	6513      	str	r3, [r2, #80]	; 0x50
                while (cluster < media_ptr -> fx_media_fat_reserved)
 8009d82:	461c      	mov	r4, r3
                i =        0;
 8009d84:	930c      	str	r3, [sp, #48]	; 0x30
                while (cluster < media_ptr -> fx_media_fat_reserved)
 8009d86:	e012      	b.n	8009dae <_fx_directory_search+0xda>
                {

                    /* Increment the cluster count.  */
                    i++;
 8009d88:	950c      	str	r5, [sp, #48]	; 0x30

                    /* Read the next FAT entry.  */
                    status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8009d8a:	f7fd fd2b 	bl	80077e4 <_fx_utility_FAT_entry_read>

                    /* Check the return status.  */
                    if (status != FX_SUCCESS)
 8009d8e:	2800      	cmp	r0, #0
 8009d90:	f040 81af 	bne.w	800a0f2 <_fx_directory_search+0x41e>
                        /* Return the bad status.  */
                        return(status);
                    }

                    /* Check for error situation.  */
                    if ((cluster < FX_FAT_ENTRY_START) || (cluster == next_cluster) || (i > media_ptr -> fx_media_total_clusters))
 8009d94:	2e01      	cmp	r6, #1
 8009d96:	f240 81a7 	bls.w	800a0e8 <_fx_directory_search+0x414>
 8009d9a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8009d9c:	42b3      	cmp	r3, r6
 8009d9e:	461e      	mov	r6, r3
 8009da0:	f000 81a2 	beq.w	800a0e8 <_fx_directory_search+0x414>
 8009da4:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8009da6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009da8:	42a3      	cmp	r3, r4
 8009daa:	f0c0 819d 	bcc.w	800a0e8 <_fx_directory_search+0x414>
                while (cluster < media_ptr -> fx_media_fat_reserved)
 8009dae:	f8d9 3000 	ldr.w	r3, [r9]
                    i++;
 8009db2:	1c65      	adds	r5, r4, #1
                    status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8009db4:	4631      	mov	r1, r6
 8009db6:	aa0d      	add	r2, sp, #52	; 0x34
                while (cluster < media_ptr -> fx_media_fat_reserved)
 8009db8:	42b3      	cmp	r3, r6
                    status =  _fx_utility_FAT_entry_read(media_ptr, cluster, &next_cluster);
 8009dba:	4638      	mov	r0, r7
                while (cluster < media_ptr -> fx_media_fat_reserved)
 8009dbc:	d8e4      	bhi.n	8009d88 <_fx_directory_search+0xb4>

                    cluster = next_cluster;
                }

                /* Now we can calculate the directory size.  */
                directory_size =  (((ULONG64) media_ptr -> fx_media_bytes_per_sector) *
 8009dbe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009dc0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
                                   ((ULONG64) media_ptr -> fx_media_sectors_per_cluster) * i)
                                    / (ULONG64) FX_DIR_ENTRY_SIZE;

                /* Also save this in the directory entry so we don't have to
                   calculate it later.  */
                search_dir_ptr -> fx_dir_entry_file_size =  directory_size;
 8009dc2:	9e01      	ldr	r6, [sp, #4]
                directory_size =  (((ULONG64) media_ptr -> fx_media_bytes_per_sector) *
 8009dc4:	fba0 0103 	umull	r0, r1, r0, r3
            }
#endif /* FX_ENABLE_EXFAT */

            /* If required, copy the last search directory entry into the
               destination.  */
            if (last_dir_ptr)
 8009dc8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
                                   ((ULONG64) media_ptr -> fx_media_sectors_per_cluster) * i)
 8009dca:	fba0 2304 	umull	r2, r3, r0, r4
            if (last_dir_ptr)
 8009dce:	4628      	mov	r0, r5
                                   ((ULONG64) media_ptr -> fx_media_sectors_per_cluster) * i)
 8009dd0:	fb04 3301 	mla	r3, r4, r1, r3
                directory_size =  (((ULONG64) media_ptr -> fx_media_bytes_per_sector) *
 8009dd4:	0951      	lsrs	r1, r2, #5
 8009dd6:	ea41 61c3 	orr.w	r1, r1, r3, lsl #27
 8009dda:	095b      	lsrs	r3, r3, #5
 8009ddc:	9104      	str	r1, [sp, #16]
 8009dde:	9305      	str	r3, [sp, #20]
                search_dir_ptr -> fx_dir_entry_file_size =  directory_size;
 8009de0:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
 8009de4:	e9c6 120e 	strd	r1, r2, [r6, #56]	; 0x38
            if (last_dir_ptr)
 8009de8:	b1dd      	cbz	r5, 8009e22 <_fx_directory_search+0x14e>

                /* First, save the name pointer from the list directory pointer.  */
                destination_name_ptr =  last_dir_ptr -> fx_dir_entry_name;

                /* Copy the entire directory entry structure.  */
                *last_dir_ptr =  *search_dir_ptr;
 8009dea:	2270      	movs	r2, #112	; 0x70
 8009dec:	4631      	mov	r1, r6
                destination_name_ptr =  last_dir_ptr -> fx_dir_entry_name;
 8009dee:	682c      	ldr	r4, [r5, #0]
                *last_dir_ptr =  *search_dir_ptr;
 8009df0:	f003 ff6a 	bl	800dcc8 <memcpy>
 8009df4:	6833      	ldr	r3, [r6, #0]

                /* Pickup pointer to name to copy.  */
                source_name_ptr =  search_dir_ptr -> fx_dir_entry_name;

                /* Loop to copy the name into the last directory name buffer.  */
                for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 8009df6:	2200      	movs	r2, #0
 8009df8:	1e61      	subs	r1, r4, #1
                last_dir_ptr -> fx_dir_entry_name =  destination_name_ptr;
 8009dfa:	602c      	str	r4, [r5, #0]
 8009dfc:	3b01      	subs	r3, #1
                {

                    /* Copy a character.  */
                    destination_name_ptr[n] =  source_name_ptr[n];
 8009dfe:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8009e02:	f801 0f01 	strb.w	r0, [r1, #1]!

                    /* See if we have copied the NULL termination character.  */
                    if (source_name_ptr[n] == (CHAR) FX_NULL)
 8009e06:	7818      	ldrb	r0, [r3, #0]
                    {
                
                        /* Determine if we should break here or at the top of the loop.  */
                        if (n < (FX_MAX_LONG_NAME_LEN - 1))
 8009e08:	b908      	cbnz	r0, 8009e0e <_fx_directory_search+0x13a>
 8009e0a:	2aff      	cmp	r2, #255	; 0xff
 8009e0c:	d109      	bne.n	8009e22 <_fx_directory_search+0x14e>
                for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 8009e0e:	3201      	adds	r2, #1
 8009e10:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8009e14:	d1f3      	bne.n	8009dfe <_fx_directory_search+0x12a>
 8009e16:	e004      	b.n	8009e22 <_fx_directory_search+0x14e>
        }
        else
        {

            /* Directory size is the number of entries in the root directory.  */
            directory_size =  (ULONG)media_ptr -> fx_media_root_directory_entries;
 8009e18:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8009e1a:	2200      	movs	r2, #0
 8009e1c:	4619      	mov	r1, r3
 8009e1e:	e9cd 1204 	strd	r1, r2, [sp, #16]
        }

        /* Loop through entries in the directory.  Yes, this is a
           linear search!  */
        i =      0;
 8009e22:	aa2a      	add	r2, sp, #168	; 0xa8
 8009e24:	2300      	movs	r3, #0
 8009e26:	f842 3d78 	str.w	r3, [r2, #-120]!
 8009e2a:	9202      	str	r2, [sp, #8]

            /* Read an entry from the directory.  */
#ifdef FX_ENABLE_EXFAT
            status =  _fx_directory_entry_read_ex(media_ptr, search_dir_ptr, &i, entry_ptr, hash);
#else
            status =  _fx_directory_entry_read(media_ptr, search_dir_ptr, &i, entry_ptr);
 8009e2c:	4643      	mov	r3, r8
 8009e2e:	9a02      	ldr	r2, [sp, #8]
 8009e30:	9901      	ldr	r1, [sp, #4]
 8009e32:	4638      	mov	r0, r7
 8009e34:	f7fe fdf2 	bl	8008a1c <_fx_directory_entry_read>
#endif /* FX_ENABLE_EXFAT */

            i++;
 8009e38:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8009e3a:	3501      	adds	r5, #1
 8009e3c:	950c      	str	r5, [sp, #48]	; 0x30

            /* Check for error status.  */
            if (status != FX_SUCCESS)
 8009e3e:	2800      	cmp	r0, #0
 8009e40:	f040 8157 	bne.w	800a0f2 <_fx_directory_search+0x41e>

            /* Determine if this is the last directory entry.  */
#ifdef FX_ENABLE_EXFAT
            if (entry_ptr -> fx_dir_entry_type == FX_EXFAT_DIR_ENTRY_TYPE_END_MARKER)
#else
            if ((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_DONE)
 8009e44:	f8d8 4000 	ldr.w	r4, [r8]
 8009e48:	7823      	ldrb	r3, [r4, #0]
 8009e4a:	b373      	cbz	r3, 8009eaa <_fx_directory_search+0x1d6>

            /* Determine if this is an empty entry.  */
#ifdef FX_ENABLE_EXFAT
            if (entry_ptr -> fx_dir_entry_type != FX_EXFAT_DIR_ENTRY_TYPE_FILE_DIRECTORY)
#else
            if (((UCHAR)entry_ptr -> fx_dir_entry_name[0] == (UCHAR)FX_DIR_ENTRY_FREE) && (entry_ptr -> fx_dir_entry_short_name[0] == 0))
 8009e4c:	2be5      	cmp	r3, #229	; 0xe5
 8009e4e:	d102      	bne.n	8009e56 <_fx_directory_search+0x182>
 8009e50:	f898 3004 	ldrb.w	r3, [r8, #4]
 8009e54:	b313      	cbz	r3, 8009e9c <_fx_directory_search+0x1c8>
 8009e56:	9e03      	ldr	r6, [sp, #12]
 8009e58:	46b2      	mov	sl, r6
 8009e5a:	e002      	b.n	8009e62 <_fx_directory_search+0x18e>
                }

                /* Otherwise, increment the name pointers.  */
                work_ptr++;
                dir_name_ptr++;
            } while (*dir_name_ptr);
 8009e5c:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8009e60:	b343      	cbz	r3, 8009eb4 <_fx_directory_search+0x1e0>
                alpha =  *dir_name_ptr;
 8009e62:	7822      	ldrb	r2, [r4, #0]
 8009e64:	46b3      	mov	fp, r6
                name_alpha =  *work_ptr;
 8009e66:	f816 3b01 	ldrb.w	r3, [r6], #1
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009e6a:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
                    alpha =  (CHAR)((INT)alpha - 0x20);
 8009e6e:	f1a2 0c20 	sub.w	ip, r2, #32
 8009e72:	4696      	mov	lr, r2
                    name_alpha =  (CHAR)((INT)name_alpha - 0x20);
 8009e74:	f1a3 0920 	sub.w	r9, r3, #32
                if ((alpha >= 'a') && (alpha <= 'z'))
 8009e78:	2919      	cmp	r1, #25
                if ((name_alpha >= 'a') && (name_alpha <= 'z'))
 8009e7a:	f1a3 0161 	sub.w	r1, r3, #97	; 0x61
                    alpha =  (CHAR)((INT)alpha - 0x20);
 8009e7e:	bf98      	it	ls
 8009e80:	fa5f fe8c 	uxtbls.w	lr, ip
                if ((name_alpha >= 'a') && (name_alpha <= 'z'))
 8009e84:	2919      	cmp	r1, #25
 8009e86:	469c      	mov	ip, r3
                    name_alpha =  (CHAR)((INT)name_alpha - 0x20);
 8009e88:	bf98      	it	ls
 8009e8a:	fa5f fc89 	uxtbls.w	ip, r9
                if (alpha != name_alpha)
 8009e8e:	45e6      	cmp	lr, ip
 8009e90:	d0e4      	beq.n	8009e5c <_fx_directory_search+0x188>

            /* Determine if the requested name has been found.  If so,
               return success to the caller.  */
            if ((*dir_name_ptr == 0) && (*work_ptr == *dir_name_ptr))
 8009e92:	b18a      	cbz	r2, 8009eb8 <_fx_directory_search+0x1e4>
            /* Determine if there is a short name to check.  */
#ifdef FX_ENABLE_EXFAT
            else if ((media_ptr -> fx_media_FAT_type != FX_exFAT) &&
                     (entry_ptr -> fx_dir_entry_short_name[0] != 0))
#else
            else if (entry_ptr -> fx_dir_entry_short_name[0] != 0)
 8009e94:	f898 3004 	ldrb.w	r3, [r8, #4]
 8009e98:	2b00      	cmp	r3, #0
 8009e9a:	d141      	bne.n	8009f20 <_fx_directory_search+0x24c>
                    /* Yes, the name was located.  All pertinent directory
                        information is in the directory entry field.  */
                    found =  FX_TRUE;
                }
            }
        } while ((i < directory_size) && (!found));
 8009e9c:	2300      	movs	r3, #0
 8009e9e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8009ea2:	428b      	cmp	r3, r1
 8009ea4:	bf08      	it	eq
 8009ea6:	4285      	cmpeq	r5, r0
 8009ea8:	d3c0      	bcc.n	8009e2c <_fx_directory_search+0x158>
        /* Now determine if we have a match.  */
        if (!found)
        {

            /* Return a "not found" status to the caller.  */
            return(FX_NOT_FOUND);
 8009eaa:	2504      	movs	r5, #4
        }
    }
#endif

    return(FX_SUCCESS);
}
 8009eac:	4628      	mov	r0, r5
 8009eae:	b02b      	add	sp, #172	; 0xac
 8009eb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009eb4:	f89b 3001 	ldrb.w	r3, [fp, #1]
            if ((*dir_name_ptr == 0) && (*work_ptr == *dir_name_ptr))
 8009eb8:	2b00      	cmp	r3, #0
 8009eba:	d1eb      	bne.n	8009e94 <_fx_directory_search+0x1c0>
        if (entry_ptr -> fx_dir_entry_attributes & FX_DIRECTORY)
 8009ebc:	f898 301c 	ldrb.w	r3, [r8, #28]
 8009ec0:	4605      	mov	r5, r0
 8009ec2:	06db      	lsls	r3, r3, #27
 8009ec4:	d44b      	bmi.n	8009f5e <_fx_directory_search+0x28a>
            if (name_ptr)
 8009ec6:	9b06      	ldr	r3, [sp, #24]
 8009ec8:	2b00      	cmp	r3, #0
 8009eca:	d1ee      	bne.n	8009eaa <_fx_directory_search+0x1d6>
    if ((*original_name != '\\') && (*original_name != '/') && (path_ptr))
 8009ecc:	9b07      	ldr	r3, [sp, #28]
 8009ece:	781b      	ldrb	r3, [r3, #0]
 8009ed0:	2b5c      	cmp	r3, #92	; 0x5c
 8009ed2:	f000 8176 	beq.w	800a1c2 <_fx_directory_search+0x4ee>
 8009ed6:	2b2f      	cmp	r3, #47	; 0x2f
 8009ed8:	f000 8173 	beq.w	800a1c2 <_fx_directory_search+0x4ee>
 8009edc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009ede:	2b00      	cmp	r3, #0
 8009ee0:	f000 81c3 	beq.w	800a26a <_fx_directory_search+0x596>
 8009ee4:	1e59      	subs	r1, r3, #1
 8009ee6:	f207 32df 	addw	r2, r7, #991	; 0x3df
    v=  0;
 8009eea:	2300      	movs	r3, #0
 8009eec:	e005      	b.n	8009efa <_fx_directory_search+0x226>
            v++;
 8009eee:	3301      	adds	r3, #1
            media_ptr -> fx_media_last_found_name[v] =  path_ptr[v];
 8009ef0:	f802 0f01 	strb.w	r0, [r2, #1]!
        while ((v< (FX_MAX_LAST_NAME_LEN - 1)) && (path_ptr[v]))
 8009ef4:	2bff      	cmp	r3, #255	; 0xff
 8009ef6:	f000 8165 	beq.w	800a1c4 <_fx_directory_search+0x4f0>
 8009efa:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8009efe:	2800      	cmp	r0, #0
 8009f00:	d1f5      	bne.n	8009eee <_fx_directory_search+0x21a>
    if ((*original_name != '\\') && (*original_name != '/'))
 8009f02:	9a07      	ldr	r2, [sp, #28]
 8009f04:	7812      	ldrb	r2, [r2, #0]
 8009f06:	2a5c      	cmp	r2, #92	; 0x5c
 8009f08:	f000 815c 	beq.w	800a1c4 <_fx_directory_search+0x4f0>
 8009f0c:	2a2f      	cmp	r2, #47	; 0x2f
 8009f0e:	f000 8159 	beq.w	800a1c4 <_fx_directory_search+0x4f0>
 8009f12:	1c5a      	adds	r2, r3, #1
            media_ptr -> fx_media_last_found_name[v++] =  '/';
 8009f14:	18f9      	adds	r1, r7, r3
 8009f16:	202f      	movs	r0, #47	; 0x2f
 8009f18:	4613      	mov	r3, r2
 8009f1a:	f881 03e0 	strb.w	r0, [r1, #992]	; 0x3e0
 8009f1e:	e151      	b.n	800a1c4 <_fx_directory_search+0x4f0>
                dir_name_ptr =  &(entry_ptr -> fx_dir_entry_short_name[0]);
 8009f20:	f108 0204 	add.w	r2, r8, #4
 8009f24:	e003      	b.n	8009f2e <_fx_directory_search+0x25a>
                } while (*dir_name_ptr);
 8009f26:	f812 3f01 	ldrb.w	r3, [r2, #1]!
                    work_ptr++;
 8009f2a:	4656      	mov	r6, sl
                } while (*dir_name_ptr);
 8009f2c:	b17b      	cbz	r3, 8009f4e <_fx_directory_search+0x27a>
 8009f2e:	4656      	mov	r6, sl
                    name_alpha =  *work_ptr;
 8009f30:	f81a 3b01 	ldrb.w	r3, [sl], #1
                    alpha =  *dir_name_ptr;
 8009f34:	7811      	ldrb	r1, [r2, #0]
                    if ((name_alpha >= 'a') && (name_alpha <= 'z'))
 8009f36:	f1a3 0461 	sub.w	r4, r3, #97	; 0x61
                        name_alpha =  (CHAR)((INT)name_alpha - 0x20);
 8009f3a:	f1a3 0c20 	sub.w	ip, r3, #32
                    if ((name_alpha >= 'a') && (name_alpha <= 'z'))
 8009f3e:	2c19      	cmp	r4, #25
                        name_alpha =  (CHAR)((INT)name_alpha - 0x20);
 8009f40:	bf98      	it	ls
 8009f42:	fa5f f38c 	uxtbls.w	r3, ip
                    if (alpha != name_alpha)
 8009f46:	428b      	cmp	r3, r1
 8009f48:	d0ed      	beq.n	8009f26 <_fx_directory_search+0x252>
                if ((*dir_name_ptr == 0) && (*work_ptr == *dir_name_ptr))
 8009f4a:	2900      	cmp	r1, #0
 8009f4c:	d1a6      	bne.n	8009e9c <_fx_directory_search+0x1c8>
 8009f4e:	7833      	ldrb	r3, [r6, #0]
 8009f50:	2b00      	cmp	r3, #0
 8009f52:	d1a3      	bne.n	8009e9c <_fx_directory_search+0x1c8>
        if (entry_ptr -> fx_dir_entry_attributes & FX_DIRECTORY)
 8009f54:	f898 301c 	ldrb.w	r3, [r8, #28]
 8009f58:	4605      	mov	r5, r0
 8009f5a:	06db      	lsls	r3, r3, #27
 8009f5c:	d5b3      	bpl.n	8009ec6 <_fx_directory_search+0x1f2>
            search_dir =      *entry_ptr;
 8009f5e:	2270      	movs	r2, #112	; 0x70
 8009f60:	4641      	mov	r1, r8
 8009f62:	a80e      	add	r0, sp, #56	; 0x38
 8009f64:	f003 feb0 	bl	800dcc8 <memcpy>
            search_dir_ptr -> fx_dir_entry_last_search_cluster =  0;
 8009f68:	2200      	movs	r2, #0
            if (!search_dir_ptr -> fx_dir_entry_cluster)
 8009f6a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
            search_dir_ptr -> fx_dir_entry_last_search_cluster =  0;
 8009f6c:	9222      	str	r2, [sp, #136]	; 0x88
            if (!search_dir_ptr -> fx_dir_entry_cluster)
 8009f6e:	2b00      	cmp	r3, #0
 8009f70:	f040 80d4 	bne.w	800a11c <_fx_directory_search+0x448>
                search_dir_ptr -> fx_dir_entry_name[0] =  0;
 8009f74:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8009f76:	7013      	strb	r3, [r2, #0]
                if (last_dir_ptr)
 8009f78:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009f7a:	b1fb      	cbz	r3, 8009fbc <_fx_directory_search+0x2e8>
                    *last_dir_ptr =  *search_dir_ptr;
 8009f7c:	a90e      	add	r1, sp, #56	; 0x38
 8009f7e:	2270      	movs	r2, #112	; 0x70
 8009f80:	4618      	mov	r0, r3
                    destination_name_ptr =  last_dir_ptr -> fx_dir_entry_name;
 8009f82:	681c      	ldr	r4, [r3, #0]
 8009f84:	461e      	mov	r6, r3
                    *last_dir_ptr =  *search_dir_ptr;
 8009f86:	f003 fe9f 	bl	800dcc8 <memcpy>
                    source_name_ptr =  search_dir_ptr -> fx_dir_entry_name;
 8009f8a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8009f8c:	1d23      	adds	r3, r4, #4
                    last_dir_ptr -> fx_dir_entry_name =  destination_name_ptr;
 8009f8e:	6034      	str	r4, [r6, #0]
 8009f90:	1d11      	adds	r1, r2, #4
 8009f92:	428c      	cmp	r4, r1
 8009f94:	bf38      	it	cc
 8009f96:	429a      	cmpcc	r2, r3
 8009f98:	f0c0 8156 	bcc.w	800a248 <_fx_directory_search+0x574>
 8009f9c:	ea44 0102 	orr.w	r1, r4, r2
 8009fa0:	0789      	lsls	r1, r1, #30
 8009fa2:	f040 8151 	bne.w	800a248 <_fx_directory_search+0x574>
 8009fa6:	3a04      	subs	r2, #4
 8009fa8:	f504 7080 	add.w	r0, r4, #256	; 0x100
                        destination_name_ptr[n] =  source_name_ptr[n];
 8009fac:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8009fb0:	4298      	cmp	r0, r3
 8009fb2:	6021      	str	r1, [r4, #0]
 8009fb4:	461c      	mov	r4, r3
 8009fb6:	f103 0304 	add.w	r3, r3, #4
 8009fba:	d1f7      	bne.n	8009fac <_fx_directory_search+0x2d8>
                search_dir_ptr =  FX_NULL;
 8009fbc:	2300      	movs	r3, #0
 8009fbe:	9301      	str	r3, [sp, #4]
 8009fc0:	e0ae      	b.n	800a120 <_fx_directory_search+0x44c>
 8009fc2:	bf00      	nop
 8009fc4:	20000f2c 	.word	0x20000f2c
 8009fc8:	9907      	ldr	r1, [sp, #28]
 8009fca:	f507 7278 	add.w	r2, r7, #992	; 0x3e0
 8009fce:	460b      	mov	r3, r1
 8009fd0:	f101 06fe 	add.w	r6, r1, #254	; 0xfe
            while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (name_ptr[v]))
 8009fd4:	b18c      	cbz	r4, 8009ffa <_fx_directory_search+0x326>
                if (alpha == '\\')
 8009fd6:	2c5c      	cmp	r4, #92	; 0x5c
 8009fd8:	f000 8082 	beq.w	800a0e0 <_fx_directory_search+0x40c>
                if (beta == '\\')
 8009fdc:	2d5c      	cmp	r5, #92	; 0x5c
 8009fde:	4621      	mov	r1, r4
 8009fe0:	d04f      	beq.n	800a082 <_fx_directory_search+0x3ae>
                    alpha =  '/';
 8009fe2:	4628      	mov	r0, r5
                if (alpha != beta)
 8009fe4:	4288      	cmp	r0, r1
 8009fe6:	d108      	bne.n	8009ffa <_fx_directory_search+0x326>
            while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (name_ptr[v]))
 8009fe8:	42b3      	cmp	r3, r6
 8009fea:	f000 8127 	beq.w	800a23c <_fx_directory_search+0x568>
 8009fee:	f813 4f01 	ldrb.w	r4, [r3, #1]!
 8009ff2:	f812 5f01 	ldrb.w	r5, [r2, #1]!
 8009ff6:	2c00      	cmp	r4, #0
 8009ff8:	d1ed      	bne.n	8009fd6 <_fx_directory_search+0x302>
            if (name_ptr[v] != media_ptr -> fx_media_last_found_name[v])
 8009ffa:	42a5      	cmp	r5, r4
 8009ffc:	f47f aea1 	bne.w	8009d42 <_fx_directory_search+0x6e>
            temp_ptr =  entry_ptr -> fx_dir_entry_name;
 800a000:	9d08      	ldr	r5, [sp, #32]
            *entry_ptr =  media_ptr -> fx_media_last_found_entry;
 800a002:	f507 711c 	add.w	r1, r7, #624	; 0x270
 800a006:	2270      	movs	r2, #112	; 0x70
            temp_ptr =  entry_ptr -> fx_dir_entry_name;
 800a008:	682c      	ldr	r4, [r5, #0]
            *entry_ptr =  media_ptr -> fx_media_last_found_entry;
 800a00a:	4628      	mov	r0, r5
 800a00c:	f003 fe5c 	bl	800dcc8 <memcpy>
 800a010:	f207 21df 	addw	r1, r7, #735	; 0x2df
 800a014:	1e60      	subs	r0, r4, #1
            for (index = 0; index < FX_MAX_LONG_NAME_LEN; index++)
 800a016:	2300      	movs	r3, #0
            entry_ptr -> fx_dir_entry_name =  temp_ptr;
 800a018:	602c      	str	r4, [r5, #0]
                temp_ptr[index] =  media_ptr -> fx_media_last_found_file_name[index];
 800a01a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
                    if (index < (FX_MAX_LONG_NAME_LEN - 1))
 800a01e:	2bff      	cmp	r3, #255	; 0xff
            for (index = 0; index < FX_MAX_LONG_NAME_LEN; index++)
 800a020:	f103 0301 	add.w	r3, r3, #1
                temp_ptr[index] =  media_ptr -> fx_media_last_found_file_name[index];
 800a024:	f800 2f01 	strb.w	r2, [r0, #1]!
                    if (index < (FX_MAX_LONG_NAME_LEN - 1))
 800a028:	d07f      	beq.n	800a12a <_fx_directory_search+0x456>
 800a02a:	2a00      	cmp	r2, #0
 800a02c:	d17d      	bne.n	800a12a <_fx_directory_search+0x456>
            if ((last_dir_ptr) && (media_ptr -> fx_media_last_found_directory_valid))
 800a02e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 800a030:	b1d6      	cbz	r6, 800a068 <_fx_directory_search+0x394>
 800a032:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 800a036:	b1bb      	cbz	r3, 800a068 <_fx_directory_search+0x394>
                destination_name_ptr =  last_dir_ptr -> fx_dir_entry_name;
 800a038:	6835      	ldr	r5, [r6, #0]
                *last_dir_ptr =  media_ptr -> fx_media_last_found_directory;
 800a03a:	2270      	movs	r2, #112	; 0x70
 800a03c:	f507 7100 	add.w	r1, r7, #512	; 0x200
 800a040:	4630      	mov	r0, r6
 800a042:	f003 fe41 	bl	800dcc8 <memcpy>
                last_dir_ptr -> fx_dir_entry_name =  destination_name_ptr;
 800a046:	6035      	str	r5, [r6, #0]
 800a048:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 800a04c:	1e6a      	subs	r2, r5, #1
                for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 800a04e:	2100      	movs	r1, #0
 800a050:	3b01      	subs	r3, #1
                    destination_name_ptr[n] =  source_name_ptr[n];
 800a052:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 800a056:	f802 0f01 	strb.w	r0, [r2, #1]!
                    if (source_name_ptr[n] == (CHAR)FX_NULL)
 800a05a:	7818      	ldrb	r0, [r3, #0]
                        if (n < (FX_MAX_LONG_NAME_LEN - 1))
 800a05c:	2800      	cmp	r0, #0
 800a05e:	f040 80aa 	bne.w	800a1b6 <_fx_directory_search+0x4e2>
 800a062:	29ff      	cmp	r1, #255	; 0xff
 800a064:	f000 80a7 	beq.w	800a1b6 <_fx_directory_search+0x4e2>
            if (last_name_ptr)
 800a068:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 800a06a:	b103      	cbz	r3, 800a06e <_fx_directory_search+0x39a>
                *last_name_ptr =  temp_ptr;
 800a06c:	601c      	str	r4, [r3, #0]
            media_ptr -> fx_media_directory_search_cache_hits++;
 800a06e:	f8d7 31c4 	ldr.w	r3, [r7, #452]	; 0x1c4
            return(FX_SUCCESS);
 800a072:	2500      	movs	r5, #0
            media_ptr -> fx_media_directory_search_cache_hits++;
 800a074:	3301      	adds	r3, #1
}
 800a076:	4628      	mov	r0, r5
            media_ptr -> fx_media_directory_search_cache_hits++;
 800a078:	f8c7 31c4 	str.w	r3, [r7, #452]	; 0x1c4
}
 800a07c:	b02b      	add	sp, #172	; 0xac
 800a07e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    beta =  '/';
 800a082:	202f      	movs	r0, #47	; 0x2f
 800a084:	e7ae      	b.n	8009fe4 <_fx_directory_search+0x310>
    if (media_ptr -> fx_media_last_found_name[0])
 800a086:	2d00      	cmp	r5, #0
 800a088:	f43f ae5b 	beq.w	8009d42 <_fx_directory_search+0x6e>
                if ((media_ptr -> fx_media_last_found_name[v] != '\\') &&
 800a08c:	2d5c      	cmp	r5, #92	; 0x5c
 800a08e:	d002      	beq.n	800a096 <_fx_directory_search+0x3c2>
 800a090:	2d2f      	cmp	r5, #47	; 0x2f
 800a092:	f47f ae56 	bne.w	8009d42 <_fx_directory_search+0x6e>
 800a096:	2300      	movs	r3, #0
                    v++;
 800a098:	2501      	movs	r5, #1
                if ((media_ptr -> fx_media_last_found_name[v] != '\\') &&
 800a09a:	930b      	str	r3, [sp, #44]	; 0x2c
 800a09c:	9301      	str	r3, [sp, #4]
                while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (name_ptr[j]) && (match))
 800a09e:	2c00      	cmp	r4, #0
 800a0a0:	f000 80e5 	beq.w	800a26e <_fx_directory_search+0x59a>
 800a0a4:	f203 30e1 	addw	r0, r3, #993	; 0x3e1
 800a0a8:	9e07      	ldr	r6, [sp, #28]
 800a0aa:	f1c3 03fe 	rsb	r3, r3, #254	; 0xfe
                j =  0;
 800a0ae:	2100      	movs	r1, #0
 800a0b0:	4438      	add	r0, r7
 800a0b2:	e00c      	b.n	800a0ce <_fx_directory_search+0x3fa>
                        beta =  '/';
 800a0b4:	2a5c      	cmp	r2, #92	; 0x5c
 800a0b6:	bf08      	it	eq
 800a0b8:	222f      	moveq	r2, #47	; 0x2f
                    if (alpha != beta)
 800a0ba:	42a2      	cmp	r2, r4
 800a0bc:	d172      	bne.n	800a1a4 <_fx_directory_search+0x4d0>
                    j++;
 800a0be:	3101      	adds	r1, #1
                    v++;
 800a0c0:	3501      	adds	r5, #1
                while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (name_ptr[j]) && (match))
 800a0c2:	4299      	cmp	r1, r3
 800a0c4:	d06e      	beq.n	800a1a4 <_fx_directory_search+0x4d0>
 800a0c6:	f816 4f01 	ldrb.w	r4, [r6, #1]!
 800a0ca:	2c00      	cmp	r4, #0
 800a0cc:	d06a      	beq.n	800a1a4 <_fx_directory_search+0x4d0>
                    if (alpha == '\\')
 800a0ce:	2c5c      	cmp	r4, #92	; 0x5c
                    beta =   media_ptr -> fx_media_last_found_name[v];
 800a0d0:	f810 2b01 	ldrb.w	r2, [r0], #1
                    if (alpha == '\\')
 800a0d4:	d1ee      	bne.n	800a0b4 <_fx_directory_search+0x3e0>
                    if (beta == '\\')
 800a0d6:	2a5c      	cmp	r2, #92	; 0x5c
                        alpha =  '/';
 800a0d8:	f04f 042f 	mov.w	r4, #47	; 0x2f
                    if (beta == '\\')
 800a0dc:	d1ed      	bne.n	800a0ba <_fx_directory_search+0x3e6>
 800a0de:	e7ee      	b.n	800a0be <_fx_directory_search+0x3ea>
                if (beta == '\\')
 800a0e0:	2d5c      	cmp	r5, #92	; 0x5c
 800a0e2:	d081      	beq.n	8009fe8 <_fx_directory_search+0x314>
                    alpha =  '/';
 800a0e4:	212f      	movs	r1, #47	; 0x2f
 800a0e6:	e77c      	b.n	8009fe2 <_fx_directory_search+0x30e>
                        return(FX_FAT_READ_ERROR);
 800a0e8:	2503      	movs	r5, #3
}
 800a0ea:	4628      	mov	r0, r5
 800a0ec:	b02b      	add	sp, #172	; 0xac
 800a0ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a0f2:	4605      	mov	r5, r0
 800a0f4:	4628      	mov	r0, r5
 800a0f6:	b02b      	add	sp, #172	; 0xac
 800a0f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (media_ptr -> fx_media_default_path.fx_path_directory.fx_dir_entry_name[0])
 800a0fc:	f8d7 34e0 	ldr.w	r3, [r7, #1248]	; 0x4e0
 800a100:	781b      	ldrb	r3, [r3, #0]
 800a102:	2b00      	cmp	r3, #0
 800a104:	d0bf      	beq.n	800a086 <_fx_directory_search+0x3b2>
            search_dir =  media_ptr -> fx_media_default_path.fx_path_directory;
 800a106:	ae0e      	add	r6, sp, #56	; 0x38
            path_ptr =  media_ptr -> fx_media_default_path.fx_path_string;
 800a108:	f507 63aa 	add.w	r3, r7, #1360	; 0x550
            search_dir =  media_ptr -> fx_media_default_path.fx_path_directory;
 800a10c:	2270      	movs	r2, #112	; 0x70
 800a10e:	f507 619c 	add.w	r1, r7, #1248	; 0x4e0
 800a112:	4630      	mov	r0, r6
            path_ptr =  media_ptr -> fx_media_default_path.fx_path_string;
 800a114:	930b      	str	r3, [sp, #44]	; 0x2c
            search_dir =  media_ptr -> fx_media_default_path.fx_path_directory;
 800a116:	f003 fdd7 	bl	800dcc8 <memcpy>
 800a11a:	e60a      	b.n	8009d32 <_fx_directory_search+0x5e>
            search_dir_ptr =  &search_dir;
 800a11c:	ab0e      	add	r3, sp, #56	; 0x38
 800a11e:	9301      	str	r3, [sp, #4]
    } while (name_ptr);
 800a120:	9b06      	ldr	r3, [sp, #24]
 800a122:	2b00      	cmp	r3, #0
 800a124:	f47f ae1b 	bne.w	8009d5e <_fx_directory_search+0x8a>
 800a128:	e6d0      	b.n	8009ecc <_fx_directory_search+0x1f8>
            for (index = 0; index < FX_MAX_LONG_NAME_LEN; index++)
 800a12a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a12e:	f47f af74 	bne.w	800a01a <_fx_directory_search+0x346>
 800a132:	e77c      	b.n	800a02e <_fx_directory_search+0x35a>
 800a134:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a136:	f507 7078 	add.w	r0, r7, #992	; 0x3e0
 800a13a:	1e59      	subs	r1, r3, #1
        v =  0;
 800a13c:	2300      	movs	r3, #0
 800a13e:	e008      	b.n	800a152 <_fx_directory_search+0x47e>
                        beta =  '/';
 800a140:	2a5c      	cmp	r2, #92	; 0x5c
 800a142:	bf08      	it	eq
 800a144:	222f      	moveq	r2, #47	; 0x2f
                    if (alpha != beta)
 800a146:	42aa      	cmp	r2, r5
 800a148:	d10f      	bne.n	800a16a <_fx_directory_search+0x496>
                while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (path_ptr[v]))
 800a14a:	2bff      	cmp	r3, #255	; 0xff
 800a14c:	d00d      	beq.n	800a16a <_fx_directory_search+0x496>
 800a14e:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 800a152:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800a156:	b1b2      	cbz	r2, 800a186 <_fx_directory_search+0x4b2>
                    if (alpha == '\\')
 800a158:	2d5c      	cmp	r5, #92	; 0x5c
 800a15a:	f103 0301 	add.w	r3, r3, #1
 800a15e:	d1ef      	bne.n	800a140 <_fx_directory_search+0x46c>
                    if (beta == '\\')
 800a160:	2a5c      	cmp	r2, #92	; 0x5c
                        alpha =  '/';
 800a162:	f04f 052f 	mov.w	r5, #47	; 0x2f
                    if (beta == '\\')
 800a166:	d1ee      	bne.n	800a146 <_fx_directory_search+0x472>
 800a168:	e7ef      	b.n	800a14a <_fx_directory_search+0x476>
                if (path_ptr[v])
 800a16a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800a16c:	5cd2      	ldrb	r2, [r2, r3]
 800a16e:	2a00      	cmp	r2, #0
 800a170:	f47f ade2 	bne.w	8009d38 <_fx_directory_search+0x64>
 800a174:	18fa      	adds	r2, r7, r3
 800a176:	f892 23e0 	ldrb.w	r2, [r2, #992]	; 0x3e0
                if ((media_ptr -> fx_media_last_found_name[v] != '\\') &&
 800a17a:	2a5c      	cmp	r2, #92	; 0x5c
 800a17c:	d008      	beq.n	800a190 <_fx_directory_search+0x4bc>
 800a17e:	2a2f      	cmp	r2, #47	; 0x2f
 800a180:	f47f adda 	bne.w	8009d38 <_fx_directory_search+0x64>
 800a184:	e004      	b.n	800a190 <_fx_directory_search+0x4bc>
 800a186:	2d5c      	cmp	r5, #92	; 0x5c
 800a188:	d002      	beq.n	800a190 <_fx_directory_search+0x4bc>
 800a18a:	2d2f      	cmp	r5, #47	; 0x2f
 800a18c:	f47f add4 	bne.w	8009d38 <_fx_directory_search+0x64>
                    v++;
 800a190:	1c5d      	adds	r5, r3, #1
                while ((v < (FX_MAX_LAST_NAME_LEN - 1)) && (name_ptr[j]) && (match))
 800a192:	9601      	str	r6, [sp, #4]
 800a194:	2dfe      	cmp	r5, #254	; 0xfe
 800a196:	d982      	bls.n	800a09e <_fx_directory_search+0x3ca>
                if (v >= 256)
 800a198:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 800a19c:	f43f add4 	beq.w	8009d48 <_fx_directory_search+0x74>
                j =  0;
 800a1a0:	2100      	movs	r1, #0
                if (v >= 256)
 800a1a2:	25ff      	movs	r5, #255	; 0xff
                else if ((match) && (name_ptr[j] != media_ptr -> fx_media_last_found_name[v]))
 800a1a4:	9b07      	ldr	r3, [sp, #28]
 800a1a6:	443d      	add	r5, r7
 800a1a8:	5c5a      	ldrb	r2, [r3, r1]
 800a1aa:	f895 33e0 	ldrb.w	r3, [r5, #992]	; 0x3e0
 800a1ae:	429a      	cmp	r2, r3
 800a1b0:	f47f adca 	bne.w	8009d48 <_fx_directory_search+0x74>
 800a1b4:	e724      	b.n	800a000 <_fx_directory_search+0x32c>
                for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 800a1b6:	3101      	adds	r1, #1
 800a1b8:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 800a1bc:	f47f af49 	bne.w	800a052 <_fx_directory_search+0x37e>
 800a1c0:	e752      	b.n	800a068 <_fx_directory_search+0x394>
    v=  0;
 800a1c2:	2300      	movs	r3, #0
 800a1c4:	f503 7278 	add.w	r2, r3, #992	; 0x3e0
 800a1c8:	9907      	ldr	r1, [sp, #28]
 800a1ca:	443a      	add	r2, r7
 800a1cc:	1e48      	subs	r0, r1, #1
 800a1ce:	e005      	b.n	800a1dc <_fx_directory_search+0x508>
        v++;
 800a1d0:	3301      	adds	r3, #1
        media_ptr -> fx_media_last_found_name[v] =  original_name[j];
 800a1d2:	f802 1b01 	strb.w	r1, [r2], #1
    while ((v < FX_MAX_LAST_NAME_LEN) && (original_name[j]))
 800a1d6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a1da:	d040      	beq.n	800a25e <_fx_directory_search+0x58a>
 800a1dc:	f810 1f01 	ldrb.w	r1, [r0, #1]!
 800a1e0:	2900      	cmp	r1, #0
 800a1e2:	d1f5      	bne.n	800a1d0 <_fx_directory_search+0x4fc>
        media_ptr -> fx_media_last_found_name[v] =  FX_NULL;
 800a1e4:	443b      	add	r3, r7
 800a1e6:	f883 13e0 	strb.w	r1, [r3, #992]	; 0x3e0
    if (search_dir_ptr)
 800a1ea:	9901      	ldr	r1, [sp, #4]
 800a1ec:	2900      	cmp	r1, #0
 800a1ee:	d03a      	beq.n	800a266 <_fx_directory_search+0x592>
        media_ptr -> fx_media_last_found_directory =  *search_dir_ptr;
 800a1f0:	2270      	movs	r2, #112	; 0x70
 800a1f2:	f507 7000 	add.w	r0, r7, #512	; 0x200
 800a1f6:	f003 fd67 	bl	800dcc8 <memcpy>
        media_ptr -> fx_media_last_found_directory_valid =  FX_TRUE;
 800a1fa:	2301      	movs	r3, #1
    media_ptr -> fx_media_last_found_entry =  *entry_ptr;
 800a1fc:	9c08      	ldr	r4, [sp, #32]
 800a1fe:	2270      	movs	r2, #112	; 0x70
 800a200:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
 800a204:	f507 701c 	add.w	r0, r7, #624	; 0x270
 800a208:	4621      	mov	r1, r4
 800a20a:	f003 fd5d 	bl	800dcc8 <memcpy>
    media_ptr -> fx_media_last_found_entry.fx_dir_entry_name =  media_ptr -> fx_media_last_found_file_name;
 800a20e:	f507 7238 	add.w	r2, r7, #736	; 0x2e0
 800a212:	f207 21df 	addw	r1, r7, #735	; 0x2df
    for (index = 0; index < FX_MAX_LONG_NAME_LEN; index++)
 800a216:	2300      	movs	r3, #0
    media_ptr -> fx_media_last_found_entry.fx_dir_entry_name =  media_ptr -> fx_media_last_found_file_name;
 800a218:	f8c7 2270 	str.w	r2, [r7, #624]	; 0x270
 800a21c:	6822      	ldr	r2, [r4, #0]
        media_ptr -> fx_media_last_found_file_name[index] =  entry_ptr ->  fx_dir_entry_name[index];
 800a21e:	5cd2      	ldrb	r2, [r2, r3]
 800a220:	f801 2f01 	strb.w	r2, [r1, #1]!
        if (entry_ptr -> fx_dir_entry_name[index] == (CHAR)FX_NULL)
 800a224:	9a08      	ldr	r2, [sp, #32]
 800a226:	6812      	ldr	r2, [r2, #0]
 800a228:	5cd0      	ldrb	r0, [r2, r3]
            if (index < (FX_MAX_LONG_NAME_LEN - 1))
 800a22a:	b910      	cbnz	r0, 800a232 <_fx_directory_search+0x55e>
 800a22c:	2bff      	cmp	r3, #255	; 0xff
 800a22e:	f47f ae3d 	bne.w	8009eac <_fx_directory_search+0x1d8>
    for (index = 0; index < FX_MAX_LONG_NAME_LEN; index++)
 800a232:	3301      	adds	r3, #1
 800a234:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a238:	d1f1      	bne.n	800a21e <_fx_directory_search+0x54a>
 800a23a:	e637      	b.n	8009eac <_fx_directory_search+0x1d8>
 800a23c:	9b07      	ldr	r3, [sp, #28]
 800a23e:	f897 54df 	ldrb.w	r5, [r7, #1247]	; 0x4df
 800a242:	f893 40ff 	ldrb.w	r4, [r3, #255]	; 0xff
 800a246:	e6d8      	b.n	8009ffa <_fx_directory_search+0x326>
 800a248:	3c01      	subs	r4, #1
 800a24a:	1e51      	subs	r1, r2, #1
 800a24c:	f102 03ff 	add.w	r3, r2, #255	; 0xff
                        destination_name_ptr[n] =  source_name_ptr[n];
 800a250:	f811 2f01 	ldrb.w	r2, [r1, #1]!
                    for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 800a254:	428b      	cmp	r3, r1
                        destination_name_ptr[n] =  source_name_ptr[n];
 800a256:	f804 2f01 	strb.w	r2, [r4, #1]!
                    for (n = 0; n < FX_MAX_LONG_NAME_LEN; n++)
 800a25a:	d1f9      	bne.n	800a250 <_fx_directory_search+0x57c>
 800a25c:	e6ae      	b.n	8009fbc <_fx_directory_search+0x2e8>
        media_ptr -> fx_media_last_found_name[0] =  FX_NULL;
 800a25e:	2300      	movs	r3, #0
 800a260:	f887 33e0 	strb.w	r3, [r7, #992]	; 0x3e0
 800a264:	e7c1      	b.n	800a1ea <_fx_directory_search+0x516>
 800a266:	460b      	mov	r3, r1
 800a268:	e7c8      	b.n	800a1fc <_fx_directory_search+0x528>
 800a26a:	2201      	movs	r2, #1
 800a26c:	e652      	b.n	8009f14 <_fx_directory_search+0x240>
                j =  0;
 800a26e:	4621      	mov	r1, r4
 800a270:	e798      	b.n	800a1a4 <_fx_directory_search+0x4d0>
 800a272:	bf00      	nop

0800a274 <_fx_media_abort>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_media_abort(FX_MEDIA  *media_ptr)
{
 800a274:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    /* Increment the number of times this service has been called.  */
    media_ptr -> fx_media_aborts++;
#endif

    /* Check the media to make sure it is open.  */
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800a276:	4a29      	ldr	r2, [pc, #164]	; (800a31c <_fx_media_abort+0xa8>)
    media_ptr -> fx_media_aborts++;
 800a278:	f8d0 3158 	ldr.w	r3, [r0, #344]	; 0x158
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800a27c:	6801      	ldr	r1, [r0, #0]
    media_ptr -> fx_media_aborts++;
 800a27e:	3301      	adds	r3, #1
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800a280:	4291      	cmp	r1, r2
    media_ptr -> fx_media_aborts++;
 800a282:	f8c0 3158 	str.w	r3, [r0, #344]	; 0x158
    if (media_ptr -> fx_media_id != FX_MEDIA_ID)
 800a286:	d002      	beq.n	800a28e <_fx_media_abort+0x1a>
    {

        /* Return the media not opened error.  */
        return(FX_MEDIA_NOT_OPEN);
 800a288:	2511      	movs	r5, #17
    FX_UNPROTECT
#endif

    /* Return status to the caller.  */
    return(FX_SUCCESS);
}
 800a28a:	4628      	mov	r0, r5
 800a28c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    FX_PROTECT
 800a28e:	f500 76e4 	add.w	r6, r0, #456	; 0x1c8
 800a292:	4604      	mov	r4, r0
 800a294:	f04f 31ff 	mov.w	r1, #4294967295
 800a298:	4630      	mov	r0, r6
 800a29a:	f001 ffbd 	bl	800c218 <_tx_mutex_get>
 800a29e:	4605      	mov	r5, r0
 800a2a0:	2800      	cmp	r0, #0
 800a2a2:	d1f1      	bne.n	800a288 <_fx_media_abort+0x14>
    file_ptr =    media_ptr -> fx_media_opened_file_list;
 800a2a4:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	; 0xc8
    while (open_count)
 800a2a8:	b123      	cbz	r3, 800a2b4 <_fx_media_abort+0x40>
        file_ptr -> fx_file_id =  FX_FILE_ABORTED_ID;
 800a2aa:	491d      	ldr	r1, [pc, #116]	; (800a320 <_fx_media_abort+0xac>)
    while (open_count)
 800a2ac:	3b01      	subs	r3, #1
        file_ptr -> fx_file_id =  FX_FILE_ABORTED_ID;
 800a2ae:	6011      	str	r1, [r2, #0]
        file_ptr =  file_ptr -> fx_file_opened_next;
 800a2b0:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
    while (open_count)
 800a2b2:	d1fb      	bne.n	800a2ac <_fx_media_abort+0x38>
    media_ptr -> fx_media_driver_request =      FX_DRIVER_ABORT;
 800a2b4:	2103      	movs	r1, #3
    media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800a2b6:	2290      	movs	r2, #144	; 0x90
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800a2b8:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
 800a2bc:	4620      	mov	r0, r4
    media_ptr -> fx_media_driver_status =       FX_IO_ERROR;
 800a2be:	e9c4 1222 	strd	r1, r2, [r4, #136]	; 0x88
    (media_ptr -> fx_media_driver_entry) (media_ptr);
 800a2c2:	4798      	blx	r3
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800a2c4:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800a2c8:	b672      	cpsid	i
    if (_fx_system_media_opened_count == ((ULONG) 1))
 800a2ca:	4a16      	ldr	r2, [pc, #88]	; (800a324 <_fx_media_abort+0xb0>)
 800a2cc:	6813      	ldr	r3, [r2, #0]
 800a2ce:	2b01      	cmp	r3, #1
 800a2d0:	d01a      	beq.n	800a308 <_fx_media_abort+0x94>
        (media_ptr -> fx_media_opened_next) -> fx_media_opened_previous =
 800a2d2:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
 800a2d6:	f8d4 70d0 	ldr.w	r7, [r4, #208]	; 0xd0
        if (_fx_system_media_opened_ptr == media_ptr)
 800a2da:	f8df c050 	ldr.w	ip, [pc, #80]	; 800a32c <_fx_media_abort+0xb8>
        (media_ptr -> fx_media_opened_next) -> fx_media_opened_previous =
 800a2de:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4
        (media_ptr -> fx_media_opened_previous) -> fx_media_opened_next =
 800a2e2:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
 800a2e6:	f8c0 70d0 	str.w	r7, [r0, #208]	; 0xd0
        if (_fx_system_media_opened_ptr == media_ptr)
 800a2ea:	f8dc 0000 	ldr.w	r0, [ip]
 800a2ee:	42a0      	cmp	r0, r4
 800a2f0:	d00e      	beq.n	800a310 <_fx_media_abort+0x9c>
    _fx_system_media_opened_count--;
 800a2f2:	3b01      	subs	r3, #1
    media_ptr -> fx_media_id =  FX_MEDIA_ABORTED_ID;
 800a2f4:	480c      	ldr	r0, [pc, #48]	; (800a328 <_fx_media_abort+0xb4>)
    _fx_system_media_opened_count--;
 800a2f6:	6013      	str	r3, [r2, #0]
    media_ptr -> fx_media_id =  FX_MEDIA_ABORTED_ID;
 800a2f8:	6020      	str	r0, [r4, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800a2fa:	f381 8810 	msr	PRIMASK, r1
    tx_mutex_delete(& (media_ptr -> fx_media_protect));
 800a2fe:	4630      	mov	r0, r6
 800a300:	f001 ff30 	bl	800c164 <_tx_mutex_delete>
}
 800a304:	4628      	mov	r0, r5
 800a306:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        _fx_system_media_opened_ptr =  FX_NULL;
 800a308:	4808      	ldr	r0, [pc, #32]	; (800a32c <_fx_media_abort+0xb8>)
 800a30a:	2700      	movs	r7, #0
 800a30c:	6007      	str	r7, [r0, #0]
 800a30e:	e7f0      	b.n	800a2f2 <_fx_media_abort+0x7e>
            _fx_system_media_opened_ptr =  media_ptr -> fx_media_opened_next;
 800a310:	f8d4 70d0 	ldr.w	r7, [r4, #208]	; 0xd0
 800a314:	f8cc 7000 	str.w	r7, [ip]
 800a318:	e7eb      	b.n	800a2f2 <_fx_media_abort+0x7e>
 800a31a:	bf00      	nop
 800a31c:	4d454449 	.word	0x4d454449
 800a320:	46494c41 	.word	0x46494c41
 800a324:	20000e00 	.word	0x20000e00
 800a328:	4d454441 	.word	0x4d454441
 800a32c:	20000e08 	.word	0x20000e08

0800a330 <_fx_media_boot_info_extract>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _fx_media_boot_info_extract(FX_MEDIA *media_ptr)
{
 800a330:	b538      	push	{r3, r4, r5, lr}

UCHAR *boot_sector;


    /* Move the buffer pointer into a local copy.  */
    boot_sector =  media_ptr -> fx_media_driver_buffer;
 800a332:	f8d0 5090 	ldr.w	r5, [r0, #144]	; 0x90
{
 800a336:	4604      	mov	r4, r0

    /* Extract the number of bytes per sector.  */
    media_ptr -> fx_media_bytes_per_sector =    _fx_utility_16_unsigned_read(&boot_sector[FX_BYTES_SECTOR]);
 800a338:	f105 000b 	add.w	r0, r5, #11
 800a33c:	f7fd fa38 	bl	80077b0 <_fx_utility_16_unsigned_read>
 800a340:	62a0      	str	r0, [r4, #40]	; 0x28
    if (media_ptr -> fx_media_bytes_per_sector == 0)
 800a342:	b388      	cbz	r0, 800a3a8 <_fx_media_boot_info_extract+0x78>
#endif /* FX_ENABLE_EXFAT */


        /* FAT12/16/32 volume.  */
        /* Extract the number of sectors per track.  */
        media_ptr -> fx_media_sectors_per_track =   _fx_utility_16_unsigned_read(&boot_sector[FX_SECTORS_PER_TRK]);
 800a344:	f105 0018 	add.w	r0, r5, #24
 800a348:	f7fd fa32 	bl	80077b0 <_fx_utility_16_unsigned_read>
 800a34c:	62e0      	str	r0, [r4, #44]	; 0x2c

        /* Extract the number of heads.  */
        media_ptr -> fx_media_heads =               _fx_utility_16_unsigned_read(&boot_sector[FX_HEADS]);
 800a34e:	f105 001a 	add.w	r0, r5, #26
 800a352:	f7fd fa2d 	bl	80077b0 <_fx_utility_16_unsigned_read>
 800a356:	6320      	str	r0, [r4, #48]	; 0x30

        /* Extract the total number of sectors.  */
        media_ptr -> fx_media_total_sectors =       _fx_utility_16_unsigned_read(&boot_sector[FX_SECTORS]);
 800a358:	f105 0013 	add.w	r0, r5, #19
 800a35c:	f7fd fa28 	bl	80077b0 <_fx_utility_16_unsigned_read>
 800a360:	2100      	movs	r1, #0
        if (media_ptr -> fx_media_total_sectors == 0)
 800a362:	ea50 0301 	orrs.w	r3, r0, r1
        media_ptr -> fx_media_total_sectors =       _fx_utility_16_unsigned_read(&boot_sector[FX_SECTORS]);
 800a366:	e9c4 010e 	strd	r0, r1, [r4, #56]	; 0x38
        if (media_ptr -> fx_media_total_sectors == 0)
 800a36a:	d013      	beq.n	800a394 <_fx_media_boot_info_extract+0x64>
        {
            return(FX_MEDIA_INVALID);
        }

        /* Extract the number of reserved sectors before the first FAT.  */
        media_ptr -> fx_media_reserved_sectors =    _fx_utility_16_unsigned_read(&boot_sector[FX_RESERVED_SECTORS]);
 800a36c:	f105 000e 	add.w	r0, r5, #14
 800a370:	f7fd fa1e 	bl	80077b0 <_fx_utility_16_unsigned_read>
 800a374:	6460      	str	r0, [r4, #68]	; 0x44
        if (media_ptr -> fx_media_reserved_sectors == 0)
 800a376:	b1b8      	cbz	r0, 800a3a8 <_fx_media_boot_info_extract+0x78>
        {
            return(FX_MEDIA_INVALID);
        }

        /* Extract the number of sectors per cluster.  */
        media_ptr -> fx_media_sectors_per_cluster = ((UINT)boot_sector[FX_SECTORS_CLUSTER] & 0xFF);
 800a378:	7b6b      	ldrb	r3, [r5, #13]
 800a37a:	6563      	str	r3, [r4, #84]	; 0x54

        /* There should always be at least one reserved sector, representing the boot record itself.  */
        if (media_ptr -> fx_media_sectors_per_cluster == 0)
 800a37c:	b1a3      	cbz	r3, 800a3a8 <_fx_media_boot_info_extract+0x78>
        {
            return(FX_MEDIA_INVALID);
        }

        /* Extract the number of sectors per FAT.  */
        media_ptr -> fx_media_sectors_per_FAT =     _fx_utility_16_unsigned_read(&boot_sector[FX_SECTORS_PER_FAT]);
 800a37e:	f105 0016 	add.w	r0, r5, #22
 800a382:	f7fd fa15 	bl	80077b0 <_fx_utility_16_unsigned_read>
 800a386:	65a0      	str	r0, [r4, #88]	; 0x58
        if (media_ptr -> fx_media_sectors_per_FAT == 0)
 800a388:	b310      	cbz	r0, 800a3d0 <_fx_media_boot_info_extract+0xa0>
        {
            return(FX_MEDIA_INVALID);
        }

        /* Extract the number of FATs.  */
        media_ptr -> fx_media_number_of_FATs =      ((UINT)boot_sector[FX_NUMBER_OF_FATS] & 0xFF);
 800a38a:	7c2b      	ldrb	r3, [r5, #16]
 800a38c:	65e3      	str	r3, [r4, #92]	; 0x5c
        if (media_ptr -> fx_media_number_of_FATs == 0)
 800a38e:	b973      	cbnz	r3, 800a3ae <_fx_media_boot_info_extract+0x7e>
        {
            return(FX_BOOT_ERROR);
 800a390:	2301      	movs	r3, #1
 800a392:	e00a      	b.n	800a3aa <_fx_media_boot_info_extract+0x7a>
            media_ptr -> fx_media_total_sectors = _fx_utility_32_unsigned_read(&boot_sector[FX_HUGE_SECTORS]);
 800a394:	f105 0020 	add.w	r0, r5, #32
 800a398:	f7fd fa10 	bl	80077bc <_fx_utility_32_unsigned_read>
 800a39c:	2100      	movs	r1, #0
        if (media_ptr -> fx_media_total_sectors == 0)
 800a39e:	ea50 0301 	orrs.w	r3, r0, r1
            media_ptr -> fx_media_total_sectors = _fx_utility_32_unsigned_read(&boot_sector[FX_HUGE_SECTORS]);
 800a3a2:	e9c4 010e 	strd	r0, r1, [r4, #56]	; 0x38
        if (media_ptr -> fx_media_total_sectors == 0)
 800a3a6:	d1e1      	bne.n	800a36c <_fx_media_boot_info_extract+0x3c>
        return(FX_MEDIA_INVALID);
 800a3a8:	2302      	movs	r3, #2
    }
#endif /* FX_ENABLE_EXFAT */

    /* Return a successful status.  */
    return(FX_SUCCESS);
}
 800a3aa:	4618      	mov	r0, r3
 800a3ac:	bd38      	pop	{r3, r4, r5, pc}
        media_ptr -> fx_media_hidden_sectors =      _fx_utility_32_unsigned_read(&boot_sector[FX_HIDDEN_SECTORS]);
 800a3ae:	f105 001c 	add.w	r0, r5, #28
 800a3b2:	f7fd fa03 	bl	80077bc <_fx_utility_32_unsigned_read>
 800a3b6:	6720      	str	r0, [r4, #112]	; 0x70
        media_ptr -> fx_media_root_directory_entries =  _fx_utility_16_unsigned_read(&boot_sector[FX_ROOT_DIR_ENTRIES]);
 800a3b8:	f105 0011 	add.w	r0, r5, #17
 800a3bc:	f7fd f9f8 	bl	80077b0 <_fx_utility_16_unsigned_read>
 800a3c0:	67a0      	str	r0, [r4, #120]	; 0x78
        media_ptr -> fx_media_root_cluster_32 = _fx_utility_32_unsigned_read(&boot_sector[FX_ROOT_CLUSTER_32]);
 800a3c2:	f105 002c 	add.w	r0, r5, #44	; 0x2c
 800a3c6:	f7fd f9f9 	bl	80077bc <_fx_utility_32_unsigned_read>
    return(FX_SUCCESS);
 800a3ca:	2300      	movs	r3, #0
        media_ptr -> fx_media_root_cluster_32 = _fx_utility_32_unsigned_read(&boot_sector[FX_ROOT_CLUSTER_32]);
 800a3cc:	6760      	str	r0, [r4, #116]	; 0x74
    return(FX_SUCCESS);
 800a3ce:	e7ec      	b.n	800a3aa <_fx_media_boot_info_extract+0x7a>
            media_ptr -> fx_media_sectors_per_FAT = _fx_utility_32_unsigned_read(&boot_sector[FX_SECTORS_PER_FAT_32]);
 800a3d0:	f105 0024 	add.w	r0, r5, #36	; 0x24
 800a3d4:	f7fd f9f2 	bl	80077bc <_fx_utility_32_unsigned_read>
 800a3d8:	65a0      	str	r0, [r4, #88]	; 0x58
        if (media_ptr -> fx_media_sectors_per_FAT == 0)
 800a3da:	2800      	cmp	r0, #0
 800a3dc:	d0e4      	beq.n	800a3a8 <_fx_media_boot_info_extract+0x78>
 800a3de:	e7d4      	b.n	800a38a <_fx_media_boot_info_extract+0x5a>

0800a3e0 <_fx_utility_16_unsigned_write>:
VOID  _fx_utility_16_unsigned_write(UCHAR *dest_ptr, UINT value)
{

    /* Store the UINT into the destination with endian-awareness.  */
    *(dest_ptr) =       (UCHAR)(value & 0xFF);
    *(dest_ptr + 1) =   (UCHAR)((value >> 8) & 0xFF);
 800a3e0:	0a0b      	lsrs	r3, r1, #8
    *(dest_ptr) =       (UCHAR)(value & 0xFF);
 800a3e2:	7001      	strb	r1, [r0, #0]
    *(dest_ptr + 1) =   (UCHAR)((value >> 8) & 0xFF);
 800a3e4:	7043      	strb	r3, [r0, #1]
}
 800a3e6:	4770      	bx	lr

0800a3e8 <_fx_utility_logical_sector_cache_entry_read>:
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
FX_CACHED_SECTOR  *_fx_utility_logical_sector_cache_entry_read(FX_MEDIA *media_ptr, ULONG64 logical_sector,
                                                               FX_CACHED_SECTOR **previous_cache_entry)
{
 800a3e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
ULONG             cache_size;
ULONG             index;


    /* Determine if the logical sector cache access should use the hash function.  */
    if (media_ptr -> fx_media_sector_cache_hashed)
 800a3ec:	6904      	ldr	r4, [r0, #16]
{
 800a3ee:	4616      	mov	r6, r2
 800a3f0:	461f      	mov	r7, r3
 800a3f2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    if (media_ptr -> fx_media_sector_cache_hashed)
 800a3f4:	2c00      	cmp	r4, #0
 800a3f6:	f000 808d 	beq.w	800a514 <_fx_utility_logical_sector_cache_entry_read+0x12c>

        /* Calculate the area of the cache for this logical sector.  */

        /* First compute the hashed value of this index by simply using the lower bits of
           the sector number.  */
        index =  (ULONG)(logical_sector & media_ptr -> fx_media_sector_cache_hash_mask);
 800a3fa:	f242 43a0 	movw	r3, #9376	; 0x24a0

        /* Set the bit indicating there is one or more valid sectors at this cache index.  */
        media_ptr -> fx_media_sector_cache_hashed_sector_valid |=  ((ULONG)1) << (index % 32);
 800a3fe:	2501      	movs	r5, #1
 800a400:	6a04      	ldr	r4, [r0, #32]
        index =  (ULONG)(logical_sector & media_ptr -> fx_media_sector_cache_hash_mask);
 800a402:	58c3      	ldr	r3, [r0, r3]
 800a404:	4033      	ands	r3, r6

        /* Compute the actual array index by multiplying by the cache depth.  */
        index =  index * FX_SECTOR_CACHE_DEPTH;
 800a406:	0099      	lsls	r1, r3, #2
        media_ptr -> fx_media_sector_cache_hashed_sector_valid |=  ((ULONG)1) << (index % 32);
 800a408:	f003 0c1f 	and.w	ip, r3, #31

        /* Build a pointer to the cache entry.  */
        cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 800a40c:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
        media_ptr -> fx_media_sector_cache_hashed_sector_valid |=  ((ULONG)1) << (index % 32);
 800a410:	fa05 f50c 	lsl.w	r5, r5, ip
        cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 800a414:	00db      	lsls	r3, r3, #3
        media_ptr -> fx_media_sector_cache_hashed_sector_valid |=  ((ULONG)1) << (index % 32);
 800a416:	432c      	orrs	r4, r5

        /* Determine if the logical sector is in the cache - assuming the depth of the
           sector cache is 4 entries.  */
        if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800a418:	eb00 0e03 	add.w	lr, r0, r3
        cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 800a41c:	f503 634a 	add.w	r3, r3, #3232	; 0xca0
        media_ptr -> fx_media_sector_cache_hashed_sector_valid |=  ((ULONG)1) << (index % 32);
 800a420:	6204      	str	r4, [r0, #32]
        if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800a422:	f89e ccb1 	ldrb.w	ip, [lr, #3249]	; 0xcb1
        cache_entry =  &(media_ptr -> fx_media_sector_cache[index]);
 800a426:	4403      	add	r3, r0
        if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800a428:	f1bc 0f00 	cmp.w	ip, #0
 800a42c:	f040 8086 	bne.w	800a53c <_fx_utility_logical_sector_cache_entry_read+0x154>
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
#endif
            /* Success, return to caller immediately!  */
            return(FX_NULL);
        }
        else if (((cache_entry + 1) -> fx_cached_sector_valid) && ((cache_entry + 1) -> fx_cached_sector == logical_sector))
 800a430:	f893 e029 	ldrb.w	lr, [r3, #41]	; 0x29
 800a434:	f1be 0f00 	cmp.w	lr, #0
 800a438:	d006      	beq.n	800a448 <_fx_utility_logical_sector_cache_entry_read+0x60>
 800a43a:	e9d3 4508 	ldrd	r4, r5, [r3, #32]
 800a43e:	42bd      	cmp	r5, r7
 800a440:	bf08      	it	eq
 800a442:	42b4      	cmpeq	r4, r6
 800a444:	f000 80f5 	beq.w	800a632 <_fx_utility_logical_sector_cache_entry_read+0x24a>
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;

            /* Success, return to caller immediately!  */
            return(FX_NULL);
        }
        else if (((cache_entry + 2) -> fx_cached_sector_valid) && ((cache_entry + 2) -> fx_cached_sector == logical_sector))
 800a448:	f893 9041 	ldrb.w	r9, [r3, #65]	; 0x41
 800a44c:	f1b9 0f00 	cmp.w	r9, #0
 800a450:	d006      	beq.n	800a460 <_fx_utility_logical_sector_cache_entry_read+0x78>
 800a452:	e9d3 450e 	ldrd	r4, r5, [r3, #56]	; 0x38
 800a456:	42bd      	cmp	r5, r7
 800a458:	bf08      	it	eq
 800a45a:	42b4      	cmpeq	r4, r6
 800a45c:	f000 811c 	beq.w	800a698 <_fx_utility_logical_sector_cache_entry_read+0x2b0>
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;

            /* Success, return to caller immediately!  */
            return(FX_NULL);
        }
        else if (((cache_entry + 3) -> fx_cached_sector_valid) && ((cache_entry + 3) -> fx_cached_sector == logical_sector))
 800a460:	f893 a059 	ldrb.w	sl, [r3, #89]	; 0x59
 800a464:	f8d3 8048 	ldr.w	r8, [r3, #72]	; 0x48
 800a468:	e9d3 4514 	ldrd	r4, r5, [r3, #80]	; 0x50
 800a46c:	f1ba 0f00 	cmp.w	sl, #0
 800a470:	d004      	beq.n	800a47c <_fx_utility_logical_sector_cache_entry_read+0x94>
 800a472:	42af      	cmp	r7, r5
 800a474:	bf08      	it	eq
 800a476:	42a6      	cmpeq	r6, r4
 800a478:	f000 8085 	beq.w	800a586 <_fx_utility_logical_sector_cache_entry_read+0x19e>
        (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
        (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
        (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
        (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;

        (cache_entry + 1) -> fx_cached_sector_memory_buffer =   (cache_entry) -> fx_cached_sector_memory_buffer;
 800a47c:	eb01 0741 	add.w	r7, r1, r1, lsl #1
        (cache_entry + 3) -> fx_cached_sector_memory_buffer =   (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a480:	6b1e      	ldr	r6, [r3, #48]	; 0x30
        (cache_entry + 3) -> fx_cached_sector_valid =           (cache_entry + 2) -> fx_cached_sector_valid;
 800a482:	f883 9059 	strb.w	r9, [r3, #89]	; 0x59
        (cache_entry + 1) -> fx_cached_sector_memory_buffer =   (cache_entry) -> fx_cached_sector_memory_buffer;
 800a486:	eb00 00c7 	add.w	r0, r0, r7, lsl #3
        (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a48a:	699f      	ldr	r7, [r3, #24]
        (cache_entry + 3) -> fx_cached_sector_memory_buffer =   (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a48c:	649e      	str	r6, [r3, #72]	; 0x48
        (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a48e:	631f      	str	r7, [r3, #48]	; 0x30
        (cache_entry + 3) -> fx_cached_sector_buffer_dirty =    (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800a490:	f893 c040 	ldrb.w	ip, [r3, #64]	; 0x40
        (cache_entry + 3) -> fx_cached_sector_type =            (cache_entry + 2) -> fx_cached_sector_type;
 800a494:	f893 b042 	ldrb.w	fp, [r3, #66]	; 0x42
        (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a498:	f893 9028 	ldrb.w	r9, [r3, #40]	; 0x28
        (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800a49c:	f883 e041 	strb.w	lr, [r3, #65]	; 0x41
        (cache_entry + 1) -> fx_cached_sector =                 (cache_entry) -> fx_cached_sector;
 800a4a0:	f600 4ea8 	addw	lr, r0, #3240	; 0xca8
        (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a4a4:	f883 9040 	strb.w	r9, [r3, #64]	; 0x40
        (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800a4a8:	f893 902a 	ldrb.w	r9, [r3, #42]	; 0x2a
        (cache_entry + 3) -> fx_cached_sector =                 (cache_entry + 2) -> fx_cached_sector;
 800a4ac:	e9d3 670e 	ldrd	r6, r7, [r3, #56]	; 0x38
        (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800a4b0:	f883 9042 	strb.w	r9, [r3, #66]	; 0x42
        (cache_entry + 3) -> fx_cached_sector =                 (cache_entry + 2) -> fx_cached_sector;
 800a4b4:	e9c3 6714 	strd	r6, r7, [r3, #80]	; 0x50
        temp_storage.fx_cached_sector_type =                    (cache_entry + 3) -> fx_cached_sector_type;
 800a4b8:	f893 705a 	ldrb.w	r7, [r3, #90]	; 0x5a
        temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry + 3) -> fx_cached_sector_buffer_dirty;
 800a4bc:	f893 6058 	ldrb.w	r6, [r3, #88]	; 0x58
        (cache_entry + 3) -> fx_cached_sector_type =            (cache_entry + 2) -> fx_cached_sector_type;
 800a4c0:	f883 b05a 	strb.w	fp, [r3, #90]	; 0x5a
        (cache_entry + 3) -> fx_cached_sector_buffer_dirty =    (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800a4c4:	f883 c058 	strb.w	ip, [r3, #88]	; 0x58
        (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800a4c8:	e9d3 bc08 	ldrd	fp, ip, [r3, #32]
 800a4cc:	e9c3 bc0e 	strd	fp, ip, [r3, #56]	; 0x38
        (cache_entry + 1) -> fx_cached_sector_memory_buffer =   (cache_entry) -> fx_cached_sector_memory_buffer;
 800a4d0:	f8d0 1ca0 	ldr.w	r1, [r0, #3232]	; 0xca0
 800a4d4:	6199      	str	r1, [r3, #24]
        (cache_entry) -> fx_cached_sector_buffer_dirty =        temp_storage.fx_cached_sector_buffer_dirty;
        (cache_entry) -> fx_cached_sector_valid =               temp_storage.fx_cached_sector_valid;
        (cache_entry) -> fx_cached_sector_type =                temp_storage.fx_cached_sector_type;

        /* Set the previous pointer to NULL to avoid the linked list update below.  */
        *previous_cache_entry =  FX_NULL;
 800a4d6:	2100      	movs	r1, #0
        (cache_entry + 1) -> fx_cached_sector =                 (cache_entry) -> fx_cached_sector;
 800a4d8:	e9de bc00 	ldrd	fp, ip, [lr]
 800a4dc:	e9c3 bc08 	strd	fp, ip, [r3, #32]
        (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    (cache_entry) -> fx_cached_sector_buffer_dirty;
 800a4e0:	f890 ccb0 	ldrb.w	ip, [r0, #3248]	; 0xcb0
 800a4e4:	f883 c028 	strb.w	ip, [r3, #40]	; 0x28
        (cache_entry + 1) -> fx_cached_sector_valid =           (cache_entry) -> fx_cached_sector_valid;
 800a4e8:	f890 ccb1 	ldrb.w	ip, [r0, #3249]	; 0xcb1
 800a4ec:	f883 c029 	strb.w	ip, [r3, #41]	; 0x29
        (cache_entry + 1) -> fx_cached_sector_type =            (cache_entry) -> fx_cached_sector_type;
 800a4f0:	f890 ccb2 	ldrb.w	ip, [r0, #3250]	; 0xcb2
 800a4f4:	f883 c02a 	strb.w	ip, [r3, #42]	; 0x2a
        (cache_entry) -> fx_cached_sector_memory_buffer =       temp_storage.fx_cached_sector_memory_buffer;
 800a4f8:	f8c0 8ca0 	str.w	r8, [r0, #3232]	; 0xca0
        (cache_entry) -> fx_cached_sector =                     temp_storage.fx_cached_sector;
 800a4fc:	e9ce 4500 	strd	r4, r5, [lr]
        (cache_entry) -> fx_cached_sector_buffer_dirty =        temp_storage.fx_cached_sector_buffer_dirty;
 800a500:	f880 6cb0 	strb.w	r6, [r0, #3248]	; 0xcb0
        (cache_entry) -> fx_cached_sector_valid =               temp_storage.fx_cached_sector_valid;
 800a504:	f880 acb1 	strb.w	sl, [r0, #3249]	; 0xcb1
        (cache_entry) -> fx_cached_sector_type =                temp_storage.fx_cached_sector_type;
 800a508:	f880 7cb2 	strb.w	r7, [r0, #3250]	; 0xcb2
        *previous_cache_entry =  FX_NULL;
 800a50c:	6011      	str	r1, [r2, #0]
        }
    }

    /* The requested sector is not in cache, return the last cache entry.  */
    return(cache_entry);
}
 800a50e:	4618      	mov	r0, r3
 800a510:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        cache_size =            media_ptr -> fx_media_sector_cache_size;
 800a514:	6941      	ldr	r1, [r0, #20]
        cache_entry =           media_ptr -> fx_media_sector_cache_list_ptr;
 800a516:	69c3      	ldr	r3, [r0, #28]
        *previous_cache_entry =  FX_NULL;
 800a518:	6014      	str	r4, [r2, #0]
        while (cache_size--)
 800a51a:	2900      	cmp	r1, #0
 800a51c:	d0f7      	beq.n	800a50e <_fx_utility_logical_sector_cache_entry_read+0x126>
            if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800a51e:	7c5c      	ldrb	r4, [r3, #17]
 800a520:	3901      	subs	r1, #1
 800a522:	b12c      	cbz	r4, 800a530 <_fx_utility_logical_sector_cache_entry_read+0x148>
 800a524:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
 800a528:	42bd      	cmp	r5, r7
 800a52a:	bf08      	it	eq
 800a52c:	42b4      	cmpeq	r4, r6
 800a52e:	d018      	beq.n	800a562 <_fx_utility_logical_sector_cache_entry_read+0x17a>
            if (cache_entry -> fx_cached_sector_next_used)
 800a530:	695c      	ldr	r4, [r3, #20]
 800a532:	2c00      	cmp	r4, #0
 800a534:	d0f1      	beq.n	800a51a <_fx_utility_logical_sector_cache_entry_read+0x132>
                *previous_cache_entry =  cache_entry;
 800a536:	6013      	str	r3, [r2, #0]
                cache_entry =           cache_entry -> fx_cached_sector_next_used;
 800a538:	695b      	ldr	r3, [r3, #20]
 800a53a:	e7ee      	b.n	800a51a <_fx_utility_logical_sector_cache_entry_read+0x132>
        if ((cache_entry -> fx_cached_sector_valid) && (cache_entry -> fx_cached_sector == logical_sector))
 800a53c:	f60e 44a8 	addw	r4, lr, #3240	; 0xca8
 800a540:	e9d4 4500 	ldrd	r4, r5, [r4]
 800a544:	42bd      	cmp	r5, r7
 800a546:	bf08      	it	eq
 800a548:	42b4      	cmpeq	r4, r6
 800a54a:	f47f af71 	bne.w	800a430 <_fx_utility_logical_sector_cache_entry_read+0x48>
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a54e:	f8d0 21a4 	ldr.w	r2, [r0, #420]	; 0x1a4
            return(FX_NULL);
 800a552:	2300      	movs	r3, #0
            media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 800a554:	f8de 1ca0 	ldr.w	r1, [lr, #3232]	; 0xca0
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a558:	3201      	adds	r2, #1
            media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 800a55a:	6081      	str	r1, [r0, #8]
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a55c:	f8c0 21a4 	str.w	r2, [r0, #420]	; 0x1a4
            return(FX_NULL);
 800a560:	e7d5      	b.n	800a50e <_fx_utility_logical_sector_cache_entry_read+0x126>
                if (*previous_cache_entry)
 800a562:	6812      	ldr	r2, [r2, #0]
                media_ptr -> fx_media_memory_buffer =  cache_entry -> fx_cached_sector_memory_buffer;
 800a564:	6819      	ldr	r1, [r3, #0]
 800a566:	6081      	str	r1, [r0, #8]
                if (*previous_cache_entry)
 800a568:	b122      	cbz	r2, 800a574 <_fx_utility_logical_sector_cache_entry_read+0x18c>
                        cache_entry -> fx_cached_sector_next_used;
 800a56a:	695c      	ldr	r4, [r3, #20]
                    cache_entry -> fx_cached_sector_next_used =
 800a56c:	69c1      	ldr	r1, [r0, #28]
                    (*previous_cache_entry) -> fx_cached_sector_next_used =
 800a56e:	6154      	str	r4, [r2, #20]
                    cache_entry -> fx_cached_sector_next_used =
 800a570:	6159      	str	r1, [r3, #20]
                    media_ptr -> fx_media_sector_cache_list_ptr =  cache_entry;
 800a572:	61c3      	str	r3, [r0, #28]
                media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a574:	f8d0 21a4 	ldr.w	r2, [r0, #420]	; 0x1a4
                return(FX_NULL);
 800a578:	2300      	movs	r3, #0
                media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a57a:	3201      	adds	r2, #1
 800a57c:	f8c0 21a4 	str.w	r2, [r0, #420]	; 0x1a4
}
 800a580:	4618      	mov	r0, r3
 800a582:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a586:	eb01 0141 	add.w	r1, r1, r1, lsl #1
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a58a:	f8d0 21a4 	ldr.w	r2, [r0, #420]	; 0x1a4
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 3) -> fx_cached_sector_memory_buffer;
 800a58e:	f8c0 8008 	str.w	r8, [r0, #8]
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a592:	eb00 0ec1 	add.w	lr, r0, r1, lsl #3
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a596:	3201      	adds	r2, #1
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800a598:	f60e 49a8 	addw	r9, lr, #3240	; 0xca8
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a59c:	f8de 6ca0 	ldr.w	r6, [lr, #3232]	; 0xca0
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a5a0:	f8c0 21a4 	str.w	r2, [r0, #420]	; 0x1a4
            temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry) -> fx_cached_sector_buffer_dirty;
 800a5a4:	f89e 7cb0 	ldrb.w	r7, [lr, #3248]	; 0xcb0
            temp_storage.fx_cached_sector_type =                    (cache_entry) -> fx_cached_sector_type;
 800a5a8:	f89e 2cb2 	ldrb.w	r2, [lr, #3250]	; 0xcb2
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800a5ac:	e9d9 4500 	ldrd	r4, r5, [r9]
            (cache_entry) -> fx_cached_sector_memory_buffer =       (cache_entry + 3) -> fx_cached_sector_memory_buffer;
 800a5b0:	f8ce 8ca0 	str.w	r8, [lr, #3232]	; 0xca0
            (cache_entry) -> fx_cached_sector =                     (cache_entry + 3) -> fx_cached_sector;
 800a5b4:	e9d3 0114 	ldrd	r0, r1, [r3, #80]	; 0x50
 800a5b8:	e9c9 0100 	strd	r0, r1, [r9]
            (cache_entry) -> fx_cached_sector_buffer_dirty =        (cache_entry + 3) -> fx_cached_sector_buffer_dirty;
 800a5bc:	f893 1058 	ldrb.w	r1, [r3, #88]	; 0x58
 800a5c0:	f88e 1cb0 	strb.w	r1, [lr, #3248]	; 0xcb0
            (cache_entry) -> fx_cached_sector_valid =               (cache_entry + 3) -> fx_cached_sector_valid;
 800a5c4:	f893 1059 	ldrb.w	r1, [r3, #89]	; 0x59
 800a5c8:	f88e 1cb1 	strb.w	r1, [lr, #3249]	; 0xcb1
            (cache_entry) -> fx_cached_sector_type =                (cache_entry + 3) -> fx_cached_sector_type;
 800a5cc:	f893 105a 	ldrb.w	r1, [r3, #90]	; 0x5a
 800a5d0:	f88e 1cb2 	strb.w	r1, [lr, #3250]	; 0xcb2
            (cache_entry + 3) -> fx_cached_sector_memory_buffer =   (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a5d4:	6b18      	ldr	r0, [r3, #48]	; 0x30
            (cache_entry + 3) -> fx_cached_sector_buffer_dirty =    (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800a5d6:	f893 9040 	ldrb.w	r9, [r3, #64]	; 0x40
            (cache_entry + 3) -> fx_cached_sector_valid =           (cache_entry + 2) -> fx_cached_sector_valid;
 800a5da:	f893 8041 	ldrb.w	r8, [r3, #65]	; 0x41
            (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a5de:	6999      	ldr	r1, [r3, #24]
            (cache_entry + 3) -> fx_cached_sector_memory_buffer =   (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a5e0:	6498      	str	r0, [r3, #72]	; 0x48
            (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a5e2:	f893 0028 	ldrb.w	r0, [r3, #40]	; 0x28
            (cache_entry + 3) -> fx_cached_sector_type =            (cache_entry + 2) -> fx_cached_sector_type;
 800a5e6:	f893 e042 	ldrb.w	lr, [r3, #66]	; 0x42
            (cache_entry + 3) -> fx_cached_sector_buffer_dirty =    (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800a5ea:	f883 9058 	strb.w	r9, [r3, #88]	; 0x58
            (cache_entry + 3) -> fx_cached_sector_valid =           (cache_entry + 2) -> fx_cached_sector_valid;
 800a5ee:	f883 8059 	strb.w	r8, [r3, #89]	; 0x59
            (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a5f2:	6319      	str	r1, [r3, #48]	; 0x30
            (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a5f4:	f883 0040 	strb.w	r0, [r3, #64]	; 0x40
            (cache_entry + 3) -> fx_cached_sector_type =            (cache_entry + 2) -> fx_cached_sector_type;
 800a5f8:	f883 e05a 	strb.w	lr, [r3, #90]	; 0x5a
            (cache_entry + 3) -> fx_cached_sector =                 (cache_entry + 2) -> fx_cached_sector;
 800a5fc:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	; 0x38
            (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800a600:	e9d3 8908 	ldrd	r8, r9, [r3, #32]
            (cache_entry + 3) -> fx_cached_sector =                 (cache_entry + 2) -> fx_cached_sector;
 800a604:	e9c3 0114 	strd	r0, r1, [r3, #80]	; 0x50
            (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800a608:	e9c3 890e 	strd	r8, r9, [r3, #56]	; 0x38
            (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800a60c:	f893 0029 	ldrb.w	r0, [r3, #41]	; 0x29
            (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800a610:	f893 102a 	ldrb.w	r1, [r3, #42]	; 0x2a
            (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800a614:	f883 0041 	strb.w	r0, [r3, #65]	; 0x41
            (cache_entry + 1) -> fx_cached_sector_memory_buffer =   temp_storage.fx_cached_sector_memory_buffer;
 800a618:	619e      	str	r6, [r3, #24]
            (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    temp_storage.fx_cached_sector_buffer_dirty;
 800a61a:	f883 7028 	strb.w	r7, [r3, #40]	; 0x28
            (cache_entry + 1) -> fx_cached_sector_valid =           temp_storage.fx_cached_sector_valid;
 800a61e:	f883 c029 	strb.w	ip, [r3, #41]	; 0x29
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;
 800a622:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
            (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800a626:	f883 1042 	strb.w	r1, [r3, #66]	; 0x42
            (cache_entry + 1) -> fx_cached_sector =                 temp_storage.fx_cached_sector;
 800a62a:	e9c3 4508 	strd	r4, r5, [r3, #32]
            return(FX_NULL);
 800a62e:	2300      	movs	r3, #0
 800a630:	e76d      	b.n	800a50e <_fx_utility_logical_sector_cache_entry_read+0x126>
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a632:	eb01 0241 	add.w	r2, r1, r1, lsl #1
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a636:	f8d0 41a4 	ldr.w	r4, [r0, #420]	; 0x1a4
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a63a:	6999      	ldr	r1, [r3, #24]
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a63c:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a640:	3401      	adds	r4, #1
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a642:	6081      	str	r1, [r0, #8]
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800a644:	f602 45a8 	addw	r5, r2, #3240	; 0xca8
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a648:	f8d2 8ca0 	ldr.w	r8, [r2, #3232]	; 0xca0
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a64c:	f8c0 41a4 	str.w	r4, [r0, #420]	; 0x1a4
            temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry) -> fx_cached_sector_buffer_dirty;
 800a650:	f892 ecb0 	ldrb.w	lr, [r2, #3248]	; 0xcb0
            temp_storage.fx_cached_sector_type =                    (cache_entry) -> fx_cached_sector_type;
 800a654:	f892 4cb2 	ldrb.w	r4, [r2, #3250]	; 0xcb2
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800a658:	e9d5 6700 	ldrd	r6, r7, [r5]
            (cache_entry) -> fx_cached_sector_memory_buffer =       (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a65c:	f8c2 1ca0 	str.w	r1, [r2, #3232]	; 0xca0
            (cache_entry) -> fx_cached_sector =                     (cache_entry + 1) -> fx_cached_sector;
 800a660:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
 800a664:	e9c5 0100 	strd	r0, r1, [r5]
            (cache_entry) -> fx_cached_sector_buffer_dirty =        (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a668:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 800a66c:	f882 1cb0 	strb.w	r1, [r2, #3248]	; 0xcb0
            (cache_entry) -> fx_cached_sector_valid =               (cache_entry + 1) -> fx_cached_sector_valid;
 800a670:	f893 1029 	ldrb.w	r1, [r3, #41]	; 0x29
 800a674:	f882 1cb1 	strb.w	r1, [r2, #3249]	; 0xcb1
            (cache_entry) -> fx_cached_sector_type =                (cache_entry + 1) -> fx_cached_sector_type;
 800a678:	f893 102a 	ldrb.w	r1, [r3, #42]	; 0x2a
 800a67c:	f882 1cb2 	strb.w	r1, [r2, #3250]	; 0xcb2
            (cache_entry + 1) -> fx_cached_sector_memory_buffer =   temp_storage.fx_cached_sector_memory_buffer;
 800a680:	f8c3 8018 	str.w	r8, [r3, #24]
            (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    temp_storage.fx_cached_sector_buffer_dirty;
 800a684:	f883 e028 	strb.w	lr, [r3, #40]	; 0x28
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;
 800a688:	f883 402a 	strb.w	r4, [r3, #42]	; 0x2a
            (cache_entry + 1) -> fx_cached_sector_valid =           temp_storage.fx_cached_sector_valid;
 800a68c:	f883 c029 	strb.w	ip, [r3, #41]	; 0x29
            (cache_entry + 1) -> fx_cached_sector =                 temp_storage.fx_cached_sector;
 800a690:	e9c3 6708 	strd	r6, r7, [r3, #32]
            return(FX_NULL);
 800a694:	2300      	movs	r3, #0
 800a696:	e73a      	b.n	800a50e <_fx_utility_logical_sector_cache_entry_read+0x126>
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a698:	eb01 0241 	add.w	r2, r1, r1, lsl #1
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a69c:	f8d0 41a4 	ldr.w	r4, [r0, #420]	; 0x1a4
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a6a0:	6b19      	ldr	r1, [r3, #48]	; 0x30
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a6a2:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a6a6:	3401      	adds	r4, #1
            media_ptr -> fx_media_memory_buffer =  (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a6a8:	6081      	str	r1, [r0, #8]
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800a6aa:	f602 45a8 	addw	r5, r2, #3240	; 0xca8
            temp_storage.fx_cached_sector_memory_buffer =           (cache_entry) -> fx_cached_sector_memory_buffer;
 800a6ae:	f8d2 eca0 	ldr.w	lr, [r2, #3232]	; 0xca0
            media_ptr -> fx_media_logical_sector_cache_read_hits++;
 800a6b2:	f8c0 41a4 	str.w	r4, [r0, #420]	; 0x1a4
            temp_storage.fx_cached_sector_buffer_dirty =            (cache_entry) -> fx_cached_sector_buffer_dirty;
 800a6b6:	f892 8cb0 	ldrb.w	r8, [r2, #3248]	; 0xcb0
            temp_storage.fx_cached_sector_type =                    (cache_entry) -> fx_cached_sector_type;
 800a6ba:	f892 4cb2 	ldrb.w	r4, [r2, #3250]	; 0xcb2
            temp_storage.fx_cached_sector =                         (cache_entry) -> fx_cached_sector;
 800a6be:	e9d5 6700 	ldrd	r6, r7, [r5]
            (cache_entry) -> fx_cached_sector_memory_buffer =       (cache_entry + 2) -> fx_cached_sector_memory_buffer;
 800a6c2:	f8c2 1ca0 	str.w	r1, [r2, #3232]	; 0xca0
            (cache_entry) -> fx_cached_sector =                     (cache_entry + 2) -> fx_cached_sector;
 800a6c6:	e9d3 010e 	ldrd	r0, r1, [r3, #56]	; 0x38
 800a6ca:	e9c5 0100 	strd	r0, r1, [r5]
            (cache_entry) -> fx_cached_sector_buffer_dirty =        (cache_entry + 2) -> fx_cached_sector_buffer_dirty;
 800a6ce:	f893 1040 	ldrb.w	r1, [r3, #64]	; 0x40
 800a6d2:	f882 1cb0 	strb.w	r1, [r2, #3248]	; 0xcb0
            (cache_entry) -> fx_cached_sector_valid =               (cache_entry + 2) -> fx_cached_sector_valid;
 800a6d6:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
 800a6da:	f882 1cb1 	strb.w	r1, [r2, #3249]	; 0xcb1
            (cache_entry) -> fx_cached_sector_type =                (cache_entry + 2) -> fx_cached_sector_type;
 800a6de:	f893 1042 	ldrb.w	r1, [r3, #66]	; 0x42
 800a6e2:	f882 1cb2 	strb.w	r1, [r2, #3250]	; 0xcb2
            (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a6e6:	6999      	ldr	r1, [r3, #24]
            (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800a6e8:	f893 002a 	ldrb.w	r0, [r3, #42]	; 0x2a
            (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a6ec:	f893 5028 	ldrb.w	r5, [r3, #40]	; 0x28
            (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800a6f0:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
            (cache_entry + 2) -> fx_cached_sector_memory_buffer =   (cache_entry + 1) -> fx_cached_sector_memory_buffer;
 800a6f4:	6319      	str	r1, [r3, #48]	; 0x30
            (cache_entry + 2) -> fx_cached_sector_type =            (cache_entry + 1) -> fx_cached_sector_type;
 800a6f6:	f883 0042 	strb.w	r0, [r3, #66]	; 0x42
            (cache_entry + 1) -> fx_cached_sector_memory_buffer =   temp_storage.fx_cached_sector_memory_buffer;
 800a6fa:	f8c3 e018 	str.w	lr, [r3, #24]
            (cache_entry + 1) -> fx_cached_sector_buffer_dirty =    temp_storage.fx_cached_sector_buffer_dirty;
 800a6fe:	f883 8028 	strb.w	r8, [r3, #40]	; 0x28
            (cache_entry + 2) -> fx_cached_sector_buffer_dirty =    (cache_entry + 1) -> fx_cached_sector_buffer_dirty;
 800a702:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
            (cache_entry + 1) -> fx_cached_sector_type =            temp_storage.fx_cached_sector_type;
 800a706:	f883 402a 	strb.w	r4, [r3, #42]	; 0x2a
            (cache_entry + 2) -> fx_cached_sector_valid =           (cache_entry + 1) -> fx_cached_sector_valid;
 800a70a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
            (cache_entry + 1) -> fx_cached_sector_valid =           temp_storage.fx_cached_sector_valid;
 800a70e:	f883 c029 	strb.w	ip, [r3, #41]	; 0x29
            (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800a712:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
            (cache_entry + 1) -> fx_cached_sector =                 temp_storage.fx_cached_sector;
 800a716:	e9c3 6708 	strd	r6, r7, [r3, #32]
            (cache_entry + 2) -> fx_cached_sector =                 (cache_entry + 1) -> fx_cached_sector;
 800a71a:	e9c3 010e 	strd	r0, r1, [r3, #56]	; 0x38
            return(FX_NULL);
 800a71e:	2300      	movs	r3, #0
 800a720:	e6f5      	b.n	800a50e <_fx_utility_logical_sector_cache_entry_read+0x126>
 800a722:	bf00      	nop

0800a724 <_fx_directory_name_extract>:

UINT i;


    /* Set the destination string to NULL.  */
    dest_ptr[0] = 0;
 800a724:	2300      	movs	r3, #0
{
 800a726:	b4f0      	push	{r4, r5, r6, r7}
    dest_ptr[0] = 0;
 800a728:	700b      	strb	r3, [r1, #0]

    /* Is a backslash present?  */
    if ((*source_ptr == '\\') || (*source_ptr == '/'))
 800a72a:	7803      	ldrb	r3, [r0, #0]
 800a72c:	2b5c      	cmp	r3, #92	; 0x5c
 800a72e:	d03b      	beq.n	800a7a8 <_fx_directory_name_extract+0x84>
 800a730:	2b2f      	cmp	r3, #47	; 0x2f
 800a732:	d102      	bne.n	800a73a <_fx_directory_name_extract+0x16>
 800a734:	e038      	b.n	800a7a8 <_fx_directory_name_extract+0x84>
        /* Advance the string pointer.  */
        source_ptr++;
    }

    /* Loop to remove any leading spaces.  */
    while (*source_ptr == ' ')
 800a736:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800a73a:	2b20      	cmp	r3, #32
 800a73c:	d0fb      	beq.n	800a736 <_fx_directory_name_extract+0x12>
        source_ptr++;
    }

    /* Loop to extract the name.  */
    i = 0;
    while (*source_ptr)
 800a73e:	2b00      	cmp	r3, #0
 800a740:	d039      	beq.n	800a7b6 <_fx_directory_name_extract+0x92>
    {

        /* If another backslash is present, break the loop.  */
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
 800a742:	2b5c      	cmp	r3, #92	; 0x5c
 800a744:	d039      	beq.n	800a7ba <_fx_directory_name_extract+0x96>
 800a746:	f1a3 022f 	sub.w	r2, r3, #47	; 0x2f
 800a74a:	fab2 f282 	clz	r2, r2
 800a74e:	0952      	lsrs	r2, r2, #5
 800a750:	bb9a      	cbnz	r2, 800a7ba <_fx_directory_name_extract+0x96>
 800a752:	1e4d      	subs	r5, r1, #1
 800a754:	e00b      	b.n	800a76e <_fx_directory_name_extract+0x4a>
 800a756:	2b5c      	cmp	r3, #92	; 0x5c
 800a758:	d010      	beq.n	800a77c <_fx_directory_name_extract+0x58>
 800a75a:	f1a3 072f 	sub.w	r7, r3, #47	; 0x2f
 800a75e:	fab7 f787 	clz	r7, r7
 800a762:	097f      	lsrs	r7, r7, #5
 800a764:	b957      	cbnz	r7, 800a77c <_fx_directory_name_extract+0x58>
            break;
        }

        /* Long name can be at most 255 characters, but are further limited by the
           FX_MAX_LONG_NAME_LEN define.  */
        if (i == FX_MAX_LONG_NAME_LEN - 1)
 800a766:	2eff      	cmp	r6, #255	; 0xff
 800a768:	4632      	mov	r2, r6
 800a76a:	d020      	beq.n	800a7ae <_fx_directory_name_extract+0x8a>
 800a76c:	4620      	mov	r0, r4
        {
            break;
        }

        /* Store the character.  */
        dest_ptr[i] =  *source_ptr++;
 800a76e:	f805 3f01 	strb.w	r3, [r5, #1]!
 800a772:	1c44      	adds	r4, r0, #1
    while (*source_ptr)
 800a774:	7843      	ldrb	r3, [r0, #1]

        /* Increment the character counter.  */
        i++;
 800a776:	1c56      	adds	r6, r2, #1
    while (*source_ptr)
 800a778:	2b00      	cmp	r3, #0
 800a77a:	d1ec      	bne.n	800a756 <_fx_directory_name_extract+0x32>
    }

    /* NULL-terminate the string.  */
    dest_ptr[i] =  0;
 800a77c:	2300      	movs	r3, #0
 800a77e:	558b      	strb	r3, [r1, r6]
        /* Yes, we can move backwards.  */
        i--;
    }

    /* Get rid of trailing blanks in the destination string.  */
    while (dest_ptr[i] == ' ')
 800a780:	5c8d      	ldrb	r5, [r1, r2]
 800a782:	188b      	adds	r3, r1, r2
 800a784:	2d20      	cmp	r5, #32
 800a786:	d108      	bne.n	800a79a <_fx_directory_name_extract+0x76>
 800a788:	3a01      	subs	r2, #1
    {

        /* Set this entry to NULL.  */
        dest_ptr[i] =  0;
 800a78a:	2500      	movs	r5, #0
 800a78c:	4411      	add	r1, r2
 800a78e:	701d      	strb	r5, [r3, #0]
    while (dest_ptr[i] == ' ')
 800a790:	460b      	mov	r3, r1
 800a792:	3901      	subs	r1, #1
 800a794:	781a      	ldrb	r2, [r3, #0]
 800a796:	2a20      	cmp	r2, #32
 800a798:	d0f9      	beq.n	800a78e <_fx_directory_name_extract+0x6a>
 800a79a:	7843      	ldrb	r3, [r0, #1]
    /* Determine if the source string is now at the end.  */
    if (*source_ptr == 0)
    {

        /* Yes, return a NULL pointer.  */
        source_ptr = FX_NULL;
 800a79c:	2b00      	cmp	r3, #0
 800a79e:	bf08      	it	eq
 800a7a0:	2400      	moveq	r4, #0
    }

    /* Return the last pointer position in the source.  */
    return(source_ptr);
}
 800a7a2:	4620      	mov	r0, r4
 800a7a4:	bcf0      	pop	{r4, r5, r6, r7}
 800a7a6:	4770      	bx	lr
 800a7a8:	7843      	ldrb	r3, [r0, #1]
        source_ptr++;
 800a7aa:	3001      	adds	r0, #1
 800a7ac:	e7c5      	b.n	800a73a <_fx_directory_name_extract+0x16>
    dest_ptr[i] =  0;
 800a7ae:	f881 70ff 	strb.w	r7, [r1, #255]	; 0xff
 800a7b2:	22fe      	movs	r2, #254	; 0xfe
 800a7b4:	e7e4      	b.n	800a780 <_fx_directory_name_extract+0x5c>
        source_ptr = FX_NULL;
 800a7b6:	461c      	mov	r4, r3
 800a7b8:	e7f3      	b.n	800a7a2 <_fx_directory_name_extract+0x7e>
        if ((*source_ptr == '\\') || (*source_ptr == '/'))
 800a7ba:	4604      	mov	r4, r0
 800a7bc:	e7f1      	b.n	800a7a2 <_fx_directory_name_extract+0x7e>
 800a7be:	bf00      	nop

0800a7c0 <BSP_SDRAM_MspInit>:
{
	static DMA_HandleTypeDef dma_handle;
	GPIO_InitTypeDef gpio_init_structure;

	/* Enable FMC clock */
	__HAL_RCC_FMC_CLK_ENABLE();
 800a7c0:	4b53      	ldr	r3, [pc, #332]	; (800a910 <BSP_SDRAM_MspInit+0x150>)
	__HAL_RCC_GPIOF_CLK_ENABLE();
	__HAL_RCC_GPIOG_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();

	/* Common GPIO configuration */
	gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 800a7c2:	2102      	movs	r1, #2
	__HAL_RCC_FMC_CLK_ENABLE();
 800a7c4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800a7c6:	f042 0201 	orr.w	r2, r2, #1
{
 800a7ca:	b570      	push	{r4, r5, r6, lr}
	__HAL_RCC_FMC_CLK_ENABLE();
 800a7cc:	639a      	str	r2, [r3, #56]	; 0x38
{
 800a7ce:	4606      	mov	r6, r0
	__HAL_RCC_FMC_CLK_ENABLE();
 800a7d0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
	gpio_init_structure.Pull = GPIO_PULLUP;
 800a7d2:	2001      	movs	r0, #1
{
 800a7d4:	b08e      	sub	sp, #56	; 0x38
	gpio_init_structure.Speed = GPIO_SPEED_FAST;
	gpio_init_structure.Alternate = GPIO_AF12_FMC;

	/* GPIOC configuration */
	gpio_init_structure.Pin = GPIO_PIN_3;
 800a7d6:	2508      	movs	r5, #8
	__HAL_RCC_FMC_CLK_ENABLE();
 800a7d8:	4002      	ands	r2, r0
	gpio_init_structure.Pin = GPIO_PIN_3;
 800a7da:	ac0e      	add	r4, sp, #56	; 0x38
	__HAL_RCC_FMC_CLK_ENABLE();
 800a7dc:	9201      	str	r2, [sp, #4]
 800a7de:	9a01      	ldr	r2, [sp, #4]
	__DMAx_CLK_ENABLE()
 800a7e0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a7e2:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 800a7e6:	631a      	str	r2, [r3, #48]	; 0x30
 800a7e8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a7ea:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
 800a7ee:	9202      	str	r2, [sp, #8]
 800a7f0:	9a02      	ldr	r2, [sp, #8]
	__HAL_RCC_GPIOC_CLK_ENABLE();
 800a7f2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a7f4:	f042 0204 	orr.w	r2, r2, #4
 800a7f8:	631a      	str	r2, [r3, #48]	; 0x30
 800a7fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a7fc:	f002 0204 	and.w	r2, r2, #4
 800a800:	9203      	str	r2, [sp, #12]
 800a802:	9a03      	ldr	r2, [sp, #12]
	__HAL_RCC_GPIOD_CLK_ENABLE();
 800a804:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a806:	432a      	orrs	r2, r5
 800a808:	631a      	str	r2, [r3, #48]	; 0x30
 800a80a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a80c:	402a      	ands	r2, r5
 800a80e:	9204      	str	r2, [sp, #16]
 800a810:	9a04      	ldr	r2, [sp, #16]
	__HAL_RCC_GPIOE_CLK_ENABLE();
 800a812:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a814:	f042 0210 	orr.w	r2, r2, #16
 800a818:	631a      	str	r2, [r3, #48]	; 0x30
 800a81a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a81c:	f002 0210 	and.w	r2, r2, #16
 800a820:	9205      	str	r2, [sp, #20]
 800a822:	9a05      	ldr	r2, [sp, #20]
	__HAL_RCC_GPIOF_CLK_ENABLE();
 800a824:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a826:	f042 0220 	orr.w	r2, r2, #32
 800a82a:	631a      	str	r2, [r3, #48]	; 0x30
 800a82c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a82e:	f002 0220 	and.w	r2, r2, #32
 800a832:	9206      	str	r2, [sp, #24]
 800a834:	9a06      	ldr	r2, [sp, #24]
	__HAL_RCC_GPIOG_CLK_ENABLE();
 800a836:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a838:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a83c:	631a      	str	r2, [r3, #48]	; 0x30
 800a83e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a840:	f002 0240 	and.w	r2, r2, #64	; 0x40
 800a844:	9207      	str	r2, [sp, #28]
 800a846:	9a07      	ldr	r2, [sp, #28]
	__HAL_RCC_GPIOH_CLK_ENABLE();
 800a848:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a84a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a84e:	631a      	str	r2, [r3, #48]	; 0x30
	gpio_init_structure.Alternate = GPIO_AF12_FMC;
 800a850:	220c      	movs	r2, #12
	__HAL_RCC_GPIOH_CLK_ENABLE();
 800a852:	6b1b      	ldr	r3, [r3, #48]	; 0x30
	gpio_init_structure.Pin = GPIO_PIN_3;
 800a854:	f844 5d14 	str.w	r5, [r4, #-20]!
	/* GPIOH configuration */
	gpio_init_structure.Pin = GPIO_PIN_3 | GPIO_PIN_5;
	HAL_GPIO_Init(GPIOH, &gpio_init_structure);

	/* Configure common DMA parameters */
	dma_handle.Init.Channel = SDRAM_DMAx_CHANNEL;
 800a858:	2500      	movs	r5, #0
	__HAL_RCC_GPIOH_CLK_ENABLE();
 800a85a:	f003 0380 	and.w	r3, r3, #128	; 0x80
	gpio_init_structure.Mode = GPIO_MODE_AF_PP;
 800a85e:	910a      	str	r1, [sp, #40]	; 0x28
	gpio_init_structure.Speed = GPIO_SPEED_FAST;
 800a860:	910c      	str	r1, [sp, #48]	; 0x30
	HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 800a862:	4621      	mov	r1, r4
	__HAL_RCC_GPIOH_CLK_ENABLE();
 800a864:	9308      	str	r3, [sp, #32]
	gpio_init_structure.Pull = GPIO_PULLUP;
 800a866:	900b      	str	r0, [sp, #44]	; 0x2c
	HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 800a868:	482a      	ldr	r0, [pc, #168]	; (800a914 <BSP_SDRAM_MspInit+0x154>)
	gpio_init_structure.Alternate = GPIO_AF12_FMC;
 800a86a:	920d      	str	r2, [sp, #52]	; 0x34
	__HAL_RCC_GPIOH_CLK_ENABLE();
 800a86c:	9b08      	ldr	r3, [sp, #32]
	HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 800a86e:	f000 faa1 	bl	800adb4 <HAL_GPIO_Init>
	gpio_init_structure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8 | GPIO_PIN_9 |
 800a872:	f24c 7303 	movw	r3, #50947	; 0xc703
	HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 800a876:	4621      	mov	r1, r4
 800a878:	4827      	ldr	r0, [pc, #156]	; (800a918 <BSP_SDRAM_MspInit+0x158>)
	gpio_init_structure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8 | GPIO_PIN_9 |
 800a87a:	9309      	str	r3, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 800a87c:	f000 fa9a 	bl	800adb4 <HAL_GPIO_Init>
	gpio_init_structure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9
 800a880:	f64f 7383 	movw	r3, #65411	; 0xff83
	HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 800a884:	4621      	mov	r1, r4
 800a886:	4825      	ldr	r0, [pc, #148]	; (800a91c <BSP_SDRAM_MspInit+0x15c>)
	gpio_init_structure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9
 800a888:	9309      	str	r3, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 800a88a:	f000 fa93 	bl	800adb4 <HAL_GPIO_Init>
	gpio_init_structure.Pin =
 800a88e:	f64f 033f 	movw	r3, #63551	; 0xf83f
	HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 800a892:	4621      	mov	r1, r4
 800a894:	4822      	ldr	r0, [pc, #136]	; (800a920 <BSP_SDRAM_MspInit+0x160>)
	gpio_init_structure.Pin =
 800a896:	9309      	str	r3, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 800a898:	f000 fa8c 	bl	800adb4 <HAL_GPIO_Init>
	gpio_init_structure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_8
 800a89c:	f248 1333 	movw	r3, #33075	; 0x8133
	HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 800a8a0:	4621      	mov	r1, r4
 800a8a2:	4820      	ldr	r0, [pc, #128]	; (800a924 <BSP_SDRAM_MspInit+0x164>)
	gpio_init_structure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_8
 800a8a4:	9309      	str	r3, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 800a8a6:	f000 fa85 	bl	800adb4 <HAL_GPIO_Init>
	gpio_init_structure.Pin = GPIO_PIN_3 | GPIO_PIN_5;
 800a8aa:	2328      	movs	r3, #40	; 0x28
	HAL_GPIO_Init(GPIOH, &gpio_init_structure);
 800a8ac:	4621      	mov	r1, r4
 800a8ae:	481e      	ldr	r0, [pc, #120]	; (800a928 <BSP_SDRAM_MspInit+0x168>)
	dma_handle.Init.Channel = SDRAM_DMAx_CHANNEL;
 800a8b0:	4c1e      	ldr	r4, [pc, #120]	; (800a92c <BSP_SDRAM_MspInit+0x16c>)
	gpio_init_structure.Pin = GPIO_PIN_3 | GPIO_PIN_5;
 800a8b2:	9309      	str	r3, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOH, &gpio_init_structure);
 800a8b4:	f000 fa7e 	bl	800adb4 <HAL_GPIO_Init>
	dma_handle.Init.Direction = DMA_MEMORY_TO_MEMORY;
	dma_handle.Init.PeriphInc = DMA_PINC_ENABLE;
 800a8b8:	f44f 7300 	mov.w	r3, #512	; 0x200
	dma_handle.Init.Direction = DMA_MEMORY_TO_MEMORY;
 800a8bc:	2180      	movs	r1, #128	; 0x80
	dma_handle.Init.MemInc = DMA_MINC_ENABLE;
 800a8be:	f44f 6280 	mov.w	r2, #1024	; 0x400
	dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800a8c2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
	dma_handle.Init.PeriphInc = DMA_PINC_ENABLE;
 800a8c6:	60e3      	str	r3, [r4, #12]
	dma_handle.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
	dma_handle.Init.Mode = DMA_NORMAL;
	dma_handle.Init.Priority = DMA_PRIORITY_HIGH;
 800a8c8:	f44f 3300 	mov.w	r3, #131072	; 0x20000
	dma_handle.Init.Direction = DMA_MEMORY_TO_MEMORY;
 800a8cc:	60a1      	str	r1, [r4, #8]
	dma_handle.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 800a8ce:	f44f 4180 	mov.w	r1, #16384	; 0x4000
	dma_handle.Init.MemInc = DMA_MINC_ENABLE;
 800a8d2:	6122      	str	r2, [r4, #16]
	dma_handle.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
	dma_handle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 800a8d4:	2203      	movs	r2, #3
	dma_handle.Init.Priority = DMA_PRIORITY_HIGH;
 800a8d6:	6223      	str	r3, [r4, #32]
	dma_handle.Init.MemBurst = DMA_MBURST_SINGLE;
	dma_handle.Init.PeriphBurst = DMA_PBURST_SINGLE;

	dma_handle.Instance = SDRAM_DMAx_STREAM;
 800a8d8:	4b15      	ldr	r3, [pc, #84]	; (800a930 <BSP_SDRAM_MspInit+0x170>)
	dma_handle.Init.PeriphBurst = DMA_PBURST_SINGLE;
 800a8da:	6325      	str	r5, [r4, #48]	; 0x30
	dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800a8dc:	6160      	str	r0, [r4, #20]

	/* Associate the DMA handle */
	__HAL_LINKDMA(hsdram, hdma, dma_handle);

	/* Deinitialize the stream for new transfer */
	HAL_DMA_DeInit(&dma_handle);
 800a8de:	4620      	mov	r0, r4
	__HAL_LINKDMA(hsdram, hdma, dma_handle);
 800a8e0:	6334      	str	r4, [r6, #48]	; 0x30
	dma_handle.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 800a8e2:	61a1      	str	r1, [r4, #24]
	dma_handle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 800a8e4:	62a2      	str	r2, [r4, #40]	; 0x28
	dma_handle.Init.Mode = DMA_NORMAL;
 800a8e6:	61e5      	str	r5, [r4, #28]
	dma_handle.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 800a8e8:	6265      	str	r5, [r4, #36]	; 0x24
	dma_handle.Init.MemBurst = DMA_MBURST_SINGLE;
 800a8ea:	62e5      	str	r5, [r4, #44]	; 0x2c
	__HAL_LINKDMA(hsdram, hdma, dma_handle);
 800a8ec:	63a6      	str	r6, [r4, #56]	; 0x38
	dma_handle.Init.Channel = SDRAM_DMAx_CHANNEL;
 800a8ee:	e9c4 3500 	strd	r3, r5, [r4]
	HAL_DMA_DeInit(&dma_handle);
 800a8f2:	f000 fa1d 	bl	800ad30 <HAL_DMA_DeInit>

	/* Configure the DMA stream */
	HAL_DMA_Init(&dma_handle);
 800a8f6:	4620      	mov	r0, r4
 800a8f8:	f000 f97e 	bl	800abf8 <HAL_DMA_Init>

	/* NVIC configuration for DMA transfer complete interrupt */
	HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 0x0F, 0);
 800a8fc:	462a      	mov	r2, r5
 800a8fe:	210f      	movs	r1, #15
 800a900:	2038      	movs	r0, #56	; 0x38
 800a902:	f000 f8eb 	bl	800aadc <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
 800a906:	2038      	movs	r0, #56	; 0x38
 800a908:	f000 f91e 	bl	800ab48 <HAL_NVIC_EnableIRQ>
}
 800a90c:	b00e      	add	sp, #56	; 0x38
 800a90e:	bd70      	pop	{r4, r5, r6, pc}
 800a910:	40023800 	.word	0x40023800
 800a914:	40020800 	.word	0x40020800
 800a918:	40020c00 	.word	0x40020c00
 800a91c:	40021000 	.word	0x40021000
 800a920:	40021400 	.word	0x40021400
 800a924:	40021800 	.word	0x40021800
 800a928:	40021c00 	.word	0x40021c00
 800a92c:	200001b0 	.word	0x200001b0
 800a930:	40026410 	.word	0x40026410

0800a934 <BSP_SDRAM_Init>:
{
 800a934:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sdramHandle.Instance = FMC_SDRAM_DEVICE;
 800a938:	483d      	ldr	r0, [pc, #244]	; (800aa30 <BSP_SDRAM_Init+0xfc>)
	sdramHandle.Init.SDBank = FMC_SDRAM_BANK1;
 800a93a:	2600      	movs	r6, #0
	sdramHandle.Instance = FMC_SDRAM_DEVICE;
 800a93c:	4d3d      	ldr	r5, [pc, #244]	; (800aa34 <BSP_SDRAM_Init+0x100>)
	sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 800a93e:	2140      	movs	r1, #64	; 0x40
	Timing.LoadToActiveDelay = 2;
 800a940:	4c3d      	ldr	r4, [pc, #244]	; (800aa38 <BSP_SDRAM_Init+0x104>)
	sdramHandle.Init.SDClockPeriod = SDCLOCK_PERIOD;
 800a942:	f44f 6c00 	mov.w	ip, #2048	; 0x800
	sdramHandle.Init.MemoryDataWidth = SDRAM_MEMORY_WIDTH;
 800a946:	f04f 0810 	mov.w	r8, #16
	Timing.LoadToActiveDelay = 2;
 800a94a:	f04f 0902 	mov.w	r9, #2
	Timing.ExitSelfRefreshDelay = 7;
 800a94e:	2307      	movs	r3, #7
	sdramHandle.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 800a950:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	Timing.SelfRefreshTime = 4;
 800a954:	f04f 0a04 	mov.w	sl, #4
	sdramHandle.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
 800a958:	f44f 7780 	mov.w	r7, #256	; 0x100
{
 800a95c:	b083      	sub	sp, #12
	sdramHandle.Instance = FMC_SDRAM_DEVICE;
 800a95e:	6028      	str	r0, [r5, #0]
	sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 800a960:	6169      	str	r1, [r5, #20]
	BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
 800a962:	4628      	mov	r0, r5
 800a964:	4631      	mov	r1, r6
	Timing.ExitSelfRefreshDelay = 7;
 800a966:	6063      	str	r3, [r4, #4]
	Timing.RowCycleDelay = 7;
 800a968:	60e3      	str	r3, [r4, #12]
	sdramHandle.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
 800a96a:	61af      	str	r7, [r5, #24]
	Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 800a96c:	2701      	movs	r7, #1
	Timing.SelfRefreshTime = 4;
 800a96e:	f8c4 a008 	str.w	sl, [r4, #8]
	Timing.LoadToActiveDelay = 2;
 800a972:	f8c4 9000 	str.w	r9, [r4]
	Timing.RCDDelay = 2;
 800a976:	f8c4 9018 	str.w	r9, [r4, #24]
	sdramHandle.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 800a97a:	61ee      	str	r6, [r5, #28]
	sdramHandle.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
 800a97c:	62ae      	str	r6, [r5, #40]	; 0x28
	sdramHandle.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_12;
 800a97e:	f8c5 a00c 	str.w	sl, [r5, #12]
	sdramHandle.Init.MemoryDataWidth = SDRAM_MEMORY_WIDTH;
 800a982:	f8c5 8010 	str.w	r8, [r5, #16]
 800a986:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 800aa40 <BSP_SDRAM_Init+0x10c>
	sdramHandle.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 800a98a:	e9c5 c208 	strd	ip, r2, [r5, #32]
	Timing.RPDelay = 2;
 800a98e:	e9c4 9904 	strd	r9, r9, [r4, #16]
	sdramHandle.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_8;
 800a992:	e9c5 6601 	strd	r6, r6, [r5, #4]
	BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
 800a996:	f7ff ff13 	bl	800a7c0 <BSP_SDRAM_MspInit>
	if (HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 800a99a:	4621      	mov	r1, r4
 800a99c:	4628      	mov	r0, r5
	Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 800a99e:	4c27      	ldr	r4, [pc, #156]	; (800aa3c <BSP_SDRAM_Init+0x108>)
	if (HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 800a9a0:	f000 fe88 	bl	800b6b4 <HAL_SDRAM_Init>
 800a9a4:	1b83      	subs	r3, r0, r6
	HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800a9a6:	4621      	mov	r1, r4
 800a9a8:	f64f 72ff 	movw	r2, #65535	; 0xffff
	if (HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 800a9ac:	bf18      	it	ne
 800a9ae:	2301      	movne	r3, #1
	HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800a9b0:	4628      	mov	r0, r5
	__IO uint32_t tmpmrd = 0;
 800a9b2:	9601      	str	r6, [sp, #4]
	if (HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 800a9b4:	f88b 3000 	strb.w	r3, [fp]
	Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 800a9b8:	f8c4 8004 	str.w	r8, [r4, #4]
	Command.ModeRegisterDefinition = 0;
 800a9bc:	60e6      	str	r6, [r4, #12]
	Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 800a9be:	6027      	str	r7, [r4, #0]
	Command.AutoRefreshNumber = 1;
 800a9c0:	60a7      	str	r7, [r4, #8]
	HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800a9c2:	f000 fe99 	bl	800b6f8 <HAL_SDRAM_SendCommand>
	HAL_Delay(1);
 800a9c6:	4638      	mov	r0, r7
 800a9c8:	f000 f862 	bl	800aa90 <HAL_Delay>
	HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800a9cc:	4621      	mov	r1, r4
 800a9ce:	4628      	mov	r0, r5
 800a9d0:	f64f 72ff 	movw	r2, #65535	; 0xffff
	Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 800a9d4:	e9c4 9800 	strd	r9, r8, [r4]
	Command.ModeRegisterDefinition = 0;
 800a9d8:	e9c4 7602 	strd	r7, r6, [r4, #8]
	HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800a9dc:	f000 fe8c 	bl	800b6f8 <HAL_SDRAM_SendCommand>
	Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 800a9e0:	f04f 0c03 	mov.w	ip, #3
	Command.AutoRefreshNumber = 8;
 800a9e4:	2308      	movs	r3, #8
	HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800a9e6:	4621      	mov	r1, r4
 800a9e8:	4628      	mov	r0, r5
 800a9ea:	f64f 72ff 	movw	r2, #65535	; 0xffff
	Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 800a9ee:	f8c4 c000 	str.w	ip, [r4]
	Command.AutoRefreshNumber = 8;
 800a9f2:	60a3      	str	r3, [r4, #8]
	Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 800a9f4:	f8c4 8004 	str.w	r8, [r4, #4]
	Command.ModeRegisterDefinition = 0;
 800a9f8:	60e6      	str	r6, [r4, #12]
	HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800a9fa:	f000 fe7d 	bl	800b6f8 <HAL_SDRAM_SendCommand>
	tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1 |\
 800a9fe:	f44f 7308 	mov.w	r3, #544	; 0x220
	HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800aa02:	4621      	mov	r1, r4
 800aa04:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800aa08:	4628      	mov	r0, r5
	tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1 |\
 800aa0a:	9301      	str	r3, [sp, #4]
	Command.ModeRegisterDefinition = tmpmrd;
 800aa0c:	9b01      	ldr	r3, [sp, #4]
	Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 800aa0e:	e9c4 a800 	strd	sl, r8, [r4]
	Command.ModeRegisterDefinition = tmpmrd;
 800aa12:	e9c4 7302 	strd	r7, r3, [r4, #8]
	HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800aa16:	f000 fe6f 	bl	800b6f8 <HAL_SDRAM_SendCommand>
	HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount);
 800aa1a:	4628      	mov	r0, r5
 800aa1c:	f240 6103 	movw	r1, #1539	; 0x603
 800aa20:	f000 fe84 	bl	800b72c <HAL_SDRAM_ProgramRefreshRate>
}
 800aa24:	f89b 0000 	ldrb.w	r0, [fp]
 800aa28:	b003      	add	sp, #12
 800aa2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800aa2e:	bf00      	nop
 800aa30:	a0000140 	.word	0xa0000140
 800aa34:	20000e18 	.word	0x20000e18
 800aa38:	20000194 	.word	0x20000194
 800aa3c:	20000184 	.word	0x20000184
 800aa40:	20000158 	.word	0x20000158

0800aa44 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 800aa44:	4770      	bx	lr
 800aa46:	bf00      	nop

0800aa48 <HAL_Init>:
   __HAL_FLASH_ART_ENABLE();
 800aa48:	4a07      	ldr	r2, [pc, #28]	; (800aa68 <HAL_Init+0x20>)
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800aa4a:	2003      	movs	r0, #3
{
 800aa4c:	b508      	push	{r3, lr}
   __HAL_FLASH_ART_ENABLE();
 800aa4e:	6813      	ldr	r3, [r2, #0]
 800aa50:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800aa54:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800aa56:	f000 f82d 	bl	800aab4 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 800aa5a:	200f      	movs	r0, #15
 800aa5c:	f000 fe7a 	bl	800b754 <HAL_InitTick>
  HAL_MspInit();
 800aa60:	f7ff fff0 	bl	800aa44 <HAL_MspInit>
}
 800aa64:	2000      	movs	r0, #0
 800aa66:	bd08      	pop	{r3, pc}
 800aa68:	40023c00 	.word	0x40023c00

0800aa6c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800aa6c:	4a03      	ldr	r2, [pc, #12]	; (800aa7c <HAL_IncTick+0x10>)
 800aa6e:	4b04      	ldr	r3, [pc, #16]	; (800aa80 <HAL_IncTick+0x14>)
 800aa70:	6811      	ldr	r1, [r2, #0]
 800aa72:	781b      	ldrb	r3, [r3, #0]
 800aa74:	440b      	add	r3, r1
 800aa76:	6013      	str	r3, [r2, #0]
}
 800aa78:	4770      	bx	lr
 800aa7a:	bf00      	nop
 800aa7c:	20000e4c 	.word	0x20000e4c
 800aa80:	20000159 	.word	0x20000159

0800aa84 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 800aa84:	4b01      	ldr	r3, [pc, #4]	; (800aa8c <HAL_GetTick+0x8>)
 800aa86:	6818      	ldr	r0, [r3, #0]
}
 800aa88:	4770      	bx	lr
 800aa8a:	bf00      	nop
 800aa8c:	20000e4c 	.word	0x20000e4c

0800aa90 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800aa90:	b538      	push	{r3, r4, r5, lr}
 800aa92:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 800aa94:	f7ff fff6 	bl	800aa84 <HAL_GetTick>
 800aa98:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800aa9a:	1c63      	adds	r3, r4, #1
 800aa9c:	d002      	beq.n	800aaa4 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 800aa9e:	4b04      	ldr	r3, [pc, #16]	; (800aab0 <HAL_Delay+0x20>)
 800aaa0:	781b      	ldrb	r3, [r3, #0]
 800aaa2:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800aaa4:	f7ff ffee 	bl	800aa84 <HAL_GetTick>
 800aaa8:	1b40      	subs	r0, r0, r5
 800aaaa:	42a0      	cmp	r0, r4
 800aaac:	d3fa      	bcc.n	800aaa4 <HAL_Delay+0x14>
  {
  }
}
 800aaae:	bd38      	pop	{r3, r4, r5, pc}
 800aab0:	20000159 	.word	0x20000159

0800aab4 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800aab4:	4907      	ldr	r1, [pc, #28]	; (800aad4 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800aab6:	0200      	lsls	r0, r0, #8
 800aab8:	4b07      	ldr	r3, [pc, #28]	; (800aad8 <HAL_NVIC_SetPriorityGrouping+0x24>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800aaba:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800aabc:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 800aac0:	b410      	push	{r4}
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800aac2:	f64f 04ff 	movw	r4, #63743	; 0xf8ff
 800aac6:	4022      	ands	r2, r4
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800aac8:	f85d 4b04 	ldr.w	r4, [sp], #4
 800aacc:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 800aace:	4318      	orrs	r0, r3
  SCB->AIRCR =  reg_value;
 800aad0:	60c8      	str	r0, [r1, #12]
 800aad2:	4770      	bx	lr
 800aad4:	e000ed00 	.word	0xe000ed00
 800aad8:	05fa0000 	.word	0x05fa0000

0800aadc <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800aadc:	4b17      	ldr	r3, [pc, #92]	; (800ab3c <HAL_NVIC_SetPriority+0x60>)
 800aade:	68db      	ldr	r3, [r3, #12]
 800aae0:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800aae4:	b430      	push	{r4, r5}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800aae6:	f1c3 0507 	rsb	r5, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800aaea:	1d1c      	adds	r4, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800aaec:	2d04      	cmp	r5, #4
 800aaee:	bf28      	it	cs
 800aaf0:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800aaf2:	2c06      	cmp	r4, #6
 800aaf4:	d918      	bls.n	800ab28 <HAL_NVIC_SetPriority+0x4c>
 800aaf6:	3b03      	subs	r3, #3
 800aaf8:	f04f 34ff 	mov.w	r4, #4294967295
 800aafc:	409c      	lsls	r4, r3
 800aafe:	ea22 0404 	bic.w	r4, r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800ab02:	f04f 32ff 	mov.w	r2, #4294967295
  if ((int32_t)(IRQn) >= 0)
 800ab06:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800ab08:	fa02 f205 	lsl.w	r2, r2, r5
 800ab0c:	ea21 0102 	bic.w	r1, r1, r2
 800ab10:	fa01 f203 	lsl.w	r2, r1, r3
 800ab14:	ea42 0204 	orr.w	r2, r2, r4
 800ab18:	ea4f 1202 	mov.w	r2, r2, lsl #4
 800ab1c:	b2d2      	uxtb	r2, r2
  if ((int32_t)(IRQn) >= 0)
 800ab1e:	db06      	blt.n	800ab2e <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800ab20:	4b07      	ldr	r3, [pc, #28]	; (800ab40 <HAL_NVIC_SetPriority+0x64>)
 800ab22:	541a      	strb	r2, [r3, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800ab24:	bc30      	pop	{r4, r5}
 800ab26:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800ab28:	2400      	movs	r4, #0
 800ab2a:	4623      	mov	r3, r4
 800ab2c:	e7e9      	b.n	800ab02 <HAL_NVIC_SetPriority+0x26>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800ab2e:	f000 000f 	and.w	r0, r0, #15
 800ab32:	4b04      	ldr	r3, [pc, #16]	; (800ab44 <HAL_NVIC_SetPriority+0x68>)
 800ab34:	541a      	strb	r2, [r3, r0]
 800ab36:	bc30      	pop	{r4, r5}
 800ab38:	4770      	bx	lr
 800ab3a:	bf00      	nop
 800ab3c:	e000ed00 	.word	0xe000ed00
 800ab40:	e000e400 	.word	0xe000e400
 800ab44:	e000ed14 	.word	0xe000ed14

0800ab48 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800ab48:	2800      	cmp	r0, #0
 800ab4a:	db07      	blt.n	800ab5c <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800ab4c:	f000 011f 	and.w	r1, r0, #31
 800ab50:	2301      	movs	r3, #1
 800ab52:	0940      	lsrs	r0, r0, #5
 800ab54:	4a02      	ldr	r2, [pc, #8]	; (800ab60 <HAL_NVIC_EnableIRQ+0x18>)
 800ab56:	408b      	lsls	r3, r1
 800ab58:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800ab5c:	4770      	bx	lr
 800ab5e:	bf00      	nop
 800ab60:	e000e100 	.word	0xe000e100

0800ab64 <HAL_MPU_Disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 800ab64:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800ab68:	4a04      	ldr	r2, [pc, #16]	; (800ab7c <HAL_MPU_Disable+0x18>)
  
  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 800ab6a:	2000      	movs	r0, #0
 800ab6c:	4904      	ldr	r1, [pc, #16]	; (800ab80 <HAL_MPU_Disable+0x1c>)
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800ab6e:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800ab70:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800ab74:	6253      	str	r3, [r2, #36]	; 0x24
  MPU->CTRL = 0;
 800ab76:	6048      	str	r0, [r1, #4]
}
 800ab78:	4770      	bx	lr
 800ab7a:	bf00      	nop
 800ab7c:	e000ed00 	.word	0xe000ed00
 800ab80:	e000ed90 	.word	0xe000ed90

0800ab84 <HAL_MPU_Enable>:
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
  
  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 800ab84:	4a06      	ldr	r2, [pc, #24]	; (800aba0 <HAL_MPU_Enable+0x1c>)
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 800ab86:	f040 0001 	orr.w	r0, r0, #1
 800ab8a:	4b06      	ldr	r3, [pc, #24]	; (800aba4 <HAL_MPU_Enable+0x20>)
 800ab8c:	6058      	str	r0, [r3, #4]
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 800ab8e:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800ab90:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800ab94:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 800ab96:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800ab9a:	f3bf 8f6f 	isb	sy
  
  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 800ab9e:	4770      	bx	lr
 800aba0:	e000ed00 	.word	0xe000ed00
 800aba4:	e000ed90 	.word	0xe000ed90

0800aba8 <HAL_MPU_ConfigRegion>:
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 800aba8:	4a12      	ldr	r2, [pc, #72]	; (800abf4 <HAL_MPU_ConfigRegion+0x4c>)
 800abaa:	7843      	ldrb	r3, [r0, #1]
 800abac:	6093      	str	r3, [r2, #8]

  if ((MPU_Init->Enable) != RESET)
 800abae:	7801      	ldrb	r1, [r0, #0]
 800abb0:	b911      	cbnz	r1, 800abb8 <HAL_MPU_ConfigRegion+0x10>
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
  }
  else
  {
    MPU->RBAR = 0x00;
 800abb2:	60d1      	str	r1, [r2, #12]
    MPU->RASR = 0x00;
 800abb4:	6111      	str	r1, [r2, #16]
 800abb6:	4770      	bx	lr
    MPU->RBAR = MPU_Init->BaseAddress;
 800abb8:	6843      	ldr	r3, [r0, #4]
{
 800abba:	b470      	push	{r4, r5, r6}
    MPU->RBAR = MPU_Init->BaseAddress;
 800abbc:	60d3      	str	r3, [r2, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 800abbe:	7ac3      	ldrb	r3, [r0, #11]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800abc0:	7b04      	ldrb	r4, [r0, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 800abc2:	061b      	lsls	r3, r3, #24
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 800abc4:	7a85      	ldrb	r5, [r0, #10]
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 800abc6:	7b86      	ldrb	r6, [r0, #14]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800abc8:	ea43 7304 	orr.w	r3, r3, r4, lsl #28
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 800abcc:	7b44      	ldrb	r4, [r0, #13]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800abce:	430b      	orrs	r3, r1
 800abd0:	7a01      	ldrb	r1, [r0, #8]
 800abd2:	ea43 43c5 	orr.w	r3, r3, r5, lsl #19
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 800abd6:	7bc5      	ldrb	r5, [r0, #15]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800abd8:	ea43 4384 	orr.w	r3, r3, r4, lsl #18
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 800abdc:	7a44      	ldrb	r4, [r0, #9]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800abde:	ea43 4346 	orr.w	r3, r3, r6, lsl #17
 800abe2:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
 800abe6:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 800abea:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
  }
}
 800abee:	bc70      	pop	{r4, r5, r6}
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800abf0:	6113      	str	r3, [r2, #16]
}
 800abf2:	4770      	bx	lr
 800abf4:	e000ed90 	.word	0xe000ed90

0800abf8 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 800abf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800abfa:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 800abfc:	f7ff ff42 	bl	800aa84 <HAL_GetTick>
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 800ac00:	2c00      	cmp	r4, #0
 800ac02:	d053      	beq.n	800acac <HAL_DMA_Init+0xb4>
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 800ac04:	2202      	movs	r2, #2
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 800ac06:	6823      	ldr	r3, [r4, #0]
  __HAL_UNLOCK(hdma);
 800ac08:	2100      	movs	r1, #0
 800ac0a:	4605      	mov	r5, r0
  hdma->State = HAL_DMA_STATE_BUSY;
 800ac0c:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
  __HAL_DMA_DISABLE(hdma);
 800ac10:	681a      	ldr	r2, [r3, #0]
  __HAL_UNLOCK(hdma);
 800ac12:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  __HAL_DMA_DISABLE(hdma);
 800ac16:	f022 0201 	bic.w	r2, r2, #1
 800ac1a:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 800ac1c:	e005      	b.n	800ac2a <HAL_DMA_Init+0x32>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 800ac1e:	f7ff ff31 	bl	800aa84 <HAL_GetTick>
 800ac22:	1b40      	subs	r0, r0, r5
 800ac24:	2805      	cmp	r0, #5
 800ac26:	d83a      	bhi.n	800ac9e <HAL_DMA_Init+0xa6>
 800ac28:	6823      	ldr	r3, [r4, #0]
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 800ac2a:	681a      	ldr	r2, [r3, #0]
 800ac2c:	07d1      	lsls	r1, r2, #31
 800ac2e:	d4f6      	bmi.n	800ac1e <HAL_DMA_Init+0x26>
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800ac30:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
 800ac34:	68e1      	ldr	r1, [r4, #12]
 800ac36:	4302      	orrs	r2, r0
  tmp = hdma->Instance->CR;
 800ac38:	681f      	ldr	r7, [r3, #0]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800ac3a:	e9d4 0504 	ldrd	r0, r5, [r4, #16]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800ac3e:	430a      	orrs	r2, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800ac40:	4302      	orrs	r2, r0
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;
 800ac42:	6a20      	ldr	r0, [r4, #32]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800ac44:	e9d4 6106 	ldrd	r6, r1, [r4, #24]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800ac48:	432a      	orrs	r2, r5
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800ac4a:	4d35      	ldr	r5, [pc, #212]	; (800ad20 <HAL_DMA_Init+0x128>)
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800ac4c:	4332      	orrs	r2, r6
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800ac4e:	403d      	ands	r5, r7
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800ac50:	430a      	orrs	r2, r1

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800ac52:	6a61      	ldr	r1, [r4, #36]	; 0x24
          hdma->Init.Mode                | hdma->Init.Priority;
 800ac54:	4302      	orrs	r2, r0
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800ac56:	2904      	cmp	r1, #4
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 800ac58:	ea42 0205 	orr.w	r2, r2, r5
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800ac5c:	d028      	beq.n	800acb0 <HAL_DMA_Init+0xb8>
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 800ac5e:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 800ac60:	695a      	ldr	r2, [r3, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800ac62:	f022 0207 	bic.w	r2, r2, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 800ac66:	4311      	orrs	r1, r2
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800ac68:	b2da      	uxtb	r2, r3
 800ac6a:	4d2e      	ldr	r5, [pc, #184]	; (800ad24 <HAL_DMA_Init+0x12c>)
  hdma->Instance->FCR = tmp;
 800ac6c:	6159      	str	r1, [r3, #20]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800ac6e:	3a10      	subs	r2, #16
 800ac70:	492d      	ldr	r1, [pc, #180]	; (800ad28 <HAL_DMA_Init+0x130>)
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800ac72:	482e      	ldr	r0, [pc, #184]	; (800ad2c <HAL_DMA_Init+0x134>)
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800ac74:	fba5 5202 	umull	r5, r2, r5, r2
 800ac78:	4019      	ands	r1, r3
  hdma->State = HAL_DMA_STATE_READY;
 800ac7a:	2501      	movs	r5, #1
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800ac7c:	0913      	lsrs	r3, r2, #4
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800ac7e:	2200      	movs	r2, #0
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800ac80:	5cc0      	ldrb	r0, [r0, r3]
  
  if (stream_number > 3U)
 800ac82:	2b03      	cmp	r3, #3
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 800ac84:	f04f 033f 	mov.w	r3, #63	; 0x3f
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800ac88:	bf88      	it	hi
 800ac8a:	3104      	addhi	r1, #4
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800ac8c:	65e0      	str	r0, [r4, #92]	; 0x5c
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 800ac8e:	4083      	lsls	r3, r0
  return HAL_OK;
 800ac90:	4610      	mov	r0, r2
 800ac92:	65a1      	str	r1, [r4, #88]	; 0x58
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 800ac94:	608b      	str	r3, [r1, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800ac96:	6562      	str	r2, [r4, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 800ac98:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
}
 800ac9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 800ac9e:	2303      	movs	r3, #3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800aca0:	2220      	movs	r2, #32
      return HAL_TIMEOUT;
 800aca2:	4618      	mov	r0, r3
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 800aca4:	6562      	str	r2, [r4, #84]	; 0x54
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 800aca6:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 800acaa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 800acac:	2001      	movs	r0, #1
}
 800acae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800acb0:	e9d4 510b 	ldrd	r5, r1, [r4, #44]	; 0x2c
    tmp |= hdma->Init.FIFOThreshold;
 800acb4:	6aa7      	ldr	r7, [r4, #40]	; 0x28
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800acb6:	ea45 0001 	orr.w	r0, r5, r1
    tmp |= hdma->Init.FIFOThreshold;
 800acba:	f047 0104 	orr.w	r1, r7, #4
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 800acbe:	4302      	orrs	r2, r0
  hdma->Instance->CR = tmp;  
 800acc0:	601a      	str	r2, [r3, #0]
  tmp = hdma->Instance->FCR;
 800acc2:	695a      	ldr	r2, [r3, #20]
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800acc4:	f022 0207 	bic.w	r2, r2, #7
    tmp |= hdma->Init.FIFOThreshold;
 800acc8:	4311      	orrs	r1, r2
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 800acca:	2d00      	cmp	r5, #0
 800accc:	d0cc      	beq.n	800ac68 <HAL_DMA_Init+0x70>
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 800acce:	b17e      	cbz	r6, 800acf0 <HAL_DMA_Init+0xf8>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 800acd0:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
 800acd4:	d016      	beq.n	800ad04 <HAL_DMA_Init+0x10c>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 800acd6:	2f02      	cmp	r7, #2
 800acd8:	d903      	bls.n	800ace2 <HAL_DMA_Init+0xea>
 800acda:	2f03      	cmp	r7, #3
 800acdc:	d1c4      	bne.n	800ac68 <HAL_DMA_Init+0x70>
    case DMA_FIFO_THRESHOLD_HALFFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
      break;
    case DMA_FIFO_THRESHOLD_FULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800acde:	01ea      	lsls	r2, r5, #7
 800ace0:	d5c2      	bpl.n	800ac68 <HAL_DMA_Init+0x70>
        hdma->State = HAL_DMA_STATE_READY;
 800ace2:	2301      	movs	r3, #1
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800ace4:	2240      	movs	r2, #64	; 0x40
        return HAL_ERROR; 
 800ace6:	4618      	mov	r0, r3
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800ace8:	6562      	str	r2, [r4, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_READY;
 800acea:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
 800acee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch (tmp)
 800acf0:	2f01      	cmp	r7, #1
 800acf2:	d003      	beq.n	800acfc <HAL_DMA_Init+0x104>
 800acf4:	d3f3      	bcc.n	800acde <HAL_DMA_Init+0xe6>
 800acf6:	2f02      	cmp	r7, #2
 800acf8:	d1b6      	bne.n	800ac68 <HAL_DMA_Init+0x70>
 800acfa:	e7f0      	b.n	800acde <HAL_DMA_Init+0xe6>
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 800acfc:	f1b5 7fc0 	cmp.w	r5, #25165824	; 0x1800000
 800ad00:	d1b2      	bne.n	800ac68 <HAL_DMA_Init+0x70>
 800ad02:	e7ee      	b.n	800ace2 <HAL_DMA_Init+0xea>
    switch (tmp)
 800ad04:	2f03      	cmp	r7, #3
 800ad06:	d8af      	bhi.n	800ac68 <HAL_DMA_Init+0x70>
 800ad08:	a201      	add	r2, pc, #4	; (adr r2, 800ad10 <HAL_DMA_Init+0x118>)
 800ad0a:	f852 f027 	ldr.w	pc, [r2, r7, lsl #2]
 800ad0e:	bf00      	nop
 800ad10:	0800ace3 	.word	0x0800ace3
 800ad14:	0800acdf 	.word	0x0800acdf
 800ad18:	0800ace3 	.word	0x0800ace3
 800ad1c:	0800acfd 	.word	0x0800acfd
 800ad20:	f010803f 	.word	0xf010803f
 800ad24:	aaaaaaab 	.word	0xaaaaaaab
 800ad28:	fffffc00 	.word	0xfffffc00
 800ad2c:	0800de88 	.word	0x0800de88

0800ad30 <HAL_DMA_DeInit>:
  if(hdma == NULL)
 800ad30:	2800      	cmp	r0, #0
 800ad32:	d035      	beq.n	800ada0 <HAL_DMA_DeInit+0x70>
 800ad34:	4603      	mov	r3, r0
  if(hdma->State == HAL_DMA_STATE_BUSY)
 800ad36:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
 800ad3a:	b2c0      	uxtb	r0, r0
 800ad3c:	2802      	cmp	r0, #2
 800ad3e:	d031      	beq.n	800ada4 <HAL_DMA_DeInit+0x74>
  __HAL_DMA_DISABLE(hdma);
 800ad40:	681a      	ldr	r2, [r3, #0]
  hdma->Instance->CR   = 0U;
 800ad42:	2000      	movs	r0, #0
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800ad44:	b2d1      	uxtb	r1, r2
{
 800ad46:	b470      	push	{r4, r5, r6}
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800ad48:	3910      	subs	r1, #16
  __HAL_DMA_DISABLE(hdma);
 800ad4a:	6814      	ldr	r4, [r2, #0]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800ad4c:	4d16      	ldr	r5, [pc, #88]	; (800ada8 <HAL_DMA_DeInit+0x78>)
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
 800ad4e:	2621      	movs	r6, #33	; 0x21
  __HAL_DMA_DISABLE(hdma);
 800ad50:	f024 0401 	bic.w	r4, r4, #1
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800ad54:	fba5 5101 	umull	r5, r1, r5, r1
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800ad58:	4d14      	ldr	r5, [pc, #80]	; (800adac <HAL_DMA_DeInit+0x7c>)
  __HAL_DMA_DISABLE(hdma);
 800ad5a:	6014      	str	r4, [r2, #0]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 800ad5c:	0909      	lsrs	r1, r1, #4
 800ad5e:	4c14      	ldr	r4, [pc, #80]	; (800adb0 <HAL_DMA_DeInit+0x80>)
  hdma->Instance->CR   = 0U;
 800ad60:	6010      	str	r0, [r2, #0]
 800ad62:	4014      	ands	r4, r2
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800ad64:	5c6d      	ldrb	r5, [r5, r1]
  if (stream_number > 3U)
 800ad66:	2903      	cmp	r1, #3
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 800ad68:	f04f 013f 	mov.w	r1, #63	; 0x3f
  hdma->Instance->NDTR = 0U;
 800ad6c:	6050      	str	r0, [r2, #4]
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800ad6e:	bf88      	it	hi
 800ad70:	3404      	addhi	r4, #4
  hdma->Instance->PAR  = 0U;
 800ad72:	6090      	str	r0, [r2, #8]
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 800ad74:	40a9      	lsls	r1, r5
  hdma->Instance->M0AR = 0U;
 800ad76:	60d0      	str	r0, [r2, #12]
  hdma->Instance->M1AR = 0U;
 800ad78:	6110      	str	r0, [r2, #16]
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
 800ad7a:	6156      	str	r6, [r2, #20]
  hdma->XferCpltCallback = NULL;
 800ad7c:	2200      	movs	r2, #0
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 800ad7e:	65dd      	str	r5, [r3, #92]	; 0x5c
 800ad80:	659c      	str	r4, [r3, #88]	; 0x58
  return HAL_OK;
 800ad82:	4610      	mov	r0, r2
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 800ad84:	60a1      	str	r1, [r4, #8]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800ad86:	655a      	str	r2, [r3, #84]	; 0x54
  __HAL_UNLOCK(hdma);
 800ad88:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  hdma->State = HAL_DMA_STATE_RESET;
 800ad8c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  hdma->XferHalfCpltCallback = NULL;
 800ad90:	e9c3 220f 	strd	r2, r2, [r3, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
 800ad94:	e9c3 2211 	strd	r2, r2, [r3, #68]	; 0x44
  hdma->XferAbortCallback = NULL;  
 800ad98:	e9c3 2213 	strd	r2, r2, [r3, #76]	; 0x4c
}
 800ad9c:	bc70      	pop	{r4, r5, r6}
 800ad9e:	4770      	bx	lr
    return HAL_ERROR;
 800ada0:	2001      	movs	r0, #1
 800ada2:	4770      	bx	lr
}
 800ada4:	4770      	bx	lr
 800ada6:	bf00      	nop
 800ada8:	aaaaaaab 	.word	0xaaaaaaab
 800adac:	0800de88 	.word	0x0800de88
 800adb0:	fffffc00 	.word	0xfffffc00

0800adb4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 800adb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800adb8:	4688      	mov	r8, r1
 800adba:	b083      	sub	sp, #12
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 800adbc:	2400      	movs	r4, #0
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800adbe:	f8d1 9000 	ldr.w	r9, [r1]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800adc2:	f8df e1f8 	ldr.w	lr, [pc, #504]	; 800afbc <HAL_GPIO_Init+0x208>
 800adc6:	e003      	b.n	800add0 <HAL_GPIO_Init+0x1c>
  for(position = 0; position < GPIO_NUMBER; position++)
 800adc8:	3401      	adds	r4, #1
 800adca:	2c10      	cmp	r4, #16
 800adcc:	f000 80b6 	beq.w	800af3c <HAL_GPIO_Init+0x188>
    ioposition = ((uint32_t)0x01) << position;
 800add0:	2301      	movs	r3, #1
 800add2:	40a3      	lsls	r3, r4
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 800add4:	ea09 0203 	and.w	r2, r9, r3
    if(iocurrent == ioposition)
 800add8:	4293      	cmp	r3, r2
 800adda:	d1f5      	bne.n	800adc8 <HAL_GPIO_Init+0x14>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800addc:	f8d8 5004 	ldr.w	r5, [r8, #4]
 800ade0:	0067      	lsls	r7, r4, #1
 800ade2:	2103      	movs	r1, #3
 800ade4:	f025 0c10 	bic.w	ip, r5, #16
 800ade8:	40b9      	lsls	r1, r7
 800adea:	f10c 33ff 	add.w	r3, ip, #4294967295
 800adee:	43c9      	mvns	r1, r1
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800adf0:	2b01      	cmp	r3, #1
 800adf2:	d810      	bhi.n	800ae16 <HAL_GPIO_Init+0x62>
        temp = GPIOx->OSPEEDR; 
 800adf4:	6886      	ldr	r6, [r0, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800adf6:	f3c5 1300 	ubfx	r3, r5, #4, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 800adfa:	ea06 0a01 	and.w	sl, r6, r1
        temp |= (GPIO_Init->Speed << (position * 2));
 800adfe:	f8d8 600c 	ldr.w	r6, [r8, #12]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800ae02:	40a3      	lsls	r3, r4
        temp |= (GPIO_Init->Speed << (position * 2));
 800ae04:	40be      	lsls	r6, r7
 800ae06:	ea46 060a 	orr.w	r6, r6, sl
        GPIOx->OSPEEDR = temp;
 800ae0a:	6086      	str	r6, [r0, #8]
        temp = GPIOx->OTYPER;
 800ae0c:	6846      	ldr	r6, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 800ae0e:	ea26 0602 	bic.w	r6, r6, r2
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 800ae12:	4333      	orrs	r3, r6
        GPIOx->OTYPER = temp;
 800ae14:	6043      	str	r3, [r0, #4]
      temp = GPIOx->PUPDR;
 800ae16:	68c3      	ldr	r3, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800ae18:	f1bc 0f02 	cmp.w	ip, #2
      temp |= ((GPIO_Init->Pull) << (position * 2));
 800ae1c:	f8d8 6008 	ldr.w	r6, [r8, #8]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 800ae20:	ea03 0301 	and.w	r3, r3, r1
      temp |= ((GPIO_Init->Pull) << (position * 2));
 800ae24:	fa06 f607 	lsl.w	r6, r6, r7
 800ae28:	ea46 0603 	orr.w	r6, r6, r3
      GPIOx->PUPDR = temp;
 800ae2c:	60c6      	str	r6, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800ae2e:	d115      	bne.n	800ae5c <HAL_GPIO_Init+0xa8>
        temp = GPIOx->AFR[position >> 3];
 800ae30:	08e3      	lsrs	r3, r4, #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800ae32:	f004 0c07 	and.w	ip, r4, #7
 800ae36:	f04f 0b0f 	mov.w	fp, #15
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800ae3a:	f8d8 6010 	ldr.w	r6, [r8, #16]
 800ae3e:	eb00 0383 	add.w	r3, r0, r3, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800ae42:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        temp = GPIOx->AFR[position >> 3];
 800ae46:	f8d3 a020 	ldr.w	sl, [r3, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800ae4a:	fa0b fb0c 	lsl.w	fp, fp, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800ae4e:	fa06 f60c 	lsl.w	r6, r6, ip
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 800ae52:	ea2a 0a0b 	bic.w	sl, sl, fp
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 800ae56:	ea46 060a 	orr.w	r6, r6, sl
        GPIOx->AFR[position >> 3] = temp;
 800ae5a:	621e      	str	r6, [r3, #32]
      temp = GPIOx->MODER;
 800ae5c:	6806      	ldr	r6, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800ae5e:	f005 0303 	and.w	r3, r5, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 800ae62:	4031      	ands	r1, r6
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800ae64:	40bb      	lsls	r3, r7
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800ae66:	00ef      	lsls	r7, r5, #3
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 800ae68:	ea43 0301 	orr.w	r3, r3, r1
      GPIOx->MODER = temp;
 800ae6c:	6003      	str	r3, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800ae6e:	d5ab      	bpl.n	800adc8 <HAL_GPIO_Init+0x14>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800ae70:	4b48      	ldr	r3, [pc, #288]	; (800af94 <HAL_GPIO_Init+0x1e0>)
 800ae72:	f024 0603 	bic.w	r6, r4, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800ae76:	f04f 0c0f 	mov.w	ip, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800ae7a:	6c5f      	ldr	r7, [r3, #68]	; 0x44
 800ae7c:	4619      	mov	r1, r3
 800ae7e:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800ae82:	f004 0303 	and.w	r3, r4, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800ae86:	f447 4780 	orr.w	r7, r7, #16384	; 0x4000
 800ae8a:	f506 369c 	add.w	r6, r6, #79872	; 0x13800
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800ae8e:	009b      	lsls	r3, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800ae90:	644f      	str	r7, [r1, #68]	; 0x44
 800ae92:	6c4f      	ldr	r7, [r1, #68]	; 0x44
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800ae94:	fa0c f103 	lsl.w	r1, ip, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800ae98:	f407 4780 	and.w	r7, r7, #16384	; 0x4000
 800ae9c:	9701      	str	r7, [sp, #4]
 800ae9e:	9f01      	ldr	r7, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2];
 800aea0:	68b7      	ldr	r7, [r6, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 800aea2:	ea27 0101 	bic.w	r1, r7, r1
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 800aea6:	4f3c      	ldr	r7, [pc, #240]	; (800af98 <HAL_GPIO_Init+0x1e4>)
 800aea8:	42b8      	cmp	r0, r7
 800aeaa:	d020      	beq.n	800aeee <HAL_GPIO_Init+0x13a>
 800aeac:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 800aeb0:	42b8      	cmp	r0, r7
 800aeb2:	d046      	beq.n	800af42 <HAL_GPIO_Init+0x18e>
 800aeb4:	4f39      	ldr	r7, [pc, #228]	; (800af9c <HAL_GPIO_Init+0x1e8>)
 800aeb6:	42b8      	cmp	r0, r7
 800aeb8:	d048      	beq.n	800af4c <HAL_GPIO_Init+0x198>
 800aeba:	4f39      	ldr	r7, [pc, #228]	; (800afa0 <HAL_GPIO_Init+0x1ec>)
 800aebc:	42b8      	cmp	r0, r7
 800aebe:	d04a      	beq.n	800af56 <HAL_GPIO_Init+0x1a2>
 800aec0:	4f38      	ldr	r7, [pc, #224]	; (800afa4 <HAL_GPIO_Init+0x1f0>)
 800aec2:	42b8      	cmp	r0, r7
 800aec4:	d04c      	beq.n	800af60 <HAL_GPIO_Init+0x1ac>
 800aec6:	4f38      	ldr	r7, [pc, #224]	; (800afa8 <HAL_GPIO_Init+0x1f4>)
 800aec8:	42b8      	cmp	r0, r7
 800aeca:	d053      	beq.n	800af74 <HAL_GPIO_Init+0x1c0>
 800aecc:	4f37      	ldr	r7, [pc, #220]	; (800afac <HAL_GPIO_Init+0x1f8>)
 800aece:	42b8      	cmp	r0, r7
 800aed0:	d055      	beq.n	800af7e <HAL_GPIO_Init+0x1ca>
 800aed2:	4f37      	ldr	r7, [pc, #220]	; (800afb0 <HAL_GPIO_Init+0x1fc>)
 800aed4:	42b8      	cmp	r0, r7
 800aed6:	d048      	beq.n	800af6a <HAL_GPIO_Init+0x1b6>
 800aed8:	4f36      	ldr	r7, [pc, #216]	; (800afb4 <HAL_GPIO_Init+0x200>)
 800aeda:	42b8      	cmp	r0, r7
 800aedc:	d054      	beq.n	800af88 <HAL_GPIO_Init+0x1d4>
 800aede:	4f36      	ldr	r7, [pc, #216]	; (800afb8 <HAL_GPIO_Init+0x204>)
 800aee0:	42b8      	cmp	r0, r7
 800aee2:	bf0c      	ite	eq
 800aee4:	2709      	moveq	r7, #9
 800aee6:	270a      	movne	r7, #10
 800aee8:	fa07 f303 	lsl.w	r3, r7, r3
 800aeec:	4319      	orrs	r1, r3
        SYSCFG->EXTICR[position >> 2] = temp;
 800aeee:	60b1      	str	r1, [r6, #8]
        temp &= ~((uint32_t)iocurrent);
 800aef0:	43d1      	mvns	r1, r2
        temp = EXTI->IMR;
 800aef2:	f8de 3000 	ldr.w	r3, [lr]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800aef6:	03ee      	lsls	r6, r5, #15
  for(position = 0; position < GPIO_NUMBER; position++)
 800aef8:	f104 0401 	add.w	r4, r4, #1
        temp &= ~((uint32_t)iocurrent);
 800aefc:	bf54      	ite	pl
 800aefe:	400b      	andpl	r3, r1
        {
          temp |= iocurrent;
 800af00:	4313      	orrmi	r3, r2
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800af02:	03af      	lsls	r7, r5, #14
        EXTI->IMR = temp;
 800af04:	f8ce 3000 	str.w	r3, [lr]
        temp = EXTI->EMR;
 800af08:	f8de 3004 	ldr.w	r3, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
 800af0c:	bf54      	ite	pl
 800af0e:	400b      	andpl	r3, r1
        {
          temp |= iocurrent;
 800af10:	4313      	orrmi	r3, r2
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800af12:	02ee      	lsls	r6, r5, #11
        EXTI->EMR = temp;
 800af14:	f8ce 3004 	str.w	r3, [lr, #4]
        temp = EXTI->RTSR;
 800af18:	f8de 3008 	ldr.w	r3, [lr, #8]
        temp &= ~((uint32_t)iocurrent);
 800af1c:	bf54      	ite	pl
 800af1e:	400b      	andpl	r3, r1
        {
          temp |= iocurrent;
 800af20:	4313      	orrmi	r3, r2
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800af22:	02ad      	lsls	r5, r5, #10
        EXTI->RTSR = temp;
 800af24:	f8ce 3008 	str.w	r3, [lr, #8]
        temp = EXTI->FTSR;
 800af28:	f8de 300c 	ldr.w	r3, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
 800af2c:	bf54      	ite	pl
 800af2e:	400b      	andpl	r3, r1
        {
          temp |= iocurrent;
 800af30:	4313      	orrmi	r3, r2
  for(position = 0; position < GPIO_NUMBER; position++)
 800af32:	2c10      	cmp	r4, #16
        }
        EXTI->FTSR = temp;
 800af34:	f8ce 300c 	str.w	r3, [lr, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 800af38:	f47f af4a 	bne.w	800add0 <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 800af3c:	b003      	add	sp, #12
 800af3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800af42:	2701      	movs	r7, #1
 800af44:	fa07 f303 	lsl.w	r3, r7, r3
 800af48:	4319      	orrs	r1, r3
 800af4a:	e7d0      	b.n	800aeee <HAL_GPIO_Init+0x13a>
 800af4c:	2702      	movs	r7, #2
 800af4e:	fa07 f303 	lsl.w	r3, r7, r3
 800af52:	4319      	orrs	r1, r3
 800af54:	e7cb      	b.n	800aeee <HAL_GPIO_Init+0x13a>
 800af56:	2703      	movs	r7, #3
 800af58:	fa07 f303 	lsl.w	r3, r7, r3
 800af5c:	4319      	orrs	r1, r3
 800af5e:	e7c6      	b.n	800aeee <HAL_GPIO_Init+0x13a>
 800af60:	2704      	movs	r7, #4
 800af62:	fa07 f303 	lsl.w	r3, r7, r3
 800af66:	4319      	orrs	r1, r3
 800af68:	e7c1      	b.n	800aeee <HAL_GPIO_Init+0x13a>
 800af6a:	2707      	movs	r7, #7
 800af6c:	fa07 f303 	lsl.w	r3, r7, r3
 800af70:	4319      	orrs	r1, r3
 800af72:	e7bc      	b.n	800aeee <HAL_GPIO_Init+0x13a>
 800af74:	2705      	movs	r7, #5
 800af76:	fa07 f303 	lsl.w	r3, r7, r3
 800af7a:	4319      	orrs	r1, r3
 800af7c:	e7b7      	b.n	800aeee <HAL_GPIO_Init+0x13a>
 800af7e:	2706      	movs	r7, #6
 800af80:	fa07 f303 	lsl.w	r3, r7, r3
 800af84:	4319      	orrs	r1, r3
 800af86:	e7b2      	b.n	800aeee <HAL_GPIO_Init+0x13a>
 800af88:	2708      	movs	r7, #8
 800af8a:	fa07 f303 	lsl.w	r3, r7, r3
 800af8e:	4319      	orrs	r1, r3
 800af90:	e7ad      	b.n	800aeee <HAL_GPIO_Init+0x13a>
 800af92:	bf00      	nop
 800af94:	40023800 	.word	0x40023800
 800af98:	40020000 	.word	0x40020000
 800af9c:	40020800 	.word	0x40020800
 800afa0:	40020c00 	.word	0x40020c00
 800afa4:	40021000 	.word	0x40021000
 800afa8:	40021400 	.word	0x40021400
 800afac:	40021800 	.word	0x40021800
 800afb0:	40021c00 	.word	0x40021c00
 800afb4:	40022000 	.word	0x40022000
 800afb8:	40022400 	.word	0x40022400
 800afbc:	40013c00 	.word	0x40013c00

0800afc0 <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 800afc0:	4a1b      	ldr	r2, [pc, #108]	; (800b030 <HAL_PWREx_EnableOverDrive+0x70>)
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 800afc2:	4b1c      	ldr	r3, [pc, #112]	; (800b034 <HAL_PWREx_EnableOverDrive+0x74>)
  __HAL_RCC_PWR_CLK_ENABLE();
 800afc4:	6c11      	ldr	r1, [r2, #64]	; 0x40
 800afc6:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
{
 800afca:	b530      	push	{r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 800afcc:	6411      	str	r1, [r2, #64]	; 0x40
{
 800afce:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 800afd0:	6c12      	ldr	r2, [r2, #64]	; 0x40

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800afd2:	461c      	mov	r4, r3
  __HAL_RCC_PWR_CLK_ENABLE();
 800afd4:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 800afd8:	9201      	str	r2, [sp, #4]
 800afda:	9a01      	ldr	r2, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
 800afdc:	681a      	ldr	r2, [r3, #0]
 800afde:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800afe2:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 800afe4:	f7ff fd4e 	bl	800aa84 <HAL_GetTick>
 800afe8:	4605      	mov	r5, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800afea:	e005      	b.n	800aff8 <HAL_PWREx_EnableOverDrive+0x38>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800afec:	f7ff fd4a 	bl	800aa84 <HAL_GetTick>
 800aff0:	1b40      	subs	r0, r0, r5
 800aff2:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800aff6:	d817      	bhi.n	800b028 <HAL_PWREx_EnableOverDrive+0x68>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800aff8:	6863      	ldr	r3, [r4, #4]
 800affa:	03da      	lsls	r2, r3, #15
 800affc:	d5f6      	bpl.n	800afec <HAL_PWREx_EnableOverDrive+0x2c>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800affe:	6823      	ldr	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800b000:	4d0c      	ldr	r5, [pc, #48]	; (800b034 <HAL_PWREx_EnableOverDrive+0x74>)
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800b002:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800b006:	6023      	str	r3, [r4, #0]
  tickstart = HAL_GetTick();
 800b008:	f7ff fd3c 	bl	800aa84 <HAL_GetTick>
 800b00c:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800b00e:	e005      	b.n	800b01c <HAL_PWREx_EnableOverDrive+0x5c>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800b010:	f7ff fd38 	bl	800aa84 <HAL_GetTick>
 800b014:	1b00      	subs	r0, r0, r4
 800b016:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800b01a:	d805      	bhi.n	800b028 <HAL_PWREx_EnableOverDrive+0x68>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800b01c:	686b      	ldr	r3, [r5, #4]
 800b01e:	039b      	lsls	r3, r3, #14
 800b020:	d5f6      	bpl.n	800b010 <HAL_PWREx_EnableOverDrive+0x50>
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 800b022:	2000      	movs	r0, #0
}
 800b024:	b003      	add	sp, #12
 800b026:	bd30      	pop	{r4, r5, pc}
      return HAL_TIMEOUT;
 800b028:	2003      	movs	r0, #3
}
 800b02a:	b003      	add	sp, #12
 800b02c:	bd30      	pop	{r4, r5, pc}
 800b02e:	bf00      	nop
 800b030:	40023800 	.word	0x40023800
 800b034:	40007000 	.word	0x40007000

0800b038 <HAL_RCC_OscConfig>:
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 800b038:	2800      	cmp	r0, #0
 800b03a:	f000 814c 	beq.w	800b2d6 <HAL_RCC_OscConfig+0x29e>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800b03e:	6803      	ldr	r3, [r0, #0]
{
 800b040:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800b044:	07dd      	lsls	r5, r3, #31
{
 800b046:	b082      	sub	sp, #8
 800b048:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800b04a:	d535      	bpl.n	800b0b8 <HAL_RCC_OscConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 800b04c:	49ac      	ldr	r1, [pc, #688]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b04e:	688a      	ldr	r2, [r1, #8]
 800b050:	f002 020c 	and.w	r2, r2, #12
 800b054:	2a04      	cmp	r2, #4
 800b056:	f000 80ff 	beq.w	800b258 <HAL_RCC_OscConfig+0x220>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800b05a:	688a      	ldr	r2, [r1, #8]
 800b05c:	f002 020c 	and.w	r2, r2, #12
 800b060:	2a08      	cmp	r2, #8
 800b062:	f000 80f5 	beq.w	800b250 <HAL_RCC_OscConfig+0x218>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800b066:	6863      	ldr	r3, [r4, #4]
 800b068:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800b06c:	d010      	beq.n	800b090 <HAL_RCC_OscConfig+0x58>
 800b06e:	2b00      	cmp	r3, #0
 800b070:	f000 811a 	beq.w	800b2a8 <HAL_RCC_OscConfig+0x270>
 800b074:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800b078:	4ba1      	ldr	r3, [pc, #644]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b07a:	681a      	ldr	r2, [r3, #0]
 800b07c:	f000 8164 	beq.w	800b348 <HAL_RCC_OscConfig+0x310>
 800b080:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800b084:	601a      	str	r2, [r3, #0]
 800b086:	681a      	ldr	r2, [r3, #0]
 800b088:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800b08c:	601a      	str	r2, [r3, #0]
 800b08e:	e004      	b.n	800b09a <HAL_RCC_OscConfig+0x62>
 800b090:	4a9b      	ldr	r2, [pc, #620]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b092:	6813      	ldr	r3, [r2, #0]
 800b094:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800b098:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800b09a:	f7ff fcf3 	bl	800aa84 <HAL_GetTick>

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800b09e:	4d98      	ldr	r5, [pc, #608]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
        tickstart = HAL_GetTick();
 800b0a0:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800b0a2:	e005      	b.n	800b0b0 <HAL_RCC_OscConfig+0x78>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800b0a4:	f7ff fcee 	bl	800aa84 <HAL_GetTick>
 800b0a8:	1b80      	subs	r0, r0, r6
 800b0aa:	2864      	cmp	r0, #100	; 0x64
 800b0ac:	f200 80ef 	bhi.w	800b28e <HAL_RCC_OscConfig+0x256>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800b0b0:	682b      	ldr	r3, [r5, #0]
 800b0b2:	039a      	lsls	r2, r3, #14
 800b0b4:	d5f6      	bpl.n	800b0a4 <HAL_RCC_OscConfig+0x6c>
 800b0b6:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800b0b8:	079f      	lsls	r7, r3, #30
 800b0ba:	d442      	bmi.n	800b142 <HAL_RCC_OscConfig+0x10a>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800b0bc:	071a      	lsls	r2, r3, #28
 800b0be:	d517      	bpl.n	800b0f0 <HAL_RCC_OscConfig+0xb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 800b0c0:	6963      	ldr	r3, [r4, #20]
 800b0c2:	2b00      	cmp	r3, #0
 800b0c4:	f000 80b1 	beq.w	800b22a <HAL_RCC_OscConfig+0x1f2>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800b0c8:	4b8d      	ldr	r3, [pc, #564]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b0ca:	6f5a      	ldr	r2, [r3, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800b0cc:	461d      	mov	r5, r3
      __HAL_RCC_LSI_ENABLE();
 800b0ce:	f042 0201 	orr.w	r2, r2, #1
 800b0d2:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 800b0d4:	f7ff fcd6 	bl	800aa84 <HAL_GetTick>
 800b0d8:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800b0da:	e005      	b.n	800b0e8 <HAL_RCC_OscConfig+0xb0>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800b0dc:	f7ff fcd2 	bl	800aa84 <HAL_GetTick>
 800b0e0:	1b80      	subs	r0, r0, r6
 800b0e2:	2802      	cmp	r0, #2
 800b0e4:	f200 80d3 	bhi.w	800b28e <HAL_RCC_OscConfig+0x256>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800b0e8:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800b0ea:	079b      	lsls	r3, r3, #30
 800b0ec:	d5f6      	bpl.n	800b0dc <HAL_RCC_OscConfig+0xa4>
 800b0ee:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800b0f0:	075d      	lsls	r5, r3, #29
 800b0f2:	d56b      	bpl.n	800b1cc <HAL_RCC_OscConfig+0x194>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 800b0f4:	4b82      	ldr	r3, [pc, #520]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b0f6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800b0f8:	00d0      	lsls	r0, r2, #3
 800b0fa:	f100 80ee 	bmi.w	800b2da <HAL_RCC_OscConfig+0x2a2>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 800b0fe:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      pwrclkchanged = SET;
 800b100:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 800b102:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800b106:	641a      	str	r2, [r3, #64]	; 0x40
 800b108:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b10a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800b10e:	9301      	str	r3, [sp, #4]
 800b110:	9b01      	ldr	r3, [sp, #4]
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800b112:	4b7c      	ldr	r3, [pc, #496]	; (800b304 <HAL_RCC_OscConfig+0x2cc>)
 800b114:	681a      	ldr	r2, [r3, #0]
 800b116:	05d1      	lsls	r1, r2, #23
 800b118:	f140 80a8 	bpl.w	800b26c <HAL_RCC_OscConfig+0x234>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800b11c:	68a3      	ldr	r3, [r4, #8]
 800b11e:	2b01      	cmp	r3, #1
 800b120:	d039      	beq.n	800b196 <HAL_RCC_OscConfig+0x15e>
 800b122:	2b00      	cmp	r3, #0
 800b124:	f000 80db 	beq.w	800b2de <HAL_RCC_OscConfig+0x2a6>
 800b128:	2b05      	cmp	r3, #5
 800b12a:	4b75      	ldr	r3, [pc, #468]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b12c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800b12e:	f000 8113 	beq.w	800b358 <HAL_RCC_OscConfig+0x320>
 800b132:	f022 0201 	bic.w	r2, r2, #1
 800b136:	671a      	str	r2, [r3, #112]	; 0x70
 800b138:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800b13a:	f022 0204 	bic.w	r2, r2, #4
 800b13e:	671a      	str	r2, [r3, #112]	; 0x70
 800b140:	e02e      	b.n	800b1a0 <HAL_RCC_OscConfig+0x168>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 800b142:	4a6f      	ldr	r2, [pc, #444]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b144:	6891      	ldr	r1, [r2, #8]
 800b146:	f011 0f0c 	tst.w	r1, #12
 800b14a:	d063      	beq.n	800b214 <HAL_RCC_OscConfig+0x1dc>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800b14c:	6891      	ldr	r1, [r2, #8]
 800b14e:	f001 010c 	and.w	r1, r1, #12
 800b152:	2908      	cmp	r1, #8
 800b154:	d05b      	beq.n	800b20e <HAL_RCC_OscConfig+0x1d6>
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 800b156:	68e3      	ldr	r3, [r4, #12]
 800b158:	2b00      	cmp	r3, #0
 800b15a:	f000 80e1 	beq.w	800b320 <HAL_RCC_OscConfig+0x2e8>
        __HAL_RCC_HSI_ENABLE();
 800b15e:	4b68      	ldr	r3, [pc, #416]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b160:	681a      	ldr	r2, [r3, #0]
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800b162:	461d      	mov	r5, r3
        __HAL_RCC_HSI_ENABLE();
 800b164:	f042 0201 	orr.w	r2, r2, #1
 800b168:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800b16a:	f7ff fc8b 	bl	800aa84 <HAL_GetTick>
 800b16e:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800b170:	e005      	b.n	800b17e <HAL_RCC_OscConfig+0x146>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800b172:	f7ff fc87 	bl	800aa84 <HAL_GetTick>
 800b176:	1b80      	subs	r0, r0, r6
 800b178:	2802      	cmp	r0, #2
 800b17a:	f200 8088 	bhi.w	800b28e <HAL_RCC_OscConfig+0x256>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800b17e:	682b      	ldr	r3, [r5, #0]
 800b180:	0798      	lsls	r0, r3, #30
 800b182:	d5f6      	bpl.n	800b172 <HAL_RCC_OscConfig+0x13a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800b184:	682b      	ldr	r3, [r5, #0]
 800b186:	6922      	ldr	r2, [r4, #16]
 800b188:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800b18c:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800b190:	602b      	str	r3, [r5, #0]
 800b192:	6823      	ldr	r3, [r4, #0]
 800b194:	e792      	b.n	800b0bc <HAL_RCC_OscConfig+0x84>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800b196:	4a5a      	ldr	r2, [pc, #360]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b198:	6f13      	ldr	r3, [r2, #112]	; 0x70
 800b19a:	f043 0301 	orr.w	r3, r3, #1
 800b19e:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800b1a0:	f7ff fc70 	bl	800aa84 <HAL_GetTick>

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800b1a4:	4e56      	ldr	r6, [pc, #344]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
      tickstart = HAL_GetTick();
 800b1a6:	4680      	mov	r8, r0
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800b1a8:	f241 3788 	movw	r7, #5000	; 0x1388
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800b1ac:	e005      	b.n	800b1ba <HAL_RCC_OscConfig+0x182>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800b1ae:	f7ff fc69 	bl	800aa84 <HAL_GetTick>
 800b1b2:	eba0 0008 	sub.w	r0, r0, r8
 800b1b6:	42b8      	cmp	r0, r7
 800b1b8:	d869      	bhi.n	800b28e <HAL_RCC_OscConfig+0x256>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800b1ba:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800b1bc:	079b      	lsls	r3, r3, #30
 800b1be:	d5f6      	bpl.n	800b1ae <HAL_RCC_OscConfig+0x176>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 800b1c0:	b125      	cbz	r5, 800b1cc <HAL_RCC_OscConfig+0x194>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800b1c2:	4a4f      	ldr	r2, [pc, #316]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b1c4:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800b1c6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800b1ca:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800b1cc:	69a0      	ldr	r0, [r4, #24]
 800b1ce:	b1d0      	cbz	r0, 800b206 <HAL_RCC_OscConfig+0x1ce>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800b1d0:	4b4b      	ldr	r3, [pc, #300]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b1d2:	689a      	ldr	r2, [r3, #8]
 800b1d4:	f002 020c 	and.w	r2, r2, #12
 800b1d8:	2a08      	cmp	r2, #8
 800b1da:	f000 80c5 	beq.w	800b368 <HAL_RCC_OscConfig+0x330>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800b1de:	2802      	cmp	r0, #2
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800b1e0:	681a      	ldr	r2, [r3, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800b1e2:	f000 80eb 	beq.w	800b3bc <HAL_RCC_OscConfig+0x384>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800b1e6:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800b1ea:	461c      	mov	r4, r3
        __HAL_RCC_PLL_DISABLE();
 800b1ec:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800b1ee:	f7ff fc49 	bl	800aa84 <HAL_GetTick>
 800b1f2:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800b1f4:	e004      	b.n	800b200 <HAL_RCC_OscConfig+0x1c8>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800b1f6:	f7ff fc45 	bl	800aa84 <HAL_GetTick>
 800b1fa:	1b40      	subs	r0, r0, r5
 800b1fc:	2802      	cmp	r0, #2
 800b1fe:	d846      	bhi.n	800b28e <HAL_RCC_OscConfig+0x256>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800b200:	6823      	ldr	r3, [r4, #0]
 800b202:	019b      	lsls	r3, r3, #6
 800b204:	d4f7      	bmi.n	800b1f6 <HAL_RCC_OscConfig+0x1be>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 800b206:	2000      	movs	r0, #0
}
 800b208:	b002      	add	sp, #8
 800b20a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800b20e:	6852      	ldr	r2, [r2, #4]
 800b210:	0256      	lsls	r6, r2, #9
 800b212:	d4a0      	bmi.n	800b156 <HAL_RCC_OscConfig+0x11e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800b214:	4a3a      	ldr	r2, [pc, #232]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b216:	6812      	ldr	r2, [r2, #0]
 800b218:	0795      	lsls	r5, r2, #30
 800b21a:	d53c      	bpl.n	800b296 <HAL_RCC_OscConfig+0x25e>
 800b21c:	68e2      	ldr	r2, [r4, #12]
 800b21e:	2a01      	cmp	r2, #1
 800b220:	d039      	beq.n	800b296 <HAL_RCC_OscConfig+0x25e>
        return HAL_ERROR;
 800b222:	2001      	movs	r0, #1
}
 800b224:	b002      	add	sp, #8
 800b226:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 800b22a:	4b35      	ldr	r3, [pc, #212]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b22c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800b22e:	461d      	mov	r5, r3
      __HAL_RCC_LSI_DISABLE();
 800b230:	f022 0201 	bic.w	r2, r2, #1
 800b234:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 800b236:	f7ff fc25 	bl	800aa84 <HAL_GetTick>
 800b23a:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800b23c:	e004      	b.n	800b248 <HAL_RCC_OscConfig+0x210>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800b23e:	f7ff fc21 	bl	800aa84 <HAL_GetTick>
 800b242:	1b80      	subs	r0, r0, r6
 800b244:	2802      	cmp	r0, #2
 800b246:	d822      	bhi.n	800b28e <HAL_RCC_OscConfig+0x256>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800b248:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800b24a:	079f      	lsls	r7, r3, #30
 800b24c:	d4f7      	bmi.n	800b23e <HAL_RCC_OscConfig+0x206>
 800b24e:	e74e      	b.n	800b0ee <HAL_RCC_OscConfig+0xb6>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800b250:	684a      	ldr	r2, [r1, #4]
 800b252:	0250      	lsls	r0, r2, #9
 800b254:	f57f af07 	bpl.w	800b066 <HAL_RCC_OscConfig+0x2e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800b258:	4a29      	ldr	r2, [pc, #164]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b25a:	6812      	ldr	r2, [r2, #0]
 800b25c:	0391      	lsls	r1, r2, #14
 800b25e:	f57f af2b 	bpl.w	800b0b8 <HAL_RCC_OscConfig+0x80>
 800b262:	6862      	ldr	r2, [r4, #4]
 800b264:	2a00      	cmp	r2, #0
 800b266:	f47f af27 	bne.w	800b0b8 <HAL_RCC_OscConfig+0x80>
 800b26a:	e7da      	b.n	800b222 <HAL_RCC_OscConfig+0x1ea>
      PWR->CR1 |= PWR_CR1_DBP;
 800b26c:	681a      	ldr	r2, [r3, #0]
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800b26e:	461e      	mov	r6, r3
      PWR->CR1 |= PWR_CR1_DBP;
 800b270:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800b274:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 800b276:	f7ff fc05 	bl	800aa84 <HAL_GetTick>
 800b27a:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800b27c:	6833      	ldr	r3, [r6, #0]
 800b27e:	05da      	lsls	r2, r3, #23
 800b280:	f53f af4c 	bmi.w	800b11c <HAL_RCC_OscConfig+0xe4>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800b284:	f7ff fbfe 	bl	800aa84 <HAL_GetTick>
 800b288:	1bc0      	subs	r0, r0, r7
 800b28a:	2864      	cmp	r0, #100	; 0x64
 800b28c:	d9f6      	bls.n	800b27c <HAL_RCC_OscConfig+0x244>
            return HAL_TIMEOUT;
 800b28e:	2003      	movs	r0, #3
}
 800b290:	b002      	add	sp, #8
 800b292:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800b296:	491a      	ldr	r1, [pc, #104]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b298:	6920      	ldr	r0, [r4, #16]
 800b29a:	680a      	ldr	r2, [r1, #0]
 800b29c:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 800b2a0:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 800b2a4:	600a      	str	r2, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800b2a6:	e709      	b.n	800b0bc <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800b2a8:	4b15      	ldr	r3, [pc, #84]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
 800b2aa:	681a      	ldr	r2, [r3, #0]
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800b2ac:	461d      	mov	r5, r3
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800b2ae:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800b2b2:	601a      	str	r2, [r3, #0]
 800b2b4:	681a      	ldr	r2, [r3, #0]
 800b2b6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800b2ba:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800b2bc:	f7ff fbe2 	bl	800aa84 <HAL_GetTick>
 800b2c0:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800b2c2:	e004      	b.n	800b2ce <HAL_RCC_OscConfig+0x296>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800b2c4:	f7ff fbde 	bl	800aa84 <HAL_GetTick>
 800b2c8:	1b80      	subs	r0, r0, r6
 800b2ca:	2864      	cmp	r0, #100	; 0x64
 800b2cc:	d8df      	bhi.n	800b28e <HAL_RCC_OscConfig+0x256>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800b2ce:	682b      	ldr	r3, [r5, #0]
 800b2d0:	039b      	lsls	r3, r3, #14
 800b2d2:	d4f7      	bmi.n	800b2c4 <HAL_RCC_OscConfig+0x28c>
 800b2d4:	e6ef      	b.n	800b0b6 <HAL_RCC_OscConfig+0x7e>
    return HAL_ERROR;
 800b2d6:	2001      	movs	r0, #1
}
 800b2d8:	4770      	bx	lr
  FlagStatus pwrclkchanged = RESET;
 800b2da:	2500      	movs	r5, #0
 800b2dc:	e719      	b.n	800b112 <HAL_RCC_OscConfig+0xda>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800b2de:	4b08      	ldr	r3, [pc, #32]	; (800b300 <HAL_RCC_OscConfig+0x2c8>)
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800b2e0:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800b2e4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800b2e6:	461e      	mov	r6, r3
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800b2e8:	f022 0201 	bic.w	r2, r2, #1
 800b2ec:	671a      	str	r2, [r3, #112]	; 0x70
 800b2ee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800b2f0:	f022 0204 	bic.w	r2, r2, #4
 800b2f4:	671a      	str	r2, [r3, #112]	; 0x70
      tickstart = HAL_GetTick();
 800b2f6:	f7ff fbc5 	bl	800aa84 <HAL_GetTick>
 800b2fa:	4607      	mov	r7, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800b2fc:	e009      	b.n	800b312 <HAL_RCC_OscConfig+0x2da>
 800b2fe:	bf00      	nop
 800b300:	40023800 	.word	0x40023800
 800b304:	40007000 	.word	0x40007000
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800b308:	f7ff fbbc 	bl	800aa84 <HAL_GetTick>
 800b30c:	1bc0      	subs	r0, r0, r7
 800b30e:	4540      	cmp	r0, r8
 800b310:	d8bd      	bhi.n	800b28e <HAL_RCC_OscConfig+0x256>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800b312:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800b314:	0798      	lsls	r0, r3, #30
 800b316:	d4f7      	bmi.n	800b308 <HAL_RCC_OscConfig+0x2d0>
    if (pwrclkchanged == SET)
 800b318:	2d00      	cmp	r5, #0
 800b31a:	f43f af57 	beq.w	800b1cc <HAL_RCC_OscConfig+0x194>
 800b31e:	e750      	b.n	800b1c2 <HAL_RCC_OscConfig+0x18a>
        __HAL_RCC_HSI_DISABLE();
 800b320:	4b41      	ldr	r3, [pc, #260]	; (800b428 <HAL_RCC_OscConfig+0x3f0>)
 800b322:	681a      	ldr	r2, [r3, #0]
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800b324:	461d      	mov	r5, r3
        __HAL_RCC_HSI_DISABLE();
 800b326:	f022 0201 	bic.w	r2, r2, #1
 800b32a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800b32c:	f7ff fbaa 	bl	800aa84 <HAL_GetTick>
 800b330:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800b332:	e004      	b.n	800b33e <HAL_RCC_OscConfig+0x306>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 800b334:	f7ff fba6 	bl	800aa84 <HAL_GetTick>
 800b338:	1b80      	subs	r0, r0, r6
 800b33a:	2802      	cmp	r0, #2
 800b33c:	d8a7      	bhi.n	800b28e <HAL_RCC_OscConfig+0x256>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800b33e:	682b      	ldr	r3, [r5, #0]
 800b340:	0799      	lsls	r1, r3, #30
 800b342:	d4f7      	bmi.n	800b334 <HAL_RCC_OscConfig+0x2fc>
 800b344:	6823      	ldr	r3, [r4, #0]
 800b346:	e6b9      	b.n	800b0bc <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800b348:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800b34c:	601a      	str	r2, [r3, #0]
 800b34e:	681a      	ldr	r2, [r3, #0]
 800b350:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800b354:	601a      	str	r2, [r3, #0]
 800b356:	e6a0      	b.n	800b09a <HAL_RCC_OscConfig+0x62>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800b358:	f042 0204 	orr.w	r2, r2, #4
 800b35c:	671a      	str	r2, [r3, #112]	; 0x70
 800b35e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800b360:	f042 0201 	orr.w	r2, r2, #1
 800b364:	671a      	str	r2, [r3, #112]	; 0x70
 800b366:	e71b      	b.n	800b1a0 <HAL_RCC_OscConfig+0x168>
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800b368:	2801      	cmp	r0, #1
      pll_config = RCC->PLLCFGR;
 800b36a:	685a      	ldr	r2, [r3, #4]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800b36c:	f43f af5a 	beq.w	800b224 <HAL_RCC_OscConfig+0x1ec>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800b370:	f402 0380 	and.w	r3, r2, #4194304	; 0x400000
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800b374:	69e1      	ldr	r1, [r4, #28]
 800b376:	428b      	cmp	r3, r1
 800b378:	f47f af53 	bne.w	800b222 <HAL_RCC_OscConfig+0x1ea>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800b37c:	f002 033f 	and.w	r3, r2, #63	; 0x3f
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800b380:	6a21      	ldr	r1, [r4, #32]
 800b382:	428b      	cmp	r3, r1
 800b384:	f47f af4d 	bne.w	800b222 <HAL_RCC_OscConfig+0x1ea>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 800b388:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800b38c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800b38e:	4013      	ands	r3, r2
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 800b390:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
 800b394:	f47f af45 	bne.w	800b222 <HAL_RCC_OscConfig+0x1ea>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 800b398:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800b39a:	f402 3140 	and.w	r1, r2, #196608	; 0x30000
 800b39e:	085b      	lsrs	r3, r3, #1
 800b3a0:	3b01      	subs	r3, #1
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 800b3a2:	ebb1 4f03 	cmp.w	r1, r3, lsl #16
 800b3a6:	f47f af3c 	bne.w	800b222 <HAL_RCC_OscConfig+0x1ea>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 800b3aa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800b3ac:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 800b3b0:	ebb2 6f03 	cmp.w	r2, r3, lsl #24
    return HAL_ERROR;
 800b3b4:	bf14      	ite	ne
 800b3b6:	2001      	movne	r0, #1
 800b3b8:	2000      	moveq	r0, #0
 800b3ba:	e733      	b.n	800b224 <HAL_RCC_OscConfig+0x1ec>
        __HAL_RCC_PLL_DISABLE();
 800b3bc:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800b3c0:	461d      	mov	r5, r3
        __HAL_RCC_PLL_DISABLE();
 800b3c2:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800b3c4:	f7ff fb5e 	bl	800aa84 <HAL_GetTick>
 800b3c8:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800b3ca:	e005      	b.n	800b3d8 <HAL_RCC_OscConfig+0x3a0>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800b3cc:	f7ff fb5a 	bl	800aa84 <HAL_GetTick>
 800b3d0:	1b80      	subs	r0, r0, r6
 800b3d2:	2802      	cmp	r0, #2
 800b3d4:	f63f af5b 	bhi.w	800b28e <HAL_RCC_OscConfig+0x256>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800b3d8:	682b      	ldr	r3, [r5, #0]
 800b3da:	0199      	lsls	r1, r3, #6
 800b3dc:	d4f6      	bmi.n	800b3cc <HAL_RCC_OscConfig+0x394>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800b3de:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 800b3e2:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800b3e4:	4313      	orrs	r3, r2
 800b3e6:	e9d4 210a 	ldrd	r2, r1, [r4, #40]	; 0x28
 800b3ea:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800b3ee:	4c0e      	ldr	r4, [pc, #56]	; (800b428 <HAL_RCC_OscConfig+0x3f0>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800b3f0:	0852      	lsrs	r2, r2, #1
 800b3f2:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 800b3f6:	3a01      	subs	r2, #1
 800b3f8:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800b3fc:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800b400:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 800b402:	682b      	ldr	r3, [r5, #0]
 800b404:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800b408:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800b40a:	f7ff fb3b 	bl	800aa84 <HAL_GetTick>
 800b40e:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800b410:	e005      	b.n	800b41e <HAL_RCC_OscConfig+0x3e6>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800b412:	f7ff fb37 	bl	800aa84 <HAL_GetTick>
 800b416:	1b40      	subs	r0, r0, r5
 800b418:	2802      	cmp	r0, #2
 800b41a:	f63f af38 	bhi.w	800b28e <HAL_RCC_OscConfig+0x256>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800b41e:	6823      	ldr	r3, [r4, #0]
 800b420:	019a      	lsls	r2, r3, #6
 800b422:	d5f6      	bpl.n	800b412 <HAL_RCC_OscConfig+0x3da>
 800b424:	e6ef      	b.n	800b206 <HAL_RCC_OscConfig+0x1ce>
 800b426:	bf00      	nop
 800b428:	40023800 	.word	0x40023800

0800b42c <HAL_RCC_ClockConfig>:
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t tickstart = 0;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 800b42c:	b178      	cbz	r0, 800b44e <HAL_RCC_ClockConfig+0x22>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800b42e:	4a5e      	ldr	r2, [pc, #376]	; (800b5a8 <HAL_RCC_ClockConfig+0x17c>)
 800b430:	6813      	ldr	r3, [r2, #0]
 800b432:	f003 030f 	and.w	r3, r3, #15
 800b436:	428b      	cmp	r3, r1
 800b438:	d20b      	bcs.n	800b452 <HAL_RCC_ClockConfig+0x26>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800b43a:	6813      	ldr	r3, [r2, #0]
 800b43c:	f023 030f 	bic.w	r3, r3, #15
 800b440:	430b      	orrs	r3, r1
 800b442:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800b444:	6813      	ldr	r3, [r2, #0]
 800b446:	f003 030f 	and.w	r3, r3, #15
 800b44a:	428b      	cmp	r3, r1
 800b44c:	d001      	beq.n	800b452 <HAL_RCC_ClockConfig+0x26>
    return HAL_ERROR;
 800b44e:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);

  return HAL_OK;
}
 800b450:	4770      	bx	lr
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800b452:	6803      	ldr	r3, [r0, #0]
{
 800b454:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800b458:	079d      	lsls	r5, r3, #30
 800b45a:	d514      	bpl.n	800b486 <HAL_RCC_ClockConfig+0x5a>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800b45c:	075c      	lsls	r4, r3, #29
 800b45e:	d504      	bpl.n	800b46a <HAL_RCC_ClockConfig+0x3e>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800b460:	4c52      	ldr	r4, [pc, #328]	; (800b5ac <HAL_RCC_ClockConfig+0x180>)
 800b462:	68a2      	ldr	r2, [r4, #8]
 800b464:	f442 52e0 	orr.w	r2, r2, #7168	; 0x1c00
 800b468:	60a2      	str	r2, [r4, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800b46a:	071a      	lsls	r2, r3, #28
 800b46c:	d504      	bpl.n	800b478 <HAL_RCC_ClockConfig+0x4c>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800b46e:	4c4f      	ldr	r4, [pc, #316]	; (800b5ac <HAL_RCC_ClockConfig+0x180>)
 800b470:	68a2      	ldr	r2, [r4, #8]
 800b472:	f442 4260 	orr.w	r2, r2, #57344	; 0xe000
 800b476:	60a2      	str	r2, [r4, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800b478:	4c4c      	ldr	r4, [pc, #304]	; (800b5ac <HAL_RCC_ClockConfig+0x180>)
 800b47a:	6885      	ldr	r5, [r0, #8]
 800b47c:	68a2      	ldr	r2, [r4, #8]
 800b47e:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 800b482:	432a      	orrs	r2, r5
 800b484:	60a2      	str	r2, [r4, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800b486:	07df      	lsls	r7, r3, #31
 800b488:	4604      	mov	r4, r0
 800b48a:	460d      	mov	r5, r1
 800b48c:	d521      	bpl.n	800b4d2 <HAL_RCC_ClockConfig+0xa6>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800b48e:	6842      	ldr	r2, [r0, #4]
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800b490:	4b46      	ldr	r3, [pc, #280]	; (800b5ac <HAL_RCC_ClockConfig+0x180>)
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800b492:	2a01      	cmp	r2, #1
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800b494:	681b      	ldr	r3, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800b496:	d063      	beq.n	800b560 <HAL_RCC_ClockConfig+0x134>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800b498:	2a02      	cmp	r2, #2
 800b49a:	d079      	beq.n	800b590 <HAL_RCC_ClockConfig+0x164>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800b49c:	0799      	lsls	r1, r3, #30
 800b49e:	d528      	bpl.n	800b4f2 <HAL_RCC_ClockConfig+0xc6>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800b4a0:	4942      	ldr	r1, [pc, #264]	; (800b5ac <HAL_RCC_ClockConfig+0x180>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800b4a2:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800b4a6:	688b      	ldr	r3, [r1, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800b4a8:	460e      	mov	r6, r1
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800b4aa:	f023 0303 	bic.w	r3, r3, #3
 800b4ae:	4313      	orrs	r3, r2
 800b4b0:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 800b4b2:	f7ff fae7 	bl	800aa84 <HAL_GetTick>
 800b4b6:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800b4b8:	e004      	b.n	800b4c4 <HAL_RCC_ClockConfig+0x98>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800b4ba:	f7ff fae3 	bl	800aa84 <HAL_GetTick>
 800b4be:	1bc0      	subs	r0, r0, r7
 800b4c0:	4540      	cmp	r0, r8
 800b4c2:	d863      	bhi.n	800b58c <HAL_RCC_ClockConfig+0x160>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800b4c4:	68b3      	ldr	r3, [r6, #8]
 800b4c6:	6862      	ldr	r2, [r4, #4]
 800b4c8:	f003 030c 	and.w	r3, r3, #12
 800b4cc:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 800b4d0:	d1f3      	bne.n	800b4ba <HAL_RCC_ClockConfig+0x8e>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800b4d2:	4a35      	ldr	r2, [pc, #212]	; (800b5a8 <HAL_RCC_ClockConfig+0x17c>)
 800b4d4:	6813      	ldr	r3, [r2, #0]
 800b4d6:	f003 030f 	and.w	r3, r3, #15
 800b4da:	42ab      	cmp	r3, r5
 800b4dc:	d90c      	bls.n	800b4f8 <HAL_RCC_ClockConfig+0xcc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800b4de:	6813      	ldr	r3, [r2, #0]
 800b4e0:	f023 030f 	bic.w	r3, r3, #15
 800b4e4:	432b      	orrs	r3, r5
 800b4e6:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800b4e8:	6813      	ldr	r3, [r2, #0]
 800b4ea:	f003 030f 	and.w	r3, r3, #15
 800b4ee:	42ab      	cmp	r3, r5
 800b4f0:	d002      	beq.n	800b4f8 <HAL_RCC_ClockConfig+0xcc>
    return HAL_ERROR;
 800b4f2:	2001      	movs	r0, #1
}
 800b4f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800b4f8:	6823      	ldr	r3, [r4, #0]
 800b4fa:	075a      	lsls	r2, r3, #29
 800b4fc:	d506      	bpl.n	800b50c <HAL_RCC_ClockConfig+0xe0>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800b4fe:	492b      	ldr	r1, [pc, #172]	; (800b5ac <HAL_RCC_ClockConfig+0x180>)
 800b500:	68e0      	ldr	r0, [r4, #12]
 800b502:	688a      	ldr	r2, [r1, #8]
 800b504:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 800b508:	4302      	orrs	r2, r0
 800b50a:	608a      	str	r2, [r1, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800b50c:	071b      	lsls	r3, r3, #28
 800b50e:	d507      	bpl.n	800b520 <HAL_RCC_ClockConfig+0xf4>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800b510:	4a26      	ldr	r2, [pc, #152]	; (800b5ac <HAL_RCC_ClockConfig+0x180>)
 800b512:	6921      	ldr	r1, [r4, #16]
 800b514:	6893      	ldr	r3, [r2, #8]
 800b516:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800b51a:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800b51e:	6093      	str	r3, [r2, #8]
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800b520:	4922      	ldr	r1, [pc, #136]	; (800b5ac <HAL_RCC_ClockConfig+0x180>)
 800b522:	688b      	ldr	r3, [r1, #8]
 800b524:	f003 030c 	and.w	r3, r3, #12
 800b528:	2b04      	cmp	r3, #4
 800b52a:	d01c      	beq.n	800b566 <HAL_RCC_ClockConfig+0x13a>
 800b52c:	2b08      	cmp	r3, #8
 800b52e:	d12b      	bne.n	800b588 <HAL_RCC_ClockConfig+0x15c>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800b530:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800b532:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800b534:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800b538:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800b53a:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
 800b53e:	d12a      	bne.n	800b596 <HAL_RCC_ClockConfig+0x16a>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800b540:	481b      	ldr	r0, [pc, #108]	; (800b5b0 <HAL_RCC_ClockConfig+0x184>)
 800b542:	f3c1 1188 	ubfx	r1, r1, #6, #9
 800b546:	fba1 0100 	umull	r0, r1, r1, r0
 800b54a:	f7f4 ffad 	bl	80004a8 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 800b54e:	4b17      	ldr	r3, [pc, #92]	; (800b5ac <HAL_RCC_ClockConfig+0x180>)
 800b550:	685b      	ldr	r3, [r3, #4]
 800b552:	f3c3 4301 	ubfx	r3, r3, #16, #2
 800b556:	3301      	adds	r3, #1
 800b558:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco / pllp;
 800b55a:	fbb0 f3f3 	udiv	r3, r0, r3
 800b55e:	e003      	b.n	800b568 <HAL_RCC_ClockConfig+0x13c>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800b560:	039e      	lsls	r6, r3, #14
 800b562:	d49d      	bmi.n	800b4a0 <HAL_RCC_ClockConfig+0x74>
 800b564:	e7c5      	b.n	800b4f2 <HAL_RCC_ClockConfig+0xc6>
      sysclockfreq = HSE_VALUE;
 800b566:	4b13      	ldr	r3, [pc, #76]	; (800b5b4 <HAL_RCC_ClockConfig+0x188>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800b568:	4a10      	ldr	r2, [pc, #64]	; (800b5ac <HAL_RCC_ClockConfig+0x180>)
 800b56a:	4c13      	ldr	r4, [pc, #76]	; (800b5b8 <HAL_RCC_ClockConfig+0x18c>)
 800b56c:	6892      	ldr	r2, [r2, #8]
  HAL_InitTick(uwTickPrio);
 800b56e:	4813      	ldr	r0, [pc, #76]	; (800b5bc <HAL_RCC_ClockConfig+0x190>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800b570:	f3c2 1203 	ubfx	r2, r2, #4, #4
 800b574:	4912      	ldr	r1, [pc, #72]	; (800b5c0 <HAL_RCC_ClockConfig+0x194>)
  HAL_InitTick(uwTickPrio);
 800b576:	6800      	ldr	r0, [r0, #0]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800b578:	5ca2      	ldrb	r2, [r4, r2]
 800b57a:	40d3      	lsrs	r3, r2
 800b57c:	600b      	str	r3, [r1, #0]
  HAL_InitTick(uwTickPrio);
 800b57e:	f000 f8e9 	bl	800b754 <HAL_InitTick>
  return HAL_OK;
 800b582:	2000      	movs	r0, #0
}
 800b584:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      sysclockfreq = HSI_VALUE;
 800b588:	4b09      	ldr	r3, [pc, #36]	; (800b5b0 <HAL_RCC_ClockConfig+0x184>)
 800b58a:	e7ed      	b.n	800b568 <HAL_RCC_ClockConfig+0x13c>
        return HAL_TIMEOUT;
 800b58c:	2003      	movs	r0, #3
 800b58e:	e7b1      	b.n	800b4f4 <HAL_RCC_ClockConfig+0xc8>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800b590:	0198      	lsls	r0, r3, #6
 800b592:	d485      	bmi.n	800b4a0 <HAL_RCC_ClockConfig+0x74>
 800b594:	e7ad      	b.n	800b4f2 <HAL_RCC_ClockConfig+0xc6>
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800b596:	4807      	ldr	r0, [pc, #28]	; (800b5b4 <HAL_RCC_ClockConfig+0x188>)
 800b598:	f3c1 1188 	ubfx	r1, r1, #6, #9
 800b59c:	2300      	movs	r3, #0
 800b59e:	fba1 0100 	umull	r0, r1, r1, r0
 800b5a2:	f7f4 ff81 	bl	80004a8 <__aeabi_uldivmod>
 800b5a6:	e7d2      	b.n	800b54e <HAL_RCC_ClockConfig+0x122>
 800b5a8:	40023c00 	.word	0x40023c00
 800b5ac:	40023800 	.word	0x40023800
 800b5b0:	00f42400 	.word	0x00f42400
 800b5b4:	017d7840 	.word	0x017d7840
 800b5b8:	0800dea4 	.word	0x0800dea4
 800b5bc:	2000015c 	.word	0x2000015c
 800b5c0:	20000160 	.word	0x20000160

0800b5c4 <HAL_RCC_GetSysClockFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800b5c4:	4916      	ldr	r1, [pc, #88]	; (800b620 <HAL_RCC_GetSysClockFreq+0x5c>)
{
 800b5c6:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800b5c8:	688b      	ldr	r3, [r1, #8]
 800b5ca:	f003 030c 	and.w	r3, r3, #12
 800b5ce:	2b04      	cmp	r3, #4
 800b5d0:	d01b      	beq.n	800b60a <HAL_RCC_GetSysClockFreq+0x46>
 800b5d2:	2b08      	cmp	r3, #8
 800b5d4:	d117      	bne.n	800b606 <HAL_RCC_GetSysClockFreq+0x42>
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800b5d6:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800b5d8:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800b5da:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800b5de:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800b5e0:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
 800b5e4:	d113      	bne.n	800b60e <HAL_RCC_GetSysClockFreq+0x4a>
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800b5e6:	480f      	ldr	r0, [pc, #60]	; (800b624 <HAL_RCC_GetSysClockFreq+0x60>)
 800b5e8:	f3c1 1188 	ubfx	r1, r1, #6, #9
 800b5ec:	fba1 0100 	umull	r0, r1, r1, r0
 800b5f0:	f7f4 ff5a 	bl	80004a8 <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 800b5f4:	4b0a      	ldr	r3, [pc, #40]	; (800b620 <HAL_RCC_GetSysClockFreq+0x5c>)
 800b5f6:	685b      	ldr	r3, [r3, #4]
 800b5f8:	f3c3 4301 	ubfx	r3, r3, #16, #2
 800b5fc:	3301      	adds	r3, #1
 800b5fe:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco / pllp;
 800b600:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 800b604:	bd08      	pop	{r3, pc}
      sysclockfreq = HSI_VALUE;
 800b606:	4807      	ldr	r0, [pc, #28]	; (800b624 <HAL_RCC_GetSysClockFreq+0x60>)
}
 800b608:	bd08      	pop	{r3, pc}
      sysclockfreq = HSE_VALUE;
 800b60a:	4807      	ldr	r0, [pc, #28]	; (800b628 <HAL_RCC_GetSysClockFreq+0x64>)
}
 800b60c:	bd08      	pop	{r3, pc}
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800b60e:	4806      	ldr	r0, [pc, #24]	; (800b628 <HAL_RCC_GetSysClockFreq+0x64>)
 800b610:	f3c1 1188 	ubfx	r1, r1, #6, #9
 800b614:	2300      	movs	r3, #0
 800b616:	fba1 0100 	umull	r0, r1, r1, r0
 800b61a:	f7f4 ff45 	bl	80004a8 <__aeabi_uldivmod>
 800b61e:	e7e9      	b.n	800b5f4 <HAL_RCC_GetSysClockFreq+0x30>
 800b620:	40023800 	.word	0x40023800
 800b624:	00f42400 	.word	0x00f42400
 800b628:	017d7840 	.word	0x017d7840

0800b62c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800b62c:	4b04      	ldr	r3, [pc, #16]	; (800b640 <HAL_RCC_GetPCLK1Freq+0x14>)
 800b62e:	4a05      	ldr	r2, [pc, #20]	; (800b644 <HAL_RCC_GetPCLK1Freq+0x18>)
 800b630:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 800b632:	4905      	ldr	r1, [pc, #20]	; (800b648 <HAL_RCC_GetPCLK1Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800b634:	f3c3 2382 	ubfx	r3, r3, #10, #3
 800b638:	6808      	ldr	r0, [r1, #0]
 800b63a:	5cd3      	ldrb	r3, [r2, r3]
}
 800b63c:	40d8      	lsrs	r0, r3
 800b63e:	4770      	bx	lr
 800b640:	40023800 	.word	0x40023800
 800b644:	0800deb4 	.word	0x0800deb4
 800b648:	20000160 	.word	0x20000160

0800b64c <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800b64c:	4b04      	ldr	r3, [pc, #16]	; (800b660 <HAL_RCC_GetPCLK2Freq+0x14>)
 800b64e:	4a05      	ldr	r2, [pc, #20]	; (800b664 <HAL_RCC_GetPCLK2Freq+0x18>)
 800b650:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 800b652:	4905      	ldr	r1, [pc, #20]	; (800b668 <HAL_RCC_GetPCLK2Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800b654:	f3c3 3342 	ubfx	r3, r3, #13, #3
 800b658:	6808      	ldr	r0, [r1, #0]
 800b65a:	5cd3      	ldrb	r3, [r2, r3]
}
 800b65c:	40d8      	lsrs	r0, r3
 800b65e:	4770      	bx	lr
 800b660:	40023800 	.word	0x40023800
 800b664:	0800deb4 	.word	0x0800deb4
 800b668:	20000160 	.word	0x20000160

0800b66c <HAL_RCC_GetClockConfig>:
{
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 800b66c:	4b0e      	ldr	r3, [pc, #56]	; (800b6a8 <HAL_RCC_GetClockConfig+0x3c>)
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 800b66e:	220f      	movs	r2, #15
 800b670:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 800b672:	689a      	ldr	r2, [r3, #8]
 800b674:	f002 0203 	and.w	r2, r2, #3
 800b678:	6042      	str	r2, [r0, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 800b67a:	689a      	ldr	r2, [r3, #8]
 800b67c:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800b680:	6082      	str	r2, [r0, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 800b682:	689a      	ldr	r2, [r3, #8]
 800b684:	f402 52e0 	and.w	r2, r2, #7168	; 0x1c00
 800b688:	60c2      	str	r2, [r0, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 800b68a:	689b      	ldr	r3, [r3, #8]
 800b68c:	08db      	lsrs	r3, r3, #3
{
 800b68e:	b410      	push	{r4}
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 800b690:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800b694:	4c05      	ldr	r4, [pc, #20]	; (800b6ac <HAL_RCC_GetClockConfig+0x40>)
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 800b696:	6103      	str	r3, [r0, #16]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800b698:	6823      	ldr	r3, [r4, #0]
}
 800b69a:	f85d 4b04 	ldr.w	r4, [sp], #4
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800b69e:	f003 030f 	and.w	r3, r3, #15
 800b6a2:	600b      	str	r3, [r1, #0]
}
 800b6a4:	4770      	bx	lr
 800b6a6:	bf00      	nop
 800b6a8:	40023800 	.word	0x40023800
 800b6ac:	40023c00 	.word	0x40023c00

0800b6b0 <HAL_SDRAM_MspInit>:
  UNUSED(hsdram);
 
  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */ 
}
 800b6b0:	4770      	bx	lr
 800b6b2:	bf00      	nop

0800b6b4 <HAL_SDRAM_Init>:
  if(hsdram == NULL)
 800b6b4:	b1e8      	cbz	r0, 800b6f2 <HAL_SDRAM_Init+0x3e>
{   
 800b6b6:	b538      	push	{r3, r4, r5, lr}
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 800b6b8:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800b6bc:	4604      	mov	r4, r0
 800b6be:	460d      	mov	r5, r1
 800b6c0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800b6c4:	b183      	cbz	r3, 800b6e8 <HAL_SDRAM_Init+0x34>
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800b6c6:	2302      	movs	r3, #2
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800b6c8:	1d21      	adds	r1, r4, #4
 800b6ca:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800b6cc:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800b6d0:	f000 fad6 	bl	800bc80 <FMC_SDRAM_Init>
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 800b6d4:	4629      	mov	r1, r5
 800b6d6:	e9d4 0200 	ldrd	r0, r2, [r4]
 800b6da:	f000 fb0f 	bl	800bcfc <FMC_SDRAM_Timing_Init>
  hsdram->State = HAL_SDRAM_STATE_READY;
 800b6de:	2301      	movs	r3, #1
  return HAL_OK;
 800b6e0:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
 800b6e2:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 800b6e6:	bd38      	pop	{r3, r4, r5, pc}
    hsdram->Lock = HAL_UNLOCKED;
 800b6e8:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    HAL_SDRAM_MspInit(hsdram);
 800b6ec:	f7ff ffe0 	bl	800b6b0 <HAL_SDRAM_MspInit>
 800b6f0:	e7e9      	b.n	800b6c6 <HAL_SDRAM_Init+0x12>
    return HAL_ERROR;
 800b6f2:	2001      	movs	r0, #1
}
 800b6f4:	4770      	bx	lr
 800b6f6:	bf00      	nop

0800b6f8 <HAL_SDRAM_SendCommand>:
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 800b6f8:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 800b6fa:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800b6fe:	b2db      	uxtb	r3, r3
 800b700:	2b02      	cmp	r3, #2
 800b702:	d010      	beq.n	800b726 <HAL_SDRAM_SendCommand+0x2e>
 800b704:	4604      	mov	r4, r0
  {
    return HAL_BUSY;
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800b706:	2302      	movs	r3, #2
 800b708:	460d      	mov	r5, r1
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800b70a:	6800      	ldr	r0, [r0, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800b70c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800b710:	f000 fb46 	bl	800bda0 <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800b714:	682b      	ldr	r3, [r5, #0]
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
  }
  
  return HAL_OK;  
 800b716:	2000      	movs	r0, #0
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800b718:	2b02      	cmp	r3, #2
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800b71a:	bf0c      	ite	eq
 800b71c:	2305      	moveq	r3, #5
    hsdram->State = HAL_SDRAM_STATE_READY;
 800b71e:	2301      	movne	r3, #1
 800b720:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 800b724:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_BUSY;
 800b726:	4618      	mov	r0, r3
}
 800b728:	bd38      	pop	{r3, r4, r5, pc}
 800b72a:	bf00      	nop

0800b72c <HAL_SDRAM_ProgramRefreshRate>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 800b72c:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800b730:	b2db      	uxtb	r3, r3
 800b732:	2b02      	cmp	r3, #2
 800b734:	d00c      	beq.n	800b750 <HAL_SDRAM_ProgramRefreshRate+0x24>
  {
    return HAL_BUSY;
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800b736:	2302      	movs	r3, #2
{
 800b738:	b510      	push	{r4, lr}
 800b73a:	4604      	mov	r4, r0
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 800b73c:	6800      	ldr	r0, [r0, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800b73e:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 800b742:	f000 fb43 	bl	800bdcc <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 800b746:	2301      	movs	r3, #1
  
  return HAL_OK;   
 800b748:	2000      	movs	r0, #0
  hsdram->State = HAL_SDRAM_STATE_READY;
 800b74a:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
}
 800b74e:	bd10      	pop	{r4, pc}
    return HAL_BUSY;
 800b750:	4618      	mov	r0, r3
}
 800b752:	4770      	bx	lr

0800b754 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority)
{
 800b754:	b530      	push	{r4, r5, lr}
  uint32_t              uwTimclock, uwAPB1Prescaler = 0U;
  uint32_t              uwPrescalerValue = 0U;
  uint32_t              pFLatency;
  
    /*Configure the TIM6 IRQ priority */
  HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority ,0U);
 800b756:	4601      	mov	r1, r0
{
 800b758:	b089      	sub	sp, #36	; 0x24
  HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority ,0U);
 800b75a:	2200      	movs	r2, #0
 800b75c:	2036      	movs	r0, #54	; 0x36
 800b75e:	f7ff f9bd 	bl	800aadc <HAL_NVIC_SetPriority>
  
  /* Enable the TIM6 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 800b762:	2036      	movs	r0, #54	; 0x36
 800b764:	f7ff f9f0 	bl	800ab48 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM6 clock */
  __HAL_RCC_TIM6_CLK_ENABLE();
 800b768:	4b18      	ldr	r3, [pc, #96]	; (800b7cc <HAL_InitTick+0x78>)
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800b76a:	a901      	add	r1, sp, #4
 800b76c:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM6_CLK_ENABLE();
 800b76e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800b770:	f042 0210 	orr.w	r2, r2, #16
 800b774:	641a      	str	r2, [r3, #64]	; 0x40
 800b776:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b778:	f003 0310 	and.w	r3, r3, #16
 800b77c:	9302      	str	r3, [sp, #8]
 800b77e:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800b780:	f7ff ff74 	bl	800b66c <HAL_RCC_GetClockConfig>
  
  /* Get APB1 prescaler */
  uwAPB1Prescaler = clkconfig.APB1CLKDivider;
  
  /* Compute TIM6 clock */
  if (uwAPB1Prescaler == RCC_HCLK_DIV1) 
 800b784:	9b06      	ldr	r3, [sp, #24]
 800b786:	b9c3      	cbnz	r3, 800b7ba <HAL_InitTick+0x66>
  {
    uwTimclock = HAL_RCC_GetPCLK1Freq();
 800b788:	f7ff ff50 	bl	800b62c <HAL_RCC_GetPCLK1Freq>
  {
    uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
  }
  
  /* Compute the prescaler value to have TIM6 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800b78c:	4b10      	ldr	r3, [pc, #64]	; (800b7d0 <HAL_InitTick+0x7c>)
  + ClockDivision = 0
  + Counter direction = Up
  */
  TimHandle.Init.Period = (1000000U / 1000U) - 1U;
  TimHandle.Init.Prescaler = uwPrescalerValue;
  TimHandle.Init.ClockDivision = 0;
 800b78e:	2200      	movs	r2, #0
  TimHandle.Instance = TIM6;
 800b790:	4c10      	ldr	r4, [pc, #64]	; (800b7d4 <HAL_InitTick+0x80>)
  TimHandle.Init.Period = (1000000U / 1000U) - 1U;
 800b792:	f240 35e7 	movw	r5, #999	; 0x3e7
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800b796:	fba3 1300 	umull	r1, r3, r3, r0
  TimHandle.Instance = TIM6;
 800b79a:	490f      	ldr	r1, [pc, #60]	; (800b7d8 <HAL_InitTick+0x84>)
  TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
  TimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if(HAL_TIM_Base_Init(&TimHandle) == HAL_OK)
 800b79c:	4620      	mov	r0, r4
  TimHandle.Init.Period = (1000000U / 1000U) - 1U;
 800b79e:	60e5      	str	r5, [r4, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800b7a0:	0c9b      	lsrs	r3, r3, #18
  TimHandle.Instance = TIM6;
 800b7a2:	6021      	str	r1, [r4, #0]
  TimHandle.Init.ClockDivision = 0;
 800b7a4:	6122      	str	r2, [r4, #16]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 800b7a6:	3b01      	subs	r3, #1
  TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
 800b7a8:	60a2      	str	r2, [r4, #8]
  TimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 800b7aa:	61a2      	str	r2, [r4, #24]
  TimHandle.Init.Prescaler = uwPrescalerValue;
 800b7ac:	6063      	str	r3, [r4, #4]
  if(HAL_TIM_Base_Init(&TimHandle) == HAL_OK)
 800b7ae:	f000 fb25 	bl	800bdfc <HAL_TIM_Base_Init>
 800b7b2:	b130      	cbz	r0, 800b7c2 <HAL_InitTick+0x6e>
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&TimHandle);
  }
  
  /* Return function status */
  return HAL_ERROR;
 800b7b4:	2001      	movs	r0, #1
}
 800b7b6:	b009      	add	sp, #36	; 0x24
 800b7b8:	bd30      	pop	{r4, r5, pc}
    uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
 800b7ba:	f7ff ff37 	bl	800b62c <HAL_RCC_GetPCLK1Freq>
 800b7be:	0040      	lsls	r0, r0, #1
 800b7c0:	e7e4      	b.n	800b78c <HAL_InitTick+0x38>
    return HAL_TIM_Base_Start_IT(&TimHandle);
 800b7c2:	4620      	mov	r0, r4
 800b7c4:	f000 fb9e 	bl	800bf04 <HAL_TIM_Base_Start_IT>
}
 800b7c8:	b009      	add	sp, #36	; 0x24
 800b7ca:	bd30      	pop	{r4, r5, pc}
 800b7cc:	40023800 	.word	0x40023800
 800b7d0:	431bde83 	.word	0x431bde83
 800b7d4:	20000e50 	.word	0x20000e50
 800b7d8:	40001000 	.word	0x40001000

0800b7dc <HAL_TIM_PeriodElapsedCallback>:
  * @param  htim  TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  HAL_IncTick();
 800b7dc:	f7ff b946 	b.w	800aa6c <HAL_IncTick>

0800b7e0 <TIM6_DAC_IRQHandler>:
  * @brief  This function handles TIM interrupt request.
  * @retval None
  */
void TIM6_DAC_IRQHandler(void)
{
  HAL_TIM_IRQHandler(&TimHandle);
 800b7e0:	4801      	ldr	r0, [pc, #4]	; (800b7e8 <TIM6_DAC_IRQHandler+0x8>)
 800b7e2:	f000 bbad 	b.w	800bf40 <HAL_TIM_IRQHandler>
 800b7e6:	bf00      	nop
 800b7e8:	20000e50 	.word	0x20000e50

0800b7ec <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800b7ec:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800b7ee:	07da      	lsls	r2, r3, #31
{
 800b7f0:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800b7f2:	d506      	bpl.n	800b802 <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800b7f4:	6801      	ldr	r1, [r0, #0]
 800b7f6:	6a84      	ldr	r4, [r0, #40]	; 0x28
 800b7f8:	684a      	ldr	r2, [r1, #4]
 800b7fa:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800b7fe:	4322      	orrs	r2, r4
 800b800:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800b802:	079c      	lsls	r4, r3, #30
 800b804:	d506      	bpl.n	800b814 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800b806:	6801      	ldr	r1, [r0, #0]
 800b808:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800b80a:	684a      	ldr	r2, [r1, #4]
 800b80c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800b810:	4322      	orrs	r2, r4
 800b812:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800b814:	0759      	lsls	r1, r3, #29
 800b816:	d506      	bpl.n	800b826 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800b818:	6801      	ldr	r1, [r0, #0]
 800b81a:	6b04      	ldr	r4, [r0, #48]	; 0x30
 800b81c:	684a      	ldr	r2, [r1, #4]
 800b81e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800b822:	4322      	orrs	r2, r4
 800b824:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800b826:	071a      	lsls	r2, r3, #28
 800b828:	d506      	bpl.n	800b838 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800b82a:	6801      	ldr	r1, [r0, #0]
 800b82c:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800b82e:	684a      	ldr	r2, [r1, #4]
 800b830:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800b834:	4322      	orrs	r2, r4
 800b836:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800b838:	06dc      	lsls	r4, r3, #27
 800b83a:	d506      	bpl.n	800b84a <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800b83c:	6801      	ldr	r1, [r0, #0]
 800b83e:	6b84      	ldr	r4, [r0, #56]	; 0x38
 800b840:	688a      	ldr	r2, [r1, #8]
 800b842:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800b846:	4322      	orrs	r2, r4
 800b848:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800b84a:	0699      	lsls	r1, r3, #26
 800b84c:	d506      	bpl.n	800b85c <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800b84e:	6801      	ldr	r1, [r0, #0]
 800b850:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 800b852:	688a      	ldr	r2, [r1, #8]
 800b854:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800b858:	4322      	orrs	r2, r4
 800b85a:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800b85c:	065a      	lsls	r2, r3, #25
 800b85e:	d50a      	bpl.n	800b876 <UART_AdvFeatureConfig+0x8a>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800b860:	6801      	ldr	r1, [r0, #0]
 800b862:	6c04      	ldr	r4, [r0, #64]	; 0x40
 800b864:	684a      	ldr	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800b866:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800b86a:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800b86e:	ea42 0204 	orr.w	r2, r2, r4
 800b872:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800b874:	d00b      	beq.n	800b88e <UART_AdvFeatureConfig+0xa2>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800b876:	061b      	lsls	r3, r3, #24
 800b878:	d506      	bpl.n	800b888 <UART_AdvFeatureConfig+0x9c>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800b87a:	6802      	ldr	r2, [r0, #0]
 800b87c:	6c81      	ldr	r1, [r0, #72]	; 0x48
 800b87e:	6853      	ldr	r3, [r2, #4]
 800b880:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800b884:	430b      	orrs	r3, r1
 800b886:	6053      	str	r3, [r2, #4]
  }
}
 800b888:	f85d 4b04 	ldr.w	r4, [sp], #4
 800b88c:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800b88e:	684a      	ldr	r2, [r1, #4]
 800b890:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800b892:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 800b896:	4322      	orrs	r2, r4
 800b898:	604a      	str	r2, [r1, #4]
 800b89a:	e7ec      	b.n	800b876 <UART_AdvFeatureConfig+0x8a>

0800b89c <HAL_UART_Init>:
  if (huart == NULL)
 800b89c:	2800      	cmp	r0, #0
 800b89e:	d04f      	beq.n	800b940 <HAL_UART_Init+0xa4>
  if (huart->gState == HAL_UART_STATE_RESET)
 800b8a0:	6f43      	ldr	r3, [r0, #116]	; 0x74
{
 800b8a2:	b570      	push	{r4, r5, r6, lr}
 800b8a4:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 800b8a6:	2b00      	cmp	r3, #0
 800b8a8:	d045      	beq.n	800b936 <HAL_UART_Init+0x9a>
  __HAL_UART_DISABLE(huart);
 800b8aa:	6823      	ldr	r3, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800b8ac:	2124      	movs	r1, #36	; 0x24
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800b8ae:	6920      	ldr	r0, [r4, #16]
  huart->gState = HAL_UART_STATE_BUSY;
 800b8b0:	6761      	str	r1, [r4, #116]	; 0x74
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800b8b2:	68a2      	ldr	r2, [r4, #8]
  __HAL_UART_DISABLE(huart);
 800b8b4:	6819      	ldr	r1, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800b8b6:	4302      	orrs	r2, r0
 800b8b8:	6960      	ldr	r0, [r4, #20]
  __HAL_UART_DISABLE(huart);
 800b8ba:	f021 0101 	bic.w	r1, r1, #1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800b8be:	4dbc      	ldr	r5, [pc, #752]	; (800bbb0 <HAL_UART_Init+0x314>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800b8c0:	4302      	orrs	r2, r0
 800b8c2:	69e0      	ldr	r0, [r4, #28]
  __HAL_UART_DISABLE(huart);
 800b8c4:	6019      	str	r1, [r3, #0]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800b8c6:	6819      	ldr	r1, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800b8c8:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800b8ca:	68e6      	ldr	r6, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800b8cc:	400d      	ands	r5, r1
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800b8ce:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800b8d0:	432a      	orrs	r2, r5
  tmpreg |= huart->Init.OneBitSampling;
 800b8d2:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800b8d4:	601a      	str	r2, [r3, #0]
  tmpreg |= huart->Init.OneBitSampling;
 800b8d6:	ea41 0205 	orr.w	r2, r1, r5
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800b8da:	6859      	ldr	r1, [r3, #4]
  UART_GETCLOCKSOURCE(huart, clocksource);
 800b8dc:	4db5      	ldr	r5, [pc, #724]	; (800bbb4 <HAL_UART_Init+0x318>)
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800b8de:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
  UART_GETCLOCKSOURCE(huart, clocksource);
 800b8e2:	42ab      	cmp	r3, r5
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800b8e4:	ea41 0106 	orr.w	r1, r1, r6
 800b8e8:	6059      	str	r1, [r3, #4]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800b8ea:	6899      	ldr	r1, [r3, #8]
 800b8ec:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
 800b8f0:	ea42 0201 	orr.w	r2, r2, r1
 800b8f4:	609a      	str	r2, [r3, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 800b8f6:	d025      	beq.n	800b944 <HAL_UART_Init+0xa8>
 800b8f8:	4aaf      	ldr	r2, [pc, #700]	; (800bbb8 <HAL_UART_Init+0x31c>)
 800b8fa:	4293      	cmp	r3, r2
 800b8fc:	d044      	beq.n	800b988 <HAL_UART_Init+0xec>
 800b8fe:	4aaf      	ldr	r2, [pc, #700]	; (800bbbc <HAL_UART_Init+0x320>)
 800b900:	4293      	cmp	r3, r2
 800b902:	f000 80f3 	beq.w	800baec <HAL_UART_Init+0x250>
 800b906:	4aae      	ldr	r2, [pc, #696]	; (800bbc0 <HAL_UART_Init+0x324>)
 800b908:	4293      	cmp	r3, r2
 800b90a:	d045      	beq.n	800b998 <HAL_UART_Init+0xfc>
 800b90c:	4aad      	ldr	r2, [pc, #692]	; (800bbc4 <HAL_UART_Init+0x328>)
 800b90e:	4293      	cmp	r3, r2
 800b910:	f000 80d8 	beq.w	800bac4 <HAL_UART_Init+0x228>
 800b914:	4aac      	ldr	r2, [pc, #688]	; (800bbc8 <HAL_UART_Init+0x32c>)
 800b916:	4293      	cmp	r3, r2
 800b918:	f000 8188 	beq.w	800bc2c <HAL_UART_Init+0x390>
 800b91c:	4aab      	ldr	r2, [pc, #684]	; (800bbcc <HAL_UART_Init+0x330>)
 800b91e:	4293      	cmp	r3, r2
 800b920:	f000 8198 	beq.w	800bc54 <HAL_UART_Init+0x3b8>
 800b924:	4aaa      	ldr	r2, [pc, #680]	; (800bbd0 <HAL_UART_Init+0x334>)
 800b926:	4293      	cmp	r3, r2
 800b928:	f000 815e 	beq.w	800bbe8 <HAL_UART_Init+0x34c>
  huart->RxISR = NULL;
 800b92c:	2300      	movs	r3, #0
    return HAL_ERROR;
 800b92e:	2001      	movs	r0, #1
  huart->TxISR = NULL;
 800b930:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
}
 800b934:	bd70      	pop	{r4, r5, r6, pc}
    huart->Lock = HAL_UNLOCKED;
 800b936:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    HAL_UART_MspInit(huart);
 800b93a:	f7f4 ff95 	bl	8000868 <HAL_UART_MspInit>
 800b93e:	e7b4      	b.n	800b8aa <HAL_UART_Init+0xe>
    return HAL_ERROR;
 800b940:	2001      	movs	r0, #1
}
 800b942:	4770      	bx	lr
  UART_GETCLOCKSOURCE(huart, clocksource);
 800b944:	4ba3      	ldr	r3, [pc, #652]	; (800bbd4 <HAL_UART_Init+0x338>)
 800b946:	4aa4      	ldr	r2, [pc, #656]	; (800bbd8 <HAL_UART_Init+0x33c>)
 800b948:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800b94c:	f003 0303 	and.w	r3, r3, #3
 800b950:	5cd3      	ldrb	r3, [r2, r3]
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800b952:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800b956:	d02f      	beq.n	800b9b8 <HAL_UART_Init+0x11c>
    switch (clocksource)
 800b958:	2b08      	cmp	r3, #8
 800b95a:	d8e7      	bhi.n	800b92c <HAL_UART_Init+0x90>
 800b95c:	a201      	add	r2, pc, #4	; (adr r2, 800b964 <HAL_UART_Init+0xc8>)
 800b95e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b962:	bf00      	nop
 800b964:	0800bab3 	.word	0x0800bab3
 800b968:	0800b9f5 	.word	0x0800b9f5
 800b96c:	0800bb07 	.word	0x0800bb07
 800b970:	0800b92d 	.word	0x0800b92d
 800b974:	0800badb 	.word	0x0800badb
 800b978:	0800b92d 	.word	0x0800b92d
 800b97c:	0800b92d 	.word	0x0800b92d
 800b980:	0800b92d 	.word	0x0800b92d
 800b984:	0800bb17 	.word	0x0800bb17
  UART_GETCLOCKSOURCE(huart, clocksource);
 800b988:	4b92      	ldr	r3, [pc, #584]	; (800bbd4 <HAL_UART_Init+0x338>)
 800b98a:	4a94      	ldr	r2, [pc, #592]	; (800bbdc <HAL_UART_Init+0x340>)
 800b98c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800b990:	f003 030c 	and.w	r3, r3, #12
 800b994:	5cd3      	ldrb	r3, [r2, r3]
 800b996:	e7dc      	b.n	800b952 <HAL_UART_Init+0xb6>
 800b998:	4b8e      	ldr	r3, [pc, #568]	; (800bbd4 <HAL_UART_Init+0x338>)
 800b99a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800b99e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800b9a2:	2b40      	cmp	r3, #64	; 0x40
 800b9a4:	f000 8096 	beq.w	800bad4 <HAL_UART_Init+0x238>
 800b9a8:	d97d      	bls.n	800baa6 <HAL_UART_Init+0x20a>
 800b9aa:	2b80      	cmp	r3, #128	; 0x80
 800b9ac:	f000 80a8 	beq.w	800bb00 <HAL_UART_Init+0x264>
 800b9b0:	2bc0      	cmp	r3, #192	; 0xc0
 800b9b2:	f000 80c5 	beq.w	800bb40 <HAL_UART_Init+0x2a4>
 800b9b6:	e7b9      	b.n	800b92c <HAL_UART_Init+0x90>
    switch (clocksource)
 800b9b8:	2b08      	cmp	r3, #8
 800b9ba:	d8b7      	bhi.n	800b92c <HAL_UART_Init+0x90>
 800b9bc:	a201      	add	r2, pc, #4	; (adr r2, 800b9c4 <HAL_UART_Init+0x128>)
 800b9be:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b9c2:	bf00      	nop
 800b9c4:	0800bba9 	.word	0x0800bba9
 800b9c8:	0800bb7f 	.word	0x0800bb7f
 800b9cc:	0800bb99 	.word	0x0800bb99
 800b9d0:	0800b92d 	.word	0x0800b92d
 800b9d4:	0800bb93 	.word	0x0800bb93
 800b9d8:	0800b92d 	.word	0x0800b92d
 800b9dc:	0800b92d 	.word	0x0800b92d
 800b9e0:	0800b92d 	.word	0x0800b92d
 800b9e4:	0800bb47 	.word	0x0800bb47
  UART_GETCLOCKSOURCE(huart, clocksource);
 800b9e8:	2b00      	cmp	r3, #0
 800b9ea:	d19f      	bne.n	800b92c <HAL_UART_Init+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800b9ec:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800b9f0:	f000 80c5 	beq.w	800bb7e <HAL_UART_Init+0x2e2>
        pclk = HAL_RCC_GetPCLK2Freq();
 800b9f4:	f7ff fe2a 	bl	800b64c <HAL_RCC_GetPCLK2Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800b9f8:	6863      	ldr	r3, [r4, #4]
 800b9fa:	eb00 0253 	add.w	r2, r0, r3, lsr #1
 800b9fe:	fbb2 f2f3 	udiv	r2, r2, r3
 800ba02:	b292      	uxth	r2, r2
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800ba04:	f1a2 0110 	sub.w	r1, r2, #16
 800ba08:	f64f 73ef 	movw	r3, #65519	; 0xffef
 800ba0c:	4299      	cmp	r1, r3
 800ba0e:	d88d      	bhi.n	800b92c <HAL_UART_Init+0x90>
      huart->Instance->BRR = usartdiv;
 800ba10:	6823      	ldr	r3, [r4, #0]
  huart->RxISR = NULL;
 800ba12:	2100      	movs	r1, #0
      huart->Instance->BRR = usartdiv;
 800ba14:	60da      	str	r2, [r3, #12]
  huart->TxISR = NULL;
 800ba16:	e9c4 1118 	strd	r1, r1, [r4, #96]	; 0x60
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800ba1a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800ba1c:	2a00      	cmp	r2, #0
 800ba1e:	f040 8082 	bne.w	800bb26 <HAL_UART_Init+0x28a>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800ba22:	685a      	ldr	r2, [r3, #4]
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ba24:	2100      	movs	r1, #0
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800ba26:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 800ba2a:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800ba2c:	689a      	ldr	r2, [r3, #8]
 800ba2e:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800ba32:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 800ba34:	681a      	ldr	r2, [r3, #0]
 800ba36:	f042 0201 	orr.w	r2, r2, #1
 800ba3a:	601a      	str	r2, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800ba3c:	67e1      	str	r1, [r4, #124]	; 0x7c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 800ba3e:	f7ff f821 	bl	800aa84 <HAL_GetTick>

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800ba42:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 800ba44:	4606      	mov	r6, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800ba46:	681a      	ldr	r2, [r3, #0]
 800ba48:	0710      	lsls	r0, r2, #28
 800ba4a:	d407      	bmi.n	800ba5c <HAL_UART_Init+0x1c0>
    }
  }
#endif

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 800ba4c:	2220      	movs	r2, #32
  huart->RxState = HAL_UART_STATE_READY;

  __HAL_UNLOCK(huart);
 800ba4e:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 800ba50:	6762      	str	r2, [r4, #116]	; 0x74

  return HAL_OK;
 800ba52:	4618      	mov	r0, r3
  huart->RxState = HAL_UART_STATE_READY;
 800ba54:	67a2      	str	r2, [r4, #120]	; 0x78
  __HAL_UNLOCK(huart);
 800ba56:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 800ba5a:	bd70      	pop	{r4, r5, r6, pc}
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800ba5c:	69dd      	ldr	r5, [r3, #28]
 800ba5e:	f415 1500 	ands.w	r5, r5, #2097152	; 0x200000
 800ba62:	d1f3      	bne.n	800ba4c <HAL_UART_Init+0x1b0>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ba64:	f7ff f80e 	bl	800aa84 <HAL_GetTick>
 800ba68:	1b80      	subs	r0, r0, r6
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800ba6a:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ba6c:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
 800ba70:	f080 80cd 	bcs.w	800bc0e <HAL_UART_Init+0x372>
        __HAL_UNLOCK(huart);

        return HAL_TIMEOUT;
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800ba74:	681a      	ldr	r2, [r3, #0]
 800ba76:	0751      	lsls	r1, r2, #29
 800ba78:	d5f0      	bpl.n	800ba5c <HAL_UART_Init+0x1c0>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800ba7a:	69da      	ldr	r2, [r3, #28]
 800ba7c:	0512      	lsls	r2, r2, #20
 800ba7e:	d5ed      	bpl.n	800ba5c <HAL_UART_Init+0x1c0>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800ba80:	f44f 6100 	mov.w	r1, #2048	; 0x800
          
          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);

          huart->gState = HAL_UART_STATE_READY;
 800ba84:	2220      	movs	r2, #32
      return HAL_TIMEOUT;
 800ba86:	2003      	movs	r0, #3
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800ba88:	6219      	str	r1, [r3, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800ba8a:	6819      	ldr	r1, [r3, #0]
 800ba8c:	f421 71d0 	bic.w	r1, r1, #416	; 0x1a0
 800ba90:	6019      	str	r1, [r3, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800ba92:	6899      	ldr	r1, [r3, #8]
 800ba94:	f021 0101 	bic.w	r1, r1, #1
 800ba98:	6099      	str	r1, [r3, #8]
          huart->gState = HAL_UART_STATE_READY;
 800ba9a:	6762      	str	r2, [r4, #116]	; 0x74
          huart->RxState = HAL_UART_STATE_READY;
          huart->ErrorCode = HAL_UART_ERROR_RTO;
          
          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800ba9c:	f884 5070 	strb.w	r5, [r4, #112]	; 0x70
          huart->RxState = HAL_UART_STATE_READY;
 800baa0:	67a2      	str	r2, [r4, #120]	; 0x78
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800baa2:	67e2      	str	r2, [r4, #124]	; 0x7c
}
 800baa4:	bd70      	pop	{r4, r5, r6, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 800baa6:	2b00      	cmp	r3, #0
 800baa8:	f47f af40 	bne.w	800b92c <HAL_UART_Init+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800baac:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800bab0:	d07a      	beq.n	800bba8 <HAL_UART_Init+0x30c>
        pclk = HAL_RCC_GetPCLK1Freq();
 800bab2:	f7ff fdbb 	bl	800b62c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800bab6:	6863      	ldr	r3, [r4, #4]
 800bab8:	eb00 0253 	add.w	r2, r0, r3, lsr #1
 800babc:	fbb2 f2f3 	udiv	r2, r2, r3
 800bac0:	b292      	uxth	r2, r2
 800bac2:	e79f      	b.n	800ba04 <HAL_UART_Init+0x168>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800bac4:	4b43      	ldr	r3, [pc, #268]	; (800bbd4 <HAL_UART_Init+0x338>)
 800bac6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800baca:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800bace:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800bad2:	d12d      	bne.n	800bb30 <HAL_UART_Init+0x294>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800bad4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800bad8:	d05b      	beq.n	800bb92 <HAL_UART_Init+0x2f6>
        pclk = HAL_RCC_GetSysClockFreq();
 800bada:	f7ff fd73 	bl	800b5c4 <HAL_RCC_GetSysClockFreq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800bade:	6863      	ldr	r3, [r4, #4]
 800bae0:	eb00 0253 	add.w	r2, r0, r3, lsr #1
 800bae4:	fbb2 f2f3 	udiv	r2, r2, r3
 800bae8:	b292      	uxth	r2, r2
 800baea:	e78b      	b.n	800ba04 <HAL_UART_Init+0x168>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800baec:	4b39      	ldr	r3, [pc, #228]	; (800bbd4 <HAL_UART_Init+0x338>)
 800baee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800baf2:	f003 0330 	and.w	r3, r3, #48	; 0x30
 800baf6:	2b10      	cmp	r3, #16
 800baf8:	d0ec      	beq.n	800bad4 <HAL_UART_Init+0x238>
 800bafa:	d9d4      	bls.n	800baa6 <HAL_UART_Init+0x20a>
 800bafc:	2b20      	cmp	r3, #32
 800bafe:	d13b      	bne.n	800bb78 <HAL_UART_Init+0x2dc>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800bb00:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800bb04:	d048      	beq.n	800bb98 <HAL_UART_Init+0x2fc>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 800bb06:	6863      	ldr	r3, [r4, #4]
 800bb08:	4a35      	ldr	r2, [pc, #212]	; (800bbe0 <HAL_UART_Init+0x344>)
 800bb0a:	eb02 0253 	add.w	r2, r2, r3, lsr #1
 800bb0e:	fbb2 f2f3 	udiv	r2, r2, r3
 800bb12:	b292      	uxth	r2, r2
 800bb14:	e776      	b.n	800ba04 <HAL_UART_Init+0x168>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 800bb16:	6863      	ldr	r3, [r4, #4]
 800bb18:	085a      	lsrs	r2, r3, #1
 800bb1a:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
 800bb1e:	fbb2 f2f3 	udiv	r2, r2, r3
 800bb22:	b292      	uxth	r2, r2
 800bb24:	e76e      	b.n	800ba04 <HAL_UART_Init+0x168>
    UART_AdvFeatureConfig(huart);
 800bb26:	4620      	mov	r0, r4
 800bb28:	f7ff fe60 	bl	800b7ec <UART_AdvFeatureConfig>
 800bb2c:	6823      	ldr	r3, [r4, #0]
 800bb2e:	e778      	b.n	800ba22 <HAL_UART_Init+0x186>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800bb30:	d9b9      	bls.n	800baa6 <HAL_UART_Init+0x20a>
 800bb32:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800bb36:	d0e3      	beq.n	800bb00 <HAL_UART_Init+0x264>
 800bb38:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800bb3c:	f47f aef6 	bne.w	800b92c <HAL_UART_Init+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800bb40:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800bb44:	d1e7      	bne.n	800bb16 <HAL_UART_Init+0x27a>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 800bb46:	6862      	ldr	r2, [r4, #4]
 800bb48:	0853      	lsrs	r3, r2, #1
 800bb4a:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 800bb4e:	fbb3 f3f2 	udiv	r3, r3, r2
 800bb52:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800bb54:	f1a3 0110 	sub.w	r1, r3, #16
 800bb58:	f64f 72ef 	movw	r2, #65519	; 0xffef
 800bb5c:	4291      	cmp	r1, r2
 800bb5e:	f63f aee5 	bhi.w	800b92c <HAL_UART_Init+0x90>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800bb62:	f023 010f 	bic.w	r1, r3, #15
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800bb66:	f3c3 0242 	ubfx	r2, r3, #1, #3
  huart->RxISR = NULL;
 800bb6a:	2000      	movs	r0, #0
      huart->Instance->BRR = brrtemp;
 800bb6c:	6823      	ldr	r3, [r4, #0]
 800bb6e:	430a      	orrs	r2, r1
 800bb70:	60da      	str	r2, [r3, #12]
  huart->TxISR = NULL;
 800bb72:	e9c4 0018 	strd	r0, r0, [r4, #96]	; 0x60
 800bb76:	e750      	b.n	800ba1a <HAL_UART_Init+0x17e>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800bb78:	2b30      	cmp	r3, #48	; 0x30
 800bb7a:	d0e1      	beq.n	800bb40 <HAL_UART_Init+0x2a4>
 800bb7c:	e6d6      	b.n	800b92c <HAL_UART_Init+0x90>
        pclk = HAL_RCC_GetPCLK2Freq();
 800bb7e:	f7ff fd65 	bl	800b64c <HAL_RCC_GetPCLK2Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 800bb82:	6862      	ldr	r2, [r4, #4]
 800bb84:	0853      	lsrs	r3, r2, #1
 800bb86:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 800bb8a:	fbb3 f3f2 	udiv	r3, r3, r2
 800bb8e:	b29b      	uxth	r3, r3
 800bb90:	e7e0      	b.n	800bb54 <HAL_UART_Init+0x2b8>
        pclk = HAL_RCC_GetSysClockFreq();
 800bb92:	f7ff fd17 	bl	800b5c4 <HAL_RCC_GetSysClockFreq>
 800bb96:	e7f4      	b.n	800bb82 <HAL_UART_Init+0x2e6>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 800bb98:	6862      	ldr	r2, [r4, #4]
 800bb9a:	4b12      	ldr	r3, [pc, #72]	; (800bbe4 <HAL_UART_Init+0x348>)
 800bb9c:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 800bba0:	fbb3 f3f2 	udiv	r3, r3, r2
 800bba4:	b29b      	uxth	r3, r3
 800bba6:	e7d5      	b.n	800bb54 <HAL_UART_Init+0x2b8>
        pclk = HAL_RCC_GetPCLK1Freq();
 800bba8:	f7ff fd40 	bl	800b62c <HAL_RCC_GetPCLK1Freq>
 800bbac:	e7e9      	b.n	800bb82 <HAL_UART_Init+0x2e6>
 800bbae:	bf00      	nop
 800bbb0:	efff69f3 	.word	0xefff69f3
 800bbb4:	40011000 	.word	0x40011000
 800bbb8:	40004400 	.word	0x40004400
 800bbbc:	40004800 	.word	0x40004800
 800bbc0:	40004c00 	.word	0x40004c00
 800bbc4:	40005000 	.word	0x40005000
 800bbc8:	40011400 	.word	0x40011400
 800bbcc:	40007800 	.word	0x40007800
 800bbd0:	40007c00 	.word	0x40007c00
 800bbd4:	40023800 	.word	0x40023800
 800bbd8:	0800de90 	.word	0x0800de90
 800bbdc:	0800de94 	.word	0x0800de94
 800bbe0:	00f42400 	.word	0x00f42400
 800bbe4:	01e84800 	.word	0x01e84800
  UART_GETCLOCKSOURCE(huart, clocksource);
 800bbe8:	4b24      	ldr	r3, [pc, #144]	; (800bc7c <HAL_UART_Init+0x3e0>)
 800bbea:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bbee:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800bbf2:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800bbf6:	f43f af6d 	beq.w	800bad4 <HAL_UART_Init+0x238>
 800bbfa:	f67f af54 	bls.w	800baa6 <HAL_UART_Init+0x20a>
 800bbfe:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800bc02:	f43f af7d 	beq.w	800bb00 <HAL_UART_Init+0x264>
 800bc06:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800bc0a:	d099      	beq.n	800bb40 <HAL_UART_Init+0x2a4>
 800bc0c:	e68e      	b.n	800b92c <HAL_UART_Init+0x90>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800bc0e:	681a      	ldr	r2, [r3, #0]
        huart->gState = HAL_UART_STATE_READY;
 800bc10:	2120      	movs	r1, #32
      return HAL_TIMEOUT;
 800bc12:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800bc14:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 800bc18:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800bc1a:	689a      	ldr	r2, [r3, #8]
 800bc1c:	f022 0201 	bic.w	r2, r2, #1
 800bc20:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 800bc22:	6761      	str	r1, [r4, #116]	; 0x74
        __HAL_UNLOCK(huart);
 800bc24:	f884 5070 	strb.w	r5, [r4, #112]	; 0x70
        huart->RxState = HAL_UART_STATE_READY;
 800bc28:	67a1      	str	r1, [r4, #120]	; 0x78
}
 800bc2a:	bd70      	pop	{r4, r5, r6, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 800bc2c:	4b13      	ldr	r3, [pc, #76]	; (800bc7c <HAL_UART_Init+0x3e0>)
 800bc2e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bc32:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 800bc36:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800bc3a:	f43f af4b 	beq.w	800bad4 <HAL_UART_Init+0x238>
 800bc3e:	f67f aed3 	bls.w	800b9e8 <HAL_UART_Init+0x14c>
 800bc42:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800bc46:	f43f af5b 	beq.w	800bb00 <HAL_UART_Init+0x264>
 800bc4a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800bc4e:	f43f af77 	beq.w	800bb40 <HAL_UART_Init+0x2a4>
 800bc52:	e66b      	b.n	800b92c <HAL_UART_Init+0x90>
 800bc54:	4b09      	ldr	r3, [pc, #36]	; (800bc7c <HAL_UART_Init+0x3e0>)
 800bc56:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800bc5a:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 800bc5e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800bc62:	f43f af37 	beq.w	800bad4 <HAL_UART_Init+0x238>
 800bc66:	f67f af1e 	bls.w	800baa6 <HAL_UART_Init+0x20a>
 800bc6a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800bc6e:	f43f af47 	beq.w	800bb00 <HAL_UART_Init+0x264>
 800bc72:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800bc76:	f43f af63 	beq.w	800bb40 <HAL_UART_Init+0x2a4>
 800bc7a:	e657      	b.n	800b92c <HAL_UART_Init+0x90>
 800bc7c:	40023800 	.word	0x40023800

0800bc80 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 800bc80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 800bc84:	680f      	ldr	r7, [r1, #0]
 800bc86:	f8d1 e024 	ldr.w	lr, [r1, #36]	; 0x24
 800bc8a:	2f01      	cmp	r7, #1
 800bc8c:	e9d1 3207 	ldrd	r3, r2, [r1, #28]
 800bc90:	e9d1 4801 	ldrd	r4, r8, [r1, #4]
 800bc94:	e9d1 c603 	ldrd	ip, r6, [r1, #12]
 800bc98:	e9d1 5105 	ldrd	r5, r1, [r1, #20]
 800bc9c:	d012      	beq.n	800bcc4 <FMC_SDRAM_Init+0x44>
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800bc9e:	431a      	orrs	r2, r3
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800bca0:	4f15      	ldr	r7, [pc, #84]	; (800bcf8 <FMC_SDRAM_Init+0x78>)
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 800bca2:	6803      	ldr	r3, [r0, #0]
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800bca4:	ea42 020e 	orr.w	r2, r2, lr
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800bca8:	401f      	ands	r7, r3
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800bcaa:	4322      	orrs	r2, r4
 800bcac:	ea42 0308 	orr.w	r3, r2, r8
 800bcb0:	ea43 030c 	orr.w	r3, r3, ip
 800bcb4:	4333      	orrs	r3, r6
 800bcb6:	432b      	orrs	r3, r5
 800bcb8:	430b      	orrs	r3, r1
 800bcba:	433b      	orrs	r3, r7
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
                        );                                      
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 800bcbc:	6003      	str	r3, [r0, #0]
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
  }
  
  return HAL_OK;
}
 800bcbe:	2000      	movs	r0, #0
 800bcc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800bcc4:	ea44 0408 	orr.w	r4, r4, r8
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 800bcc8:	431a      	orrs	r2, r3
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 800bcca:	6807      	ldr	r7, [r0, #0]
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800bccc:	ea44 030c 	orr.w	r3, r4, ip
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 800bcd0:	f8d0 c004 	ldr.w	ip, [r0, #4]
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800bcd4:	4c08      	ldr	r4, [pc, #32]	; (800bcf8 <FMC_SDRAM_Init+0x78>)
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 800bcd6:	ea42 020e 	orr.w	r2, r2, lr
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800bcda:	4333      	orrs	r3, r6
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
 800bcdc:	f427 46f8 	bic.w	r6, r7, #31744	; 0x7c00
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 800bce0:	ea0c 0404 	and.w	r4, ip, r4
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800bce4:	432b      	orrs	r3, r5
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 800bce6:	4332      	orrs	r2, r6
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800bce8:	430b      	orrs	r3, r1
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 800bcea:	6002      	str	r2, [r0, #0]
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800bcec:	4323      	orrs	r3, r4
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 800bcee:	6043      	str	r3, [r0, #4]
}
 800bcf0:	2000      	movs	r0, #0
 800bcf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bcf6:	bf00      	nop
 800bcf8:	ffff8000 	.word	0xffff8000

0800bcfc <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 800bcfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bd00:	690b      	ldr	r3, [r1, #16]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 800bd02:	2a01      	cmp	r2, #1
 800bd04:	68cf      	ldr	r7, [r1, #12]
 800bd06:	694e      	ldr	r6, [r1, #20]
 800bd08:	f103 33ff 	add.w	r3, r3, #4294967295
 800bd0c:	684d      	ldr	r5, [r1, #4]
 800bd0e:	f107 37ff 	add.w	r7, r7, #4294967295
 800bd12:	688c      	ldr	r4, [r1, #8]
 800bd14:	f106 36ff 	add.w	r6, r6, #4294967295
 800bd18:	f8d1 c018 	ldr.w	ip, [r1, #24]
 800bd1c:	f105 35ff 	add.w	r5, r5, #4294967295
 800bd20:	6809      	ldr	r1, [r1, #0]
 800bd22:	f104 34ff 	add.w	r4, r4, #4294967295
 800bd26:	f10c 3cff 	add.w	ip, ip, #4294967295
 800bd2a:	ea4f 3707 	mov.w	r7, r7, lsl #12
 800bd2e:	f101 38ff 	add.w	r8, r1, #4294967295
 800bd32:	ea4f 5606 	mov.w	r6, r6, lsl #20
 800bd36:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800bd3a:	ea4f 2104 	mov.w	r1, r4, lsl #8
 800bd3e:	ea4f 4e03 	mov.w	lr, r3, lsl #16
 800bd42:	ea4f 6c0c 	mov.w	ip, ip, lsl #24
 800bd46:	d012      	beq.n	800bd6e <FMC_SDRAM_Timing_Init+0x72>
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800bd48:	ea47 0206 	orr.w	r2, r7, r6
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 800bd4c:	6884      	ldr	r4, [r0, #8]
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800bd4e:	ea42 0208 	orr.w	r2, r2, r8
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 800bd52:	f004 4470 	and.w	r4, r4, #4026531840	; 0xf0000000
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800bd56:	ea42 0305 	orr.w	r3, r2, r5
 800bd5a:	430b      	orrs	r3, r1
 800bd5c:	ea43 030e 	orr.w	r3, r3, lr
 800bd60:	ea43 030c 	orr.w	r3, r3, ip
 800bd64:	4323      	orrs	r3, r4
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 800bd66:	6083      	str	r3, [r0, #8]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
  }
  
  return HAL_OK;
}
 800bd68:	2000      	movs	r0, #0
 800bd6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800bd6e:	4329      	orrs	r1, r5
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 800bd70:	ea47 0206 	orr.w	r2, r7, r6
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 800bd74:	6885      	ldr	r5, [r0, #8]
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800bd76:	ea41 0108 	orr.w	r1, r1, r8
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
 800bd7a:	68c4      	ldr	r4, [r0, #12]
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 800bd7c:	4e07      	ldr	r6, [pc, #28]	; (800bd9c <FMC_SDRAM_Timing_Init+0xa0>)
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800bd7e:	ea41 030e 	orr.w	r3, r1, lr
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 800bd82:	f004 4470 	and.w	r4, r4, #4026531840	; 0xf0000000
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 800bd86:	402e      	ands	r6, r5
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800bd88:	ea43 030c 	orr.w	r3, r3, ip
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 800bd8c:	4316      	orrs	r6, r2
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 800bd8e:	4323      	orrs	r3, r4
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 800bd90:	6086      	str	r6, [r0, #8]
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
 800bd92:	60c3      	str	r3, [r0, #12]
}
 800bd94:	2000      	movs	r0, #0
 800bd96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bd9a:	bf00      	nop
 800bd9c:	ff0f0fff 	.word	0xff0f0fff

0800bda0 <FMC_SDRAM_SendCommand>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Timeout Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 800bda0:	b430      	push	{r4, r5}
  __IO uint32_t tmpr = 0;
 800bda2:	2200      	movs	r2, #0
{
 800bda4:	b082      	sub	sp, #8
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800bda6:	684d      	ldr	r5, [r1, #4]
{
 800bda8:	4604      	mov	r4, r0
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800bdaa:	680b      	ldr	r3, [r1, #0]
                    );
    
  Device->SDCMR = tmpr;
  
  return HAL_OK;  
}
 800bdac:	4610      	mov	r0, r2
  __IO uint32_t tmpr = 0;
 800bdae:	9201      	str	r2, [sp, #4]
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800bdb0:	432b      	orrs	r3, r5
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 800bdb2:	e9d1 2502 	ldrd	r2, r5, [r1, #8]
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800bdb6:	ea43 2345 	orr.w	r3, r3, r5, lsl #9
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 800bdba:	3a01      	subs	r2, #1
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800bdbc:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
 800bdc0:	9301      	str	r3, [sp, #4]
  Device->SDCMR = tmpr;
 800bdc2:	9b01      	ldr	r3, [sp, #4]
 800bdc4:	6123      	str	r3, [r4, #16]
}
 800bdc6:	b002      	add	sp, #8
 800bdc8:	bc30      	pop	{r4, r5}
 800bdca:	4770      	bx	lr

0800bdcc <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance  
  * @param  RefreshRate The SDRAM refresh rate value.       
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 800bdcc:	4602      	mov	r2, r0
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
  
  return HAL_OK;   
}
 800bdce:	2000      	movs	r0, #0
  Device->SDRTR |= (RefreshRate<<1);
 800bdd0:	6953      	ldr	r3, [r2, #20]
 800bdd2:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
 800bdd6:	6151      	str	r1, [r2, #20]
}
 800bdd8:	4770      	bx	lr
 800bdda:	bf00      	nop

0800bddc <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800bddc:	4b05      	ldr	r3, [pc, #20]	; (800bdf4 <SystemInit+0x18>)

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800bdde:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800bde2:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800bde6:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800bdea:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800bdee:	6099      	str	r1, [r3, #8]
#endif
}
 800bdf0:	4770      	bx	lr
 800bdf2:	bf00      	nop
 800bdf4:	e000ed00 	.word	0xe000ed00

0800bdf8 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 800bdf8:	4770      	bx	lr
 800bdfa:	bf00      	nop

0800bdfc <HAL_TIM_Base_Init>:
  if (htim == NULL)
 800bdfc:	2800      	cmp	r0, #0
 800bdfe:	d065      	beq.n	800becc <HAL_TIM_Base_Init+0xd0>
{
 800be00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 800be02:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 800be06:	4604      	mov	r4, r0
 800be08:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800be0c:	2b00      	cmp	r3, #0
 800be0e:	d03b      	beq.n	800be88 <HAL_TIM_Base_Init+0x8c>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800be10:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 800be12:	2002      	movs	r0, #2
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800be14:	4e36      	ldr	r6, [pc, #216]	; (800bef0 <HAL_TIM_Base_Init+0xf4>)
 800be16:	4f37      	ldr	r7, [pc, #220]	; (800bef4 <HAL_TIM_Base_Init+0xf8>)
 800be18:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800be1c:	eba2 0606 	sub.w	r6, r2, r6
  htim->State = HAL_TIM_STATE_BUSY;
 800be20:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
 800be24:	eba2 0707 	sub.w	r7, r2, r7
  tmpcr1 = TIMx->CR1;
 800be28:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800be2a:	fab6 f686 	clz	r6, r6
 800be2e:	fab7 f787 	clz	r7, r7
 800be32:	ea4f 1656 	mov.w	r6, r6, lsr #5
 800be36:	ea4f 1757 	mov.w	r7, r7, lsr #5
 800be3a:	d02a      	beq.n	800be92 <HAL_TIM_Base_Init+0x96>
 800be3c:	bb4e      	cbnz	r6, 800be92 <HAL_TIM_Base_Init+0x96>
 800be3e:	492e      	ldr	r1, [pc, #184]	; (800bef8 <HAL_TIM_Base_Init+0xfc>)
 800be40:	428a      	cmp	r2, r1
 800be42:	d045      	beq.n	800bed0 <HAL_TIM_Base_Init+0xd4>
 800be44:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800be48:	428a      	cmp	r2, r1
 800be4a:	d041      	beq.n	800bed0 <HAL_TIM_Base_Init+0xd4>
 800be4c:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800be50:	428a      	cmp	r2, r1
 800be52:	d042      	beq.n	800beda <HAL_TIM_Base_Init+0xde>
 800be54:	2f00      	cmp	r7, #0
 800be56:	d140      	bne.n	800beda <HAL_TIM_Base_Init+0xde>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800be58:	4928      	ldr	r1, [pc, #160]	; (800befc <HAL_TIM_Base_Init+0x100>)
 800be5a:	428a      	cmp	r2, r1
 800be5c:	d01e      	beq.n	800be9c <HAL_TIM_Base_Init+0xa0>
 800be5e:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800be62:	428a      	cmp	r2, r1
 800be64:	d01a      	beq.n	800be9c <HAL_TIM_Base_Init+0xa0>
 800be66:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800be6a:	428a      	cmp	r2, r1
 800be6c:	d016      	beq.n	800be9c <HAL_TIM_Base_Init+0xa0>
 800be6e:	f5a1 3198 	sub.w	r1, r1, #77824	; 0x13000
 800be72:	428a      	cmp	r2, r1
 800be74:	d012      	beq.n	800be9c <HAL_TIM_Base_Init+0xa0>
 800be76:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800be7a:	428a      	cmp	r2, r1
 800be7c:	d00e      	beq.n	800be9c <HAL_TIM_Base_Init+0xa0>
 800be7e:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800be82:	428a      	cmp	r2, r1
 800be84:	d10e      	bne.n	800bea4 <HAL_TIM_Base_Init+0xa8>
 800be86:	e009      	b.n	800be9c <HAL_TIM_Base_Init+0xa0>
    htim->Lock = HAL_UNLOCKED;
 800be88:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 800be8c:	f7ff ffb4 	bl	800bdf8 <HAL_TIM_Base_MspInit>
 800be90:	e7be      	b.n	800be10 <HAL_TIM_Base_Init+0x14>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800be92:	f023 0570 	bic.w	r5, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800be96:	68a0      	ldr	r0, [r4, #8]
 800be98:	ea45 0300 	orr.w	r3, r5, r0
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800be9c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800bea0:	6920      	ldr	r0, [r4, #16]
 800bea2:	4303      	orrs	r3, r0
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800bea4:	69a1      	ldr	r1, [r4, #24]
 800bea6:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800beaa:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800beac:	430b      	orrs	r3, r1

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800beae:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 800beb0:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800beb2:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800beb4:	6291      	str	r1, [r2, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800beb6:	b936      	cbnz	r6, 800bec6 <HAL_TIM_Base_Init+0xca>
 800beb8:	b92f      	cbnz	r7, 800bec6 <HAL_TIM_Base_Init+0xca>
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800beba:	2301      	movs	r3, #1
  return HAL_OK;
 800bebc:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 800bebe:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 800bec0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 800bec4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TIMx->RCR = Structure->RepetitionCounter;
 800bec6:	6963      	ldr	r3, [r4, #20]
 800bec8:	6313      	str	r3, [r2, #48]	; 0x30
 800beca:	e7f6      	b.n	800beba <HAL_TIM_Base_Init+0xbe>
    return HAL_ERROR;
 800becc:	2001      	movs	r0, #1
}
 800bece:	4770      	bx	lr
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800bed0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800bed4:	68a1      	ldr	r1, [r4, #8]
 800bed6:	430b      	orrs	r3, r1
 800bed8:	e7e0      	b.n	800be9c <HAL_TIM_Base_Init+0xa0>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800beda:	4909      	ldr	r1, [pc, #36]	; (800bf00 <HAL_TIM_Base_Init+0x104>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800bedc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800bee0:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800bee2:	428a      	cmp	r2, r1
    tmpcr1 |= Structure->CounterMode;
 800bee4:	ea43 0300 	orr.w	r3, r3, r0
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800bee8:	d0d8      	beq.n	800be9c <HAL_TIM_Base_Init+0xa0>
 800beea:	2f00      	cmp	r7, #0
 800beec:	d1d6      	bne.n	800be9c <HAL_TIM_Base_Init+0xa0>
 800beee:	e7b3      	b.n	800be58 <HAL_TIM_Base_Init+0x5c>
 800bef0:	40010000 	.word	0x40010000
 800bef4:	40010400 	.word	0x40010400
 800bef8:	40000400 	.word	0x40000400
 800befc:	40014000 	.word	0x40014000
 800bf00:	40000c00 	.word	0x40000c00

0800bf04 <HAL_TIM_Base_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800bf04:	6803      	ldr	r3, [r0, #0]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800bf06:	4a09      	ldr	r2, [pc, #36]	; (800bf2c <HAL_TIM_Base_Start_IT+0x28>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800bf08:	68d9      	ldr	r1, [r3, #12]
 800bf0a:	f041 0101 	orr.w	r1, r1, #1
 800bf0e:	60d9      	str	r1, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800bf10:	6899      	ldr	r1, [r3, #8]
 800bf12:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800bf14:	2a06      	cmp	r2, #6
 800bf16:	d006      	beq.n	800bf26 <HAL_TIM_Base_Start_IT+0x22>
 800bf18:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800bf1c:	d003      	beq.n	800bf26 <HAL_TIM_Base_Start_IT+0x22>
    __HAL_TIM_ENABLE(htim);
 800bf1e:	681a      	ldr	r2, [r3, #0]
 800bf20:	f042 0201 	orr.w	r2, r2, #1
 800bf24:	601a      	str	r2, [r3, #0]
}
 800bf26:	2000      	movs	r0, #0
 800bf28:	4770      	bx	lr
 800bf2a:	bf00      	nop
 800bf2c:	00010007 	.word	0x00010007

0800bf30 <HAL_TIM_OC_DelayElapsedCallback>:
 800bf30:	4770      	bx	lr
 800bf32:	bf00      	nop

0800bf34 <HAL_TIM_IC_CaptureCallback>:
 800bf34:	4770      	bx	lr
 800bf36:	bf00      	nop

0800bf38 <HAL_TIM_PWM_PulseFinishedCallback>:
 800bf38:	4770      	bx	lr
 800bf3a:	bf00      	nop

0800bf3c <HAL_TIM_TriggerCallback>:
 800bf3c:	4770      	bx	lr
 800bf3e:	bf00      	nop

0800bf40 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800bf40:	6803      	ldr	r3, [r0, #0]
 800bf42:	691a      	ldr	r2, [r3, #16]
 800bf44:	0791      	lsls	r1, r2, #30
{
 800bf46:	b510      	push	{r4, lr}
 800bf48:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800bf4a:	d502      	bpl.n	800bf52 <HAL_TIM_IRQHandler+0x12>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 800bf4c:	68da      	ldr	r2, [r3, #12]
 800bf4e:	0792      	lsls	r2, r2, #30
 800bf50:	d468      	bmi.n	800c024 <HAL_TIM_IRQHandler+0xe4>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 800bf52:	691a      	ldr	r2, [r3, #16]
 800bf54:	0752      	lsls	r2, r2, #29
 800bf56:	d502      	bpl.n	800bf5e <HAL_TIM_IRQHandler+0x1e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 800bf58:	68da      	ldr	r2, [r3, #12]
 800bf5a:	0750      	lsls	r0, r2, #29
 800bf5c:	d44f      	bmi.n	800bffe <HAL_TIM_IRQHandler+0xbe>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800bf5e:	691a      	ldr	r2, [r3, #16]
 800bf60:	0711      	lsls	r1, r2, #28
 800bf62:	d502      	bpl.n	800bf6a <HAL_TIM_IRQHandler+0x2a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800bf64:	68da      	ldr	r2, [r3, #12]
 800bf66:	0712      	lsls	r2, r2, #28
 800bf68:	d437      	bmi.n	800bfda <HAL_TIM_IRQHandler+0x9a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800bf6a:	691a      	ldr	r2, [r3, #16]
 800bf6c:	06d0      	lsls	r0, r2, #27
 800bf6e:	d502      	bpl.n	800bf76 <HAL_TIM_IRQHandler+0x36>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 800bf70:	68da      	ldr	r2, [r3, #12]
 800bf72:	06d1      	lsls	r1, r2, #27
 800bf74:	d41e      	bmi.n	800bfb4 <HAL_TIM_IRQHandler+0x74>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800bf76:	691a      	ldr	r2, [r3, #16]
 800bf78:	07d2      	lsls	r2, r2, #31
 800bf7a:	d502      	bpl.n	800bf82 <HAL_TIM_IRQHandler+0x42>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 800bf7c:	68da      	ldr	r2, [r3, #12]
 800bf7e:	07d0      	lsls	r0, r2, #31
 800bf80:	d469      	bmi.n	800c056 <HAL_TIM_IRQHandler+0x116>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 800bf82:	691a      	ldr	r2, [r3, #16]
 800bf84:	0611      	lsls	r1, r2, #24
 800bf86:	d502      	bpl.n	800bf8e <HAL_TIM_IRQHandler+0x4e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800bf88:	68da      	ldr	r2, [r3, #12]
 800bf8a:	0612      	lsls	r2, r2, #24
 800bf8c:	d46b      	bmi.n	800c066 <HAL_TIM_IRQHandler+0x126>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800bf8e:	691a      	ldr	r2, [r3, #16]
 800bf90:	05d0      	lsls	r0, r2, #23
 800bf92:	d502      	bpl.n	800bf9a <HAL_TIM_IRQHandler+0x5a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800bf94:	68da      	ldr	r2, [r3, #12]
 800bf96:	0611      	lsls	r1, r2, #24
 800bf98:	d46d      	bmi.n	800c076 <HAL_TIM_IRQHandler+0x136>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 800bf9a:	691a      	ldr	r2, [r3, #16]
 800bf9c:	0652      	lsls	r2, r2, #25
 800bf9e:	d502      	bpl.n	800bfa6 <HAL_TIM_IRQHandler+0x66>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 800bfa0:	68da      	ldr	r2, [r3, #12]
 800bfa2:	0650      	lsls	r0, r2, #25
 800bfa4:	d46f      	bmi.n	800c086 <HAL_TIM_IRQHandler+0x146>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800bfa6:	691a      	ldr	r2, [r3, #16]
 800bfa8:	0691      	lsls	r1, r2, #26
 800bfaa:	d502      	bpl.n	800bfb2 <HAL_TIM_IRQHandler+0x72>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 800bfac:	68da      	ldr	r2, [r3, #12]
 800bfae:	0692      	lsls	r2, r2, #26
 800bfb0:	d449      	bmi.n	800c046 <HAL_TIM_IRQHandler+0x106>
}
 800bfb2:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800bfb4:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800bfb8:	2208      	movs	r2, #8
        HAL_TIM_IC_CaptureCallback(htim);
 800bfba:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800bfbc:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800bfbe:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800bfc0:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800bfc2:	f413 7f40 	tst.w	r3, #768	; 0x300
 800bfc6:	d16f      	bne.n	800c0a8 <HAL_TIM_IRQHandler+0x168>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800bfc8:	f7ff ffb2 	bl	800bf30 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800bfcc:	4620      	mov	r0, r4
 800bfce:	f7ff ffb3 	bl	800bf38 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800bfd2:	2200      	movs	r2, #0
 800bfd4:	6823      	ldr	r3, [r4, #0]
 800bfd6:	7722      	strb	r2, [r4, #28]
 800bfd8:	e7cd      	b.n	800bf76 <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800bfda:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800bfde:	2204      	movs	r2, #4
        HAL_TIM_IC_CaptureCallback(htim);
 800bfe0:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 800bfe2:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800bfe4:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800bfe6:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800bfe8:	079b      	lsls	r3, r3, #30
 800bfea:	d15a      	bne.n	800c0a2 <HAL_TIM_IRQHandler+0x162>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800bfec:	f7ff ffa0 	bl	800bf30 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800bff0:	4620      	mov	r0, r4
 800bff2:	f7ff ffa1 	bl	800bf38 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800bff6:	2200      	movs	r2, #0
 800bff8:	6823      	ldr	r3, [r4, #0]
 800bffa:	7722      	strb	r2, [r4, #28]
 800bffc:	e7b5      	b.n	800bf6a <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800bffe:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800c002:	2202      	movs	r2, #2
        HAL_TIM_IC_CaptureCallback(htim);
 800c004:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800c006:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800c008:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800c00a:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800c00c:	f413 7f40 	tst.w	r3, #768	; 0x300
 800c010:	d144      	bne.n	800c09c <HAL_TIM_IRQHandler+0x15c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800c012:	f7ff ff8d 	bl	800bf30 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800c016:	4620      	mov	r0, r4
 800c018:	f7ff ff8e 	bl	800bf38 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800c01c:	2200      	movs	r2, #0
 800c01e:	6823      	ldr	r3, [r4, #0]
 800c020:	7722      	strb	r2, [r4, #28]
 800c022:	e79c      	b.n	800bf5e <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800c024:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800c028:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800c02a:	6119      	str	r1, [r3, #16]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800c02c:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800c02e:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800c030:	0799      	lsls	r1, r3, #30
 800c032:	d130      	bne.n	800c096 <HAL_TIM_IRQHandler+0x156>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800c034:	f7ff ff7c 	bl	800bf30 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800c038:	4620      	mov	r0, r4
 800c03a:	f7ff ff7d 	bl	800bf38 <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800c03e:	2200      	movs	r2, #0
 800c040:	6823      	ldr	r3, [r4, #0]
 800c042:	7722      	strb	r2, [r4, #28]
 800c044:	e785      	b.n	800bf52 <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800c046:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 800c04a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800c04c:	611a      	str	r2, [r3, #16]
}
 800c04e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
 800c052:	f000 b82d 	b.w	800c0b0 <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800c056:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 800c05a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800c05c:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 800c05e:	f7ff fbbd 	bl	800b7dc <HAL_TIM_PeriodElapsedCallback>
 800c062:	6823      	ldr	r3, [r4, #0]
 800c064:	e78d      	b.n	800bf82 <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800c066:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 800c06a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800c06c:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 800c06e:	f000 f821 	bl	800c0b4 <HAL_TIMEx_BreakCallback>
 800c072:	6823      	ldr	r3, [r4, #0]
 800c074:	e78b      	b.n	800bf8e <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800c076:	f46f 7280 	mvn.w	r2, #256	; 0x100
      HAL_TIMEx_Break2Callback(htim);
 800c07a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800c07c:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 800c07e:	f000 f81b 	bl	800c0b8 <HAL_TIMEx_Break2Callback>
 800c082:	6823      	ldr	r3, [r4, #0]
 800c084:	e789      	b.n	800bf9a <HAL_TIM_IRQHandler+0x5a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800c086:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
 800c08a:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800c08c:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 800c08e:	f7ff ff55 	bl	800bf3c <HAL_TIM_TriggerCallback>
 800c092:	6823      	ldr	r3, [r4, #0]
 800c094:	e787      	b.n	800bfa6 <HAL_TIM_IRQHandler+0x66>
          HAL_TIM_IC_CaptureCallback(htim);
 800c096:	f7ff ff4d 	bl	800bf34 <HAL_TIM_IC_CaptureCallback>
 800c09a:	e7d0      	b.n	800c03e <HAL_TIM_IRQHandler+0xfe>
        HAL_TIM_IC_CaptureCallback(htim);
 800c09c:	f7ff ff4a 	bl	800bf34 <HAL_TIM_IC_CaptureCallback>
 800c0a0:	e7bc      	b.n	800c01c <HAL_TIM_IRQHandler+0xdc>
        HAL_TIM_IC_CaptureCallback(htim);
 800c0a2:	f7ff ff47 	bl	800bf34 <HAL_TIM_IC_CaptureCallback>
 800c0a6:	e7a6      	b.n	800bff6 <HAL_TIM_IRQHandler+0xb6>
        HAL_TIM_IC_CaptureCallback(htim);
 800c0a8:	f7ff ff44 	bl	800bf34 <HAL_TIM_IC_CaptureCallback>
 800c0ac:	e791      	b.n	800bfd2 <HAL_TIM_IRQHandler+0x92>
 800c0ae:	bf00      	nop

0800c0b0 <HAL_TIMEx_CommutCallback>:
 800c0b0:	4770      	bx	lr
 800c0b2:	bf00      	nop

0800c0b4 <HAL_TIMEx_BreakCallback>:
 800c0b4:	4770      	bx	lr
 800c0b6:	bf00      	nop

0800c0b8 <HAL_TIMEx_Break2Callback>:
 800c0b8:	4770      	bx	lr
 800c0ba:	bf00      	nop

0800c0bc <_tx_initialize_kernel_enter>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID _tx_initialize_kernel_enter(VOID)
{
 800c0bc:	b510      	push	{r4, lr}
	/* Determine if the compiler has pre-initialized ThreadX.  */
	if (_tx_thread_system_state != TX_INITIALIZE_ALMOST_DONE)
 800c0be:	4c0e      	ldr	r4, [pc, #56]	; (800c0f8 <_tx_initialize_kernel_enter+0x3c>)
 800c0c0:	6823      	ldr	r3, [r4, #0]
 800c0c2:	f113 3f0f 	cmn.w	r3, #252645135	; 0xf0f0f0f
 800c0c6:	d00a      	beq.n	800c0de <_tx_initialize_kernel_enter+0x22>
		/* No, the initialization still needs to take place.  */

		/* Ensure that the system state variable is set to indicate
		 initialization is in progress.  Note that this variable is
		 later used to represent interrupt nesting.  */
		_tx_thread_system_state = TX_INITIALIZE_IN_PROGRESS;
 800c0c8:	f04f 33f0 	mov.w	r3, #4042322160	; 0xf0f0f0f0
 800c0cc:	6023      	str	r3, [r4, #0]
		/* Call any port specific preprocessing.  */
		TX_PORT_SPECIFIC_PRE_INITIALIZATION

		/* Invoke the low-level initialization to handle all processor specific
		 initialization issues.  */
		_tx_initialize_low_level();
 800c0ce:	f7f4 f8af 	bl	8000230 <_tx_initialize_low_level>

		/* Invoke the high-level initialization to exercise all of the
		 ThreadX components and the application's initialization
		 function.  */
		_tx_initialize_high_level();
 800c0d2:	f001 f8e5 	bl	800d2a0 <_tx_initialize_high_level>

		/* Call any port specific post-processing.  */
		TX_PORT_SPECIFIC_POST_INITIALIZATION
 800c0d6:	4a09      	ldr	r2, [pc, #36]	; (800c0fc <_tx_initialize_kernel_enter+0x40>)
 800c0d8:	6813      	ldr	r3, [r2, #0]
 800c0da:	3301      	adds	r3, #1
 800c0dc:	6013      	str	r3, [r2, #0]
	 later used to represent interrupt nesting.  */
	_tx_thread_system_state = TX_INITIALIZE_IN_PROGRESS;

	/* Call the application provided initialization function. Pass the
	 * first available memory address to it.  */
	tx_application_define(_tx_initialize_unused_memory);
 800c0de:	4a08      	ldr	r2, [pc, #32]	; (800c100 <_tx_initialize_kernel_enter+0x44>)
	_tx_thread_system_state = TX_INITIALIZE_IN_PROGRESS;
 800c0e0:	f04f 33f0 	mov.w	r3, #4042322160	; 0xf0f0f0f0
	tx_application_define(_tx_initialize_unused_memory);
 800c0e4:	6810      	ldr	r0, [r2, #0]
	_tx_thread_system_state = TX_INITIALIZE_IN_PROGRESS;
 800c0e6:	6023      	str	r3, [r4, #0]
	tx_application_define(_tx_initialize_unused_memory);
 800c0e8:	f7f4 fd4e 	bl	8000b88 <tx_application_define>

	/* Set the system state in preparation for entering the thread scheduler. */
	_tx_thread_system_state = TX_INITIALIZE_IS_FINISHED;
 800c0ec:	2300      	movs	r3, #0
 800c0ee:	6023      	str	r3, [r4, #0]

#ifdef TX_SAFETY_CRITICAL
    /* If we ever get here, raise safety critical exception. */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
 800c0f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_tx_thread_schedule();
 800c0f4:	f7f4 b8fc 	b.w	80002f0 <_tx_thread_schedule>
 800c0f8:	20000164 	.word	0x20000164
 800c0fc:	20000f28 	.word	0x20000f28
 800c100:	200014d8 	.word	0x200014d8

0800c104 <_tx_mutex_create>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_create(TX_MUTEX *mutex_ptr, CHAR *name_ptr, UINT inherit)
{
 800c104:	b570      	push	{r4, r5, r6, lr}
 800c106:	460d      	mov	r5, r1
 800c108:	4614      	mov	r4, r2
TX_MUTEX        *next_mutex;
TX_MUTEX        *previous_mutex;


    /* Initialize mutex control block to all zeros.  */
    TX_MEMSET(mutex_ptr, 0, (sizeof(TX_MUTEX)));
 800c10a:	2100      	movs	r1, #0
 800c10c:	2234      	movs	r2, #52	; 0x34
 800c10e:	f001 fde6 	bl	800dcde <memset>
 800c112:	4603      	mov	r3, r0

    /* Setup the basic mutex fields.  */
    mutex_ptr -> tx_mutex_name =             name_ptr;
 800c114:	6045      	str	r5, [r0, #4]
    mutex_ptr -> tx_mutex_inherit =          inherit;
 800c116:	6104      	str	r4, [r0, #16]
__attribute__( ( always_inline ) ) static inline unsigned int __disable_interrupts(void)
{

unsigned int  primask_value;

    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c118:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c11c:	b672      	cpsid	i
    /* Setup the thread mutex release function pointer.  */
    _tx_thread_mutex_release =  &(_tx_mutex_thread_release);

    /* Place the mutex on the list of created mutexes.  First,
       check for an empty list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
 800c11e:	490c      	ldr	r1, [pc, #48]	; (800c150 <_tx_mutex_create+0x4c>)
    _tx_thread_mutex_release =  &(_tx_mutex_thread_release);
 800c120:	480c      	ldr	r0, [pc, #48]	; (800c154 <_tx_mutex_create+0x50>)
    mutex_ptr -> tx_mutex_id =  TX_MUTEX_ID;
 800c122:	4e0d      	ldr	r6, [pc, #52]	; (800c158 <_tx_mutex_create+0x54>)
    if (_tx_mutex_created_count == TX_EMPTY)
 800c124:	680a      	ldr	r2, [r1, #0]
    _tx_thread_mutex_release =  &(_tx_mutex_thread_release);
 800c126:	4d0d      	ldr	r5, [pc, #52]	; (800c15c <_tx_mutex_create+0x58>)
    mutex_ptr -> tx_mutex_id =  TX_MUTEX_ID;
 800c128:	601e      	str	r6, [r3, #0]
    _tx_thread_mutex_release =  &(_tx_mutex_thread_release);
 800c12a:	6005      	str	r5, [r0, #0]
    {

        /* The created mutex list is empty.  Add mutex to empty list.  */
        _tx_mutex_created_ptr =                   mutex_ptr;
 800c12c:	480c      	ldr	r0, [pc, #48]	; (800c160 <_tx_mutex_create+0x5c>)
    if (_tx_mutex_created_count == TX_EMPTY)
 800c12e:	b15a      	cbz	r2, 800c148 <_tx_mutex_create+0x44>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_mutex =      _tx_mutex_created_ptr;
 800c130:	6800      	ldr	r0, [r0, #0]
        previous_mutex =  next_mutex -> tx_mutex_created_previous;
 800c132:	6a45      	ldr	r5, [r0, #36]	; 0x24

        /* Place the new mutex in the list.  */
        next_mutex -> tx_mutex_created_previous =  mutex_ptr;
 800c134:	6243      	str	r3, [r0, #36]	; 0x24
        previous_mutex -> tx_mutex_created_next =  mutex_ptr;
 800c136:	622b      	str	r3, [r5, #32]

        /* Setup this mutex's next and previous created links.  */
        mutex_ptr -> tx_mutex_created_previous =  previous_mutex;
        mutex_ptr -> tx_mutex_created_next =      next_mutex;
 800c138:	e9c3 0508 	strd	r0, r5, [r3, #32]
    }

    /* Increment the ownership count.  */
    _tx_mutex_created_count++;
 800c13c:	3201      	adds	r2, #1
 800c13e:	600a      	str	r2, [r1, #0]
}

__attribute__( ( always_inline ) ) static inline void __restore_interrupts(unsigned int primask_value)
{

    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c140:	f384 8810 	msr	PRIMASK, r4
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
}
 800c144:	2000      	movs	r0, #0
 800c146:	bd70      	pop	{r4, r5, r6, pc}
        mutex_ptr -> tx_mutex_created_previous =  mutex_ptr;
 800c148:	e9c3 3308 	strd	r3, r3, [r3, #32]
        _tx_mutex_created_ptr =                   mutex_ptr;
 800c14c:	6003      	str	r3, [r0, #0]
 800c14e:	e7f5      	b.n	800c13c <_tx_mutex_create+0x38>
 800c150:	200014c4 	.word	0x200014c4
 800c154:	20000f10 	.word	0x20000f10
 800c158:	4d555445 	.word	0x4d555445
 800c15c:	0800d391 	.word	0x0800d391
 800c160:	200014c8 	.word	0x200014c8

0800c164 <_tx_mutex_delete>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_delete(TX_MUTEX *mutex_ptr)
{
 800c164:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c168:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c16c:	b672      	cpsid	i

    /* Clear the mutex ID to make it invalid.  */
    mutex_ptr -> tx_mutex_id =  TX_CLEAR_ID;

    /* Decrement the created count.  */
    _tx_mutex_created_count--;
 800c16e:	4927      	ldr	r1, [pc, #156]	; (800c20c <_tx_mutex_delete+0xa8>)
    mutex_ptr -> tx_mutex_id =  TX_CLEAR_ID;
 800c170:	2400      	movs	r4, #0
    _tx_mutex_created_count--;
 800c172:	680b      	ldr	r3, [r1, #0]
    mutex_ptr -> tx_mutex_id =  TX_CLEAR_ID;
 800c174:	6004      	str	r4, [r0, #0]
    _tx_mutex_created_count--;
 800c176:	3b01      	subs	r3, #1
 800c178:	600b      	str	r3, [r1, #0]
    
    /* See if the mutex is the only one on the list.  */
    if (_tx_mutex_created_count == TX_EMPTY)
 800c17a:	2b00      	cmp	r3, #0
 800c17c:	d13c      	bne.n	800c1f8 <_tx_mutex_delete+0x94>
    {

        /* Only created mutex, just set the created list to NULL.  */
        _tx_mutex_created_ptr =  TX_NULL;
 800c17e:	4924      	ldr	r1, [pc, #144]	; (800c210 <_tx_mutex_delete+0xac>)
 800c180:	600b      	str	r3, [r1, #0]
            _tx_mutex_created_ptr =  next_mutex;
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800c182:	4e24      	ldr	r6, [pc, #144]	; (800c214 <_tx_mutex_delete+0xb0>)

    /* Pickup the suspension information.  */
    thread_ptr =                             mutex_ptr -> tx_mutex_suspension_list;
    mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 800c184:	2700      	movs	r7, #0

    /* Setup pointer to owner of mutex.  */
    owner_thread =  mutex_ptr -> tx_mutex_owner;

    /* Determine if there is a valid thread pointer.  */
    if (owner_thread != TX_NULL)
 800c186:	68c1      	ldr	r1, [r0, #12]
    _tx_thread_preempt_disable++;
 800c188:	6833      	ldr	r3, [r6, #0]
    thread_ptr =                             mutex_ptr -> tx_mutex_suspension_list;
 800c18a:	6984      	ldr	r4, [r0, #24]
    _tx_thread_preempt_disable++;
 800c18c:	3301      	adds	r3, #1
    suspended_count =                        mutex_ptr -> tx_mutex_suspended_count;
 800c18e:	69c5      	ldr	r5, [r0, #28]
    mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 800c190:	6187      	str	r7, [r0, #24]
    _tx_thread_preempt_disable++;
 800c192:	6033      	str	r3, [r6, #0]
    mutex_ptr -> tx_mutex_suspended_count =  TX_NO_SUSPENSIONS;
 800c194:	61c7      	str	r7, [r0, #28]
    if (owner_thread != TX_NULL)
 800c196:	b141      	cbz	r1, 800c1aa <_tx_mutex_delete+0x46>
    {

        /* Yes, remove this mutex from the owned list.  */
        
        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 800c198:	2301      	movs	r3, #1
 800c19a:	6083      	str	r3, [r0, #8]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c19c:	f382 8810 	msr	PRIMASK, r2
        do
        {
            status =  _tx_mutex_put(mutex_ptr);
        } while (status != TX_SUCCESS);
#else
        _tx_mutex_put(mutex_ptr);
 800c1a0:	f000 f924 	bl	800c3ec <_tx_mutex_put>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c1a4:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c1a8:	b672      	cpsid	i
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c1aa:	f382 8810 	msr	PRIMASK, r2
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the mutex list to resume any and all threads suspended
       on this mutex.  */
    while (suspended_count != ((ULONG) 0))
 800c1ae:	b1b5      	cbz	r5, 800c1de <_tx_mutex_delete+0x7a>
        /* Lockout interrupts.  */
        TX_DISABLE

        /* Clear the cleanup pointer, this prevents the timeout from doing 
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c1b0:	f04f 0800 	mov.w	r8, #0

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 800c1b4:	2701      	movs	r7, #1
        suspended_count--;
 800c1b6:	3d01      	subs	r5, #1
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c1b8:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c1bc:	b672      	cpsid	i
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 800c1be:	6833      	ldr	r3, [r6, #0]
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c1c0:	f8c4 8068 	str.w	r8, [r4, #104]	; 0x68
        _tx_thread_preempt_disable++;
 800c1c4:	3301      	adds	r3, #1
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 800c1c6:	f8c4 7084 	str.w	r7, [r4, #132]	; 0x84
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 800c1ca:	6f22      	ldr	r2, [r4, #112]	; 0x70
        _tx_thread_preempt_disable++;
 800c1cc:	6033      	str	r3, [r6, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c1ce:	f381 8810 	msr	PRIMASK, r1

        /* Restore interrupts.  */
        TX_RESTORE
    
        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 800c1d2:	4620      	mov	r0, r4
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 800c1d4:	4614      	mov	r4, r2
        _tx_thread_system_resume(thread_ptr);
 800c1d6:	f000 faff 	bl	800c7d8 <_tx_thread_system_resume>
    while (suspended_count != ((ULONG) 0))
 800c1da:	2d00      	cmp	r5, #0
 800c1dc:	d1eb      	bne.n	800c1b6 <_tx_mutex_delete+0x52>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c1de:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c1e2:	b672      	cpsid	i

    /* Disable interrupts.  */
    TX_DISABLE

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 800c1e4:	6833      	ldr	r3, [r6, #0]
 800c1e6:	3b01      	subs	r3, #1
 800c1e8:	6033      	str	r3, [r6, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c1ea:	f382 8810 	msr	PRIMASK, r2

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800c1ee:	f000 fad5 	bl	800c79c <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
}
 800c1f2:	2000      	movs	r0, #0
 800c1f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (_tx_mutex_created_ptr == mutex_ptr)
 800c1f8:	4c05      	ldr	r4, [pc, #20]	; (800c210 <_tx_mutex_delete+0xac>)
 800c1fa:	6825      	ldr	r5, [r4, #0]
        previous_mutex =                           mutex_ptr -> tx_mutex_created_previous;
 800c1fc:	e9d0 3108 	ldrd	r3, r1, [r0, #32]
        if (_tx_mutex_created_ptr == mutex_ptr)
 800c200:	4285      	cmp	r5, r0
        next_mutex -> tx_mutex_created_previous =  previous_mutex;
 800c202:	6259      	str	r1, [r3, #36]	; 0x24
            _tx_mutex_created_ptr =  next_mutex;
 800c204:	bf08      	it	eq
 800c206:	6023      	streq	r3, [r4, #0]
        previous_mutex -> tx_mutex_created_next =  next_mutex;
 800c208:	620b      	str	r3, [r1, #32]
 800c20a:	e7ba      	b.n	800c182 <_tx_mutex_delete+0x1e>
 800c20c:	200014c4 	.word	0x200014c4
 800c210:	200014c8 	.word	0x200014c8
 800c214:	20000f28 	.word	0x20000f28

0800c218 <_tx_mutex_get>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_get(TX_MUTEX *mutex_ptr, ULONG wait_option)
{
 800c218:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c21a:	f3ef 8510 	mrs	r5, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c21e:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_MUTEX_GET_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800c220:	4a3b      	ldr	r2, [pc, #236]	; (800c310 <_tx_mutex_get+0xf8>)

    /* Determine if this mutex is available.  */
    if (mutex_ptr -> tx_mutex_ownership_count == ((UINT) 0))
 800c222:	6883      	ldr	r3, [r0, #8]
    TX_THREAD_GET_CURRENT(thread_ptr)
 800c224:	6814      	ldr	r4, [r2, #0]
    if (mutex_ptr -> tx_mutex_ownership_count == ((UINT) 0))
 800c226:	b9e3      	cbnz	r3, 800c262 <_tx_mutex_get+0x4a>
    {

        /* Set the ownership count to 1.  */
        mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 800c228:	2301      	movs	r3, #1
 800c22a:	e9c0 3402 	strd	r3, r4, [r0, #8]

        /* Remember that the calling thread owns the mutex.  */
        mutex_ptr -> tx_mutex_owner =  thread_ptr;

        /* Determine if the thread pointer is valid.  */
        if (thread_ptr != TX_NULL)
 800c22e:	b1a4      	cbz	r4, 800c25a <_tx_mutex_get+0x42>
        {

            /* Determine if priority inheritance is required.  */
            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800c230:	6903      	ldr	r3, [r0, #16]
 800c232:	2b01      	cmp	r3, #1
 800c234:	d103      	bne.n	800c23e <_tx_mutex_get+0x26>
            {
         
                /* Remember the current priority of thread.  */
                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
 800c236:	6ae2      	ldr	r2, [r4, #44]	; 0x2c

                /* Setup the highest priority waiting thread.  */
                mutex_ptr -> tx_mutex_highest_priority_waiting =  ((UINT) TX_MAX_PRIORITIES);
 800c238:	2320      	movs	r3, #32
                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
 800c23a:	6142      	str	r2, [r0, #20]
                mutex_ptr -> tx_mutex_highest_priority_waiting =  ((UINT) TX_MAX_PRIORITIES);
 800c23c:	6283      	str	r3, [r0, #40]	; 0x28
            }

            /* Pickup next mutex pointer, which is the head of the list.  */
            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
 800c23e:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4

            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
            if (next_mutex != TX_NULL)
 800c242:	2b00      	cmp	r3, #0
 800c244:	d044      	beq.n	800c2d0 <_tx_mutex_get+0xb8>
            {

                /* Non-empty list. Link up the mutex.  */

                /* Pickup the next and previous mutex pointer.  */
                previous_mutex =  next_mutex -> tx_mutex_owned_previous;
 800c246:	6b1a      	ldr	r2, [r3, #48]	; 0x30

                /* Place the owned mutex in the list.  */
                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
 800c248:	6318      	str	r0, [r3, #48]	; 0x30
                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
 800c24a:	62d0      	str	r0, [r2, #44]	; 0x2c

                /* Setup this mutex's next and previous created links.  */
                mutex_ptr -> tx_mutex_owned_previous =  previous_mutex;
                mutex_ptr -> tx_mutex_owned_next =      next_mutex;
 800c24c:	e9c0 320b 	strd	r3, r2, [r0, #44]	; 0x2c
                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
            }

            /* Increment the number of mutexes owned counter.  */
            thread_ptr -> tx_thread_owned_mutex_count++;
 800c250:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 800c254:	3301      	adds	r3, #1
 800c256:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c25a:	f385 8810 	msr	PRIMASK, r5

        /* Restore interrupts.  */
        TX_RESTORE

        /* Return success.  */
        status =  TX_SUCCESS;
 800c25e:	2000      	movs	r0, #0
        }
    }

    /* Return completion status.  */
    return(status);
}
 800c260:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if (mutex_ptr -> tx_mutex_owner == thread_ptr)
 800c262:	68c2      	ldr	r2, [r0, #12]
 800c264:	42a2      	cmp	r2, r4
 800c266:	d029      	beq.n	800c2bc <_tx_mutex_get+0xa4>
        if (wait_option != TX_NO_WAIT)
 800c268:	b371      	cbz	r1, 800c2c8 <_tx_mutex_get+0xb0>
            if (_tx_thread_preempt_disable != ((UINT) 0))
 800c26a:	4e2a      	ldr	r6, [pc, #168]	; (800c314 <_tx_mutex_get+0xfc>)
 800c26c:	6833      	ldr	r3, [r6, #0]
 800c26e:	bb5b      	cbnz	r3, 800c2c8 <_tx_mutex_get+0xb0>
                thread_ptr -> tx_thread_suspension_sequence++;
 800c270:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_mutex_cleanup);
 800c274:	f8df c0a0 	ldr.w	ip, [pc, #160]	; 800c318 <_tx_mutex_get+0x100>
                thread_ptr -> tx_thread_suspension_sequence++;
 800c278:	1c5f      	adds	r7, r3, #1
                if (mutex_ptr -> tx_mutex_suspended_count == TX_NO_SUSPENSIONS)
 800c27a:	69c3      	ldr	r3, [r0, #28]
                thread_ptr -> tx_thread_suspend_control_block =  (VOID *) mutex_ptr;
 800c27c:	66e0      	str	r0, [r4, #108]	; 0x6c
                thread_ptr -> tx_thread_suspension_sequence++;
 800c27e:	f8c4 70c0 	str.w	r7, [r4, #192]	; 0xc0
                thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_mutex_cleanup);
 800c282:	f8c4 c068 	str.w	ip, [r4, #104]	; 0x68
                if (mutex_ptr -> tx_mutex_suspended_count == TX_NO_SUSPENSIONS)
 800c286:	bb43      	cbnz	r3, 800c2da <_tx_mutex_get+0xc2>
                    mutex_ptr -> tx_mutex_suspension_list =         thread_ptr;
 800c288:	6184      	str	r4, [r0, #24]
                    thread_ptr -> tx_thread_suspended_previous =    thread_ptr;
 800c28a:	e9c4 441c 	strd	r4, r4, [r4, #112]	; 0x70
                _tx_thread_preempt_disable++;
 800c28e:	6837      	ldr	r7, [r6, #0]
                mutex_ptr -> tx_mutex_suspended_count++;
 800c290:	3301      	adds	r3, #1
                thread_ptr -> tx_thread_state =    TX_MUTEX_SUSP;
 800c292:	f04f 0c0d 	mov.w	ip, #13
                mutex_ptr -> tx_mutex_suspended_count++;
 800c296:	61c3      	str	r3, [r0, #28]
                _tx_thread_preempt_disable++;
 800c298:	3701      	adds	r7, #1
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c29a:	2301      	movs	r3, #1
                thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 800c29c:	64e1      	str	r1, [r4, #76]	; 0x4c
                _tx_thread_preempt_disable++;
 800c29e:	6037      	str	r7, [r6, #0]
                thread_ptr -> tx_thread_state =    TX_MUTEX_SUSP;
 800c2a0:	f8c4 c030 	str.w	ip, [r4, #48]	; 0x30
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c2a4:	63a3      	str	r3, [r4, #56]	; 0x38
 800c2a6:	f385 8810 	msr	PRIMASK, r5
                if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800c2aa:	6903      	ldr	r3, [r0, #16]
 800c2ac:	2b01      	cmp	r3, #1
 800c2ae:	d01d      	beq.n	800c2ec <_tx_mutex_get+0xd4>
                _tx_thread_system_suspend(thread_ptr);
 800c2b0:	4620      	mov	r0, r4
 800c2b2:	f000 fb17 	bl	800c8e4 <_tx_thread_system_suspend>
                status =  thread_ptr -> tx_thread_suspend_status;
 800c2b6:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
}
 800c2ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        mutex_ptr -> tx_mutex_ownership_count++;
 800c2bc:	3301      	adds	r3, #1
 800c2be:	6083      	str	r3, [r0, #8]
 800c2c0:	f385 8810 	msr	PRIMASK, r5
        status =  TX_SUCCESS;
 800c2c4:	2000      	movs	r0, #0
 800c2c6:	e7cb      	b.n	800c260 <_tx_mutex_get+0x48>
 800c2c8:	f385 8810 	msr	PRIMASK, r5
            status =  TX_NOT_AVAILABLE;
 800c2cc:	201d      	movs	r0, #29
}
 800c2ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
 800c2d0:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
 800c2d4:	e9c0 000b 	strd	r0, r0, [r0, #44]	; 0x2c
 800c2d8:	e7ba      	b.n	800c250 <_tx_mutex_get+0x38>
                    next_thread =                                   mutex_ptr -> tx_mutex_suspension_list;
 800c2da:	6987      	ldr	r7, [r0, #24]
                    previous_thread =                               next_thread -> tx_thread_suspended_previous;
 800c2dc:	f8d7 c074 	ldr.w	ip, [r7, #116]	; 0x74
                    thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 800c2e0:	e9c4 7c1c 	strd	r7, ip, [r4, #112]	; 0x70
                    previous_thread -> tx_thread_suspended_next =   thread_ptr;
 800c2e4:	f8cc 4070 	str.w	r4, [ip, #112]	; 0x70
                    next_thread -> tx_thread_suspended_previous =   thread_ptr;
 800c2e8:	677c      	str	r4, [r7, #116]	; 0x74
 800c2ea:	e7d0      	b.n	800c28e <_tx_mutex_get+0x76>
                    if (mutex_ptr -> tx_mutex_highest_priority_waiting > thread_ptr -> tx_thread_priority)
 800c2ec:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800c2ee:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800c2f0:	428b      	cmp	r3, r1
                    if (thread_ptr -> tx_thread_priority < mutex_owner -> tx_thread_inherit_priority)
 800c2f2:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
                        mutex_ptr -> tx_mutex_highest_priority_waiting =  thread_ptr -> tx_thread_priority;
 800c2f6:	bf88      	it	hi
 800c2f8:	6281      	strhi	r1, [r0, #40]	; 0x28
                    if (thread_ptr -> tx_thread_priority < mutex_owner -> tx_thread_inherit_priority)
 800c2fa:	4299      	cmp	r1, r3
                    if (mutex_owner -> tx_thread_priority > thread_ptr -> tx_thread_priority)
 800c2fc:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
                        mutex_owner -> tx_thread_inherit_priority =  thread_ptr -> tx_thread_priority;
 800c2fe:	bf38      	it	cc
 800c300:	f8c2 109c 	strcc.w	r1, [r2, #156]	; 0x9c
                    if (mutex_owner -> tx_thread_priority > thread_ptr -> tx_thread_priority)
 800c304:	4299      	cmp	r1, r3
 800c306:	d2d3      	bcs.n	800c2b0 <_tx_mutex_get+0x98>
                        _tx_mutex_priority_change(mutex_owner, thread_ptr -> tx_thread_priority);
 800c308:	4610      	mov	r0, r2
 800c30a:	f000 f807 	bl	800c31c <_tx_mutex_priority_change>
 800c30e:	e7cf      	b.n	800c2b0 <_tx_mutex_get+0x98>
 800c310:	20000f2c 	.word	0x20000f2c
 800c314:	20000f28 	.word	0x20000f28
 800c318:	0800d311 	.word	0x0800d311

0800c31c <_tx_mutex_priority_change>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_priority_change(TX_THREAD *thread_ptr, UINT new_priority)
{
 800c31c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c320:	4604      	mov	r4, r0
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c322:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c326:	b672      	cpsid	i
    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE
#endif

    /* Determine if this thread is currently ready.  */
    if (thread_ptr -> tx_thread_state != TX_READY)
 800c328:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800c32a:	b152      	cbz	r2, 800c342 <_tx_mutex_priority_change+0x26>
 800c32c:	f8d0 2098 	ldr.w	r2, [r0, #152]	; 0x98
    {

        /* Change thread priority to the new mutex priority-inheritance priority.  */
        thread_ptr -> tx_thread_priority =  new_priority;
 800c330:	62c1      	str	r1, [r0, #44]	; 0x2c
 800c332:	428a      	cmp	r2, r1
 800c334:	bf28      	it	cs
 800c336:	460a      	movcs	r2, r1
 800c338:	63c2      	str	r2, [r0, #60]	; 0x3c
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c33a:	f386 8810 	msr	PRIMASK, r6
        
        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
 800c33e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c342:	460d      	mov	r5, r1
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 2);
 800c344:	4925      	ldr	r1, [pc, #148]	; (800c3dc <_tx_mutex_priority_change+0xc0>)
        thread_ptr -> tx_thread_state =    TX_SUSPENDED;
 800c346:	f04f 0c03 	mov.w	ip, #3
        execute_ptr =  _tx_thread_execute_ptr;
 800c34a:	4f25      	ldr	r7, [pc, #148]	; (800c3e0 <_tx_mutex_priority_change+0xc4>)
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 2);
 800c34c:	680b      	ldr	r3, [r1, #0]
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c34e:	f04f 0a01 	mov.w	sl, #1
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800c352:	64c2      	str	r2, [r0, #76]	; 0x4c
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 2);
 800c354:	3302      	adds	r3, #2
        thread_ptr -> tx_thread_state =    TX_SUSPENDED;
 800c356:	f8c0 c030 	str.w	ip, [r0, #48]	; 0x30
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c35a:	f8c0 a038 	str.w	sl, [r0, #56]	; 0x38
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 2);
 800c35e:	600b      	str	r3, [r1, #0]
        execute_ptr =  _tx_thread_execute_ptr;
 800c360:	f8d7 8000 	ldr.w	r8, [r7]
        original_priority =  thread_ptr -> tx_thread_priority;
 800c364:	f8d0 902c 	ldr.w	r9, [r0, #44]	; 0x2c
 800c368:	f386 8810 	msr	PRIMASK, r6
        _tx_thread_system_suspend(thread_ptr);
 800c36c:	f000 faba 	bl	800c8e4 <_tx_thread_system_suspend>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c370:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c374:	b672      	cpsid	i
 800c376:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
        thread_ptr -> tx_thread_priority =  new_priority;
 800c37a:	62e5      	str	r5, [r4, #44]	; 0x2c
 800c37c:	42ab      	cmp	r3, r5
 800c37e:	bf28      	it	cs
 800c380:	462b      	movcs	r3, r5
 800c382:	63e3      	str	r3, [r4, #60]	; 0x3c
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c384:	f382 8810 	msr	PRIMASK, r2
        _tx_thread_system_resume(thread_ptr);
 800c388:	4620      	mov	r0, r4
 800c38a:	f000 fa25 	bl	800c7d8 <_tx_thread_system_resume>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c38e:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c392:	b672      	cpsid	i
        next_execute_ptr =  _tx_thread_execute_ptr;
 800c394:	683b      	ldr	r3, [r7, #0]
        if (thread_ptr != next_execute_ptr)
 800c396:	429c      	cmp	r4, r3
 800c398:	d007      	beq.n	800c3aa <_tx_mutex_priority_change+0x8e>
            if (thread_ptr -> tx_thread_state == TX_READY)
 800c39a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800c39c:	b92a      	cbnz	r2, 800c3aa <_tx_mutex_priority_change+0x8e>
                if (thread_ptr -> tx_thread_priority <= next_execute_ptr -> tx_thread_priority)
 800c39e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c3a0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800c3a2:	4293      	cmp	r3, r2
 800c3a4:	d805      	bhi.n	800c3b2 <_tx_mutex_priority_change+0x96>
                    if (thread_ptr == execute_ptr)
 800c3a6:	4544      	cmp	r4, r8
 800c3a8:	d010      	beq.n	800c3cc <_tx_mutex_priority_change+0xb0>
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c3aa:	f381 8810 	msr	PRIMASK, r1
}
 800c3ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                    if (thread_ptr -> tx_thread_preempt_threshold < thread_ptr -> tx_thread_priority)
 800c3b2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800c3b4:	4283      	cmp	r3, r0
 800c3b6:	d9f8      	bls.n	800c3aa <_tx_mutex_priority_change+0x8e>
                        if (thread_ptr -> tx_thread_preempt_threshold <= next_execute_ptr -> tx_thread_priority)
 800c3b8:	4282      	cmp	r2, r0
 800c3ba:	d207      	bcs.n	800c3cc <_tx_mutex_priority_change+0xb0>
                            _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 800c3bc:	4809      	ldr	r0, [pc, #36]	; (800c3e4 <_tx_mutex_priority_change+0xc8>)
                            TX_MOD32_BIT_SET(next_execute_ptr -> tx_thread_priority, priority_bit)
 800c3be:	fa0a fa02 	lsl.w	sl, sl, r2
                            _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 800c3c2:	6803      	ldr	r3, [r0, #0]
 800c3c4:	ea43 030a 	orr.w	r3, r3, sl
 800c3c8:	6003      	str	r3, [r0, #0]
 800c3ca:	e7ee      	b.n	800c3aa <_tx_mutex_priority_change+0x8e>
                            if (original_priority < new_priority)
 800c3cc:	45a9      	cmp	r9, r5
                            _tx_thread_execute_ptr =  thread_ptr;
 800c3ce:	603c      	str	r4, [r7, #0]
                            if (original_priority < new_priority)
 800c3d0:	d2eb      	bcs.n	800c3aa <_tx_mutex_priority_change+0x8e>
                                _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
 800c3d2:	4a05      	ldr	r2, [pc, #20]	; (800c3e8 <_tx_mutex_priority_change+0xcc>)
 800c3d4:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
 800c3d8:	e7e7      	b.n	800c3aa <_tx_mutex_priority_change+0x8e>
 800c3da:	bf00      	nop
 800c3dc:	20000f28 	.word	0x20000f28
 800c3e0:	20000f30 	.word	0x20000f30
 800c3e4:	20000f38 	.word	0x20000f38
 800c3e8:	20000e90 	.word	0x20000e90

0800c3ec <_tx_mutex_put>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_put(TX_MUTEX *mutex_ptr)
{
 800c3ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c3f0:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c3f4:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_MUTEX_PUT_INSERT

    /* Determine if this mutex is owned.  */
    if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
 800c3f6:	6882      	ldr	r2, [r0, #8]
 800c3f8:	2a00      	cmp	r2, #0
 800c3fa:	d056      	beq.n	800c4aa <_tx_mutex_put+0xbe>

        /* Pickup the owning thread pointer.  */
        thread_ptr =  mutex_ptr -> tx_mutex_owner;

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
 800c3fc:	497e      	ldr	r1, [pc, #504]	; (800c5f8 <_tx_mutex_put+0x20c>)
 800c3fe:	46a4      	mov	ip, r4
        thread_ptr =  mutex_ptr -> tx_mutex_owner;
 800c400:	68c3      	ldr	r3, [r0, #12]

        /* Check to see if the mutex is owned by the calling thread.  */
        if (mutex_ptr -> tx_mutex_owner != current_thread)
 800c402:	6809      	ldr	r1, [r1, #0]
 800c404:	428b      	cmp	r3, r1
 800c406:	d003      	beq.n	800c410 <_tx_mutex_put+0x24>
        {
        
            /* Determine if the preempt disable flag is set, indicating that 
               the caller is not the application but from ThreadX. In such
               cases, the thread mutex owner does not need to match.  */
            if (_tx_thread_preempt_disable == ((UINT) 0))
 800c408:	4e7c      	ldr	r6, [pc, #496]	; (800c5fc <_tx_mutex_put+0x210>)
 800c40a:	6831      	ldr	r1, [r6, #0]
 800c40c:	2900      	cmp	r1, #0
 800c40e:	d04c      	beq.n	800c4aa <_tx_mutex_put+0xbe>
        /* Determine if we should continue.  */
        if (status == TX_NOT_DONE)
        {
    
            /* Decrement the mutex ownership count.  */
            mutex_ptr -> tx_mutex_ownership_count--;
 800c410:	3a01      	subs	r2, #1
 800c412:	6082      	str	r2, [r0, #8]

            /* Determine if the mutex is still owned by the current thread.  */
            if (mutex_ptr -> tx_mutex_ownership_count != ((UINT) 0))
 800c414:	2a00      	cmp	r2, #0
 800c416:	d143      	bne.n	800c4a0 <_tx_mutex_put+0xb4>
            }
            else
            {

                /* Check for a NULL thread pointer, which can only happen during initialization.   */
                if (thread_ptr == TX_NULL)
 800c418:	2b00      	cmp	r3, #0
 800c41a:	d041      	beq.n	800c4a0 <_tx_mutex_put+0xb4>
                    /* The mutex is now available.   */
            
                    /* Remove this mutex from the owned mutex list.  */
                    
                    /* Decrement the ownership count.  */
                    thread_ptr -> tx_thread_owned_mutex_count--;
 800c41c:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 800c420:	3a01      	subs	r2, #1
 800c422:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

                    /* Determine if this mutex was the only one on the list.  */
                    if (thread_ptr -> tx_thread_owned_mutex_count == ((UINT) 0))
 800c426:	2a00      	cmp	r2, #0
 800c428:	d144      	bne.n	800c4b4 <_tx_mutex_put+0xc8>
                        /* See if we have to update the created list head pointer.  */
                        if (thread_ptr -> tx_thread_owned_mutex_list == mutex_ptr)
                        {

                            /* Yes, move the head pointer to the next link. */
                            thread_ptr -> tx_thread_owned_mutex_list =  next_mutex;
 800c42a:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
                        }
                    }

                    /* Determine if the simple, non-suspension, non-priority inheritance case is present.  */
                    if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
 800c42e:	6987      	ldr	r7, [r0, #24]
 800c430:	6902      	ldr	r2, [r0, #16]
 800c432:	2f00      	cmp	r7, #0
 800c434:	f000 8082 	beq.w	800c53c <_tx_mutex_put+0x150>
                        /* Initialize original owner and thread priority.  */
                        old_owner =      TX_NULL;
                        old_priority =   thread_ptr -> tx_thread_user_priority;

                        /* Does this mutex support priority inheritance?  */
                        if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800c438:	2a01      	cmp	r2, #1
 800c43a:	4605      	mov	r5, r0
                        old_priority =   thread_ptr -> tx_thread_user_priority;
 800c43c:	f8d3 8094 	ldr.w	r8, [r3, #148]	; 0x94
                        if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800c440:	f000 8084 	beq.w	800c54c <_tx_mutex_put+0x160>
                            }
                        }

                        /* Determine if priority inheritance is in effect and there are one or more
                           threads suspended on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
 800c444:	69c3      	ldr	r3, [r0, #28]
 800c446:	4e6d      	ldr	r6, [pc, #436]	; (800c5fc <_tx_mutex_put+0x210>)
 800c448:	2b01      	cmp	r3, #1
 800c44a:	d95d      	bls.n	800c508 <_tx_mutex_put+0x11c>
#endif
                            }
                        }

                        /* Now determine if there are any threads still waiting on the mutex.  */
                        if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
 800c44c:	2f00      	cmp	r7, #0
 800c44e:	f000 8097 	beq.w	800c580 <_tx_mutex_put+0x194>
                        old_owner =      TX_NULL;
 800c452:	2400      	movs	r4, #0
                                /* Setup the highest priority waiting thread.  */
                                mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
                            }

                            /* Determine how many mutexes are owned by this thread.  */
                            owned_count =  thread_ptr -> tx_thread_owned_mutex_count;
 800c454:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0

                            /* Determine if this thread owns any other mutexes that have priority inheritance.  */
                            if (owned_count == ((UINT) 0))
 800c458:	2a00      	cmp	r2, #0
 800c45a:	d167      	bne.n	800c52c <_tx_mutex_put+0x140>
                            {

                                /* The owned mutex list is empty.  Add mutex to empty list.  */
                                thread_ptr -> tx_thread_owned_mutex_list =     mutex_ptr;
 800c45c:	f8c7 50a4 	str.w	r5, [r7, #164]	; 0xa4
                                mutex_ptr -> tx_mutex_owned_next =             mutex_ptr;
                                mutex_ptr -> tx_mutex_owned_previous =         mutex_ptr;
 800c460:	e9c5 550b 	strd	r5, r5, [r5, #44]	; 0x2c
                                mutex_ptr -> tx_mutex_owned_previous =   previous_mutex;
                                mutex_ptr -> tx_mutex_owned_next =       next_mutex;
                            }

                            /* Increment the number of mutexes owned counter.  */
                            thread_ptr -> tx_thread_owned_mutex_count =  owned_count + ((UINT) 1);
 800c464:	3201      	adds	r2, #1
                            mutex_ptr -> tx_mutex_owner =            thread_ptr;

                            /* Remove the suspended thread from the list.  */

                            /* Decrement the suspension count.  */
                            mutex_ptr -> tx_mutex_suspended_count--;
 800c466:	3b01      	subs	r3, #1
                            mutex_ptr -> tx_mutex_ownership_count =  (UINT) 1;
 800c468:	2101      	movs	r1, #1
                            thread_ptr -> tx_thread_owned_mutex_count =  owned_count + ((UINT) 1);
 800c46a:	f8c7 20a0 	str.w	r2, [r7, #160]	; 0xa0
                            mutex_ptr -> tx_mutex_suspended_count--;
 800c46e:	61eb      	str	r3, [r5, #28]
                            mutex_ptr -> tx_mutex_ownership_count =  (UINT) 1;
 800c470:	e9c5 1702 	strd	r1, r7, [r5, #8]
                
                            /* Pickup the suspended count.  */
                            suspended_count =  mutex_ptr -> tx_mutex_suspended_count;

                            /* See if this is the only suspended thread on the list.  */
                            if (suspended_count == TX_NO_SUSPENSIONS)
 800c474:	2b00      	cmp	r3, #0
 800c476:	d153      	bne.n	800c520 <_tx_mutex_put+0x134>
                            {

                                /* Yes, the only suspended thread.  */
    
                                /* Update the head pointer.  */
                                mutex_ptr -> tx_mutex_suspension_list =  TX_NULL;
 800c478:	61ab      	str	r3, [r5, #24]
                            /* Restore interrupts.  */
                            TX_RESTORE
#else

                            /* Temporarily disable preemption.  */
                            _tx_thread_preempt_disable++;
 800c47a:	6833      	ldr	r3, [r6, #0]
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c47c:	2200      	movs	r2, #0
                            _tx_thread_preempt_disable++;
 800c47e:	3301      	adds	r3, #1
                            thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800c480:	66ba      	str	r2, [r7, #104]	; 0x68
                            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800c482:	f8c7 2084 	str.w	r2, [r7, #132]	; 0x84
                            _tx_thread_preempt_disable++;
 800c486:	6033      	str	r3, [r6, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c488:	f38c 8810 	msr	PRIMASK, ip

                            /* Restore interrupts.  */
                            TX_RESTORE

                            /* Determine if priority inheritance is enabled for this mutex.  */
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800c48c:	692b      	ldr	r3, [r5, #16]
 800c48e:	2b01      	cmp	r3, #1
 800c490:	f000 8097 	beq.w	800c5c2 <_tx_mutex_put+0x1d6>
                                    _tx_mutex_priority_change(old_owner, old_priority);
                                }
                            }

                            /* Resume thread.  */
                            _tx_thread_system_resume(thread_ptr);
 800c494:	4638      	mov	r0, r7
 800c496:	f000 f99f 	bl	800c7d8 <_tx_thread_system_resume>
#endif
                     
                            /* Return a successful status.  */
                            status =  TX_SUCCESS;
 800c49a:	2000      	movs	r0, #0
        status =  TX_NOT_OWNED;
    }

    /* Return the completion status.  */
    return(status);
}
 800c49c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c4a0:	f384 8810 	msr	PRIMASK, r4
                status =  TX_SUCCESS;
 800c4a4:	2000      	movs	r0, #0
}
 800c4a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c4aa:	f384 8810 	msr	PRIMASK, r4
        status =  TX_NOT_OWNED;
 800c4ae:	201e      	movs	r0, #30
}
 800c4b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                        if (thread_ptr -> tx_thread_owned_mutex_list == mutex_ptr)
 800c4b4:	f8d3 50a4 	ldr.w	r5, [r3, #164]	; 0xa4
                        previous_mutex =                         mutex_ptr -> tx_mutex_owned_previous;
 800c4b8:	e9d0 210b 	ldrd	r2, r1, [r0, #44]	; 0x2c
                        if (thread_ptr -> tx_thread_owned_mutex_list == mutex_ptr)
 800c4bc:	4285      	cmp	r5, r0
                        next_mutex -> tx_mutex_owned_previous =  previous_mutex;
 800c4be:	6311      	str	r1, [r2, #48]	; 0x30
                        previous_mutex -> tx_mutex_owned_next =  next_mutex;
 800c4c0:	62ca      	str	r2, [r1, #44]	; 0x2c
                        if (thread_ptr -> tx_thread_owned_mutex_list == mutex_ptr)
 800c4c2:	d1b4      	bne.n	800c42e <_tx_mutex_put+0x42>
 800c4c4:	e7b1      	b.n	800c42a <_tx_mutex_put+0x3e>
                            inheritance_priority =  ((UINT) TX_MAX_PRIORITIES);
 800c4c6:	2420      	movs	r4, #32
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c4c8:	f3ef 8c10 	mrs	ip, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c4cc:	b672      	cpsid	i
                            _tx_thread_preempt_disable--;
 800c4ce:	6832      	ldr	r2, [r6, #0]
 800c4d0:	45a0      	cmp	r8, r4
                            thread_ptr -> tx_thread_inherit_priority =  inheritance_priority;
 800c4d2:	f8c3 409c 	str.w	r4, [r3, #156]	; 0x9c
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
 800c4d6:	69eb      	ldr	r3, [r5, #28]
 800c4d8:	bf28      	it	cs
 800c4da:	46a0      	movcs	r8, r4
                            _tx_thread_preempt_disable--;
 800c4dc:	3a01      	subs	r2, #1
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
 800c4de:	2b01      	cmp	r3, #1
                            _tx_thread_preempt_disable--;
 800c4e0:	6032      	str	r2, [r6, #0]
                        if (mutex_ptr -> tx_mutex_suspended_count > ((UINT) 1))
 800c4e2:	d969      	bls.n	800c5b8 <_tx_mutex_put+0x1cc>
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800c4e4:	692a      	ldr	r2, [r5, #16]
 800c4e6:	2a01      	cmp	r2, #1
 800c4e8:	d176      	bne.n	800c5d8 <_tx_mutex_put+0x1ec>
                                _tx_thread_preempt_disable++;
 800c4ea:	6833      	ldr	r3, [r6, #0]
 800c4ec:	3301      	adds	r3, #1
 800c4ee:	6033      	str	r3, [r6, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c4f0:	f38c 8810 	msr	PRIMASK, ip
                                _tx_mutex_prioritize(mutex_ptr);
 800c4f4:	4628      	mov	r0, r5
 800c4f6:	f000 ff6d 	bl	800d3d4 <_tx_mutex_prioritize>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c4fa:	f3ef 8c10 	mrs	ip, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c4fe:	b672      	cpsid	i
                                _tx_thread_preempt_disable--;
 800c500:	6833      	ldr	r3, [r6, #0]
 800c502:	69af      	ldr	r7, [r5, #24]
 800c504:	3b01      	subs	r3, #1
 800c506:	6033      	str	r3, [r6, #0]
                        if (mutex_ptr -> tx_mutex_suspension_list == TX_NULL)
 800c508:	2f00      	cmp	r7, #0
 800c50a:	d039      	beq.n	800c580 <_tx_mutex_put+0x194>
                            if (mutex_ptr -> tx_mutex_inherit == TX_TRUE)
 800c50c:	692b      	ldr	r3, [r5, #16]
 800c50e:	2b01      	cmp	r3, #1
 800c510:	d154      	bne.n	800c5bc <_tx_mutex_put+0x1d0>
                                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
 800c512:	6afa      	ldr	r2, [r7, #44]	; 0x2c
                                mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
 800c514:	2320      	movs	r3, #32
                                old_owner =  mutex_ptr -> tx_mutex_owner;
 800c516:	68ec      	ldr	r4, [r5, #12]
                                mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
 800c518:	62ab      	str	r3, [r5, #40]	; 0x28
                                mutex_ptr -> tx_mutex_original_priority =   thread_ptr -> tx_thread_priority;
 800c51a:	616a      	str	r2, [r5, #20]
 800c51c:	69eb      	ldr	r3, [r5, #28]
 800c51e:	e799      	b.n	800c454 <_tx_mutex_put+0x68>
                                previous_thread =                              thread_ptr -> tx_thread_suspended_previous;
 800c520:	e9d7 321c 	ldrd	r3, r2, [r7, #112]	; 0x70
                                mutex_ptr -> tx_mutex_suspension_list =        next_thread;
 800c524:	61ab      	str	r3, [r5, #24]
                                next_thread -> tx_thread_suspended_previous =  previous_thread;
 800c526:	675a      	str	r2, [r3, #116]	; 0x74
                                previous_thread -> tx_thread_suspended_next =  next_thread;
 800c528:	6713      	str	r3, [r2, #112]	; 0x70
 800c52a:	e7a6      	b.n	800c47a <_tx_mutex_put+0x8e>
                                next_mutex =                            thread_ptr -> tx_thread_owned_mutex_list;
 800c52c:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
                                previous_mutex =                        next_mutex -> tx_mutex_owned_previous;
 800c530:	6b08      	ldr	r0, [r1, #48]	; 0x30
                                next_mutex -> tx_mutex_owned_previous =  mutex_ptr;
 800c532:	630d      	str	r5, [r1, #48]	; 0x30
                                previous_mutex -> tx_mutex_owned_next =  mutex_ptr;
 800c534:	62c5      	str	r5, [r0, #44]	; 0x2c
                                mutex_ptr -> tx_mutex_owned_next =       next_mutex;
 800c536:	e9c5 100b 	strd	r1, r0, [r5, #44]	; 0x2c
 800c53a:	e793      	b.n	800c464 <_tx_mutex_put+0x78>
                        if (mutex_ptr -> tx_mutex_inherit == TX_FALSE)
 800c53c:	2a00      	cmp	r2, #0
 800c53e:	f47f af7b 	bne.w	800c438 <_tx_mutex_put+0x4c>
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
 800c542:	60c2      	str	r2, [r0, #12]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c544:	f384 8810 	msr	PRIMASK, r4
                            status =  TX_SUCCESS;
 800c548:	4610      	mov	r0, r2
 800c54a:	e7ac      	b.n	800c4a6 <_tx_mutex_put+0xba>
                            _tx_thread_preempt_disable++;
 800c54c:	4e2b      	ldr	r6, [pc, #172]	; (800c5fc <_tx_mutex_put+0x210>)
 800c54e:	6832      	ldr	r2, [r6, #0]
 800c550:	3201      	adds	r2, #1
 800c552:	6032      	str	r2, [r6, #0]
 800c554:	f384 8810 	msr	PRIMASK, r4
                            next_mutex =  thread_ptr -> tx_thread_owned_mutex_list;
 800c558:	f8d3 10a4 	ldr.w	r1, [r3, #164]	; 0xa4
                            while (next_mutex != TX_NULL)
 800c55c:	2900      	cmp	r1, #0
 800c55e:	d0b2      	beq.n	800c4c6 <_tx_mutex_put+0xda>
 800c560:	460a      	mov	r2, r1
                            inheritance_priority =  ((UINT) TX_MAX_PRIORITIES);
 800c562:	2420      	movs	r4, #32
 800c564:	e001      	b.n	800c56a <_tx_mutex_put+0x17e>
                            while (next_mutex != TX_NULL)
 800c566:	2a00      	cmp	r2, #0
 800c568:	d0ae      	beq.n	800c4c8 <_tx_mutex_put+0xdc>
                                if (next_mutex -> tx_mutex_inherit == TX_TRUE)
 800c56a:	6910      	ldr	r0, [r2, #16]
 800c56c:	2801      	cmp	r0, #1
 800c56e:	d103      	bne.n	800c578 <_tx_mutex_put+0x18c>
 800c570:	6a90      	ldr	r0, [r2, #40]	; 0x28
 800c572:	4284      	cmp	r4, r0
 800c574:	bf28      	it	cs
 800c576:	4604      	movcs	r4, r0
                                next_mutex =  next_mutex -> tx_mutex_owned_next;
 800c578:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
                                if (next_mutex == thread_ptr -> tx_thread_owned_mutex_list)
 800c57a:	4291      	cmp	r1, r2
 800c57c:	d1f3      	bne.n	800c566 <_tx_mutex_put+0x17a>
 800c57e:	e7a3      	b.n	800c4c8 <_tx_mutex_put+0xdc>
                            _tx_thread_preempt_disable++;
 800c580:	6833      	ldr	r3, [r6, #0]
 800c582:	3301      	adds	r3, #1
 800c584:	6033      	str	r3, [r6, #0]
 800c586:	f38c 8810 	msr	PRIMASK, ip
                            if ((mutex_ptr -> tx_mutex_owner) -> tx_thread_priority != old_priority)
 800c58a:	68e8      	ldr	r0, [r5, #12]
                            mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
 800c58c:	2220      	movs	r2, #32
                            if ((mutex_ptr -> tx_mutex_owner) -> tx_thread_priority != old_priority)
 800c58e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
                            mutex_ptr -> tx_mutex_highest_priority_waiting =  (UINT) TX_MAX_PRIORITIES;
 800c590:	62aa      	str	r2, [r5, #40]	; 0x28
                            if ((mutex_ptr -> tx_mutex_owner) -> tx_thread_priority != old_priority)
 800c592:	4543      	cmp	r3, r8
 800c594:	d002      	beq.n	800c59c <_tx_mutex_put+0x1b0>
                                _tx_mutex_priority_change(mutex_ptr -> tx_mutex_owner, old_priority);
 800c596:	4641      	mov	r1, r8
 800c598:	f7ff fec0 	bl	800c31c <_tx_mutex_priority_change>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c59c:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c5a0:	b672      	cpsid	i
                            _tx_thread_preempt_disable--;
 800c5a2:	6833      	ldr	r3, [r6, #0]
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
 800c5a4:	2400      	movs	r4, #0
                            _tx_thread_preempt_disable--;
 800c5a6:	3b01      	subs	r3, #1
                            mutex_ptr -> tx_mutex_owner =  TX_NULL;
 800c5a8:	60ec      	str	r4, [r5, #12]
                            _tx_thread_preempt_disable--;
 800c5aa:	6033      	str	r3, [r6, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c5ac:	f382 8810 	msr	PRIMASK, r2
                            _tx_thread_system_preempt_check();
 800c5b0:	f000 f8f4 	bl	800c79c <_tx_thread_system_preempt_check>
                            status =  TX_SUCCESS;
 800c5b4:	4620      	mov	r0, r4
 800c5b6:	e776      	b.n	800c4a6 <_tx_mutex_put+0xba>
 800c5b8:	69af      	ldr	r7, [r5, #24]
 800c5ba:	e7a5      	b.n	800c508 <_tx_mutex_put+0x11c>
                        old_owner =      TX_NULL;
 800c5bc:	2400      	movs	r4, #0
 800c5be:	69eb      	ldr	r3, [r5, #28]
 800c5c0:	e748      	b.n	800c454 <_tx_mutex_put+0x68>
                                if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
 800c5c2:	69eb      	ldr	r3, [r5, #28]
 800c5c4:	b953      	cbnz	r3, 800c5dc <_tx_mutex_put+0x1f0>
                                if (old_owner -> tx_thread_priority != old_priority)
 800c5c6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800c5c8:	4543      	cmp	r3, r8
 800c5ca:	f43f af63 	beq.w	800c494 <_tx_mutex_put+0xa8>
                                    _tx_mutex_priority_change(old_owner, old_priority);
 800c5ce:	4641      	mov	r1, r8
 800c5d0:	4620      	mov	r0, r4
 800c5d2:	f7ff fea3 	bl	800c31c <_tx_mutex_priority_change>
 800c5d6:	e75d      	b.n	800c494 <_tx_mutex_put+0xa8>
 800c5d8:	69af      	ldr	r7, [r5, #24]
 800c5da:	e737      	b.n	800c44c <_tx_mutex_put+0x60>
                                    _tx_mutex_prioritize(mutex_ptr);
 800c5dc:	4628      	mov	r0, r5
 800c5de:	f000 fef9 	bl	800d3d4 <_tx_mutex_prioritize>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c5e2:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c5e6:	b672      	cpsid	i
                                    suspended_thread =  mutex_ptr -> tx_mutex_suspension_list;
 800c5e8:	69ab      	ldr	r3, [r5, #24]
                                    if (suspended_thread != TX_NULL)
 800c5ea:	b10b      	cbz	r3, 800c5f0 <_tx_mutex_put+0x204>
                                        mutex_ptr -> tx_mutex_highest_priority_waiting =  suspended_thread -> tx_thread_priority;
 800c5ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c5ee:	62ab      	str	r3, [r5, #40]	; 0x28
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c5f0:	f382 8810 	msr	PRIMASK, r2
 800c5f4:	e7e7      	b.n	800c5c6 <_tx_mutex_put+0x1da>
 800c5f6:	bf00      	nop
 800c5f8:	20000f2c 	.word	0x20000f2c
 800c5fc:	20000f28 	.word	0x20000f28

0800c600 <_tx_thread_identify>:
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c600:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c604:	b672      	cpsid	i

   /* Log this kernel call.  */
    TX_EL_THREAD_IDENTIFY_INSERT

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800c606:	4a02      	ldr	r2, [pc, #8]	; (800c610 <_tx_thread_identify+0x10>)
 800c608:	6810      	ldr	r0, [r2, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c60a:	f383 8810 	msr	PRIMASK, r3
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return the current thread pointer.  */
    return(thread_ptr);
}
 800c60e:	4770      	bx	lr
 800c610:	20000f2c 	.word	0x20000f2c

0800c614 <_tx_thread_initialize>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_initialize(VOID)
{
 800c614:	b538      	push	{r3, r4, r5, lr}

    /* Set current thread pointer to NULL.  */
    TX_THREAD_SET_CURRENT(TX_NULL)

    /* Initialize the execute thread pointer to NULL.  */
    _tx_thread_execute_ptr =  TX_NULL;
 800c616:	480f      	ldr	r0, [pc, #60]	; (800c654 <_tx_thread_initialize+0x40>)
    TX_THREAD_SET_CURRENT(TX_NULL)
 800c618:	2400      	movs	r4, #0

    /* Initialize the priority information.  */
    TX_MEMSET(&_tx_thread_priority_maps[0], 0, (sizeof(_tx_thread_priority_maps)));
 800c61a:	4b0f      	ldr	r3, [pc, #60]	; (800c658 <_tx_thread_initialize+0x44>)
#endif
#endif

    /* Setup the highest priority variable to the max, indicating no thread is currently
       ready.  */
    _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 800c61c:	2520      	movs	r5, #32
    _tx_thread_execute_ptr =  TX_NULL;
 800c61e:	6004      	str	r4, [r0, #0]


#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the array of priority head pointers.  */
    TX_MEMSET(&_tx_thread_priority_list[0], 0, (sizeof(_tx_thread_priority_list)));
 800c620:	4621      	mov	r1, r4
    TX_THREAD_SET_CURRENT(TX_NULL)
 800c622:	4a0e      	ldr	r2, [pc, #56]	; (800c65c <_tx_thread_initialize+0x48>)
    TX_MEMSET(&_tx_thread_preempted_maps[0], 0, (sizeof(_tx_thread_preempted_maps)));
 800c624:	480e      	ldr	r0, [pc, #56]	; (800c660 <_tx_thread_initialize+0x4c>)
    TX_MEMSET(&_tx_thread_priority_maps[0], 0, (sizeof(_tx_thread_priority_maps)));
 800c626:	601c      	str	r4, [r3, #0]
    _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 800c628:	4b0e      	ldr	r3, [pc, #56]	; (800c664 <_tx_thread_initialize+0x50>)
    TX_THREAD_SET_CURRENT(TX_NULL)
 800c62a:	6014      	str	r4, [r2, #0]
    TX_MEMSET(&_tx_thread_priority_list[0], 0, (sizeof(_tx_thread_priority_list)));
 800c62c:	2280      	movs	r2, #128	; 0x80
    TX_MEMSET(&_tx_thread_preempted_maps[0], 0, (sizeof(_tx_thread_preempted_maps)));
 800c62e:	6004      	str	r4, [r0, #0]
    TX_MEMSET(&_tx_thread_priority_list[0], 0, (sizeof(_tx_thread_priority_list)));
 800c630:	480d      	ldr	r0, [pc, #52]	; (800c668 <_tx_thread_initialize+0x54>)
    _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 800c632:	601d      	str	r5, [r3, #0]
    TX_MEMSET(&_tx_thread_priority_list[0], 0, (sizeof(_tx_thread_priority_list)));
 800c634:	f001 fb53 	bl	800dcde <memset>
    TX_MEMSET(&_tx_thread_performance_execute_log[0], 0, (sizeof(_tx_thread_performance_execute_log)));
#endif
#endif

    /* Setup the build options flag. This is used to identify how the ThreadX library was constructed.  */
    _tx_build_options =  _tx_build_options 
 800c638:	4a0c      	ldr	r2, [pc, #48]	; (800c66c <_tx_thread_initialize+0x58>)
    _tx_thread_created_ptr =        TX_NULL;
 800c63a:	490d      	ldr	r1, [pc, #52]	; (800c670 <_tx_thread_initialize+0x5c>)
#endif
#ifdef TX_ENABLE_EVENT_TRACE
                            | (((ULONG) 1) << 8)
#endif
#ifdef TX_ENABLE_EXECUTION_CHANGE_NOTIFY
                            | (((ULONG) 1) << 7)
 800c63c:	6810      	ldr	r0, [r2, #0]
 800c63e:	4b0d      	ldr	r3, [pc, #52]	; (800c674 <_tx_thread_initialize+0x60>)
    _tx_thread_created_ptr =        TX_NULL;
 800c640:	600c      	str	r4, [r1, #0]
                            | (((ULONG) 1) << 7)
 800c642:	4303      	orrs	r3, r0
    _tx_thread_created_count =      TX_EMPTY;
 800c644:	4d0c      	ldr	r5, [pc, #48]	; (800c678 <_tx_thread_initialize+0x64>)
    _tx_thread_preempt_disable =    ((UINT) 0);
 800c646:	480d      	ldr	r0, [pc, #52]	; (800c67c <_tx_thread_initialize+0x68>)
    _tx_thread_mutex_release =      TX_NULL;
 800c648:	490d      	ldr	r1, [pc, #52]	; (800c680 <_tx_thread_initialize+0x6c>)
    _tx_thread_created_count =      TX_EMPTY;
 800c64a:	602c      	str	r4, [r5, #0]
    _tx_thread_preempt_disable =    ((UINT) 0);
 800c64c:	6004      	str	r4, [r0, #0]
    _tx_thread_mutex_release =      TX_NULL;
 800c64e:	600c      	str	r4, [r1, #0]
    _tx_build_options =  _tx_build_options 
 800c650:	6013      	str	r3, [r2, #0]
#endif
#if TX_PORT_SPECIFIC_BUILD_OPTIONS != 0
                            | TX_PORT_SPECIFIC_BUILD_OPTIONS
#endif
                            ;
}
 800c652:	bd38      	pop	{r3, r4, r5, pc}
 800c654:	20000f30 	.word	0x20000f30
 800c658:	20000f14 	.word	0x20000f14
 800c65c:	20000f2c 	.word	0x20000f2c
 800c660:	20000f38 	.word	0x20000f38
 800c664:	20000f34 	.word	0x20000f34
 800c668:	20000e90 	.word	0x20000e90
 800c66c:	20000f1c 	.word	0x20000f1c
 800c670:	20000f18 	.word	0x20000f18
 800c674:	01000080 	.word	0x01000080
 800c678:	20000f20 	.word	0x20000f20
 800c67c:	20000f28 	.word	0x20000f28
 800c680:	20000f10 	.word	0x20000f10

0800c684 <_tx_thread_preemption_change>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_preemption_change(TX_THREAD *thread_ptr, UINT new_threshold, UINT *old_threshold)
{
 800c684:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c686:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c68a:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_THREAD_PREEMPTION_CHANGE_INSERT

    /* Determine if the new threshold is greater than the current user priority.  */
    if (new_threshold > thread_ptr -> tx_thread_user_priority)
 800c68c:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
 800c690:	428b      	cmp	r3, r1
 800c692:	d341      	bcc.n	800c718 <_tx_thread_preemption_change+0x94>
    {

#ifndef TX_DISABLE_PREEMPTION_THRESHOLD

        /* Determine if the new threshold is the same as the priority.  */
        if (thread_ptr -> tx_thread_user_priority == new_threshold)
 800c694:	d017      	beq.n	800c6c6 <_tx_thread_preemption_change+0x42>
            }
        }
#endif

        /* Return the user's preemption-threshold.   */
        *old_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 800c696:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
            /* Update the actual preemption-threshold with the priority inheritance.  */
            thread_ptr -> tx_thread_preempt_threshold =  thread_ptr -> tx_thread_inherit_priority;
        }

        /* Is the thread priority less than the current highest priority?  If not, no preemption is required.  */
        if (_tx_thread_highest_priority < thread_ptr -> tx_thread_priority)
 800c69a:	4d21      	ldr	r5, [pc, #132]	; (800c720 <_tx_thread_preemption_change+0x9c>)
        *old_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 800c69c:	6013      	str	r3, [r2, #0]
 800c69e:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
        if (_tx_thread_highest_priority < thread_ptr -> tx_thread_priority)
 800c6a2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 800c6a4:	428b      	cmp	r3, r1
 800c6a6:	682d      	ldr	r5, [r5, #0]
        {

            /* Is the new thread preemption-threshold less than the current highest priority?  If not, no preemption is required.  */
            if (_tx_thread_highest_priority < new_threshold)
 800c6a8:	4616      	mov	r6, r2
        thread_ptr -> tx_thread_user_preempt_threshold =  new_threshold;
 800c6aa:	f8c0 1098 	str.w	r1, [r0, #152]	; 0x98
 800c6ae:	bf28      	it	cs
 800c6b0:	460b      	movcs	r3, r1
            if (_tx_thread_highest_priority < new_threshold)
 800c6b2:	428a      	cmp	r2, r1
 800c6b4:	bf28      	it	cs
 800c6b6:	460e      	movcs	r6, r1
 800c6b8:	63c3      	str	r3, [r0, #60]	; 0x3c
 800c6ba:	42b5      	cmp	r5, r6
 800c6bc:	d312      	bcc.n	800c6e4 <_tx_thread_preemption_change+0x60>
    status =  TX_SUCCESS;
 800c6be:	2000      	movs	r0, #0
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c6c0:	f384 8810 	msr	PRIMASK, r4
    /* Restore interrupts.  */
    TX_RESTORE
    
    /* Return completion status.  */
    return(status);
}
 800c6c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if (_tx_thread_priority_list[thread_ptr -> tx_thread_priority] == thread_ptr)
 800c6c6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800c6c8:	4d16      	ldr	r5, [pc, #88]	; (800c724 <_tx_thread_preemption_change+0xa0>)
 800c6ca:	f855 5023 	ldr.w	r5, [r5, r3, lsl #2]
 800c6ce:	4285      	cmp	r5, r0
 800c6d0:	d1e1      	bne.n	800c696 <_tx_thread_preemption_change+0x12>
                _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
 800c6d2:	4f15      	ldr	r7, [pc, #84]	; (800c728 <_tx_thread_preemption_change+0xa4>)
                TX_MOD32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
 800c6d4:	2601      	movs	r6, #1
                _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
 800c6d6:	683d      	ldr	r5, [r7, #0]
                TX_MOD32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
 800c6d8:	fa06 f303 	lsl.w	r3, r6, r3
                _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
 800c6dc:	ea25 0503 	bic.w	r5, r5, r3
 800c6e0:	603d      	str	r5, [r7, #0]
 800c6e2:	e7d8      	b.n	800c696 <_tx_thread_preemption_change+0x12>
                if (_tx_thread_execute_ptr == thread_ptr)
 800c6e4:	4911      	ldr	r1, [pc, #68]	; (800c72c <_tx_thread_preemption_change+0xa8>)
 800c6e6:	680e      	ldr	r6, [r1, #0]
 800c6e8:	4286      	cmp	r6, r0
 800c6ea:	d1e8      	bne.n	800c6be <_tx_thread_preemption_change+0x3a>
                    if (thread_ptr -> tx_thread_preempt_threshold != thread_ptr -> tx_thread_priority)
 800c6ec:	429a      	cmp	r2, r3
 800c6ee:	d006      	beq.n	800c6fe <_tx_thread_preemption_change+0x7a>
                        _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 800c6f0:	4e0d      	ldr	r6, [pc, #52]	; (800c728 <_tx_thread_preemption_change+0xa4>)
                        TX_MOD32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
 800c6f2:	2001      	movs	r0, #1
                        _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 800c6f4:	6833      	ldr	r3, [r6, #0]
                        TX_MOD32_BIT_SET(thread_ptr -> tx_thread_priority, priority_bit)
 800c6f6:	fa00 f202 	lsl.w	r2, r0, r2
                        _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 800c6fa:	4313      	orrs	r3, r2
 800c6fc:	6033      	str	r3, [r6, #0]
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800c6fe:	4b09      	ldr	r3, [pc, #36]	; (800c724 <_tx_thread_preemption_change+0xa0>)
 800c700:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 800c704:	600b      	str	r3, [r1, #0]
 800c706:	f384 8810 	msr	PRIMASK, r4
                    _tx_thread_system_preempt_check();
 800c70a:	f000 f847 	bl	800c79c <_tx_thread_system_preempt_check>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c70e:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c712:	b672      	cpsid	i
    status =  TX_SUCCESS;
 800c714:	2000      	movs	r0, #0
 800c716:	e7d3      	b.n	800c6c0 <_tx_thread_preemption_change+0x3c>
        status =  TX_THRESH_ERROR;
 800c718:	2018      	movs	r0, #24
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c71a:	f384 8810 	msr	PRIMASK, r4
}
 800c71e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c720:	20000f34 	.word	0x20000f34
 800c724:	20000e90 	.word	0x20000e90
 800c728:	20000f38 	.word	0x20000f38
 800c72c:	20000f30 	.word	0x20000f30

0800c730 <_tx_thread_sleep>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_sleep(ULONG timer_ticks)
{
 800c730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c732:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c736:	b672      	cpsid	i

    /* Lockout interrupts while the thread is being resumed.  */
    TX_DISABLE

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800c738:	4b14      	ldr	r3, [pc, #80]	; (800c78c <_tx_thread_sleep+0x5c>)
 800c73a:	681c      	ldr	r4, [r3, #0]

    /* Determine if this is a legal request.  */

    /* Is there a current thread?  */
    if (thread_ptr == TX_NULL)
 800c73c:	b1f4      	cbz	r4, 800c77c <_tx_thread_sleep+0x4c>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c73e:	f3ef 8305 	mrs	r3, IPSR
        /* Illegal caller of this service.  */
        status =  TX_CALLER_ERROR;
    }
    
    /* Is the caller an ISR or Initialization?  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800c742:	4913      	ldr	r1, [pc, #76]	; (800c790 <_tx_thread_sleep+0x60>)
 800c744:	6809      	ldr	r1, [r1, #0]
 800c746:	430b      	orrs	r3, r1
 800c748:	d118      	bne.n	800c77c <_tx_thread_sleep+0x4c>
    }

#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Is the caller the system timer thread?  */
    else if (thread_ptr == &_tx_timer_thread)
 800c74a:	4b12      	ldr	r3, [pc, #72]	; (800c794 <_tx_thread_sleep+0x64>)
 800c74c:	429c      	cmp	r4, r3
 800c74e:	d015      	beq.n	800c77c <_tx_thread_sleep+0x4c>
        status =  TX_CALLER_ERROR;
    }
#endif

    /* Determine if the requested number of ticks is zero.  */
    else if (timer_ticks == ((ULONG) 0))
 800c750:	b1c0      	cbz	r0, 800c784 <_tx_thread_sleep+0x54>
    }
    else
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 800c752:	4b11      	ldr	r3, [pc, #68]	; (800c798 <_tx_thread_sleep+0x68>)
 800c754:	6819      	ldr	r1, [r3, #0]
 800c756:	b989      	cbnz	r1, 800c77c <_tx_thread_sleep+0x4c>

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  timer_ticks;

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800c758:	681d      	ldr	r5, [r3, #0]
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c75a:	2601      	movs	r6, #1
            thread_ptr -> tx_thread_state =    TX_SLEEP;
 800c75c:	2704      	movs	r7, #4
            thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800c75e:	f8c4 1084 	str.w	r1, [r4, #132]	; 0x84
            _tx_thread_preempt_disable++;
 800c762:	4435      	add	r5, r6
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  timer_ticks;
 800c764:	64e0      	str	r0, [r4, #76]	; 0x4c
            thread_ptr -> tx_thread_state =    TX_SLEEP;
 800c766:	6327      	str	r7, [r4, #48]	; 0x30
            _tx_thread_preempt_disable++;
 800c768:	601d      	str	r5, [r3, #0]
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800c76a:	63a6      	str	r6, [r4, #56]	; 0x38
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c76c:	f382 8810 	msr	PRIMASK, r2

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800c770:	4620      	mov	r0, r4
 800c772:	f000 f8b7 	bl	800c8e4 <_tx_thread_system_suspend>
#endif

            /* Return status to the caller.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 800c776:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
        }
    }
    
    /* Return completion status.  */
    return(status);
}
 800c77a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c77c:	f382 8810 	msr	PRIMASK, r2
            status =  TX_CALLER_ERROR;
 800c780:	2013      	movs	r0, #19
}
 800c782:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c784:	f382 8810 	msr	PRIMASK, r2
 800c788:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c78a:	bf00      	nop
 800c78c:	20000f2c 	.word	0x20000f2c
 800c790:	20000164 	.word	0x20000164
 800c794:	20000fd8 	.word	0x20000fd8
 800c798:	20000f28 	.word	0x20000f28

0800c79c <_tx_thread_system_preempt_check>:
TX_THREAD       *current_thread;
TX_THREAD       *thread_ptr;


    /* Combine the system state and preempt disable flags into one for comparison.  */
    TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c79c:	4b0a      	ldr	r3, [pc, #40]	; (800c7c8 <_tx_thread_system_preempt_check+0x2c>)
 800c79e:	681b      	ldr	r3, [r3, #0]

    /* Determine if we are in a system state (ISR or Initialization) or internal preemption is disabled.  */
    if (combined_flags == ((ULONG) 0))
 800c7a0:	b98b      	cbnz	r3, 800c7c6 <_tx_thread_system_preempt_check+0x2a>
    {
    
        /* No, at thread execution level so continue checking for preemption.  */

        /* Pickup thread pointer.  */
        TX_THREAD_GET_CURRENT(current_thread)
 800c7a2:	4a0a      	ldr	r2, [pc, #40]	; (800c7cc <_tx_thread_system_preempt_check+0x30>)

        /* Pickup the next execute pointer.  */
        thread_ptr =  _tx_thread_execute_ptr;
 800c7a4:	4b0a      	ldr	r3, [pc, #40]	; (800c7d0 <_tx_thread_system_preempt_check+0x34>)

        /* Determine if preemption should take place.  */
        if (current_thread != thread_ptr)
 800c7a6:	6812      	ldr	r2, [r2, #0]
 800c7a8:	681b      	ldr	r3, [r3, #0]
 800c7aa:	429a      	cmp	r2, r3
 800c7ac:	d00b      	beq.n	800c7c6 <_tx_thread_system_preempt_check+0x2a>

__attribute__( ( always_inline ) ) static inline void _tx_thread_system_return_inline(void)
{
unsigned int interrupt_save;

    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800c7ae:	4b09      	ldr	r3, [pc, #36]	; (800c7d4 <_tx_thread_system_preempt_check+0x38>)
 800c7b0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c7b4:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c7b6:	f3ef 8305 	mrs	r3, IPSR
    if (__get_ipsr_value() == 0)
 800c7ba:	b923      	cbnz	r3, 800c7c6 <_tx_thread_system_preempt_check+0x2a>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c7bc:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSIE  i": : : "memory" );
 800c7c0:	b662      	cpsie	i
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c7c2:	f383 8810 	msr	PRIMASK, r3

            /* Return to the system so the higher priority thread can be scheduled.  */
            _tx_thread_system_return();
        }
    }
}
 800c7c6:	4770      	bx	lr
 800c7c8:	20000f28 	.word	0x20000f28
 800c7cc:	20000f2c 	.word	0x20000f2c
 800c7d0:	20000f30 	.word	0x20000f30
 800c7d4:	e000ed04 	.word	0xe000ed04

0800c7d8 <_tx_thread_system_resume>:
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_resume(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
 800c7d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c7da:	4604      	mov	r4, r0
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c7dc:	f3ef 8510 	mrs	r5, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c7e0:	b672      	cpsid	i
    TX_DISABLE

#ifndef TX_NO_TIMER

    /* Deactivate the timeout timer if necessary.  */
    if (thread_ptr -> tx_thread_timer.tx_timer_internal_list_head != TX_NULL)
 800c7e2:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800c7e4:	2b00      	cmp	r3, #0
 800c7e6:	d03f      	beq.n	800c868 <_tx_thread_system_resume+0x90>
    {

        /* Deactivate the thread's timeout timer.  */
        _tx_timer_system_deactivate(&(thread_ptr -> tx_thread_timer));
 800c7e8:	304c      	adds	r0, #76	; 0x4c
 800c7ea:	f000 fa1d 	bl	800cc28 <_tx_timer_system_deactivate>
        time_stamp =  entry_ptr -> tx_trace_buffer_entry_time_stamp;
    }
#endif

    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
 800c7ee:	4a35      	ldr	r2, [pc, #212]	; (800c8c4 <_tx_thread_system_resume+0xec>)

    /* Determine if the thread is in the process of suspending.  If so, the thread
       control block is already on the linked list so nothing needs to be done.  */
    if (thread_ptr -> tx_thread_suspending == TX_FALSE)
 800c7f0:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    _tx_thread_preempt_disable--;
 800c7f2:	6813      	ldr	r3, [r2, #0]
 800c7f4:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800c7f6:	3b01      	subs	r3, #1
 800c7f8:	6013      	str	r3, [r2, #0]
    if (thread_ptr -> tx_thread_suspending == TX_FALSE)
 800c7fa:	b9b8      	cbnz	r0, 800c82c <_tx_thread_system_resume+0x54>
    {

        /* Thread is not in the process of suspending. Now check to make sure the thread 
           has not already been resumed.  */
        if (thread_ptr -> tx_thread_state != TX_READY)
 800c7fc:	b9f9      	cbnz	r1, 800c83e <_tx_thread_system_resume+0x66>
 800c7fe:	4b32      	ldr	r3, [pc, #200]	; (800c8c8 <_tx_thread_system_resume+0xf0>)
        }
    }
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800c800:	4932      	ldr	r1, [pc, #200]	; (800c8cc <_tx_thread_system_resume+0xf4>)
 800c802:	6809      	ldr	r1, [r1, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c804:	f385 8810 	msr	PRIMASK, r5

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
 800c808:	681b      	ldr	r3, [r3, #0]
 800c80a:	428b      	cmp	r3, r1
 800c80c:	d00d      	beq.n	800c82a <_tx_thread_system_resume+0x52>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Now determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c80e:	6813      	ldr	r3, [r2, #0]
        if (combined_flags == ((ULONG) 0))
 800c810:	b95b      	cbnz	r3, 800c82a <_tx_thread_system_resume+0x52>
    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800c812:	4b2f      	ldr	r3, [pc, #188]	; (800c8d0 <_tx_thread_system_resume+0xf8>)
 800c814:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c818:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c81a:	f3ef 8305 	mrs	r3, IPSR
    if (__get_ipsr_value() == 0)
 800c81e:	b923      	cbnz	r3, 800c82a <_tx_thread_system_resume+0x52>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c820:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSIE  i": : : "memory" );
 800c824:	b662      	cpsie	i
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c826:	f383 8810 	msr	PRIMASK, r3

            /* Preemption is needed - return to the system!  */
            _tx_thread_system_return();
        }
    }
}
 800c82a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if (thread_ptr -> tx_thread_state != TX_TERMINATED)
 800c82c:	3901      	subs	r1, #1
 800c82e:	2901      	cmp	r1, #1
 800c830:	d9e5      	bls.n	800c7fe <_tx_thread_system_resume+0x26>
                if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
 800c832:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800c834:	b991      	cbnz	r1, 800c85c <_tx_thread_system_resume+0x84>
 800c836:	4b24      	ldr	r3, [pc, #144]	; (800c8c8 <_tx_thread_system_resume+0xf0>)
                    thread_ptr -> tx_thread_suspending =   TX_FALSE;
 800c838:	63a1      	str	r1, [r4, #56]	; 0x38
                    thread_ptr -> tx_thread_state =        TX_READY;
 800c83a:	6321      	str	r1, [r4, #48]	; 0x30
 800c83c:	e7e0      	b.n	800c800 <_tx_thread_system_resume+0x28>
            if (thread_ptr -> tx_thread_delayed_suspend == TX_FALSE)
 800c83e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800c840:	b963      	cbnz	r3, 800c85c <_tx_thread_system_resume+0x84>
                priority =  thread_ptr -> tx_thread_priority;
 800c842:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
                head_ptr =  _tx_thread_priority_list[priority];
 800c844:	4e23      	ldr	r6, [pc, #140]	; (800c8d4 <_tx_thread_system_resume+0xfc>)
                thread_ptr -> tx_thread_state =  TX_READY;
 800c846:	6323      	str	r3, [r4, #48]	; 0x30
                head_ptr =  _tx_thread_priority_list[priority];
 800c848:	f856 1020 	ldr.w	r1, [r6, r0, lsl #2]
                if (head_ptr == TX_NULL)
 800c84c:	b171      	cbz	r1, 800c86c <_tx_thread_system_resume+0x94>
                    tail_ptr =                                 head_ptr -> tx_thread_ready_previous;
 800c84e:	6a48      	ldr	r0, [r1, #36]	; 0x24
 800c850:	4b1d      	ldr	r3, [pc, #116]	; (800c8c8 <_tx_thread_system_resume+0xf0>)
                    tail_ptr -> tx_thread_ready_next =         thread_ptr;
 800c852:	6204      	str	r4, [r0, #32]
                    head_ptr -> tx_thread_ready_previous =     thread_ptr;
 800c854:	624c      	str	r4, [r1, #36]	; 0x24
                    thread_ptr -> tx_thread_ready_next =       head_ptr;
 800c856:	e9c4 1008 	strd	r1, r0, [r4, #32]
 800c85a:	e7d1      	b.n	800c800 <_tx_thread_system_resume+0x28>
                thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 800c85c:	2000      	movs	r0, #0
                thread_ptr -> tx_thread_state =            TX_SUSPENDED;
 800c85e:	2103      	movs	r1, #3
 800c860:	4b19      	ldr	r3, [pc, #100]	; (800c8c8 <_tx_thread_system_resume+0xf0>)
 800c862:	e9c4 100c 	strd	r1, r0, [r4, #48]	; 0x30
 800c866:	e7cb      	b.n	800c800 <_tx_thread_system_resume+0x28>
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800c868:	64c3      	str	r3, [r0, #76]	; 0x4c
 800c86a:	e7c0      	b.n	800c7ee <_tx_thread_system_resume+0x16>
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
 800c86c:	491a      	ldr	r1, [pc, #104]	; (800c8d8 <_tx_thread_system_resume+0x100>)
                    TX_MOD32_BIT_SET(priority, priority_bit)
 800c86e:	f04f 0c01 	mov.w	ip, #1
                    if (priority < _tx_thread_highest_priority)
 800c872:	4f1a      	ldr	r7, [pc, #104]	; (800c8dc <_tx_thread_system_resume+0x104>)
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
 800c874:	680b      	ldr	r3, [r1, #0]
                    TX_MOD32_BIT_SET(priority, priority_bit)
 800c876:	fa0c fe00 	lsl.w	lr, ip, r0
                    _tx_thread_priority_list[priority] =       thread_ptr;
 800c87a:	f846 4020 	str.w	r4, [r6, r0, lsl #2]
                    if (priority < _tx_thread_highest_priority)
 800c87e:	683e      	ldr	r6, [r7, #0]
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
 800c880:	ea43 030e 	orr.w	r3, r3, lr
                    if (priority < _tx_thread_highest_priority)
 800c884:	4286      	cmp	r6, r0
                    _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] | priority_bit;
 800c886:	600b      	str	r3, [r1, #0]
                        execute_ptr =  _tx_thread_execute_ptr;
 800c888:	4b0f      	ldr	r3, [pc, #60]	; (800c8c8 <_tx_thread_system_resume+0xf0>)
                    thread_ptr -> tx_thread_ready_previous =   thread_ptr;
 800c88a:	e9c4 4408 	strd	r4, r4, [r4, #32]
                    if (priority < _tx_thread_highest_priority)
 800c88e:	d9b7      	bls.n	800c800 <_tx_thread_system_resume+0x28>
                        execute_ptr =  _tx_thread_execute_ptr;
 800c890:	6819      	ldr	r1, [r3, #0]
                        _tx_thread_highest_priority =  priority;
 800c892:	6038      	str	r0, [r7, #0]
                        if (execute_ptr == TX_NULL)
 800c894:	b199      	cbz	r1, 800c8be <_tx_thread_system_resume+0xe6>
                            if (priority < execute_ptr -> tx_thread_preempt_threshold)
 800c896:	6bce      	ldr	r6, [r1, #60]	; 0x3c
 800c898:	4286      	cmp	r6, r0
 800c89a:	d9b1      	bls.n	800c800 <_tx_thread_system_resume+0x28>
                                if (execute_ptr -> tx_thread_preempt_threshold != execute_ptr -> tx_thread_priority)
 800c89c:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 800c89e:	428e      	cmp	r6, r1
 800c8a0:	d006      	beq.n	800c8b0 <_tx_thread_system_resume+0xd8>
                                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 800c8a2:	480f      	ldr	r0, [pc, #60]	; (800c8e0 <_tx_thread_system_resume+0x108>)
                                    TX_MOD32_BIT_SET(execute_ptr -> tx_thread_priority, priority_bit)
 800c8a4:	fa0c fc01 	lsl.w	ip, ip, r1
                                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] | priority_bit;
 800c8a8:	6801      	ldr	r1, [r0, #0]
 800c8aa:	ea41 010c 	orr.w	r1, r1, ip
 800c8ae:	6001      	str	r1, [r0, #0]
                                _tx_thread_execute_ptr =  thread_ptr;
 800c8b0:	601c      	str	r4, [r3, #0]
 800c8b2:	f385 8810 	msr	PRIMASK, r5
                                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c8b6:	6813      	ldr	r3, [r2, #0]
                                if (combined_flags == ((ULONG) 0))
 800c8b8:	2b00      	cmp	r3, #0
 800c8ba:	d0aa      	beq.n	800c812 <_tx_thread_system_resume+0x3a>
}
 800c8bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                            _tx_thread_execute_ptr =  thread_ptr;
 800c8be:	601c      	str	r4, [r3, #0]
 800c8c0:	e79e      	b.n	800c800 <_tx_thread_system_resume+0x28>
 800c8c2:	bf00      	nop
 800c8c4:	20000f28 	.word	0x20000f28
 800c8c8:	20000f30 	.word	0x20000f30
 800c8cc:	20000f2c 	.word	0x20000f2c
 800c8d0:	e000ed04 	.word	0xe000ed04
 800c8d4:	20000e90 	.word	0x20000e90
 800c8d8:	20000f14 	.word	0x20000f14
 800c8dc:	20000f34 	.word	0x20000f34
 800c8e0:	20000f38 	.word	0x20000f38

0800c8e4 <_tx_thread_system_suspend>:
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_system_suspend(TX_THREAD *thread_ptr)
#ifndef TX_NOT_INTERRUPTABLE
{
 800c8e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
TX_TRACE_BUFFER_ENTRY       *entry_ptr;
ULONG                       time_stamp =  ((ULONG) 0);
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800c8e8:	4b57      	ldr	r3, [pc, #348]	; (800ca48 <_tx_thread_system_suspend+0x164>)
{
 800c8ea:	4604      	mov	r4, r0
    TX_THREAD_GET_CURRENT(current_thread)
 800c8ec:	681d      	ldr	r5, [r3, #0]
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c8ee:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c8f2:	b672      	cpsid	i
    TX_DISABLE

#ifndef TX_NO_TIMER

    /* Is the current thread suspending?  */
    if (thread_ptr == current_thread)
 800c8f4:	4285      	cmp	r5, r0
 800c8f6:	d060      	beq.n	800c9ba <_tx_thread_system_suspend+0xd6>
        _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
    }
#endif
    
    /* Decrease the preempt disabled count.  */
    _tx_thread_preempt_disable--;
 800c8f8:	4a54      	ldr	r2, [pc, #336]	; (800ca4c <_tx_thread_system_suspend+0x168>)
    _tx_thread_performance_suspend_count++;
#endif

    /* Check to make sure the thread suspending flag is still set.  If not, it
       has already been resumed.  */
    if (thread_ptr -> tx_thread_suspending == TX_TRUE)
 800c8fa:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    _tx_thread_preempt_disable--;
 800c8fc:	6813      	ldr	r3, [r2, #0]
    if (thread_ptr -> tx_thread_suspending == TX_TRUE)
 800c8fe:	2901      	cmp	r1, #1
    _tx_thread_preempt_disable--;
 800c900:	f103 33ff 	add.w	r3, r3, #4294967295
 800c904:	6013      	str	r3, [r2, #0]
    if (thread_ptr -> tx_thread_suspending == TX_TRUE)
 800c906:	d015      	beq.n	800c934 <_tx_thread_system_suspend+0x50>
 800c908:	4b51      	ldr	r3, [pc, #324]	; (800ca50 <_tx_thread_system_suspend+0x16c>)
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c90a:	f386 8810 	msr	PRIMASK, r6

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if a preemption condition is present.  */
    if (current_thread != _tx_thread_execute_ptr)
 800c90e:	681b      	ldr	r3, [r3, #0]
 800c910:	42ab      	cmp	r3, r5
 800c912:	d00d      	beq.n	800c930 <_tx_thread_system_suspend+0x4c>
        TX_THREAD_STACK_CHECK(thread_ptr)
#endif

        /* Determine if preemption should take place. This is only possible if the current thread pointer is
           not the same as the execute thread pointer AND the system state and preempt disable flags are clear.  */
        TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c914:	6813      	ldr	r3, [r2, #0]
        if (combined_flags == ((ULONG) 0))
 800c916:	b95b      	cbnz	r3, 800c930 <_tx_thread_system_suspend+0x4c>
    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800c918:	4b4e      	ldr	r3, [pc, #312]	; (800ca54 <_tx_thread_system_suspend+0x170>)
 800c91a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c91e:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800c920:	f3ef 8305 	mrs	r3, IPSR
    if (__get_ipsr_value() == 0)
 800c924:	b923      	cbnz	r3, 800c930 <_tx_thread_system_suspend+0x4c>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c926:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSIE  i": : : "memory" );
 800c92a:	b662      	cpsie	i
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c92c:	f383 8810 	msr	PRIMASK, r3
        }
    }

    /* Return to caller.  */
    return;
}
 800c930:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        ready_next =      thread_ptr -> tx_thread_ready_next;
 800c934:	6a23      	ldr	r3, [r4, #32]
        thread_ptr -> tx_thread_suspending =  TX_FALSE;
 800c936:	f04f 0c00 	mov.w	ip, #0
        priority =  thread_ptr -> tx_thread_priority;
 800c93a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
        if (ready_next != thread_ptr)
 800c93c:	429c      	cmp	r4, r3
        thread_ptr -> tx_thread_suspending =  TX_FALSE;
 800c93e:	f8c4 c038 	str.w	ip, [r4, #56]	; 0x38
        if (ready_next != thread_ptr)
 800c942:	d050      	beq.n	800c9e6 <_tx_thread_system_suspend+0x102>
            if (_tx_thread_priority_list[priority] == thread_ptr)
 800c944:	4f44      	ldr	r7, [pc, #272]	; (800ca58 <_tx_thread_system_suspend+0x174>)
            ready_previous =  thread_ptr -> tx_thread_ready_previous;
 800c946:	f8d4 c024 	ldr.w	ip, [r4, #36]	; 0x24
            if (_tx_thread_priority_list[priority] == thread_ptr)
 800c94a:	f857 e020 	ldr.w	lr, [r7, r0, lsl #2]
            ready_next -> tx_thread_ready_previous =    ready_previous;
 800c94e:	f8c3 c024 	str.w	ip, [r3, #36]	; 0x24
            if (_tx_thread_priority_list[priority] == thread_ptr)
 800c952:	45a6      	cmp	lr, r4
            ready_previous -> tx_thread_ready_next =    ready_next;
 800c954:	f8cc 3020 	str.w	r3, [ip, #32]
            if (_tx_thread_priority_list[priority] == thread_ptr)
 800c958:	d037      	beq.n	800c9ca <_tx_thread_system_suspend+0xe6>
        if (thread_ptr == _tx_thread_execute_ptr)
 800c95a:	4b3d      	ldr	r3, [pc, #244]	; (800ca50 <_tx_thread_system_suspend+0x16c>)
 800c95c:	6819      	ldr	r1, [r3, #0]
 800c95e:	42a1      	cmp	r1, r4
 800c960:	d1d3      	bne.n	800c90a <_tx_thread_system_suspend+0x26>
            _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800c962:	483e      	ldr	r0, [pc, #248]	; (800ca5c <_tx_thread_system_suspend+0x178>)
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800c964:	493e      	ldr	r1, [pc, #248]	; (800ca60 <_tx_thread_system_suspend+0x17c>)
            _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800c966:	6805      	ldr	r5, [r0, #0]
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800c968:	680c      	ldr	r4, [r1, #0]
            _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800c96a:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
 800c96e:	601d      	str	r5, [r3, #0]
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800c970:	b1ec      	cbz	r4, 800c9ae <_tx_thread_system_suspend+0xca>
                _tx_thread_preempt_disable++;
 800c972:	6814      	ldr	r4, [r2, #0]
 800c974:	3401      	adds	r4, #1
 800c976:	6014      	str	r4, [r2, #0]
 800c978:	f386 8810 	msr	PRIMASK, r6
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800c97c:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800c980:	b672      	cpsid	i
                _tx_thread_preempt_disable--;
 800c982:	6814      	ldr	r4, [r2, #0]
                priority_map =  _tx_thread_preempted_maps[MAP_INDEX];
 800c984:	680d      	ldr	r5, [r1, #0]
                _tx_thread_preempt_disable--;
 800c986:	3c01      	subs	r4, #1
 800c988:	6014      	str	r4, [r2, #0]
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
 800c98a:	fa95 f4a5 	rbit	r4, r5
 800c98e:	fab4 f484 	clz	r4, r4
                if (_tx_thread_highest_priority >= (_tx_thread_priority_list[priority] -> tx_thread_preempt_threshold))
 800c992:	f857 7024 	ldr.w	r7, [r7, r4, lsl #2]
 800c996:	f8d0 c000 	ldr.w	ip, [r0]
 800c99a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800c99c:	4560      	cmp	r0, ip
 800c99e:	d806      	bhi.n	800c9ae <_tx_thread_system_suspend+0xca>
                    TX_MOD32_BIT_SET(priority, priority_bit)
 800c9a0:	2001      	movs	r0, #1
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[priority];
 800c9a2:	601f      	str	r7, [r3, #0]
                    TX_MOD32_BIT_SET(priority, priority_bit)
 800c9a4:	fa00 f404 	lsl.w	r4, r0, r4
                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
 800c9a8:	ea25 0504 	bic.w	r5, r5, r4
 800c9ac:	600d      	str	r5, [r1, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800c9ae:	f386 8810 	msr	PRIMASK, r6
            TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800c9b2:	6813      	ldr	r3, [r2, #0]
            if (combined_flags == ((ULONG) 0))
 800c9b4:	2b00      	cmp	r3, #0
 800c9b6:	d0af      	beq.n	800c918 <_tx_thread_system_suspend+0x34>
 800c9b8:	e7ba      	b.n	800c930 <_tx_thread_system_suspend+0x4c>
            if (timeout != TX_WAIT_FOREVER)
 800c9ba:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 800c9bc:	3b01      	subs	r3, #1
 800c9be:	3303      	adds	r3, #3
 800c9c0:	d935      	bls.n	800ca2e <_tx_thread_system_suspend+0x14a>
        _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800c9c2:	4b28      	ldr	r3, [pc, #160]	; (800ca64 <_tx_thread_system_suspend+0x180>)
 800c9c4:	69e2      	ldr	r2, [r4, #28]
 800c9c6:	601a      	str	r2, [r3, #0]
 800c9c8:	e796      	b.n	800c8f8 <_tx_thread_system_suspend+0x14>
                if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800c9ca:	f8df c094 	ldr.w	ip, [pc, #148]	; 800ca60 <_tx_thread_system_suspend+0x17c>
                _tx_thread_priority_list[priority] =  ready_next;
 800c9ce:	f847 3020 	str.w	r3, [r7, r0, lsl #2]
                if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800c9d2:	f8dc 3000 	ldr.w	r3, [ip]
 800c9d6:	2b00      	cmp	r3, #0
 800c9d8:	d0bf      	beq.n	800c95a <_tx_thread_system_suspend+0x76>
                    TX_MOD32_BIT_SET(priority, priority_bit)
 800c9da:	4081      	lsls	r1, r0
                    _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
 800c9dc:	ea23 0301 	bic.w	r3, r3, r1
 800c9e0:	f8cc 3000 	str.w	r3, [ip]
 800c9e4:	e7b9      	b.n	800c95a <_tx_thread_system_suspend+0x76>
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
 800c9e6:	f8df e080 	ldr.w	lr, [pc, #128]	; 800ca68 <_tx_thread_system_suspend+0x184>
            TX_MOD32_BIT_SET(priority, priority_bit)
 800c9ea:	4081      	lsls	r1, r0
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800c9ec:	f8df 8070 	ldr.w	r8, [pc, #112]	; 800ca60 <_tx_thread_system_suspend+0x17c>
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
 800c9f0:	f8de 3000 	ldr.w	r3, [lr]
 800c9f4:	43c9      	mvns	r1, r1
            _tx_thread_priority_list[priority] =    TX_NULL;
 800c9f6:	4f18      	ldr	r7, [pc, #96]	; (800ca58 <_tx_thread_system_suspend+0x174>)
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
 800c9f8:	400b      	ands	r3, r1
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800c9fa:	f8d8 9000 	ldr.w	r9, [r8]
            _tx_thread_priority_list[priority] =    TX_NULL;
 800c9fe:	f847 c020 	str.w	ip, [r7, r0, lsl #2]
            _tx_thread_priority_maps[MAP_INDEX] =  _tx_thread_priority_maps[MAP_INDEX] & (~(priority_bit));
 800ca02:	f8ce 3000 	str.w	r3, [lr]
            if (_tx_thread_preempted_maps[MAP_INDEX] != ((ULONG) 0))
 800ca06:	f1b9 0f00 	cmp.w	r9, #0
 800ca0a:	d003      	beq.n	800ca14 <_tx_thread_system_suspend+0x130>
                _tx_thread_preempted_maps[MAP_INDEX] =  _tx_thread_preempted_maps[MAP_INDEX] & (~(priority_bit));
 800ca0c:	ea01 0109 	and.w	r1, r1, r9
 800ca10:	f8c8 1000 	str.w	r1, [r8]
            if (priority_map == ((ULONG) 0))
 800ca14:	b983      	cbnz	r3, 800ca38 <_tx_thread_system_suspend+0x154>
                _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 800ca16:	4811      	ldr	r0, [pc, #68]	; (800ca5c <_tx_thread_system_suspend+0x178>)
 800ca18:	2420      	movs	r4, #32
                _tx_thread_execute_ptr =       TX_NULL;
 800ca1a:	490d      	ldr	r1, [pc, #52]	; (800ca50 <_tx_thread_system_suspend+0x16c>)
                _tx_thread_highest_priority =  ((UINT) TX_MAX_PRIORITIES);
 800ca1c:	6004      	str	r4, [r0, #0]
                _tx_thread_execute_ptr =       TX_NULL;
 800ca1e:	600b      	str	r3, [r1, #0]
 800ca20:	f386 8810 	msr	PRIMASK, r6
                TX_THREAD_SYSTEM_RETURN_CHECK(combined_flags)
 800ca24:	6813      	ldr	r3, [r2, #0]
                if (combined_flags == ((ULONG) 0))
 800ca26:	2b00      	cmp	r3, #0
 800ca28:	f43f af76 	beq.w	800c918 <_tx_thread_system_suspend+0x34>
 800ca2c:	e780      	b.n	800c930 <_tx_thread_system_suspend+0x4c>
                _tx_timer_system_activate(&(thread_ptr -> tx_thread_timer));
 800ca2e:	f105 004c 	add.w	r0, r5, #76	; 0x4c
 800ca32:	f000 f8cf 	bl	800cbd4 <_tx_timer_system_activate>
 800ca36:	e7c4      	b.n	800c9c2 <_tx_thread_system_suspend+0xde>
                TX_LOWEST_SET_BIT_CALCULATE(priority_map, priority_bit)
 800ca38:	fa93 f3a3 	rbit	r3, r3
 800ca3c:	fab3 f383 	clz	r3, r3
                _tx_thread_highest_priority =  base_priority + ((UINT) priority_bit);
 800ca40:	4906      	ldr	r1, [pc, #24]	; (800ca5c <_tx_thread_system_suspend+0x178>)
 800ca42:	600b      	str	r3, [r1, #0]
 800ca44:	e789      	b.n	800c95a <_tx_thread_system_suspend+0x76>
 800ca46:	bf00      	nop
 800ca48:	20000f2c 	.word	0x20000f2c
 800ca4c:	20000f28 	.word	0x20000f28
 800ca50:	20000f30 	.word	0x20000f30
 800ca54:	e000ed04 	.word	0xe000ed04
 800ca58:	20000e90 	.word	0x20000e90
 800ca5c:	20000f34 	.word	0x20000f34
 800ca60:	20000f38 	.word	0x20000f38
 800ca64:	20000fc8 	.word	0x20000fc8
 800ca68:	20000f14 	.word	0x20000f14

0800ca6c <_tx_timer_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_timer_create(TX_TIMER *timer_ptr, CHAR *name_ptr, 
            VOID (*expiration_function)(ULONG id), ULONG expiration_input,
            ULONG initial_ticks, ULONG reschedule_ticks, UINT auto_activate)
{
 800ca6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ca6e:	460f      	mov	r7, r1
 800ca70:	4616      	mov	r6, r2
TX_TIMER        *next_timer;
TX_TIMER        *previous_timer;


    /* Initialize timer control block to all zeros.  */
    TX_MEMSET(timer_ptr, 0, (sizeof(TX_TIMER)));
 800ca72:	2100      	movs	r1, #0
 800ca74:	222c      	movs	r2, #44	; 0x2c
{
 800ca76:	4604      	mov	r4, r0
 800ca78:	461d      	mov	r5, r3
    TX_MEMSET(timer_ptr, 0, (sizeof(TX_TIMER)));
 800ca7a:	f001 f930 	bl	800dcde <memset>

    /* Setup the basic timer fields.  */
    timer_ptr -> tx_timer_name =                                            name_ptr;
    timer_ptr -> tx_timer_internal.tx_timer_internal_remaining_ticks =      initial_ticks;
 800ca7e:	9b06      	ldr	r3, [sp, #24]
    timer_ptr -> tx_timer_name =                                            name_ptr;
 800ca80:	6067      	str	r7, [r4, #4]
    timer_ptr -> tx_timer_internal.tx_timer_internal_remaining_ticks =      initial_ticks;
 800ca82:	60a3      	str	r3, [r4, #8]
    timer_ptr -> tx_timer_internal.tx_timer_internal_re_initialize_ticks =  reschedule_ticks;
 800ca84:	9b07      	ldr	r3, [sp, #28]
    timer_ptr -> tx_timer_internal.tx_timer_internal_timeout_function =     expiration_function;
    timer_ptr -> tx_timer_internal.tx_timer_internal_timeout_param =        expiration_input;
 800ca86:	6165      	str	r5, [r4, #20]
    timer_ptr -> tx_timer_internal.tx_timer_internal_timeout_function =     expiration_function;
 800ca88:	e9c4 3603 	strd	r3, r6, [r4, #12]
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800ca8c:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800ca90:	b672      	cpsid	i
    /* Setup the timer ID to make it valid.  */
    timer_ptr -> tx_timer_id =  TX_TIMER_ID;

    /* Place the timer on the list of created application timers.  First,
       check for an empty list.  */
    if (_tx_timer_created_count == TX_EMPTY)
 800ca92:	4a12      	ldr	r2, [pc, #72]	; (800cadc <_tx_timer_create+0x70>)
    timer_ptr -> tx_timer_id =  TX_TIMER_ID;
 800ca94:	4912      	ldr	r1, [pc, #72]	; (800cae0 <_tx_timer_create+0x74>)
    if (_tx_timer_created_count == TX_EMPTY)
 800ca96:	6813      	ldr	r3, [r2, #0]
    timer_ptr -> tx_timer_id =  TX_TIMER_ID;
 800ca98:	6021      	str	r1, [r4, #0]
    {

        /* The created timer list is empty.  Add timer to empty list.  */
        _tx_timer_created_ptr =                   timer_ptr;
 800ca9a:	4912      	ldr	r1, [pc, #72]	; (800cae4 <_tx_timer_create+0x78>)
    if (_tx_timer_created_count == TX_EMPTY)
 800ca9c:	b95b      	cbnz	r3, 800cab6 <_tx_timer_create+0x4a>
        timer_ptr -> tx_timer_created_previous =  previous_timer;
        timer_ptr -> tx_timer_created_next =      next_timer;
    }

    /* Increment the number of created timers.  */
    _tx_timer_created_count++;
 800ca9e:	3301      	adds	r3, #1
        _tx_timer_created_ptr =                   timer_ptr;
 800caa0:	600c      	str	r4, [r1, #0]
    _tx_timer_created_count++;
 800caa2:	6013      	str	r3, [r2, #0]

    /* Log this kernel call.  */
    TX_EL_TIMER_CREATE_INSERT

    /* Determine if this timer needs to be activated.  */
    if (auto_activate == TX_AUTO_ACTIVATE)
 800caa4:	9b08      	ldr	r3, [sp, #32]
 800caa6:	2b01      	cmp	r3, #1
        timer_ptr -> tx_timer_created_previous =  timer_ptr;
 800caa8:	e9c4 4409 	strd	r4, r4, [r4, #36]	; 0x24
    if (auto_activate == TX_AUTO_ACTIVATE)
 800caac:	d00e      	beq.n	800cacc <_tx_timer_create+0x60>
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800caae:	f386 8810 	msr	PRIMASK, r6
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
}
 800cab2:	2000      	movs	r0, #0
 800cab4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    _tx_timer_created_count++;
 800cab6:	3301      	adds	r3, #1
        next_timer =  _tx_timer_created_ptr;
 800cab8:	6809      	ldr	r1, [r1, #0]
    _tx_timer_created_count++;
 800caba:	6013      	str	r3, [r2, #0]
    if (auto_activate == TX_AUTO_ACTIVATE)
 800cabc:	9b08      	ldr	r3, [sp, #32]
        previous_timer =  next_timer -> tx_timer_created_previous;
 800cabe:	6a88      	ldr	r0, [r1, #40]	; 0x28
    if (auto_activate == TX_AUTO_ACTIVATE)
 800cac0:	2b01      	cmp	r3, #1
        next_timer -> tx_timer_created_previous =  timer_ptr;
 800cac2:	628c      	str	r4, [r1, #40]	; 0x28
        previous_timer -> tx_timer_created_next =    timer_ptr;
 800cac4:	6244      	str	r4, [r0, #36]	; 0x24
        timer_ptr -> tx_timer_created_next =      next_timer;
 800cac6:	e9c4 1009 	strd	r1, r0, [r4, #36]	; 0x24
    if (auto_activate == TX_AUTO_ACTIVATE)
 800caca:	d1f0      	bne.n	800caae <_tx_timer_create+0x42>
        _tx_timer_system_activate(&(timer_ptr -> tx_timer_internal));
 800cacc:	f104 0008 	add.w	r0, r4, #8
 800cad0:	f000 f880 	bl	800cbd4 <_tx_timer_system_activate>
 800cad4:	f386 8810 	msr	PRIMASK, r6
}
 800cad8:	2000      	movs	r0, #0
 800cada:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800cadc:	200014b4 	.word	0x200014b4
 800cae0:	4154494d 	.word	0x4154494d
 800cae4:	200010a8 	.word	0x200010a8

0800cae8 <_tx_timer_initialize>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _tx_timer_initialize(VOID)
{
 800cae8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the system clock to 0.  */
    _tx_timer_system_clock =  ((ULONG) 0);
 800caec:	2500      	movs	r5, #0
    _tx_timer_expired_timer_ptr =  TX_NULL;

    /* Initialize the thread and application timer management control structures.  */

    /* First, initialize the timer list.  */
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
 800caee:	4c26      	ldr	r4, [pc, #152]	; (800cb88 <_tx_timer_initialize+0xa0>)
    _tx_timer_system_clock =  ((ULONG) 0);
 800caf0:	f8df e0cc 	ldr.w	lr, [pc, #204]	; 800cbc0 <_tx_timer_initialize+0xd8>
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
 800caf4:	2280      	movs	r2, #128	; 0x80
    _tx_timer_time_slice =  ((ULONG) 0);
 800caf6:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 800cbc4 <_tx_timer_initialize+0xdc>
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
 800cafa:	4629      	mov	r1, r5
    _tx_timer_expired_timer_ptr =  TX_NULL;
 800cafc:	4b23      	ldr	r3, [pc, #140]	; (800cb8c <_tx_timer_initialize+0xa4>)
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
 800cafe:	4620      	mov	r0, r4
    _tx_timer_expired_time_slice =  TX_FALSE;
 800cb00:	4f23      	ldr	r7, [pc, #140]	; (800cb90 <_tx_timer_initialize+0xa8>)
{
 800cb02:	b087      	sub	sp, #28
    _tx_timer_expired =             TX_FALSE;
 800cb04:	4e23      	ldr	r6, [pc, #140]	; (800cb94 <_tx_timer_initialize+0xac>)
    _tx_timer_system_clock =  ((ULONG) 0);
 800cb06:	f8ce 5000 	str.w	r5, [lr]
    _tx_timer_time_slice =  ((ULONG) 0);
 800cb0a:	f8cc 5000 	str.w	r5, [ip]
    _tx_timer_expired_time_slice =  TX_FALSE;
 800cb0e:	603d      	str	r5, [r7, #0]
    _tx_timer_expired =             TX_FALSE;
 800cb10:	6035      	str	r5, [r6, #0]
    _tx_timer_expired_timer_ptr =  TX_NULL;
 800cb12:	601d      	str	r5, [r3, #0]
    TX_MEMSET(&_tx_timer_list[0], 0, (sizeof(_tx_timer_list)));
 800cb14:	f001 f8e3 	bl	800dcde <memset>
#endif

    /* Initialize all of the list pointers.  */
    _tx_timer_list_start =   &_tx_timer_list[0];
    _tx_timer_current_ptr =  &_tx_timer_list[0];
 800cb18:	4e1f      	ldr	r6, [pc, #124]	; (800cb98 <_tx_timer_initialize+0xb0>)
#ifndef TX_TIMER_PROCESS_IN_ISR

    /* Setup the variables associated with the system timer thread's stack and 
       priority.  */
    _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
    _tx_timer_stack_size =   ((ULONG) TX_TIMER_THREAD_STACK_SIZE);
 800cb1a:	f44f 6080 	mov.w	r0, #1024	; 0x400
    _tx_timer_list_start =   &_tx_timer_list[0];
 800cb1e:	4a1f      	ldr	r2, [pc, #124]	; (800cb9c <_tx_timer_initialize+0xb4>)
    _tx_timer_list_end =     TX_TIMER_POINTER_ADD(_tx_timer_list_end, ((ULONG) 1));
 800cb20:	f104 0e80 	add.w	lr, r4, #128	; 0x80
    _tx_timer_current_ptr =  &_tx_timer_list[0];
 800cb24:	6034      	str	r4, [r6, #0]
    _tx_timer_priority =     ((UINT) TX_TIMER_THREAD_PRIORITY);
 800cb26:	462b      	mov	r3, r5
    _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
 800cb28:	f8df c09c 	ldr.w	ip, [pc, #156]	; 800cbc8 <_tx_timer_initialize+0xe0>
    _tx_timer_list_end =     TX_TIMER_POINTER_ADD(_tx_timer_list_end, ((ULONG) 1));
 800cb2c:	4f1c      	ldr	r7, [pc, #112]	; (800cba0 <_tx_timer_initialize+0xb8>)
    _tx_timer_list_start =   &_tx_timer_list[0];
 800cb2e:	6014      	str	r4, [r2, #0]
    _tx_timer_priority =     ((UINT) TX_TIMER_THREAD_PRIORITY);
 800cb30:	4661      	mov	r1, ip
 800cb32:	f8df 8098 	ldr.w	r8, [pc, #152]	; 800cbcc <_tx_timer_initialize+0xe4>
 800cb36:	4602      	mov	r2, r0
    _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
 800cb38:	4e1a      	ldr	r6, [pc, #104]	; (800cba4 <_tx_timer_initialize+0xbc>)
    _tx_timer_stack_size =   ((ULONG) TX_TIMER_THREAD_STACK_SIZE);
 800cb3a:	4c1b      	ldr	r4, [pc, #108]	; (800cba8 <_tx_timer_initialize+0xc0>)
    _tx_timer_list_end =     TX_TIMER_POINTER_ADD(_tx_timer_list_end, ((ULONG) 1));
 800cb3c:	f8c7 e000 	str.w	lr, [r7]
    _tx_timer_priority =     ((UINT) TX_TIMER_THREAD_PRIORITY);
 800cb40:	f8c8 5000 	str.w	r5, [r8]
       low-level initialization component.  */
    do
    {
      
        /* Create the system timer thread.  */
        status =  _tx_thread_create(&_tx_timer_thread, 
 800cb44:	f8df 9088 	ldr.w	r9, [pc, #136]	; 800cbd0 <_tx_timer_initialize+0xe8>
 800cb48:	4f18      	ldr	r7, [pc, #96]	; (800cbac <_tx_timer_initialize+0xc4>)
    _tx_timer_stack_start =  (VOID *) &_tx_timer_thread_stack_area[0];
 800cb4a:	f8c6 c000 	str.w	ip, [r6]
        status =  _tx_thread_create(&_tx_timer_thread, 
 800cb4e:	4d18      	ldr	r5, [pc, #96]	; (800cbb0 <_tx_timer_initialize+0xc8>)
    _tx_timer_stack_size =   ((ULONG) TX_TIMER_THREAD_STACK_SIZE);
 800cb50:	6020      	str	r0, [r4, #0]
 800cb52:	e003      	b.n	800cb5c <_tx_timer_initialize+0x74>
 800cb54:	6831      	ldr	r1, [r6, #0]
 800cb56:	6822      	ldr	r2, [r4, #0]
 800cb58:	f8d8 3000 	ldr.w	r3, [r8]
        status =  _tx_thread_create(&_tx_timer_thread, 
 800cb5c:	2000      	movs	r0, #0
 800cb5e:	9201      	str	r2, [sp, #4]
 800cb60:	9100      	str	r1, [sp, #0]
 800cb62:	463a      	mov	r2, r7
 800cb64:	4629      	mov	r1, r5
 800cb66:	e9cd 3302 	strd	r3, r3, [sp, #8]
 800cb6a:	e9cd 0004 	strd	r0, r0, [sp, #16]
 800cb6e:	464b      	mov	r3, r9
 800cb70:	4810      	ldr	r0, [pc, #64]	; (800cbb4 <_tx_timer_initialize+0xcc>)
 800cb72:	f000 fd6d 	bl	800d650 <_tx_thread_create>
#endif

        /* Define timer initialize extension.  */
        TX_TIMER_INITIALIZE_EXTENSION(status)
        
    } while (status != TX_SUCCESS);
 800cb76:	2800      	cmp	r0, #0
 800cb78:	d1ec      	bne.n	800cb54 <_tx_timer_initialize+0x6c>
#endif

#ifndef TX_DISABLE_REDUNDANT_CLEARING

    /* Initialize the head pointer of the created application timer list.  */
    _tx_timer_created_ptr =  TX_NULL;
 800cb7a:	4a0f      	ldr	r2, [pc, #60]	; (800cbb8 <_tx_timer_initialize+0xd0>)

    /* Set the created count to zero.  */
    _tx_timer_created_count =  TX_EMPTY;
 800cb7c:	4b0f      	ldr	r3, [pc, #60]	; (800cbbc <_tx_timer_initialize+0xd4>)
    _tx_timer_created_ptr =  TX_NULL;
 800cb7e:	6010      	str	r0, [r2, #0]
    _tx_timer_created_count =  TX_EMPTY;
 800cb80:	6018      	str	r0, [r3, #0]
    _tx_timer_performance_expiration_count =         ((ULONG) 0);
    _tx_timer_performance__expiration_adjust_count =  ((ULONG) 0);
#endif
#endif
#endif
}
 800cb82:	b007      	add	sp, #28
 800cb84:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800cb88:	20000f44 	.word	0x20000f44
 800cb8c:	200010a0 	.word	0x200010a0
 800cb90:	200014b8 	.word	0x200014b8
 800cb94:	20000fc4 	.word	0x20000fc4
 800cb98:	20000f40 	.word	0x20000f40
 800cb9c:	200010a4 	.word	0x200010a4
 800cba0:	20000fd0 	.word	0x20000fd0
 800cba4:	200014b0 	.word	0x200014b0
 800cba8:	200010ac 	.word	0x200010ac
 800cbac:	0800cc59 	.word	0x0800cc59
 800cbb0:	0800debc 	.word	0x0800debc
 800cbb4:	20000fd8 	.word	0x20000fd8
 800cbb8:	200010a8 	.word	0x200010a8
 800cbbc:	200014b4 	.word	0x200014b4
 800cbc0:	200014bc 	.word	0x200014bc
 800cbc4:	20000fc8 	.word	0x20000fc8
 800cbc8:	200010b0 	.word	0x200010b0
 800cbcc:	20000fcc 	.word	0x20000fcc
 800cbd0:	4154494d 	.word	0x4154494d

0800cbd4 <_tx_timer_system_activate>:
ULONG                       remaining_ticks;
ULONG                       expiration_time;


    /* Pickup the remaining ticks.  */
    remaining_ticks =  timer_ptr -> tx_timer_internal_remaining_ticks;
 800cbd4:	6802      	ldr	r2, [r0, #0]
    /* Determine if there is a timer to activate.  */
    if (remaining_ticks != ((ULONG) 0))
    {
    
        /* Determine if the timer is set to wait forever.  */
        if (remaining_ticks != TX_WAIT_FOREVER)
 800cbd6:	1e53      	subs	r3, r2, #1
 800cbd8:	1cd9      	adds	r1, r3, #3
 800cbda:	d900      	bls.n	800cbde <_tx_timer_system_activate+0xa>
                /* Setup list head pointer.  */
                timer_ptr -> tx_timer_internal_list_head =  timer_list;
            }
        }
    }
}
 800cbdc:	4770      	bx	lr
            if (timer_ptr -> tx_timer_internal_list_head == TX_NULL)
 800cbde:	6981      	ldr	r1, [r0, #24]
 800cbe0:	2900      	cmp	r1, #0
 800cbe2:	d1fb      	bne.n	800cbdc <_tx_timer_system_activate+0x8>
                if (remaining_ticks > TX_TIMER_ENTRIES)
 800cbe4:	2a20      	cmp	r2, #32
                timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
 800cbe6:	4a0d      	ldr	r2, [pc, #52]	; (800cc1c <_tx_timer_system_activate+0x48>)
                if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
 800cbe8:	490d      	ldr	r1, [pc, #52]	; (800cc20 <_tx_timer_system_activate+0x4c>)
 800cbea:	bf94      	ite	ls
 800cbec:	009b      	lslls	r3, r3, #2
 800cbee:	237c      	movhi	r3, #124	; 0x7c
                timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
 800cbf0:	6812      	ldr	r2, [r2, #0]
                if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
 800cbf2:	6809      	ldr	r1, [r1, #0]
                timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, expiration_time);
 800cbf4:	4413      	add	r3, r2
                if (TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(timer_list) >= TX_TIMER_INDIRECT_TO_VOID_POINTER_CONVERT(_tx_timer_list_end))
 800cbf6:	4299      	cmp	r1, r3
 800cbf8:	d803      	bhi.n	800cc02 <_tx_timer_system_activate+0x2e>
                    timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
 800cbfa:	4a0a      	ldr	r2, [pc, #40]	; (800cc24 <_tx_timer_system_activate+0x50>)
                    delta =  TX_TIMER_POINTER_DIF(timer_list, _tx_timer_list_end);
 800cbfc:	1a5b      	subs	r3, r3, r1
                    timer_list =  TX_TIMER_POINTER_ADD(_tx_timer_list_start, delta);
 800cbfe:	6812      	ldr	r2, [r2, #0]
 800cc00:	4413      	add	r3, r2
                if ((*timer_list) == TX_NULL)
 800cc02:	681a      	ldr	r2, [r3, #0]
 800cc04:	b132      	cbz	r2, 800cc14 <_tx_timer_system_activate+0x40>
                    previous_timer =                                    next_timer -> tx_timer_internal_active_previous;
 800cc06:	6951      	ldr	r1, [r2, #20]
                    previous_timer -> tx_timer_internal_active_next =   timer_ptr;
 800cc08:	6108      	str	r0, [r1, #16]
                    next_timer -> tx_timer_internal_active_previous =   timer_ptr;
 800cc0a:	6150      	str	r0, [r2, #20]
                    timer_ptr -> tx_timer_internal_active_next =        next_timer;
 800cc0c:	e9c0 2104 	strd	r2, r1, [r0, #16]
                timer_ptr -> tx_timer_internal_list_head =  timer_list;
 800cc10:	6183      	str	r3, [r0, #24]
}
 800cc12:	4770      	bx	lr
                    timer_ptr -> tx_timer_internal_active_previous =  timer_ptr;
 800cc14:	e9c0 0004 	strd	r0, r0, [r0, #16]
                    *timer_list =  timer_ptr;
 800cc18:	6018      	str	r0, [r3, #0]
 800cc1a:	e7f9      	b.n	800cc10 <_tx_timer_system_activate+0x3c>
 800cc1c:	20000f40 	.word	0x20000f40
 800cc20:	20000fd0 	.word	0x20000fd0
 800cc24:	200010a4 	.word	0x200010a4

0800cc28 <_tx_timer_system_deactivate>:
TX_TIMER_INTERNAL   *next_timer;
TX_TIMER_INTERNAL   *previous_timer;


    /* Pickup the list head pointer.  */
    list_head =  timer_ptr -> tx_timer_internal_list_head;
 800cc28:	6983      	ldr	r3, [r0, #24]

    /* Determine if the timer still needs deactivation.  */
    if (list_head != TX_NULL)
 800cc2a:	b153      	cbz	r3, 800cc42 <_tx_timer_system_deactivate+0x1a>
    {

        /* Deactivate the timer.  */

        /* Pickup the next active timer.  */
        next_timer =  timer_ptr -> tx_timer_internal_active_next;
 800cc2c:	6902      	ldr	r2, [r0, #16]

        /* See if this is the only timer in the list.  */
        if (timer_ptr == next_timer)
 800cc2e:	4290      	cmp	r0, r2
 800cc30:	d008      	beq.n	800cc44 <_tx_timer_system_deactivate+0x1c>
        {

            /* At least one more timer is on the same expiration list.  */

            /* Update the links of the adjacent timers.  */
            previous_timer =                                   timer_ptr -> tx_timer_internal_active_previous;
 800cc32:	6941      	ldr	r1, [r0, #20]
            next_timer -> tx_timer_internal_active_previous =  previous_timer;
 800cc34:	6151      	str	r1, [r2, #20]
            previous_timer -> tx_timer_internal_active_next =  next_timer;
 800cc36:	610a      	str	r2, [r1, #16]

            /* Determine if the head pointer needs to be updated.  */
            if (*(list_head) == timer_ptr)
 800cc38:	6819      	ldr	r1, [r3, #0]
 800cc3a:	4281      	cmp	r1, r0
 800cc3c:	d008      	beq.n	800cc50 <_tx_timer_system_deactivate+0x28>
                *(list_head) =  next_timer;
            }
        }

        /* Clear the timer's list head pointer.  */
        timer_ptr -> tx_timer_internal_list_head =  TX_NULL;
 800cc3e:	2300      	movs	r3, #0
 800cc40:	6183      	str	r3, [r0, #24]
    }
}
 800cc42:	4770      	bx	lr
            if (*(list_head) == timer_ptr)
 800cc44:	681a      	ldr	r2, [r3, #0]
 800cc46:	4282      	cmp	r2, r0
 800cc48:	d1f9      	bne.n	800cc3e <_tx_timer_system_deactivate+0x16>
                *(list_head) =  TX_NULL;
 800cc4a:	2200      	movs	r2, #0
 800cc4c:	601a      	str	r2, [r3, #0]
 800cc4e:	e7f6      	b.n	800cc3e <_tx_timer_system_deactivate+0x16>
                next_timer -> tx_timer_internal_list_head =  list_head;
 800cc50:	6193      	str	r3, [r2, #24]
                *(list_head) =  next_timer;
 800cc52:	601a      	str	r2, [r3, #0]
 800cc54:	e7f3      	b.n	800cc3e <_tx_timer_system_deactivate+0x16>
 800cc56:	bf00      	nop

0800cc58 <_tx_timer_thread_entry>:
#endif


    /* Make sure the timer input is correct.  This also gets rid of the
       silly compiler warnings.  */
    if (timer_thread_input == TX_TIMER_ID)
 800cc58:	4b40      	ldr	r3, [pc, #256]	; (800cd5c <_tx_timer_thread_entry+0x104>)
 800cc5a:	4298      	cmp	r0, r3
 800cc5c:	d000      	beq.n	800cc60 <_tx_timer_thread_entry+0x8>
 800cc5e:	4770      	bx	lr
{
 800cc60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cc64:	b083      	sub	sp, #12
 800cc66:	f8df b10c 	ldr.w	fp, [pc, #268]	; 800cd74 <_tx_timer_thread_entry+0x11c>
 800cc6a:	f8df 810c 	ldr.w	r8, [pc, #268]	; 800cd78 <_tx_timer_thread_entry+0x120>
        
                expired_timers -> tx_timer_internal_list_head =  &expired_timers;
            }

            /* Set the current list pointer to NULL.  */
            *_tx_timer_current_ptr =  TX_NULL;
 800cc6e:	2600      	movs	r6, #0
 800cc70:	ad01      	add	r5, sp, #4
 800cc72:	4c3b      	ldr	r4, [pc, #236]	; (800cd60 <_tx_timer_thread_entry+0x108>)
 800cc74:	f8df a0f4 	ldr.w	sl, [pc, #244]	; 800cd6c <_tx_timer_thread_entry+0x114>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800cc78:	f3ef 8010 	mrs	r0, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800cc7c:	b672      	cpsid	i
            expired_timers =  *_tx_timer_current_ptr;
 800cc7e:	f8db 3000 	ldr.w	r3, [fp]
 800cc82:	681a      	ldr	r2, [r3, #0]
 800cc84:	9200      	str	r2, [sp, #0]
            if (expired_timers != TX_NULL)
 800cc86:	b10a      	cbz	r2, 800cc8c <_tx_timer_thread_entry+0x34>
                expired_timers -> tx_timer_internal_list_head =  &expired_timers;
 800cc88:	f8c2 d018 	str.w	sp, [r2, #24]

            /* Move the current pointer up one timer entry wrap if we get to 
               the end of the list.  */
            _tx_timer_current_ptr =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, 1);
            if (_tx_timer_current_ptr == _tx_timer_list_end)
 800cc8c:	f8d8 2000 	ldr.w	r2, [r8]
            *_tx_timer_current_ptr =  TX_NULL;
 800cc90:	f843 6b04 	str.w	r6, [r3], #4
            if (_tx_timer_current_ptr == _tx_timer_list_end)
 800cc94:	4293      	cmp	r3, r2
            _tx_timer_current_ptr =  TX_TIMER_POINTER_ADD(_tx_timer_current_ptr, 1);
 800cc96:	f8cb 3000 	str.w	r3, [fp]
            if (_tx_timer_current_ptr == _tx_timer_list_end)
 800cc9a:	d059      	beq.n	800cd50 <_tx_timer_thread_entry+0xf8>
        
                _tx_timer_current_ptr =  _tx_timer_list_start;
            }

            /* Clear the expired flag.  */
            _tx_timer_expired =  TX_FALSE;
 800cc9c:	4b31      	ldr	r3, [pc, #196]	; (800cd64 <_tx_timer_thread_entry+0x10c>)
 800cc9e:	601e      	str	r6, [r3, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800cca0:	f380 8810 	msr	PRIMASK, r0
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800cca4:	f3ef 8c10 	mrs	ip, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800cca8:	b672      	cpsid	i
            /* Disable interrupts again.  */
            TX_DISABLE

            /* Next, process the expiration of the associated timers at this
               time slot.  */
            while (expired_timers != TX_NULL)
 800ccaa:	9f00      	ldr	r7, [sp, #0]
 800ccac:	b9b7      	cbnz	r7, 800ccdc <_tx_timer_thread_entry+0x84>
 800ccae:	e034      	b.n	800cd1a <_tx_timer_thread_entry+0xc2>
                    }
#endif

                    /* Decrement the remaining ticks of the timer.  */
                    current_timer -> tx_timer_internal_remaining_ticks =  
                            current_timer -> tx_timer_internal_remaining_ticks - TX_TIMER_ENTRIES;
 800ccb0:	3a20      	subs	r2, #32
                    timeout_function =  TX_NULL;

                    /* Make the timer appear that it is still active while interrupts
                       are enabled.  This will permit proper processing of a timer
                       deactivate from an ISR.  */
                    current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
 800ccb2:	61bd      	str	r5, [r7, #24]
                    current_timer -> tx_timer_internal_active_next =  current_timer;
 800ccb4:	613f      	str	r7, [r7, #16]
                    current_timer -> tx_timer_internal_remaining_ticks =  
 800ccb6:	603a      	str	r2, [r7, #0]

                    /* Setup the temporary timer list head pointer.  */
                    reactivate_timer =  current_timer;
 800ccb8:	9701      	str	r7, [sp, #4]
                        current_timer -> tx_timer_internal_list_head =  TX_NULL;
                    }
                }

                /* Set pointer to indicate the expired timer that is currently being processed.  */
                _tx_timer_expired_timer_ptr =  current_timer;
 800ccba:	6027      	str	r7, [r4, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800ccbc:	f38c 8810 	msr	PRIMASK, ip
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800ccc0:	f3ef 8910 	mrs	r9, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800ccc4:	b672      	cpsid	i

                /* Clear expired timer pointer.  */
                _tx_timer_expired_timer_ptr =  TX_NULL;

                /* Determine if the timer needs to be reactivated.  */
                if (reactivate_timer == current_timer)
 800ccc6:	9801      	ldr	r0, [sp, #4]
                _tx_timer_expired_timer_ptr =  TX_NULL;
 800ccc8:	6026      	str	r6, [r4, #0]
                if (reactivate_timer == current_timer)
 800ccca:	42b8      	cmp	r0, r7
 800cccc:	d02b      	beq.n	800cd26 <_tx_timer_thread_entry+0xce>
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800ccce:	f389 8810 	msr	PRIMASK, r9
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800ccd2:	f3ef 8c10 	mrs	ip, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800ccd6:	b672      	cpsid	i
            while (expired_timers != TX_NULL)
 800ccd8:	9f00      	ldr	r7, [sp, #0]
 800ccda:	b1f7      	cbz	r7, 800cd1a <_tx_timer_thread_entry+0xc2>
                next_timer =  expired_timers -> tx_timer_internal_active_next;
 800ccdc:	693a      	ldr	r2, [r7, #16]
                reactivate_timer =  TX_NULL;
 800ccde:	9601      	str	r6, [sp, #4]
                if (current_timer == next_timer)
 800cce0:	42ba      	cmp	r2, r7
 800cce2:	d018      	beq.n	800cd16 <_tx_timer_thread_entry+0xbe>
                    previous_timer =                                   current_timer -> tx_timer_internal_active_previous;
 800cce4:	6978      	ldr	r0, [r7, #20]
                    expired_timers =  next_timer;
 800cce6:	9200      	str	r2, [sp, #0]
                    next_timer -> tx_timer_internal_active_previous =  previous_timer;
 800cce8:	6150      	str	r0, [r2, #20]
                    previous_timer -> tx_timer_internal_active_next =  next_timer;
 800ccea:	6102      	str	r2, [r0, #16]
                    next_timer -> tx_timer_internal_list_head =  &expired_timers;
 800ccec:	f8c2 d018 	str.w	sp, [r2, #24]
                if (current_timer -> tx_timer_internal_remaining_ticks > TX_TIMER_ENTRIES)
 800ccf0:	683a      	ldr	r2, [r7, #0]
 800ccf2:	2a20      	cmp	r2, #32
 800ccf4:	d8dc      	bhi.n	800ccb0 <_tx_timer_thread_entry+0x58>
                    timeout_param =     current_timer -> tx_timer_internal_timeout_param;
 800ccf6:	68f8      	ldr	r0, [r7, #12]
                    timeout_function =  current_timer -> tx_timer_internal_timeout_function;
 800ccf8:	e9d7 3201 	ldrd	r3, r2, [r7, #4]
                    current_timer -> tx_timer_internal_remaining_ticks =  current_timer -> tx_timer_internal_re_initialize_ticks;
 800ccfc:	603b      	str	r3, [r7, #0]
                    if (current_timer -> tx_timer_internal_remaining_ticks != ((ULONG) 0))
 800ccfe:	b113      	cbz	r3, 800cd06 <_tx_timer_thread_entry+0xae>
                        current_timer -> tx_timer_internal_list_head =    &reactivate_timer;
 800cd00:	462b      	mov	r3, r5
                        current_timer -> tx_timer_internal_active_next =  current_timer;
 800cd02:	613f      	str	r7, [r7, #16]
                        reactivate_timer =  current_timer;
 800cd04:	9701      	str	r7, [sp, #4]
 800cd06:	61bb      	str	r3, [r7, #24]
                _tx_timer_expired_timer_ptr =  current_timer;
 800cd08:	6027      	str	r7, [r4, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800cd0a:	f38c 8810 	msr	PRIMASK, ip
                if (timeout_function != TX_NULL)
 800cd0e:	2a00      	cmp	r2, #0
 800cd10:	d0d6      	beq.n	800ccc0 <_tx_timer_thread_entry+0x68>
                    (timeout_function) (timeout_param);
 800cd12:	4790      	blx	r2
 800cd14:	e7d4      	b.n	800ccc0 <_tx_timer_thread_entry+0x68>
                    expired_timers =  TX_NULL;
 800cd16:	9600      	str	r6, [sp, #0]
 800cd18:	e7ea      	b.n	800ccf0 <_tx_timer_thread_entry+0x98>

            /* Finally, suspend this thread and wait for the next expiration.  */

            /* Determine if another expiration took place while we were in this
               thread.  If so, process another expiration.  */
            if (_tx_timer_expired == TX_FALSE)
 800cd1a:	4b12      	ldr	r3, [pc, #72]	; (800cd64 <_tx_timer_thread_entry+0x10c>)
 800cd1c:	681b      	ldr	r3, [r3, #0]
 800cd1e:	b13b      	cbz	r3, 800cd30 <_tx_timer_thread_entry+0xd8>
 800cd20:	f38c 8810 	msr	PRIMASK, ip
 800cd24:	e7a8      	b.n	800cc78 <_tx_timer_thread_entry+0x20>
                    current_timer -> tx_timer_internal_list_head = TX_NULL;
 800cd26:	61be      	str	r6, [r7, #24]
                    _tx_timer_system_activate(current_timer);
 800cd28:	4638      	mov	r0, r7
 800cd2a:	f7ff ff53 	bl	800cbd4 <_tx_timer_system_activate>
 800cd2e:	e7ce      	b.n	800ccce <_tx_timer_thread_entry+0x76>

                /* Set the suspending flag. */
                thread_ptr -> tx_thread_suspending =  TX_TRUE;

                /* Increment the preempt disable count prior to suspending.  */
                _tx_thread_preempt_disable++;
 800cd30:	490d      	ldr	r1, [pc, #52]	; (800cd68 <_tx_timer_thread_entry+0x110>)
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800cd32:	2201      	movs	r2, #1
                thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 800cd34:	2003      	movs	r0, #3
                _tx_thread_preempt_disable++;
 800cd36:	680b      	ldr	r3, [r1, #0]
                thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 800cd38:	f8ca 0030 	str.w	r0, [sl, #48]	; 0x30
                _tx_thread_preempt_disable++;
 800cd3c:	4413      	add	r3, r2
                thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800cd3e:	f8ca 2038 	str.w	r2, [sl, #56]	; 0x38
                _tx_thread_preempt_disable++;
 800cd42:	600b      	str	r3, [r1, #0]
 800cd44:	f38c 8810 	msr	PRIMASK, ip

                /* Restore interrupts.  */
                TX_RESTORE

                /* Call actual thread suspension routine.  */
                _tx_thread_system_suspend(thread_ptr);
 800cd48:	4808      	ldr	r0, [pc, #32]	; (800cd6c <_tx_timer_thread_entry+0x114>)
 800cd4a:	f7ff fdcb 	bl	800c8e4 <_tx_thread_system_suspend>
 800cd4e:	e793      	b.n	800cc78 <_tx_timer_thread_entry+0x20>
                _tx_timer_current_ptr =  _tx_timer_list_start;
 800cd50:	4b07      	ldr	r3, [pc, #28]	; (800cd70 <_tx_timer_thread_entry+0x118>)
 800cd52:	681b      	ldr	r3, [r3, #0]
 800cd54:	f8cb 3000 	str.w	r3, [fp]
 800cd58:	e7a0      	b.n	800cc9c <_tx_timer_thread_entry+0x44>
 800cd5a:	bf00      	nop
 800cd5c:	4154494d 	.word	0x4154494d
 800cd60:	200010a0 	.word	0x200010a0
 800cd64:	20000fc4 	.word	0x20000fc4
 800cd68:	20000f28 	.word	0x20000f28
 800cd6c:	20000fd8 	.word	0x20000fd8
 800cd70:	200010a4 	.word	0x200010a4
 800cd74:	20000f40 	.word	0x20000f40
 800cd78:	20000fd0 	.word	0x20000fd0

0800cd7c <_txe_mutex_create>:
        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
    }
    
    /* Now check to make sure the control block is the correct size.  */
    else if (mutex_control_block_size != (sizeof(TX_MUTEX)))
 800cd7c:	b108      	cbz	r0, 800cd82 <_txe_mutex_create+0x6>
 800cd7e:	2b34      	cmp	r3, #52	; 0x34
 800cd80:	d001      	beq.n	800cd86 <_txe_mutex_create+0xa>
    {

        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
 800cd82:	201c      	movs	r0, #28
        status =  _tx_mutex_create(mutex_ptr, name_ptr, inherit);
    }

    /* Return completion status.  */
    return(status);
}
 800cd84:	4770      	bx	lr
{
 800cd86:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800cd8a:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800cd8e:	b672      	cpsid	i
        _tx_thread_preempt_disable++;
 800cd90:	4f29      	ldr	r7, [pc, #164]	; (800ce38 <_txe_mutex_create+0xbc>)
 800cd92:	683b      	ldr	r3, [r7, #0]
 800cd94:	3301      	adds	r3, #1
 800cd96:	603b      	str	r3, [r7, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800cd98:	f384 8810 	msr	PRIMASK, r4
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
 800cd9c:	4c27      	ldr	r4, [pc, #156]	; (800ce3c <_txe_mutex_create+0xc0>)
        next_mutex =   _tx_mutex_created_ptr;
 800cd9e:	4b28      	ldr	r3, [pc, #160]	; (800ce40 <_txe_mutex_create+0xc4>)
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
 800cda0:	6825      	ldr	r5, [r4, #0]
        next_mutex =   _tx_mutex_created_ptr;
 800cda2:	681c      	ldr	r4, [r3, #0]
            if (mutex_ptr == next_mutex)
 800cda4:	b15d      	cbz	r5, 800cdbe <_txe_mutex_create+0x42>
 800cda6:	1b03      	subs	r3, r0, r4
 800cda8:	fab3 f383 	clz	r3, r3
 800cdac:	095b      	lsrs	r3, r3, #5
 800cdae:	b113      	cbz	r3, 800cdb6 <_txe_mutex_create+0x3a>
 800cdb0:	e005      	b.n	800cdbe <_txe_mutex_create+0x42>
 800cdb2:	42ab      	cmp	r3, r5
 800cdb4:	d203      	bcs.n	800cdbe <_txe_mutex_create+0x42>
                next_mutex =  next_mutex -> tx_mutex_created_next;
 800cdb6:	6a24      	ldr	r4, [r4, #32]
        for (i = ((ULONG) 0); i < _tx_mutex_created_count; i++)
 800cdb8:	3301      	adds	r3, #1
            if (mutex_ptr == next_mutex)
 800cdba:	42a0      	cmp	r0, r4
 800cdbc:	d1f9      	bne.n	800cdb2 <_txe_mutex_create+0x36>
 800cdbe:	4605      	mov	r5, r0
 800cdc0:	4616      	mov	r6, r2
 800cdc2:	4688      	mov	r8, r1
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800cdc4:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800cdc8:	b672      	cpsid	i
        _tx_thread_preempt_disable--;
 800cdca:	683b      	ldr	r3, [r7, #0]
 800cdcc:	3b01      	subs	r3, #1
 800cdce:	603b      	str	r3, [r7, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800cdd0:	f382 8810 	msr	PRIMASK, r2
        _tx_thread_system_preempt_check();
 800cdd4:	f7ff fce2 	bl	800c79c <_tx_thread_system_preempt_check>
        if (mutex_ptr == next_mutex)
 800cdd8:	42a5      	cmp	r5, r4
 800cdda:	d015      	beq.n	800ce08 <_txe_mutex_create+0x8c>
                if (inherit != TX_NO_INHERIT)
 800cddc:	2e01      	cmp	r6, #1
 800cdde:	d81d      	bhi.n	800ce1c <_txe_mutex_create+0xa0>
        TX_THREAD_GET_CURRENT(thread_ptr)
 800cde0:	4a18      	ldr	r2, [pc, #96]	; (800ce44 <_txe_mutex_create+0xc8>)
        if (thread_ptr == &_tx_timer_thread)
 800cde2:	4b19      	ldr	r3, [pc, #100]	; (800ce48 <_txe_mutex_create+0xcc>)
 800cde4:	6812      	ldr	r2, [r2, #0]
 800cde6:	429a      	cmp	r2, r3
 800cde8:	d01a      	beq.n	800ce20 <_txe_mutex_create+0xa4>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800cdea:	f3ef 8105 	mrs	r1, IPSR
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800cdee:	4b17      	ldr	r3, [pc, #92]	; (800ce4c <_txe_mutex_create+0xd0>)
 800cdf0:	681a      	ldr	r2, [r3, #0]
 800cdf2:	430a      	orrs	r2, r1
 800cdf4:	d00b      	beq.n	800ce0e <_txe_mutex_create+0x92>
 800cdf6:	f3ef 8205 	mrs	r2, IPSR
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800cdfa:	681b      	ldr	r3, [r3, #0]
 800cdfc:	4313      	orrs	r3, r2
 800cdfe:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800ce02:	d204      	bcs.n	800ce0e <_txe_mutex_create+0x92>
            status =  TX_CALLER_ERROR;
 800ce04:	2013      	movs	r0, #19
    return(status);
 800ce06:	e000      	b.n	800ce0a <_txe_mutex_create+0x8e>
        status =  TX_MUTEX_ERROR;
 800ce08:	201c      	movs	r0, #28
}
 800ce0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        status =  _tx_mutex_create(mutex_ptr, name_ptr, inherit);
 800ce0e:	4632      	mov	r2, r6
 800ce10:	4641      	mov	r1, r8
 800ce12:	4628      	mov	r0, r5
}
 800ce14:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        status =  _tx_mutex_create(mutex_ptr, name_ptr, inherit);
 800ce18:	f7ff b974 	b.w	800c104 <_tx_mutex_create>
                    status =  TX_INHERIT_ERROR;
 800ce1c:	201f      	movs	r0, #31
 800ce1e:	e7f4      	b.n	800ce0a <_txe_mutex_create+0x8e>
 800ce20:	f3ef 8105 	mrs	r1, IPSR
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800ce24:	4b09      	ldr	r3, [pc, #36]	; (800ce4c <_txe_mutex_create+0xd0>)
 800ce26:	681a      	ldr	r2, [r3, #0]
 800ce28:	430a      	orrs	r2, r1
 800ce2a:	d0eb      	beq.n	800ce04 <_txe_mutex_create+0x88>
 800ce2c:	f3ef 8205 	mrs	r2, IPSR
                status =  TX_CALLER_ERROR;
 800ce30:	2013      	movs	r0, #19
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800ce32:	681b      	ldr	r3, [r3, #0]
 800ce34:	e7e9      	b.n	800ce0a <_txe_mutex_create+0x8e>
 800ce36:	bf00      	nop
 800ce38:	20000f28 	.word	0x20000f28
 800ce3c:	200014c4 	.word	0x200014c4
 800ce40:	200014c8 	.word	0x200014c8
 800ce44:	20000f2c 	.word	0x20000f2c
 800ce48:	20000fd8 	.word	0x20000fd8
 800ce4c:	20000164 	.word	0x20000164

0800ce50 <_txe_mutex_get>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 800ce50:	b118      	cbz	r0, 800ce5a <_txe_mutex_get+0xa>
        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
    }
    
    /* Now check for a valid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
 800ce52:	4b15      	ldr	r3, [pc, #84]	; (800cea8 <_txe_mutex_get+0x58>)
 800ce54:	6802      	ldr	r2, [r0, #0]
 800ce56:	429a      	cmp	r2, r3
 800ce58:	d001      	beq.n	800ce5e <_txe_mutex_get+0xe>
        status =  TX_MUTEX_ERROR;
 800ce5a:	201c      	movs	r0, #28
        status =  _tx_mutex_get(mutex_ptr, wait_option);
    }

    /* Return completion status.  */
    return(status);
}
 800ce5c:	4770      	bx	lr
{
 800ce5e:	b410      	push	{r4}
        if (wait_option != TX_NO_WAIT)
 800ce60:	b981      	cbnz	r1, 800ce84 <_txe_mutex_get+0x34>
 800ce62:	4b12      	ldr	r3, [pc, #72]	; (800ceac <_txe_mutex_get+0x5c>)
 800ce64:	f3ef 8205 	mrs	r2, IPSR
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800ce68:	681c      	ldr	r4, [r3, #0]
 800ce6a:	4322      	orrs	r2, r4
 800ce6c:	d006      	beq.n	800ce7c <_txe_mutex_get+0x2c>
 800ce6e:	f3ef 8205 	mrs	r2, IPSR
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800ce72:	681b      	ldr	r3, [r3, #0]
 800ce74:	4313      	orrs	r3, r2
 800ce76:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800ce7a:	d312      	bcc.n	800cea2 <_txe_mutex_get+0x52>
}
 800ce7c:	f85d 4b04 	ldr.w	r4, [sp], #4
        status =  _tx_mutex_get(mutex_ptr, wait_option);
 800ce80:	f7ff b9ca 	b.w	800c218 <_tx_mutex_get>
 800ce84:	f3ef 8205 	mrs	r2, IPSR
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800ce88:	4b08      	ldr	r3, [pc, #32]	; (800ceac <_txe_mutex_get+0x5c>)
 800ce8a:	681c      	ldr	r4, [r3, #0]
 800ce8c:	4322      	orrs	r2, r4
 800ce8e:	d104      	bne.n	800ce9a <_txe_mutex_get+0x4a>
                TX_THREAD_GET_CURRENT(current_thread)
 800ce90:	4c07      	ldr	r4, [pc, #28]	; (800ceb0 <_txe_mutex_get+0x60>)
                if (current_thread == &_tx_timer_thread)
 800ce92:	4a08      	ldr	r2, [pc, #32]	; (800ceb4 <_txe_mutex_get+0x64>)
 800ce94:	6824      	ldr	r4, [r4, #0]
 800ce96:	4294      	cmp	r4, r2
 800ce98:	d1e4      	bne.n	800ce64 <_txe_mutex_get+0x14>
                status =  TX_WAIT_ERROR;
 800ce9a:	2004      	movs	r0, #4
}
 800ce9c:	f85d 4b04 	ldr.w	r4, [sp], #4
 800cea0:	4770      	bx	lr
                status =  TX_CALLER_ERROR;
 800cea2:	2013      	movs	r0, #19
    return(status);
 800cea4:	e7fa      	b.n	800ce9c <_txe_mutex_get+0x4c>
 800cea6:	bf00      	nop
 800cea8:	4d555445 	.word	0x4d555445
 800ceac:	20000164 	.word	0x20000164
 800ceb0:	20000f2c 	.word	0x20000f2c
 800ceb4:	20000fd8 	.word	0x20000fd8

0800ceb8 <_txe_mutex_put>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid mutex pointer.  */
    if (mutex_ptr == TX_NULL)
 800ceb8:	b190      	cbz	r0, 800cee0 <_txe_mutex_put+0x28>
        /* Mutex pointer is invalid, return appropriate error code.  */
        status =  TX_MUTEX_ERROR;
    }
    
    /* Now check for invalid mutex ID.  */
    else if (mutex_ptr -> tx_mutex_id != TX_MUTEX_ID)
 800ceba:	4b0b      	ldr	r3, [pc, #44]	; (800cee8 <_txe_mutex_put+0x30>)
 800cebc:	6802      	ldr	r2, [r0, #0]
 800cebe:	429a      	cmp	r2, r3
 800cec0:	d10e      	bne.n	800cee0 <_txe_mutex_put+0x28>
 800cec2:	f3ef 8305 	mrs	r3, IPSR
    }
    else
    {

        /* Check for interrupt call.  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800cec6:	4a09      	ldr	r2, [pc, #36]	; (800ceec <_txe_mutex_put+0x34>)
 800cec8:	6811      	ldr	r1, [r2, #0]
 800ceca:	430b      	orrs	r3, r1
 800cecc:	d006      	beq.n	800cedc <_txe_mutex_put+0x24>
 800cece:	f3ef 8105 	mrs	r1, IPSR
        {
    
            /* Now, make sure the call is from an interrupt and not initialization.  */
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800ced2:	6813      	ldr	r3, [r2, #0]
 800ced4:	430b      	orrs	r3, r1
 800ced6:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800ceda:	d303      	bcc.n	800cee4 <_txe_mutex_put+0x2c>
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual put mutex function.  */
        status =  _tx_mutex_put(mutex_ptr);
 800cedc:	f7ff ba86 	b.w	800c3ec <_tx_mutex_put>
        status =  TX_MUTEX_ERROR;
 800cee0:	201c      	movs	r0, #28
 800cee2:	4770      	bx	lr
                status =  TX_CALLER_ERROR;
 800cee4:	2013      	movs	r0, #19
    }

    /* Return completion status.  */
    return(status);
}
 800cee6:	4770      	bx	lr
 800cee8:	4d555445 	.word	0x4d555445
 800ceec:	20000164 	.word	0x20000164

0800cef0 <_txe_semaphore_create>:
        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
    }

    /* Now check for a valid semaphore ID.  */
    else if (semaphore_control_block_size != (sizeof(TX_SEMAPHORE)))
 800cef0:	2b20      	cmp	r3, #32
 800cef2:	d100      	bne.n	800cef6 <_txe_semaphore_create+0x6>
 800cef4:	b908      	cbnz	r0, 800cefa <_txe_semaphore_create+0xa>
    {

        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
 800cef6:	200c      	movs	r0, #12
        status =  _tx_semaphore_create(semaphore_ptr, name_ptr, initial_count);
    }

    /* Return completion status.  */
    return(status);
}
 800cef8:	4770      	bx	lr
{
 800cefa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800cefe:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800cf02:	b672      	cpsid	i
        _tx_thread_preempt_disable++;
 800cf04:	4e21      	ldr	r6, [pc, #132]	; (800cf8c <_txe_semaphore_create+0x9c>)
 800cf06:	6833      	ldr	r3, [r6, #0]
 800cf08:	3301      	adds	r3, #1
 800cf0a:	6033      	str	r3, [r6, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800cf0c:	f384 8810 	msr	PRIMASK, r4
        next_semaphore =  _tx_semaphore_created_ptr;
 800cf10:	4c1f      	ldr	r4, [pc, #124]	; (800cf90 <_txe_semaphore_create+0xa0>)
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
 800cf12:	4b20      	ldr	r3, [pc, #128]	; (800cf94 <_txe_semaphore_create+0xa4>)
        next_semaphore =  _tx_semaphore_created_ptr;
 800cf14:	6824      	ldr	r4, [r4, #0]
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
 800cf16:	681d      	ldr	r5, [r3, #0]
            if (semaphore_ptr == next_semaphore)
 800cf18:	42a0      	cmp	r0, r4
 800cf1a:	d00a      	beq.n	800cf32 <_txe_semaphore_create+0x42>
 800cf1c:	fab5 f385 	clz	r3, r5
 800cf20:	095b      	lsrs	r3, r3, #5
 800cf22:	b113      	cbz	r3, 800cf2a <_txe_semaphore_create+0x3a>
 800cf24:	e005      	b.n	800cf32 <_txe_semaphore_create+0x42>
 800cf26:	42a0      	cmp	r0, r4
 800cf28:	d003      	beq.n	800cf32 <_txe_semaphore_create+0x42>
        for (i = ((ULONG) 0); i < _tx_semaphore_created_count; i++)
 800cf2a:	3301      	adds	r3, #1
                next_semaphore =  next_semaphore -> tx_semaphore_created_next;
 800cf2c:	6964      	ldr	r4, [r4, #20]
            if (semaphore_ptr == next_semaphore)
 800cf2e:	42ab      	cmp	r3, r5
 800cf30:	d3f9      	bcc.n	800cf26 <_txe_semaphore_create+0x36>
 800cf32:	4615      	mov	r5, r2
 800cf34:	4688      	mov	r8, r1
 800cf36:	4607      	mov	r7, r0
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800cf38:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800cf3c:	b672      	cpsid	i
        _tx_thread_preempt_disable--;
 800cf3e:	6833      	ldr	r3, [r6, #0]
 800cf40:	3b01      	subs	r3, #1
 800cf42:	6033      	str	r3, [r6, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800cf44:	f382 8810 	msr	PRIMASK, r2
        _tx_thread_system_preempt_check();
 800cf48:	f7ff fc28 	bl	800c79c <_tx_thread_system_preempt_check>
        if (semaphore_ptr == next_semaphore)
 800cf4c:	42a7      	cmp	r7, r4
 800cf4e:	d018      	beq.n	800cf82 <_txe_semaphore_create+0x92>
            TX_THREAD_GET_CURRENT(thread_ptr)
 800cf50:	4a11      	ldr	r2, [pc, #68]	; (800cf98 <_txe_semaphore_create+0xa8>)
            if (thread_ptr == &_tx_timer_thread)
 800cf52:	4b12      	ldr	r3, [pc, #72]	; (800cf9c <_txe_semaphore_create+0xac>)
 800cf54:	6812      	ldr	r2, [r2, #0]
 800cf56:	429a      	cmp	r2, r3
 800cf58:	d016      	beq.n	800cf88 <_txe_semaphore_create+0x98>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800cf5a:	f3ef 8205 	mrs	r2, IPSR
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800cf5e:	4b10      	ldr	r3, [pc, #64]	; (800cfa0 <_txe_semaphore_create+0xb0>)
 800cf60:	6819      	ldr	r1, [r3, #0]
 800cf62:	430a      	orrs	r2, r1
 800cf64:	d006      	beq.n	800cf74 <_txe_semaphore_create+0x84>
 800cf66:	f3ef 8205 	mrs	r2, IPSR
            if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800cf6a:	681b      	ldr	r3, [r3, #0]
 800cf6c:	4313      	orrs	r3, r2
 800cf6e:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800cf72:	d309      	bcc.n	800cf88 <_txe_semaphore_create+0x98>
        status =  _tx_semaphore_create(semaphore_ptr, name_ptr, initial_count);
 800cf74:	462a      	mov	r2, r5
 800cf76:	4641      	mov	r1, r8
 800cf78:	4638      	mov	r0, r7
}
 800cf7a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        status =  _tx_semaphore_create(semaphore_ptr, name_ptr, initial_count);
 800cf7e:	f000 ba7b 	b.w	800d478 <_tx_semaphore_create>
        status =  TX_SEMAPHORE_ERROR;
 800cf82:	200c      	movs	r0, #12
}
 800cf84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                status =  TX_CALLER_ERROR;
 800cf88:	2013      	movs	r0, #19
    return(status);
 800cf8a:	e7fb      	b.n	800cf84 <_txe_semaphore_create+0x94>
 800cf8c:	20000f28 	.word	0x20000f28
 800cf90:	200014d0 	.word	0x200014d0
 800cf94:	200014e0 	.word	0x200014e0
 800cf98:	20000f2c 	.word	0x20000f2c
 800cf9c:	20000fd8 	.word	0x20000fd8
 800cfa0:	20000164 	.word	0x20000164

0800cfa4 <_txe_semaphore_delete>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800cfa4:	b180      	cbz	r0, 800cfc8 <_txe_semaphore_delete+0x24>
        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
    }

    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 800cfa6:	6802      	ldr	r2, [r0, #0]
 800cfa8:	4b09      	ldr	r3, [pc, #36]	; (800cfd0 <_txe_semaphore_delete+0x2c>)
 800cfaa:	429a      	cmp	r2, r3
 800cfac:	d10c      	bne.n	800cfc8 <_txe_semaphore_delete+0x24>
 800cfae:	f3ef 8305 	mrs	r3, IPSR
    {

        /* Check for invalid caller of this function.  */

        /* Is the caller an ISR or Initialization?  */
        if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800cfb2:	4a08      	ldr	r2, [pc, #32]	; (800cfd4 <_txe_semaphore_delete+0x30>)
 800cfb4:	6812      	ldr	r2, [r2, #0]
 800cfb6:	4313      	orrs	r3, r2
 800cfb8:	d108      	bne.n	800cfcc <_txe_semaphore_delete+0x28>
#ifndef TX_TIMER_PROCESS_IN_ISR
        else
        {
        
            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800cfba:	4a07      	ldr	r2, [pc, #28]	; (800cfd8 <_txe_semaphore_delete+0x34>)

            /* Is the caller the system timer thread?  */
            if (thread_ptr == &_tx_timer_thread)
 800cfbc:	4b07      	ldr	r3, [pc, #28]	; (800cfdc <_txe_semaphore_delete+0x38>)
 800cfbe:	6812      	ldr	r2, [r2, #0]
 800cfc0:	429a      	cmp	r2, r3
 800cfc2:	d003      	beq.n	800cfcc <_txe_semaphore_delete+0x28>
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual semaphore delete function.  */
        status =  _tx_semaphore_delete(semaphore_ptr);
 800cfc4:	f000 ba82 	b.w	800d4cc <_tx_semaphore_delete>
        status =  TX_SEMAPHORE_ERROR;
 800cfc8:	200c      	movs	r0, #12
 800cfca:	4770      	bx	lr
            status =  TX_CALLER_ERROR;
 800cfcc:	2013      	movs	r0, #19
    }

    /* Return completion status.  */
    return(status);
}
 800cfce:	4770      	bx	lr
 800cfd0:	53454d41 	.word	0x53454d41
 800cfd4:	20000164 	.word	0x20000164
 800cfd8:	20000f2c 	.word	0x20000f2c
 800cfdc:	20000fd8 	.word	0x20000fd8

0800cfe0 <_txe_semaphore_get>:

    /* Default status to success.  */
    status =  TX_SUCCESS;

    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800cfe0:	b188      	cbz	r0, 800d006 <_txe_semaphore_get+0x26>
        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
    }
    
    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 800cfe2:	4b0b      	ldr	r3, [pc, #44]	; (800d010 <_txe_semaphore_get+0x30>)
 800cfe4:	6802      	ldr	r2, [r0, #0]
 800cfe6:	429a      	cmp	r2, r3
 800cfe8:	d10d      	bne.n	800d006 <_txe_semaphore_get+0x26>
    else
    {

        /* Check for a wait option error.  Only threads are allowed any form of 
           suspension.  */
        if (wait_option != TX_NO_WAIT)
 800cfea:	b151      	cbz	r1, 800d002 <_txe_semaphore_get+0x22>
 800cfec:	f3ef 8305 	mrs	r3, IPSR
        {

            /* Is the call from an ISR or Initialization?  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800cff0:	4a08      	ldr	r2, [pc, #32]	; (800d014 <_txe_semaphore_get+0x34>)
 800cff2:	6812      	ldr	r2, [r2, #0]
 800cff4:	4313      	orrs	r3, r2
 800cff6:	d108      	bne.n	800d00a <_txe_semaphore_get+0x2a>
#ifndef TX_TIMER_PROCESS_IN_ISR
            else
            {
            
                /* Pickup thread pointer.  */
                TX_THREAD_GET_CURRENT(current_thread)
 800cff8:	4a07      	ldr	r2, [pc, #28]	; (800d018 <_txe_semaphore_get+0x38>)

                /* Is the current thread the timer thread?  */
                if (current_thread == &_tx_timer_thread)
 800cffa:	4b08      	ldr	r3, [pc, #32]	; (800d01c <_txe_semaphore_get+0x3c>)
 800cffc:	6812      	ldr	r2, [r2, #0]
 800cffe:	429a      	cmp	r2, r3
 800d000:	d003      	beq.n	800d00a <_txe_semaphore_get+0x2a>
    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
    {

        /* Call actual get semaphore function.  */
        status =  _tx_semaphore_get(semaphore_ptr, wait_option);
 800d002:	f000 bab1 	b.w	800d568 <_tx_semaphore_get>
        status =  TX_SEMAPHORE_ERROR;
 800d006:	200c      	movs	r0, #12
 800d008:	4770      	bx	lr
                status =  TX_WAIT_ERROR;
 800d00a:	2004      	movs	r0, #4
    }

    /* Return completion status.  */
    return(status);
}
 800d00c:	4770      	bx	lr
 800d00e:	bf00      	nop
 800d010:	53454d41 	.word	0x53454d41
 800d014:	20000164 	.word	0x20000164
 800d018:	20000f2c 	.word	0x20000f2c
 800d01c:	20000fd8 	.word	0x20000fd8

0800d020 <_txe_semaphore_put>:

UINT        status;


    /* Check for an invalid semaphore pointer.  */
    if (semaphore_ptr == TX_NULL)
 800d020:	b118      	cbz	r0, 800d02a <_txe_semaphore_put+0xa>
        /* Semaphore pointer is invalid, return appropriate error code.  */
        status =  TX_SEMAPHORE_ERROR;
    }
    
    /* Now check for invalid semaphore ID.  */
    else if (semaphore_ptr -> tx_semaphore_id != TX_SEMAPHORE_ID)
 800d022:	6802      	ldr	r2, [r0, #0]
 800d024:	4b03      	ldr	r3, [pc, #12]	; (800d034 <_txe_semaphore_put+0x14>)
 800d026:	429a      	cmp	r2, r3
 800d028:	d001      	beq.n	800d02e <_txe_semaphore_put+0xe>
        status =  _tx_semaphore_put(semaphore_ptr);
    }

    /* Return completion status.  */
    return(status);
}
 800d02a:	200c      	movs	r0, #12
 800d02c:	4770      	bx	lr
        status =  _tx_semaphore_put(semaphore_ptr);
 800d02e:	f000 badd 	b.w	800d5ec <_tx_semaphore_put>
 800d032:	bf00      	nop
 800d034:	53454d41 	.word	0x53454d41

0800d038 <_txe_thread_create>:
UINT    _txe_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr, 
                VOID (*entry_function)(ULONG id), ULONG entry_input,
                VOID *stack_start, ULONG stack_size, 
                UINT priority, UINT preempt_threshold,
                ULONG time_slice, UINT auto_start, UINT thread_control_block_size)
{
 800d038:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d03c:	b085      	sub	sp, #20
 800d03e:	e9dd 9410 	ldrd	r9, r4, [sp, #64]	; 0x40
 800d042:	e9dd 780e 	ldrd	r7, r8, [sp, #56]	; 0x38
 800d046:	9401      	str	r4, [sp, #4]
 800d048:	9c12      	ldr	r4, [sp, #72]	; 0x48
 800d04a:	9403      	str	r4, [sp, #12]
 800d04c:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 800d04e:	9402      	str	r4, [sp, #8]
 800d050:	9c14      	ldr	r4, [sp, #80]	; 0x50
        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
    }

    /* Now check for invalid thread control block size.  */
    else if (thread_control_block_size != (sizeof(TX_THREAD)))
 800d052:	2800      	cmp	r0, #0
 800d054:	d079      	beq.n	800d14a <_txe_thread_create+0x112>
 800d056:	2cc8      	cmp	r4, #200	; 0xc8
 800d058:	d177      	bne.n	800d14a <_txe_thread_create+0x112>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d05a:	f3ef 8510 	mrs	r5, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d05e:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Increment the preempt disable flag.  */
        _tx_thread_preempt_disable++;
 800d060:	f8df e140 	ldr.w	lr, [pc, #320]	; 800d1a4 <_txe_thread_create+0x16c>
 800d064:	f8de 4000 	ldr.w	r4, [lr]
 800d068:	3401      	adds	r4, #1
 800d06a:	f8ce 4000 	str.w	r4, [lr]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d06e:	f385 8810 	msr	PRIMASK, r5
        /* Restore interrupts.  */
        TX_RESTORE

        /* Next see if it is already in the created list.  */
        break_flag =   TX_FALSE;
        next_thread =  _tx_thread_created_ptr;
 800d072:	4c47      	ldr	r4, [pc, #284]	; (800d190 <_txe_thread_create+0x158>)
        work_ptr =     TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
        work_ptr =     TX_UCHAR_POINTER_ADD(work_ptr, (stack_size - ((ULONG) 1)));
 800d074:	f108 3cff 	add.w	ip, r8, #4294967295
        stack_end =    TX_UCHAR_TO_VOID_POINTER_CONVERT(work_ptr);
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
 800d078:	4d46      	ldr	r5, [pc, #280]	; (800d194 <_txe_thread_create+0x15c>)
        next_thread =  _tx_thread_created_ptr;
 800d07a:	6824      	ldr	r4, [r4, #0]
        work_ptr =     TX_UCHAR_POINTER_ADD(work_ptr, (stack_size - ((ULONG) 1)));
 800d07c:	44bc      	add	ip, r7
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
 800d07e:	f8d5 b000 	ldr.w	fp, [r5]
        {
        
            /* Determine if this thread matches the thread in the list.  */
            if (thread_ptr == next_thread)
 800d082:	1b05      	subs	r5, r0, r4
 800d084:	fab5 f585 	clz	r5, r5
 800d088:	096d      	lsrs	r5, r5, #5
 800d08a:	f1bb 0f00 	cmp.w	fp, #0
 800d08e:	bf08      	it	eq
 800d090:	2501      	moveq	r5, #1
                /* Set the break flag.  */
                break_flag =  TX_TRUE;
            }
            
            /* Determine if we need to break the loop.  */
            if (break_flag == TX_TRUE)
 800d092:	b985      	cbnz	r5, 800d0b6 <_txe_thread_create+0x7e>
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
 800d094:	469a      	mov	sl, r3
                /* Yes, break out of the loop.  */
                break;
            }

            /* Check the stack pointer to see if it overlaps with this thread's stack.  */
            if (stack_start >= next_thread -> tx_thread_stack_start)
 800d096:	68e6      	ldr	r6, [r4, #12]
 800d098:	42be      	cmp	r6, r7
 800d09a:	d865      	bhi.n	800d168 <_txe_thread_create+0x130>
            {

                if (stack_start < next_thread -> tx_thread_stack_end)
 800d09c:	6923      	ldr	r3, [r4, #16]
 800d09e:	42bb      	cmp	r3, r7
 800d0a0:	d962      	bls.n	800d168 <_txe_thread_create+0x130>
                    break_flag =  TX_TRUE;
                }
            }

            /* Check the end of the stack to see if it is inside this thread's stack area as well.  */
            if (stack_end >= next_thread -> tx_thread_stack_start)
 800d0a2:	4566      	cmp	r6, ip
 800d0a4:	d803      	bhi.n	800d0ae <_txe_thread_create+0x76>
 800d0a6:	2601      	movs	r6, #1
                    stack_start =  TX_NULL;
 800d0a8:	2700      	movs	r7, #0
            {

                if (stack_end < next_thread -> tx_thread_stack_end)
 800d0aa:	4563      	cmp	r3, ip
 800d0ac:	d951      	bls.n	800d152 <_txe_thread_create+0x11a>
 800d0ae:	4653      	mov	r3, sl
                    break_flag =  TX_TRUE;
                }
            }

            /* Move to the next thread.  */
            next_thread =  next_thread -> tx_thread_created_next;
 800d0b0:	f8d4 4088 	ldr.w	r4, [r4, #136]	; 0x88
                    stack_start =  TX_NULL;
 800d0b4:	2700      	movs	r7, #0
 800d0b6:	4605      	mov	r5, r0
 800d0b8:	469a      	mov	sl, r3
 800d0ba:	4616      	mov	r6, r2
 800d0bc:	468b      	mov	fp, r1
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d0be:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d0c2:	b672      	cpsid	i

        /* Disable interrupts.  */
        TX_DISABLE

        /* Decrement the preempt disable flag.  */
        _tx_thread_preempt_disable--;
 800d0c4:	f8de 3000 	ldr.w	r3, [lr]
 800d0c8:	3b01      	subs	r3, #1
 800d0ca:	f8ce 3000 	str.w	r3, [lr]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d0ce:	f382 8810 	msr	PRIMASK, r2
    
        /* Restore interrupts.  */
        TX_RESTORE

        /* Check for preemption.  */
        _tx_thread_system_preempt_check();
 800d0d2:	f7ff fb63 	bl	800c79c <_tx_thread_system_preempt_check>

        /* At this point, check to see if there is a duplicate thread.  */
        if (thread_ptr == next_thread)
 800d0d6:	42a5      	cmp	r5, r4
 800d0d8:	d037      	beq.n	800d14a <_txe_thread_create+0x112>
            /* Invalid stack or entry point, return appropriate error code.  */
            status =  TX_PTR_ERROR;
        }

        /* Check for invalid thread entry point.  */
        else if (entry_function == TX_NULL)
 800d0da:	2e00      	cmp	r6, #0
 800d0dc:	d04c      	beq.n	800d178 <_txe_thread_create+0x140>
 800d0de:	2f00      	cmp	r7, #0
 800d0e0:	d04a      	beq.n	800d178 <_txe_thread_create+0x140>
            /* Invalid stack or entry point, return appropriate error code.  */
            status =  TX_PTR_ERROR;
        }

        /* Check the stack size.  */
        else if (stack_size < ((ULONG) TX_MINIMUM_STACK))
 800d0e2:	f1b8 0fc7 	cmp.w	r8, #199	; 0xc7
 800d0e6:	d945      	bls.n	800d174 <_txe_thread_create+0x13c>
            /* Stack is not big enough, return appropriate error code.  */
            status =  TX_SIZE_ERROR;
        }

        /* Check the priority specified.  */
        else if (priority >= ((UINT) TX_MAX_PRIORITIES))
 800d0e8:	f1b9 0f1f 	cmp.w	r9, #31
 800d0ec:	d848      	bhi.n	800d180 <_txe_thread_create+0x148>
            /* Invalid priority selected, return appropriate error code.  */
            status =  TX_PRIORITY_ERROR;
        }

        /* Check preemption threshold. */
        else if (preempt_threshold > priority)
 800d0ee:	9b01      	ldr	r3, [sp, #4]
 800d0f0:	4599      	cmp	r9, r3
 800d0f2:	d34b      	bcc.n	800d18c <_txe_thread_create+0x154>
            /* Invalid preempt threshold, return appropriate error code.  */
            status =  TX_THRESH_ERROR;
        }

        /* Check the start selection.  */
        else if (auto_start > TX_AUTO_START)
 800d0f4:	9b02      	ldr	r3, [sp, #8]
 800d0f6:	2b01      	cmp	r3, #1
 800d0f8:	d844      	bhi.n	800d184 <_txe_thread_create+0x14c>
        {

#ifndef TX_TIMER_PROCESS_IN_ISR

            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(current_thread)
 800d0fa:	4a27      	ldr	r2, [pc, #156]	; (800d198 <_txe_thread_create+0x160>)

            /* Check for invalid caller of this function.  First check for a calling thread.  */
            if (current_thread == &_tx_timer_thread)
 800d0fc:	4b27      	ldr	r3, [pc, #156]	; (800d19c <_txe_thread_create+0x164>)
 800d0fe:	6810      	ldr	r0, [r2, #0]
    status =  TX_SUCCESS;
 800d100:	4298      	cmp	r0, r3
 800d102:	bf0c      	ite	eq
 800d104:	2013      	moveq	r0, #19
 800d106:	2000      	movne	r0, #0
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d108:	f3ef 8205 	mrs	r2, IPSR
                status =  TX_CALLER_ERROR;
            }
#endif

            /* Check for interrupt call.  */
            if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800d10c:	4b24      	ldr	r3, [pc, #144]	; (800d1a0 <_txe_thread_create+0x168>)
 800d10e:	6819      	ldr	r1, [r3, #0]
 800d110:	430a      	orrs	r2, r1
 800d112:	d006      	beq.n	800d122 <_txe_thread_create+0xea>
 800d114:	f3ef 8205 	mrs	r2, IPSR
            {
    
                /* Now, make sure the call is from an interrupt and not initialization.  */
                if (TX_THREAD_GET_SYSTEM_STATE() < TX_INITIALIZE_IN_PROGRESS)
 800d118:	681b      	ldr	r3, [r3, #0]
 800d11a:	4313      	orrs	r3, r2
 800d11c:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800d120:	d332      	bcc.n	800d188 <_txe_thread_create+0x150>
            }
        }
    }

    /* Determine if everything is okay.  */
    if (status == TX_SUCCESS)
 800d122:	b998      	cbnz	r0, 800d14c <_txe_thread_create+0x114>
    {

        /* Call actual thread create function.  */
        status =  _tx_thread_create(thread_ptr, name_ptr, entry_function, entry_input,
 800d124:	9b02      	ldr	r3, [sp, #8]
 800d126:	4628      	mov	r0, r5
 800d128:	9a03      	ldr	r2, [sp, #12]
 800d12a:	9901      	ldr	r1, [sp, #4]
 800d12c:	9313      	str	r3, [sp, #76]	; 0x4c
 800d12e:	4653      	mov	r3, sl
 800d130:	9212      	str	r2, [sp, #72]	; 0x48
 800d132:	4632      	mov	r2, r6
 800d134:	9111      	str	r1, [sp, #68]	; 0x44
 800d136:	4659      	mov	r1, fp
 800d138:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
 800d13c:	e9cd 780e 	strd	r7, r8, [sp, #56]	; 0x38
                        time_slice, auto_start);
    }

    /* Return completion status.  */
    return(status);
}
 800d140:	b005      	add	sp, #20
 800d142:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        status =  _tx_thread_create(thread_ptr, name_ptr, entry_function, entry_input,
 800d146:	f000 ba83 	b.w	800d650 <_tx_thread_create>
        status =  TX_THREAD_ERROR;
 800d14a:	200e      	movs	r0, #14
}
 800d14c:	b005      	add	sp, #20
 800d14e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            next_thread =  next_thread -> tx_thread_created_next;
 800d152:	f8d4 4088 	ldr.w	r4, [r4, #136]	; 0x88
        for (i = ((ULONG) 0); i < _tx_thread_created_count; i++)
 800d156:	3501      	adds	r5, #1
            if (break_flag == TX_TRUE)
 800d158:	42a0      	cmp	r0, r4
 800d15a:	bf18      	it	ne
 800d15c:	455d      	cmpne	r5, fp
 800d15e:	d201      	bcs.n	800d164 <_txe_thread_create+0x12c>
 800d160:	2e00      	cmp	r6, #0
 800d162:	d098      	beq.n	800d096 <_txe_thread_create+0x5e>
 800d164:	4653      	mov	r3, sl
 800d166:	e7a6      	b.n	800d0b6 <_txe_thread_create+0x7e>
            if (stack_end >= next_thread -> tx_thread_stack_start)
 800d168:	4566      	cmp	r6, ip
 800d16a:	f04f 0600 	mov.w	r6, #0
 800d16e:	d8f0      	bhi.n	800d152 <_txe_thread_create+0x11a>
 800d170:	6923      	ldr	r3, [r4, #16]
 800d172:	e79a      	b.n	800d0aa <_txe_thread_create+0x72>
            status =  TX_SIZE_ERROR;
 800d174:	2005      	movs	r0, #5
 800d176:	e7e9      	b.n	800d14c <_txe_thread_create+0x114>
            status =  TX_PTR_ERROR;
 800d178:	2003      	movs	r0, #3
}
 800d17a:	b005      	add	sp, #20
 800d17c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            status =  TX_PRIORITY_ERROR;
 800d180:	200f      	movs	r0, #15
 800d182:	e7e3      	b.n	800d14c <_txe_thread_create+0x114>
            status =  TX_START_ERROR;
 800d184:	2010      	movs	r0, #16
 800d186:	e7e1      	b.n	800d14c <_txe_thread_create+0x114>
                    status =  TX_CALLER_ERROR;
 800d188:	2013      	movs	r0, #19
    return(status);
 800d18a:	e7df      	b.n	800d14c <_txe_thread_create+0x114>
            status =  TX_THRESH_ERROR;
 800d18c:	2018      	movs	r0, #24
 800d18e:	e7dd      	b.n	800d14c <_txe_thread_create+0x114>
 800d190:	20000f18 	.word	0x20000f18
 800d194:	20000f20 	.word	0x20000f20
 800d198:	20000f2c 	.word	0x20000f2c
 800d19c:	20000fd8 	.word	0x20000fd8
 800d1a0:	20000164 	.word	0x20000164
 800d1a4:	20000f28 	.word	0x20000f28

0800d1a8 <_txe_thread_delete>:
 800d1a8:	f3ef 8205 	mrs	r2, IPSR

UINT        status;


    /* Check for invalid caller of this function.  */
    if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800d1ac:	4907      	ldr	r1, [pc, #28]	; (800d1cc <_txe_thread_delete+0x24>)
 800d1ae:	6809      	ldr	r1, [r1, #0]
 800d1b0:	430a      	orrs	r2, r1
 800d1b2:	d108      	bne.n	800d1c6 <_txe_thread_delete+0x1e>
        /* Invalid caller of this function, return appropriate error code.  */
        status =  TX_CALLER_ERROR;
    }

    /* Check for an invalid thread pointer.  */
    else if (thread_ptr == TX_NULL)
 800d1b4:	b118      	cbz	r0, 800d1be <_txe_thread_delete+0x16>
        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
    }

    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800d1b6:	6802      	ldr	r2, [r0, #0]
 800d1b8:	4b05      	ldr	r3, [pc, #20]	; (800d1d0 <_txe_thread_delete+0x28>)
 800d1ba:	429a      	cmp	r2, r3
 800d1bc:	d001      	beq.n	800d1c2 <_txe_thread_delete+0x1a>
        status =  TX_THREAD_ERROR;
 800d1be:	200e      	movs	r0, #14
        status =  _tx_thread_delete(thread_ptr);
    }

    /* Return completion status.  */
    return(status);
}
 800d1c0:	4770      	bx	lr
        status =  _tx_thread_delete(thread_ptr);
 800d1c2:	f000 badb 	b.w	800d77c <_tx_thread_delete>
        status =  TX_CALLER_ERROR;
 800d1c6:	2013      	movs	r0, #19
 800d1c8:	4770      	bx	lr
 800d1ca:	bf00      	nop
 800d1cc:	20000164 	.word	0x20000164
 800d1d0:	54485244 	.word	0x54485244

0800d1d4 <_txe_thread_info_get>:

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800d1d4:	b150      	cbz	r0, 800d1ec <_txe_thread_info_get+0x18>
{
 800d1d6:	b430      	push	{r4, r5}
        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
    }
    
    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800d1d8:	6805      	ldr	r5, [r0, #0]
 800d1da:	4c05      	ldr	r4, [pc, #20]	; (800d1f0 <_txe_thread_info_get+0x1c>)
 800d1dc:	42a5      	cmp	r5, r4
 800d1de:	d002      	beq.n	800d1e6 <_txe_thread_info_get+0x12>
                            time_slice, next_thread, next_suspended_thread);
    }

    /* Return completion status.  */
    return(status);
}
 800d1e0:	200e      	movs	r0, #14
 800d1e2:	bc30      	pop	{r4, r5}
 800d1e4:	4770      	bx	lr
 800d1e6:	bc30      	pop	{r4, r5}
        status =  _tx_thread_info_get(thread_ptr, name, state, run_count, priority, preemption_threshold, 
 800d1e8:	f000 baf6 	b.w	800d7d8 <_tx_thread_info_get>
}
 800d1ec:	200e      	movs	r0, #14
 800d1ee:	4770      	bx	lr
 800d1f0:	54485244 	.word	0x54485244

0800d1f4 <_txe_thread_priority_change>:

UINT        status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800d1f4:	b1b0      	cbz	r0, 800d224 <_txe_thread_priority_change+0x30>
        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
    }
    
    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800d1f6:	4b0f      	ldr	r3, [pc, #60]	; (800d234 <_txe_thread_priority_change+0x40>)
{
 800d1f8:	b470      	push	{r4, r5, r6}
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800d1fa:	6804      	ldr	r4, [r0, #0]
 800d1fc:	429c      	cmp	r4, r3
 800d1fe:	d10b      	bne.n	800d218 <_txe_thread_priority_change+0x24>
        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
    }

    /* Check for a valid old priority pointer.  */
    else if (old_priority == TX_NULL)
 800d200:	b1aa      	cbz	r2, 800d22e <_txe_thread_priority_change+0x3a>
        /* Invalid destination pointer, return appropriate error code.  */
        status =  TX_PTR_ERROR;
    }

    /* Determine if the priority is legal.  */
    else if (new_priority >= ((UINT) TX_MAX_PRIORITIES))
 800d202:	291f      	cmp	r1, #31
 800d204:	d810      	bhi.n	800d228 <_txe_thread_priority_change+0x34>
 800d206:	f3ef 8305 	mrs	r3, IPSR
        /* Return an error status.  */
        status =  TX_PRIORITY_ERROR;
    }

    /* Check for invalid caller of this function.  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800d20a:	4c0b      	ldr	r4, [pc, #44]	; (800d238 <_txe_thread_priority_change+0x44>)
 800d20c:	6824      	ldr	r4, [r4, #0]
 800d20e:	4323      	orrs	r3, r4
 800d210:	d105      	bne.n	800d21e <_txe_thread_priority_change+0x2a>
        status =  _tx_thread_priority_change(thread_ptr, new_priority, old_priority);
    }

    /* Return completion status.  */
    return(status);
}
 800d212:	bc70      	pop	{r4, r5, r6}
        status =  _tx_thread_priority_change(thread_ptr, new_priority, old_priority);
 800d214:	f000 bb12 	b.w	800d83c <_tx_thread_priority_change>
        status =  TX_THREAD_ERROR;
 800d218:	200e      	movs	r0, #14
}
 800d21a:	bc70      	pop	{r4, r5, r6}
 800d21c:	4770      	bx	lr
        status =  TX_CALLER_ERROR;
 800d21e:	2013      	movs	r0, #19
}
 800d220:	bc70      	pop	{r4, r5, r6}
 800d222:	4770      	bx	lr
        status =  TX_THREAD_ERROR;
 800d224:	200e      	movs	r0, #14
}
 800d226:	4770      	bx	lr
        status =  TX_PRIORITY_ERROR;
 800d228:	200f      	movs	r0, #15
}
 800d22a:	bc70      	pop	{r4, r5, r6}
 800d22c:	4770      	bx	lr
        status =  TX_PTR_ERROR;
 800d22e:	2003      	movs	r0, #3
 800d230:	e7f3      	b.n	800d21a <_txe_thread_priority_change+0x26>
 800d232:	bf00      	nop
 800d234:	54485244 	.word	0x54485244
 800d238:	20000164 	.word	0x20000164

0800d23c <_txe_thread_relinquish>:

TX_THREAD   *current_thread;


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(current_thread)
 800d23c:	4b05      	ldr	r3, [pc, #20]	; (800d254 <_txe_thread_relinquish+0x18>)

    /* Make sure a thread is executing.  */
    if (current_thread != TX_NULL)
 800d23e:	681b      	ldr	r3, [r3, #0]
 800d240:	b12b      	cbz	r3, 800d24e <_txe_thread_relinquish+0x12>
 800d242:	f3ef 8305 	mrs	r3, IPSR
    {

        /* Now make sure the call is not from an ISR or Initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() == ((ULONG) 0))
 800d246:	4a04      	ldr	r2, [pc, #16]	; (800d258 <_txe_thread_relinquish+0x1c>)
 800d248:	6812      	ldr	r2, [r2, #0]
 800d24a:	4313      	orrs	r3, r2
 800d24c:	d000      	beq.n	800d250 <_txe_thread_relinquish+0x14>
        
            /* Okay to call the real relinquish function.  */
            _tx_thread_relinquish();
        }
    }
}
 800d24e:	4770      	bx	lr
            _tx_thread_relinquish();
 800d250:	f000 bb5a 	b.w	800d908 <_tx_thread_relinquish>
 800d254:	20000f2c 	.word	0x20000f2c
 800d258:	20000164 	.word	0x20000164

0800d25c <_txe_thread_resume>:

UINT    status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800d25c:	b118      	cbz	r0, 800d266 <_txe_thread_resume+0xa>
        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
    }
    
    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800d25e:	6802      	ldr	r2, [r0, #0]
 800d260:	4b03      	ldr	r3, [pc, #12]	; (800d270 <_txe_thread_resume+0x14>)
 800d262:	429a      	cmp	r2, r3
 800d264:	d001      	beq.n	800d26a <_txe_thread_resume+0xe>
        status =  _tx_thread_resume(thread_ptr);
    }

    /* Return completion status.  */
    return(status);
}
 800d266:	200e      	movs	r0, #14
 800d268:	4770      	bx	lr
        status =  _tx_thread_resume(thread_ptr);
 800d26a:	f000 bb89 	b.w	800d980 <_tx_thread_resume>
 800d26e:	bf00      	nop
 800d270:	54485244 	.word	0x54485244

0800d274 <_txe_thread_terminate>:

UINT        status;


    /* Check for an invalid thread pointer.  */
    if (thread_ptr == TX_NULL)
 800d274:	b158      	cbz	r0, 800d28e <_txe_thread_terminate+0x1a>
        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
    }
    
    /* Now check for invalid thread ID.  */
    else if (thread_ptr -> tx_thread_id != TX_THREAD_ID)
 800d276:	6802      	ldr	r2, [r0, #0]
 800d278:	4b07      	ldr	r3, [pc, #28]	; (800d298 <_txe_thread_terminate+0x24>)
 800d27a:	429a      	cmp	r2, r3
 800d27c:	d107      	bne.n	800d28e <_txe_thread_terminate+0x1a>
 800d27e:	f3ef 8305 	mrs	r3, IPSR
        /* Thread pointer is invalid, return appropriate error code.  */
        status =  TX_THREAD_ERROR;
    }

    /* Check for invalid caller of this function.  */
    else if (TX_THREAD_GET_SYSTEM_STATE() != ((ULONG) 0))
 800d282:	4a06      	ldr	r2, [pc, #24]	; (800d29c <_txe_thread_terminate+0x28>)
 800d284:	6812      	ldr	r2, [r2, #0]
 800d286:	4313      	orrs	r3, r2
 800d288:	d103      	bne.n	800d292 <_txe_thread_terminate+0x1e>
    }
    else
    {

        /* Call actual thread terminate function.  */
        status =  _tx_thread_terminate(thread_ptr);
 800d28a:	f000 bbef 	b.w	800da6c <_tx_thread_terminate>
        status =  TX_THREAD_ERROR;
 800d28e:	200e      	movs	r0, #14
 800d290:	4770      	bx	lr
        status =  TX_CALLER_ERROR;
 800d292:	2013      	movs	r0, #19
    }

    /* Return completion status.  */
    return(status);
}
 800d294:	4770      	bx	lr
 800d296:	bf00      	nop
 800d298:	54485244 	.word	0x54485244
 800d29c:	20000164 	.word	0x20000164

0800d2a0 <_tx_initialize_high_level>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID _tx_initialize_high_level(VOID)
{
 800d2a0:	b538      	push	{r3, r4, r5, lr}

	/* Initialize the event log, if enabled.  */
	TX_EL_INITIALIZE

	/* Call the thread control initialization function.  */
	_tx_thread_initialize();
 800d2a2:	f7ff f9b7 	bl	800c614 <_tx_thread_initialize>
#ifndef TX_DISABLE_REDUNDANT_CLEARING
	/* Call the semaphore initialization function.  */
	_tx_semaphore_initialize();

	/* Call the queue initialization function.  */
	_tx_queue_initialize();
 800d2a6:	4d0e      	ldr	r5, [pc, #56]	; (800d2e0 <_tx_initialize_high_level+0x40>)
	_tx_timer_initialize();
 800d2a8:	f7ff fc1e 	bl	800cae8 <_tx_timer_initialize>
	_tx_semaphore_initialize();
 800d2ac:	2300      	movs	r3, #0
 800d2ae:	490d      	ldr	r1, [pc, #52]	; (800d2e4 <_tx_initialize_high_level+0x44>)
 800d2b0:	4a0d      	ldr	r2, [pc, #52]	; (800d2e8 <_tx_initialize_high_level+0x48>)
 800d2b2:	600b      	str	r3, [r1, #0]
 800d2b4:	6013      	str	r3, [r2, #0]
	_tx_queue_initialize();
 800d2b6:	4c0d      	ldr	r4, [pc, #52]	; (800d2ec <_tx_initialize_high_level+0x4c>)

	/* Call the event flag initialization function.  */
	_tx_event_flags_initialize();
 800d2b8:	480d      	ldr	r0, [pc, #52]	; (800d2f0 <_tx_initialize_high_level+0x50>)
 800d2ba:	490e      	ldr	r1, [pc, #56]	; (800d2f4 <_tx_initialize_high_level+0x54>)

	/* Call the block pool initialization function.  */
	_tx_block_pool_initialize();
 800d2bc:	4a0e      	ldr	r2, [pc, #56]	; (800d2f8 <_tx_initialize_high_level+0x58>)
	_tx_queue_initialize();
 800d2be:	602b      	str	r3, [r5, #0]
 800d2c0:	6023      	str	r3, [r4, #0]
	_tx_event_flags_initialize();
 800d2c2:	6003      	str	r3, [r0, #0]
 800d2c4:	600b      	str	r3, [r1, #0]
	_tx_block_pool_initialize();
 800d2c6:	6013      	str	r3, [r2, #0]
 800d2c8:	4d0c      	ldr	r5, [pc, #48]	; (800d2fc <_tx_initialize_high_level+0x5c>)

	/* Call the byte pool initialization function.  */
	_tx_byte_pool_initialize();
 800d2ca:	4c0d      	ldr	r4, [pc, #52]	; (800d300 <_tx_initialize_high_level+0x60>)
 800d2cc:	480d      	ldr	r0, [pc, #52]	; (800d304 <_tx_initialize_high_level+0x64>)

	/* Call the mutex initialization function.  */
	_tx_mutex_initialize();
 800d2ce:	490e      	ldr	r1, [pc, #56]	; (800d308 <_tx_initialize_high_level+0x68>)
 800d2d0:	4a0e      	ldr	r2, [pc, #56]	; (800d30c <_tx_initialize_high_level+0x6c>)
	_tx_block_pool_initialize();
 800d2d2:	602b      	str	r3, [r5, #0]
	_tx_byte_pool_initialize();
 800d2d4:	6023      	str	r3, [r4, #0]
 800d2d6:	6003      	str	r3, [r0, #0]
	_tx_mutex_initialize();
 800d2d8:	600b      	str	r3, [r1, #0]
 800d2da:	6013      	str	r3, [r2, #0]
#endif
}
 800d2dc:	bd38      	pop	{r3, r4, r5, pc}
 800d2de:	bf00      	nop
 800d2e0:	200014ec 	.word	0x200014ec
 800d2e4:	200014d0 	.word	0x200014d0
 800d2e8:	200014e0 	.word	0x200014e0
 800d2ec:	200014cc 	.word	0x200014cc
 800d2f0:	200014c0 	.word	0x200014c0
 800d2f4:	200014e4 	.word	0x200014e4
 800d2f8:	200014e8 	.word	0x200014e8
 800d2fc:	200014dc 	.word	0x200014dc
 800d300:	200014d4 	.word	0x200014d4
 800d304:	200014f0 	.word	0x200014f0
 800d308:	200014c8 	.word	0x200014c8
 800d30c:	200014c4 	.word	0x200014c4

0800d310 <_tx_mutex_cleanup>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_cleanup(TX_THREAD  *thread_ptr, ULONG suspension_sequence)
{
 800d310:	b538      	push	{r3, r4, r5, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d312:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d316:	b672      	cpsid	i

    /* Disable interrupts to remove the suspended thread from the mutex.  */
    TX_DISABLE

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_mutex_cleanup))
 800d318:	4a1a      	ldr	r2, [pc, #104]	; (800d384 <_tx_mutex_cleanup+0x74>)
 800d31a:	6e84      	ldr	r4, [r0, #104]	; 0x68
 800d31c:	4294      	cmp	r4, r2
 800d31e:	d002      	beq.n	800d326 <_tx_mutex_cleanup+0x16>
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d320:	f383 8810 	msr	PRIMASK, r3
    }
    
    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 800d324:	bd38      	pop	{r3, r4, r5, pc}
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 800d326:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
 800d32a:	428a      	cmp	r2, r1
 800d32c:	d1f8      	bne.n	800d320 <_tx_mutex_cleanup+0x10>
            mutex_ptr =  TX_VOID_TO_MUTEX_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 800d32e:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
            if (mutex_ptr != TX_NULL)
 800d330:	2a00      	cmp	r2, #0
 800d332:	d0f5      	beq.n	800d320 <_tx_mutex_cleanup+0x10>
                if (mutex_ptr -> tx_mutex_id == TX_MUTEX_ID)
 800d334:	4914      	ldr	r1, [pc, #80]	; (800d388 <_tx_mutex_cleanup+0x78>)
 800d336:	6814      	ldr	r4, [r2, #0]
 800d338:	428c      	cmp	r4, r1
 800d33a:	d1f1      	bne.n	800d320 <_tx_mutex_cleanup+0x10>
                    if (mutex_ptr -> tx_mutex_suspended_count != TX_NO_SUSPENSIONS)
 800d33c:	69d1      	ldr	r1, [r2, #28]
 800d33e:	2900      	cmp	r1, #0
 800d340:	d0ee      	beq.n	800d320 <_tx_mutex_cleanup+0x10>
                        mutex_ptr -> tx_mutex_suspended_count--;
 800d342:	3901      	subs	r1, #1
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800d344:	2400      	movs	r4, #0
 800d346:	6684      	str	r4, [r0, #104]	; 0x68
                        mutex_ptr -> tx_mutex_suspended_count--;
 800d348:	61d1      	str	r1, [r2, #28]
                        if (suspended_count == TX_NO_SUSPENSIONS)
 800d34a:	b1c1      	cbz	r1, 800d37e <_tx_mutex_cleanup+0x6e>
                            if (mutex_ptr -> tx_mutex_suspension_list == thread_ptr)
 800d34c:	6995      	ldr	r5, [r2, #24]
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800d34e:	e9d0 141c 	ldrd	r1, r4, [r0, #112]	; 0x70
                            if (mutex_ptr -> tx_mutex_suspension_list == thread_ptr)
 800d352:	4285      	cmp	r5, r0
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 800d354:	674c      	str	r4, [r1, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 800d356:	6721      	str	r1, [r4, #112]	; 0x70
                            if (mutex_ptr -> tx_mutex_suspension_list == thread_ptr)
 800d358:	d011      	beq.n	800d37e <_tx_mutex_cleanup+0x6e>
                        if (thread_ptr -> tx_thread_state == TX_MUTEX_SUSP)
 800d35a:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800d35c:	2a0d      	cmp	r2, #13
 800d35e:	d1df      	bne.n	800d320 <_tx_mutex_cleanup+0x10>
                            _tx_thread_preempt_disable++;
 800d360:	490a      	ldr	r1, [pc, #40]	; (800d38c <_tx_mutex_cleanup+0x7c>)
                            thread_ptr -> tx_thread_suspend_status =  TX_NOT_AVAILABLE;
 800d362:	241d      	movs	r4, #29
                            _tx_thread_preempt_disable++;
 800d364:	680a      	ldr	r2, [r1, #0]
                            thread_ptr -> tx_thread_suspend_status =  TX_NOT_AVAILABLE;
 800d366:	f8c0 4084 	str.w	r4, [r0, #132]	; 0x84
                            _tx_thread_preempt_disable++;
 800d36a:	3201      	adds	r2, #1
 800d36c:	600a      	str	r2, [r1, #0]
 800d36e:	f383 8810 	msr	PRIMASK, r3
                            _tx_thread_system_resume(thread_ptr);
 800d372:	f7ff fa31 	bl	800c7d8 <_tx_thread_system_resume>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d376:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d37a:	b672      	cpsid	i
 800d37c:	e7d0      	b.n	800d320 <_tx_mutex_cleanup+0x10>
                                mutex_ptr -> tx_mutex_suspension_list =         next_thread;
 800d37e:	6191      	str	r1, [r2, #24]
 800d380:	e7eb      	b.n	800d35a <_tx_mutex_cleanup+0x4a>
 800d382:	bf00      	nop
 800d384:	0800d311 	.word	0x0800d311
 800d388:	4d555445 	.word	0x4d555445
 800d38c:	20000f28 	.word	0x20000f28

0800d390 <_tx_mutex_thread_release>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _tx_mutex_thread_release(TX_THREAD  *thread_ptr)
{
 800d390:	b570      	push	{r4, r5, r6, lr}
 800d392:	4604      	mov	r4, r0
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d394:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d398:	b672      	cpsid	i

    /* Disable interrupts.  */
    TX_DISABLE
    
    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800d39a:	4d0d      	ldr	r5, [pc, #52]	; (800d3d0 <_tx_mutex_thread_release+0x40>)
        /* Determine if there is a mutex.  */
        if (mutex_ptr != TX_NULL)
        {
        
            /* Yes, set the ownership count to 1.  */
            mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 800d39c:	2601      	movs	r6, #1
 800d39e:	f8d0 00a4 	ldr.w	r0, [r0, #164]	; 0xa4
    _tx_thread_preempt_disable++;
 800d3a2:	682a      	ldr	r2, [r5, #0]
 800d3a4:	4432      	add	r2, r6
 800d3a6:	602a      	str	r2, [r5, #0]
        if (mutex_ptr != TX_NULL)
 800d3a8:	b158      	cbz	r0, 800d3c2 <_tx_mutex_thread_release+0x32>
            mutex_ptr -> tx_mutex_ownership_count =  ((UINT) 1);
 800d3aa:	6086      	str	r6, [r0, #8]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d3ac:	f383 8810 	msr	PRIMASK, r3
            do
            {
                status =  _tx_mutex_put(mutex_ptr);
            } while (status != TX_SUCCESS);
#else
            _tx_mutex_put(mutex_ptr);
 800d3b0:	f7ff f81c 	bl	800c3ec <_tx_mutex_put>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d3b4:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d3b8:	b672      	cpsid	i

            /* Disable interrupts.  */
            TX_DISABLE

            /* Move to the next mutex.  */
            mutex_ptr =  thread_ptr -> tx_thread_owned_mutex_list;
 800d3ba:	f8d4 00a4 	ldr.w	r0, [r4, #164]	; 0xa4
        }
    } while (mutex_ptr != TX_NULL);
 800d3be:	2800      	cmp	r0, #0
 800d3c0:	d1f2      	bne.n	800d3a8 <_tx_mutex_thread_release+0x18>
    
    /* Restore preemption.  */
    _tx_thread_preempt_disable--;
 800d3c2:	682a      	ldr	r2, [r5, #0]
 800d3c4:	3a01      	subs	r2, #1
 800d3c6:	602a      	str	r2, [r5, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d3c8:	f383 8810 	msr	PRIMASK, r3
    
    /* Restore interrupts.  */
    TX_RESTORE
}
 800d3cc:	bd70      	pop	{r4, r5, r6, pc}
 800d3ce:	bf00      	nop
 800d3d0:	20000f28 	.word	0x20000f28

0800d3d4 <_tx_mutex_prioritize>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_mutex_prioritize(TX_MUTEX *mutex_ptr)
{
 800d3d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d3d6:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d3da:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_MUTEX_PRIORITIZE_INSERT

    /* Pickup the suspended count.  */
    suspended_count =  mutex_ptr -> tx_mutex_suspended_count;
 800d3dc:	69c7      	ldr	r7, [r0, #28]

    /* Determine if there are fewer than 2 suspended threads.  */
    if (suspended_count < ((UINT) 2))
 800d3de:	2f01      	cmp	r7, #1
 800d3e0:	d92a      	bls.n	800d438 <_tx_mutex_prioritize+0x64>
 800d3e2:	6982      	ldr	r2, [r0, #24]
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if there how many threads are suspended on this mutex.  */
    else if (suspended_count == ((UINT) 2))
 800d3e4:	2f02      	cmp	r7, #2
 800d3e6:	6f11      	ldr	r1, [r2, #112]	; 0x70
 800d3e8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800d3ea:	6acd      	ldr	r5, [r1, #44]	; 0x2c
 800d3ec:	d021      	beq.n	800d432 <_tx_mutex_prioritize+0x5e>

        /* Setup search pointer.  */
        thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 800d3ee:	f8df c084 	ldr.w	ip, [pc, #132]	; 800d474 <_tx_mutex_prioritize+0xa0>
 800d3f2:	4616      	mov	r6, r2
 800d3f4:	f8dc e000 	ldr.w	lr, [ip]
 800d3f8:	f10e 0e01 	add.w	lr, lr, #1
 800d3fc:	f8cc e000 	str.w	lr, [ip]
 800d400:	e007      	b.n	800d412 <_tx_mutex_prioritize+0x3e>
 800d402:	69c7      	ldr	r7, [r0, #28]

                /* Default the highest priority thread to the thread at the front of the list.  */
                priority_thread_ptr =  head_ptr;

                /* Setup search pointer.  */
                thread_ptr =  priority_thread_ptr -> tx_thread_suspended_next;
 800d404:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800d406:	461a      	mov	r2, r3

                /* Reset the list changed flag.  */
                list_changed =  TX_FALSE;
            }

        } while (thread_ptr != head_ptr);
 800d408:	428b      	cmp	r3, r1
 800d40a:	461e      	mov	r6, r3
 800d40c:	d018      	beq.n	800d440 <_tx_mutex_prioritize+0x6c>
 800d40e:	6acd      	ldr	r5, [r1, #44]	; 0x2c
 800d410:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 800d412:	42ab      	cmp	r3, r5
 800d414:	bf88      	it	hi
 800d416:	460a      	movhi	r2, r1
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d418:	f384 8810 	msr	PRIMASK, r4
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d41c:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d420:	b672      	cpsid	i
            if (head_ptr != mutex_ptr -> tx_mutex_suspension_list)
 800d422:	6983      	ldr	r3, [r0, #24]
 800d424:	42b3      	cmp	r3, r6
 800d426:	d1ec      	bne.n	800d402 <_tx_mutex_prioritize+0x2e>
                if (suspended_count != mutex_ptr -> tx_mutex_suspended_count)
 800d428:	69c5      	ldr	r5, [r0, #28]
 800d42a:	42bd      	cmp	r5, r7
 800d42c:	d020      	beq.n	800d470 <_tx_mutex_prioritize+0x9c>
 800d42e:	462f      	mov	r7, r5
 800d430:	e7e8      	b.n	800d404 <_tx_mutex_prioritize+0x30>
        if ((next_thread -> tx_thread_priority) < (head_ptr -> tx_thread_priority))
 800d432:	429d      	cmp	r5, r3
            mutex_ptr -> tx_mutex_suspension_list =  next_thread;
 800d434:	bf38      	it	cc
 800d436:	6181      	strcc	r1, [r0, #24]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d438:	f384 8810 	msr	PRIMASK, r4
#else

    /* Return successful completion.  */
    return(TX_SUCCESS);
#endif
}
 800d43c:	2000      	movs	r0, #0
 800d43e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        _tx_thread_preempt_disable--;
 800d440:	f8dc 1000 	ldr.w	r1, [ip]
        if (priority_thread_ptr != head_ptr)
 800d444:	4293      	cmp	r3, r2
        _tx_thread_preempt_disable--;
 800d446:	f101 31ff 	add.w	r1, r1, #4294967295
 800d44a:	f8cc 1000 	str.w	r1, [ip]
        if (priority_thread_ptr != head_ptr)
 800d44e:	d009      	beq.n	800d464 <_tx_mutex_prioritize+0x90>
            previous_thread =                              priority_thread_ptr -> tx_thread_suspended_previous;
 800d450:	e9d2 651c 	ldrd	r6, r5, [r2, #112]	; 0x70
            next_thread -> tx_thread_suspended_previous =  previous_thread;
 800d454:	6775      	str	r5, [r6, #116]	; 0x74
            previous_thread =                                      head_ptr -> tx_thread_suspended_previous;
 800d456:	6f59      	ldr	r1, [r3, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =  next_thread;
 800d458:	672e      	str	r6, [r5, #112]	; 0x70
            priority_thread_ptr -> tx_thread_suspended_next =      head_ptr;
 800d45a:	e9c2 311c 	strd	r3, r1, [r2, #112]	; 0x70
            previous_thread -> tx_thread_suspended_next =          priority_thread_ptr;
 800d45e:	670a      	str	r2, [r1, #112]	; 0x70
            head_ptr -> tx_thread_suspended_previous =             priority_thread_ptr;
 800d460:	675a      	str	r2, [r3, #116]	; 0x74
            mutex_ptr -> tx_mutex_suspension_list =  priority_thread_ptr;
 800d462:	6182      	str	r2, [r0, #24]
 800d464:	f384 8810 	msr	PRIMASK, r4
        _tx_thread_system_preempt_check();
 800d468:	f7ff f998 	bl	800c79c <_tx_thread_system_preempt_check>
}
 800d46c:	2000      	movs	r0, #0
 800d46e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                thread_ptr =  thread_ptr -> tx_thread_suspended_next;
 800d470:	6f09      	ldr	r1, [r1, #112]	; 0x70
 800d472:	e7c9      	b.n	800d408 <_tx_mutex_prioritize+0x34>
 800d474:	20000f28 	.word	0x20000f28

0800d478 <_tx_semaphore_create>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_create(TX_SEMAPHORE *semaphore_ptr, CHAR *name_ptr, ULONG initial_count)
{
 800d478:	b538      	push	{r3, r4, r5, lr}
 800d47a:	460d      	mov	r5, r1
 800d47c:	4614      	mov	r4, r2
TX_SEMAPHORE    *next_semaphore;
TX_SEMAPHORE    *previous_semaphore;


    /* Initialize semaphore control block to all zeros.  */
    TX_MEMSET(semaphore_ptr, 0, (sizeof(TX_SEMAPHORE)));
 800d47e:	2100      	movs	r1, #0
 800d480:	2220      	movs	r2, #32
 800d482:	f000 fc2c 	bl	800dcde <memset>
 800d486:	4603      	mov	r3, r0

    /* Setup the basic semaphore fields.  */
    semaphore_ptr -> tx_semaphore_name =             name_ptr;
    semaphore_ptr -> tx_semaphore_count =            initial_count;
 800d488:	e9c0 5401 	strd	r5, r4, [r0, #4]
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d48c:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d490:	b672      	cpsid	i
    /* Setup the semaphore ID to make it valid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_SEMAPHORE_ID;

    /* Place the semaphore on the list of created semaphores.  First,
       check for an empty list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
 800d492:	490b      	ldr	r1, [pc, #44]	; (800d4c0 <_tx_semaphore_create+0x48>)
    semaphore_ptr -> tx_semaphore_id =  TX_SEMAPHORE_ID;
 800d494:	480b      	ldr	r0, [pc, #44]	; (800d4c4 <_tx_semaphore_create+0x4c>)
    if (_tx_semaphore_created_count == TX_EMPTY)
 800d496:	680a      	ldr	r2, [r1, #0]
    semaphore_ptr -> tx_semaphore_id =  TX_SEMAPHORE_ID;
 800d498:	6018      	str	r0, [r3, #0]
    {

        /* The created semaphore list is empty.  Add semaphore to empty list.  */
        _tx_semaphore_created_ptr =                       semaphore_ptr;
 800d49a:	480b      	ldr	r0, [pc, #44]	; (800d4c8 <_tx_semaphore_create+0x50>)
    if (_tx_semaphore_created_count == TX_EMPTY)
 800d49c:	b15a      	cbz	r2, 800d4b6 <_tx_semaphore_create+0x3e>
    }
    else
    {

        /* This list is not NULL, add to the end of the list.  */
        next_semaphore =      _tx_semaphore_created_ptr;
 800d49e:	6800      	ldr	r0, [r0, #0]
        previous_semaphore =  next_semaphore -> tx_semaphore_created_previous;
 800d4a0:	6985      	ldr	r5, [r0, #24]

        /* Place the new semaphore in the list.  */
        next_semaphore -> tx_semaphore_created_previous =  semaphore_ptr;
 800d4a2:	6183      	str	r3, [r0, #24]
        previous_semaphore -> tx_semaphore_created_next =  semaphore_ptr;
 800d4a4:	616b      	str	r3, [r5, #20]

        /* Setup this semaphore's next and previous created links.  */
        semaphore_ptr -> tx_semaphore_created_previous =  previous_semaphore;
        semaphore_ptr -> tx_semaphore_created_next =      next_semaphore;
 800d4a6:	e9c3 0505 	strd	r0, r5, [r3, #20]
    }
    
    /* Increment the created count.  */
    _tx_semaphore_created_count++;
 800d4aa:	3201      	adds	r2, #1
 800d4ac:	600a      	str	r2, [r1, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d4ae:	f384 8810 	msr	PRIMASK, r4
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
}
 800d4b2:	2000      	movs	r0, #0
 800d4b4:	bd38      	pop	{r3, r4, r5, pc}
        semaphore_ptr -> tx_semaphore_created_previous =  semaphore_ptr;
 800d4b6:	e9c3 3305 	strd	r3, r3, [r3, #20]
        _tx_semaphore_created_ptr =                       semaphore_ptr;
 800d4ba:	6003      	str	r3, [r0, #0]
 800d4bc:	e7f5      	b.n	800d4aa <_tx_semaphore_create+0x32>
 800d4be:	bf00      	nop
 800d4c0:	200014e0 	.word	0x200014e0
 800d4c4:	53454d41 	.word	0x53454d41
 800d4c8:	200014d0 	.word	0x200014d0

0800d4cc <_tx_semaphore_delete>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_delete(TX_SEMAPHORE *semaphore_ptr)
{
 800d4cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d4d0:	4603      	mov	r3, r0
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d4d2:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d4d6:	b672      	cpsid	i

    /* Clear the semaphore ID to make it invalid.  */
    semaphore_ptr -> tx_semaphore_id =  TX_CLEAR_ID;

    /* Decrement the number of semaphores.  */
    _tx_semaphore_created_count--;
 800d4d8:	4920      	ldr	r1, [pc, #128]	; (800d55c <_tx_semaphore_delete+0x90>)
    semaphore_ptr -> tx_semaphore_id =  TX_CLEAR_ID;
 800d4da:	2000      	movs	r0, #0
    _tx_semaphore_created_count--;
 800d4dc:	680a      	ldr	r2, [r1, #0]
    semaphore_ptr -> tx_semaphore_id =  TX_CLEAR_ID;
 800d4de:	6018      	str	r0, [r3, #0]
    _tx_semaphore_created_count--;
 800d4e0:	3a01      	subs	r2, #1
 800d4e2:	600a      	str	r2, [r1, #0]

    /* See if the semaphore is the only one on the list.  */
    if (_tx_semaphore_created_count == TX_EMPTY)
 800d4e4:	2a00      	cmp	r2, #0
 800d4e6:	d12e      	bne.n	800d546 <_tx_semaphore_delete+0x7a>
    {

        /* Only created semaphore, just set the created list to NULL.  */
        _tx_semaphore_created_ptr =  TX_NULL;
 800d4e8:	491d      	ldr	r1, [pc, #116]	; (800d560 <_tx_semaphore_delete+0x94>)
 800d4ea:	600a      	str	r2, [r1, #0]
            _tx_semaphore_created_ptr =  next_semaphore;
        }
    }

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800d4ec:	4d1d      	ldr	r5, [pc, #116]	; (800d564 <_tx_semaphore_delete+0x98>)

    /* Pickup the suspension information.  */
    thread_ptr =                                     semaphore_ptr -> tx_semaphore_suspension_list;
    semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 800d4ee:	2700      	movs	r7, #0
    thread_ptr =                                     semaphore_ptr -> tx_semaphore_suspension_list;
 800d4f0:	68d8      	ldr	r0, [r3, #12]
    _tx_thread_preempt_disable++;
 800d4f2:	682a      	ldr	r2, [r5, #0]
    suspended_count =                                semaphore_ptr -> tx_semaphore_suspended_count;
 800d4f4:	691c      	ldr	r4, [r3, #16]
    _tx_thread_preempt_disable++;
 800d4f6:	3201      	adds	r2, #1
    semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 800d4f8:	60df      	str	r7, [r3, #12]
    semaphore_ptr -> tx_semaphore_suspended_count =  TX_NO_SUSPENSIONS;
 800d4fa:	611f      	str	r7, [r3, #16]
    _tx_thread_preempt_disable++;
 800d4fc:	602a      	str	r2, [r5, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d4fe:	f386 8810 	msr	PRIMASK, r6
    /* Restore interrupts.  */
    TX_RESTORE

    /* Walk through the semaphore list to resume any and all threads suspended
       on this semaphore.  */
    while (suspended_count != TX_NO_SUSPENSIONS)
 800d502:	b19c      	cbz	r4, 800d52c <_tx_semaphore_delete+0x60>
        /* Clear the cleanup pointer, this prevents the timeout from doing 
           anything.  */
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;

        /* Set the return status in the thread to TX_DELETED.  */
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 800d504:	f04f 0801 	mov.w	r8, #1
        suspended_count--;
 800d508:	3c01      	subs	r4, #1
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d50a:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d50e:	b672      	cpsid	i
        /* Restore interrupts.  */
        TX_RESTORE
#else

        /* Temporarily disable preemption again.  */
        _tx_thread_preempt_disable++;
 800d510:	682b      	ldr	r3, [r5, #0]
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800d512:	6687      	str	r7, [r0, #104]	; 0x68
        _tx_thread_preempt_disable++;
 800d514:	3301      	adds	r3, #1
        thread_ptr -> tx_thread_suspend_status =  TX_DELETED;
 800d516:	f8c0 8084 	str.w	r8, [r0, #132]	; 0x84
        next_thread =  thread_ptr -> tx_thread_suspended_next;
 800d51a:	6f06      	ldr	r6, [r0, #112]	; 0x70
        _tx_thread_preempt_disable++;
 800d51c:	602b      	str	r3, [r5, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d51e:	f382 8810 	msr	PRIMASK, r2

        /* Restore interrupts.  */
        TX_RESTORE
    
        /* Resume the thread.  */
        _tx_thread_system_resume(thread_ptr);
 800d522:	f7ff f959 	bl	800c7d8 <_tx_thread_system_resume>
#endif

        /* Move to next thread.  */
        thread_ptr =  next_thread;
 800d526:	4630      	mov	r0, r6
    while (suspended_count != TX_NO_SUSPENSIONS)
 800d528:	2c00      	cmp	r4, #0
 800d52a:	d1ed      	bne.n	800d508 <_tx_semaphore_delete+0x3c>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d52c:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d530:	b672      	cpsid	i

    /* Disable interrupts.  */
    TX_DISABLE

    /* Release previous preempt disable.  */
    _tx_thread_preempt_disable--;
 800d532:	682b      	ldr	r3, [r5, #0]
 800d534:	3b01      	subs	r3, #1
 800d536:	602b      	str	r3, [r5, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d538:	f382 8810 	msr	PRIMASK, r2

    /* Restore interrupts.  */
    TX_RESTORE

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800d53c:	f7ff f92e 	bl	800c79c <_tx_thread_system_preempt_check>

    /* Return TX_SUCCESS.  */
    return(TX_SUCCESS);
}
 800d540:	2000      	movs	r0, #0
 800d542:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (_tx_semaphore_created_ptr == semaphore_ptr)
 800d546:	4806      	ldr	r0, [pc, #24]	; (800d560 <_tx_semaphore_delete+0x94>)
 800d548:	6804      	ldr	r4, [r0, #0]
        previous_semaphore =                               semaphore_ptr -> tx_semaphore_created_previous;
 800d54a:	e9d3 2105 	ldrd	r2, r1, [r3, #20]
        if (_tx_semaphore_created_ptr == semaphore_ptr)
 800d54e:	429c      	cmp	r4, r3
        next_semaphore -> tx_semaphore_created_previous =  previous_semaphore;
 800d550:	6191      	str	r1, [r2, #24]
            _tx_semaphore_created_ptr =  next_semaphore;
 800d552:	bf08      	it	eq
 800d554:	6002      	streq	r2, [r0, #0]
        previous_semaphore -> tx_semaphore_created_next =  next_semaphore;
 800d556:	614a      	str	r2, [r1, #20]
 800d558:	e7c8      	b.n	800d4ec <_tx_semaphore_delete+0x20>
 800d55a:	bf00      	nop
 800d55c:	200014e0 	.word	0x200014e0
 800d560:	200014d0 	.word	0x200014d0
 800d564:	20000f28 	.word	0x20000f28

0800d568 <_tx_semaphore_get>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_get(TX_SEMAPHORE *semaphore_ptr, ULONG wait_option)
{
 800d568:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d56a:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d56e:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_GET_INSERT

    /* Determine if there is an instance of the semaphore.  */
    if (semaphore_ptr -> tx_semaphore_count != ((ULONG) 0))
 800d570:	6883      	ldr	r3, [r0, #8]
 800d572:	bb5b      	cbnz	r3, 800d5cc <_tx_semaphore_get+0x64>
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Determine if the request specifies suspension.  */
    else if (wait_option != TX_NO_WAIT)
 800d574:	b331      	cbz	r1, 800d5c4 <_tx_semaphore_get+0x5c>
    {

        /* Determine if the preempt disable flag is non-zero.  */
        if (_tx_thread_preempt_disable != ((UINT) 0))
 800d576:	4d1a      	ldr	r5, [pc, #104]	; (800d5e0 <_tx_semaphore_get+0x78>)
 800d578:	682b      	ldr	r3, [r5, #0]
 800d57a:	bb1b      	cbnz	r3, 800d5c4 <_tx_semaphore_get+0x5c>
            /* Increment the number of suspensions on this semaphore.  */
            semaphore_ptr -> tx_semaphore_performance_suspension_count++;
#endif
            
            /* Pickup thread pointer.  */
            TX_THREAD_GET_CURRENT(thread_ptr)
 800d57c:	4b19      	ldr	r3, [pc, #100]	; (800d5e4 <_tx_semaphore_get+0x7c>)

            /* Setup cleanup routine pointer.  */
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_semaphore_cleanup);
 800d57e:	4f1a      	ldr	r7, [pc, #104]	; (800d5e8 <_tx_semaphore_get+0x80>)
            TX_THREAD_GET_CURRENT(thread_ptr)
 800d580:	681c      	ldr	r4, [r3, #0]
               this suspension event.  */
            thread_ptr -> tx_thread_suspension_sequence++;
#endif

            /* Setup suspension list.  */
            if (semaphore_ptr -> tx_semaphore_suspended_count == TX_NO_SUSPENSIONS)
 800d582:	6903      	ldr	r3, [r0, #16]
            thread_ptr -> tx_thread_suspension_sequence++;
 800d584:	f8d4 60c0 	ldr.w	r6, [r4, #192]	; 0xc0
            thread_ptr -> tx_thread_suspend_control_block =  (VOID *) semaphore_ptr;
 800d588:	66e0      	str	r0, [r4, #108]	; 0x6c
            thread_ptr -> tx_thread_suspension_sequence++;
 800d58a:	3601      	adds	r6, #1
            thread_ptr -> tx_thread_suspend_cleanup =  &(_tx_semaphore_cleanup);
 800d58c:	66a7      	str	r7, [r4, #104]	; 0x68
            thread_ptr -> tx_thread_suspension_sequence++;
 800d58e:	f8c4 60c0 	str.w	r6, [r4, #192]	; 0xc0
            if (semaphore_ptr -> tx_semaphore_suspended_count == TX_NO_SUSPENSIONS)
 800d592:	b30b      	cbz	r3, 800d5d8 <_tx_semaphore_get+0x70>
            }
            else
            {

                /* This list is not NULL, add current thread to the end. */
                next_thread =                                   semaphore_ptr -> tx_semaphore_suspension_list;
 800d594:	68c6      	ldr	r6, [r0, #12]
                thread_ptr -> tx_thread_suspended_next =        next_thread;
                previous_thread =                               next_thread -> tx_thread_suspended_previous;
 800d596:	6f77      	ldr	r7, [r6, #116]	; 0x74
                thread_ptr -> tx_thread_suspended_previous =    previous_thread;
 800d598:	e9c4 671c 	strd	r6, r7, [r4, #112]	; 0x70
                previous_thread -> tx_thread_suspended_next =   thread_ptr;
 800d59c:	673c      	str	r4, [r7, #112]	; 0x70
                next_thread -> tx_thread_suspended_previous =   thread_ptr;
 800d59e:	6774      	str	r4, [r6, #116]	; 0x74

            /* Setup the timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;

            /* Temporarily disable preemption.  */
            _tx_thread_preempt_disable++;
 800d5a0:	682e      	ldr	r6, [r5, #0]
            semaphore_ptr -> tx_semaphore_suspended_count++;
 800d5a2:	3301      	adds	r3, #1
            thread_ptr -> tx_thread_state =    TX_SEMAPHORE_SUSP;
 800d5a4:	2706      	movs	r7, #6
            semaphore_ptr -> tx_semaphore_suspended_count++;
 800d5a6:	6103      	str	r3, [r0, #16]
            _tx_thread_preempt_disable++;
 800d5a8:	3601      	adds	r6, #1
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800d5aa:	2301      	movs	r3, #1
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  wait_option;
 800d5ac:	64e1      	str	r1, [r4, #76]	; 0x4c
            _tx_thread_preempt_disable++;
 800d5ae:	602e      	str	r6, [r5, #0]
            thread_ptr -> tx_thread_state =    TX_SEMAPHORE_SUSP;
 800d5b0:	6327      	str	r7, [r4, #48]	; 0x30
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800d5b2:	63a3      	str	r3, [r4, #56]	; 0x38
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d5b4:	f382 8810 	msr	PRIMASK, r2

            /* Restore interrupts.  */
            TX_RESTORE

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800d5b8:	4620      	mov	r0, r4
 800d5ba:	f7ff f993 	bl	800c8e4 <_tx_thread_system_suspend>
#endif

            /* Return the completion status.  */
            status =  thread_ptr -> tx_thread_suspend_status;
 800d5be:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
        status =  TX_NO_INSTANCE;
    }

    /* Return completion status.  */
    return(status);
}
 800d5c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800d5c4:	f382 8810 	msr	PRIMASK, r2
        status =  TX_NO_INSTANCE;
 800d5c8:	200d      	movs	r0, #13
}
 800d5ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        semaphore_ptr -> tx_semaphore_count--;
 800d5cc:	3b01      	subs	r3, #1
 800d5ce:	6083      	str	r3, [r0, #8]
 800d5d0:	f382 8810 	msr	PRIMASK, r2
    status =  TX_SUCCESS;
 800d5d4:	2000      	movs	r0, #0
}
 800d5d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                semaphore_ptr -> tx_semaphore_suspension_list =         thread_ptr;
 800d5d8:	60c4      	str	r4, [r0, #12]
                thread_ptr -> tx_thread_suspended_previous =            thread_ptr;
 800d5da:	e9c4 441c 	strd	r4, r4, [r4, #112]	; 0x70
 800d5de:	e7df      	b.n	800d5a0 <_tx_semaphore_get+0x38>
 800d5e0:	20000f28 	.word	0x20000f28
 800d5e4:	20000f2c 	.word	0x20000f2c
 800d5e8:	0800dc01 	.word	0x0800dc01

0800d5ec <_tx_semaphore_put>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_semaphore_put(TX_SEMAPHORE *semaphore_ptr)
{
 800d5ec:	b570      	push	{r4, r5, r6, lr}
 800d5ee:	4604      	mov	r4, r0
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d5f0:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d5f4:	b672      	cpsid	i

    /* Log this kernel call.  */
    TX_EL_SEMAPHORE_PUT_INSERT

    /* Pickup the number of suspended threads.  */
    suspended_count =  semaphore_ptr -> tx_semaphore_suspended_count;
 800d5f6:	6903      	ldr	r3, [r0, #16]

    /* Determine if there are any threads suspended on the semaphore.  */
    if (suspended_count == TX_NO_SUSPENSIONS)
 800d5f8:	b94b      	cbnz	r3, 800d60e <_tx_semaphore_put+0x22>
    {

        /* Increment the semaphore count.  */
        semaphore_ptr -> tx_semaphore_count++;
 800d5fa:	6883      	ldr	r3, [r0, #8]

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the application notify function.  */
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
 800d5fc:	69c1      	ldr	r1, [r0, #28]
        semaphore_ptr -> tx_semaphore_count++;
 800d5fe:	3301      	adds	r3, #1
 800d600:	6083      	str	r3, [r0, #8]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d602:	f382 8810 	msr	PRIMASK, r2
        TX_RESTORE

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Determine if notification is required.  */
        if (semaphore_put_notify != TX_NULL)
 800d606:	b101      	cbz	r1, 800d60a <_tx_semaphore_put+0x1e>
        {

            /* Yes, call the appropriate notify callback function.  */
            (semaphore_put_notify)(semaphore_ptr);
 800d608:	4788      	blx	r1
#endif
    }

    /* Return successful completion.  */
    return(TX_SUCCESS);
}
 800d60a:	2000      	movs	r0, #0
 800d60c:	bd70      	pop	{r4, r5, r6, pc}
        if (suspended_count == TX_NO_SUSPENSIONS)
 800d60e:	3b01      	subs	r3, #1
        thread_ptr =  semaphore_ptr -> tx_semaphore_suspension_list;
 800d610:	68c0      	ldr	r0, [r0, #12]
        if (suspended_count == TX_NO_SUSPENSIONS)
 800d612:	d018      	beq.n	800d646 <_tx_semaphore_put+0x5a>
            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800d614:	e9d0 151c 	ldrd	r1, r5, [r0, #112]	; 0x70
            semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
 800d618:	60e1      	str	r1, [r4, #12]
            next_thread -> tx_thread_suspended_previous =   previous_thread;
 800d61a:	674d      	str	r5, [r1, #116]	; 0x74
            previous_thread -> tx_thread_suspended_next =   next_thread;
 800d61c:	6729      	str	r1, [r5, #112]	; 0x70
        _tx_thread_preempt_disable++;
 800d61e:	490b      	ldr	r1, [pc, #44]	; (800d64c <_tx_semaphore_put+0x60>)
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800d620:	2500      	movs	r5, #0
        semaphore_ptr -> tx_semaphore_suspended_count =  suspended_count;
 800d622:	6123      	str	r3, [r4, #16]
        _tx_thread_preempt_disable++;
 800d624:	680b      	ldr	r3, [r1, #0]
        semaphore_put_notify =  semaphore_ptr -> tx_semaphore_put_notify;
 800d626:	69e6      	ldr	r6, [r4, #28]
        _tx_thread_preempt_disable++;
 800d628:	3301      	adds	r3, #1
        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800d62a:	6685      	str	r5, [r0, #104]	; 0x68
        thread_ptr -> tx_thread_suspend_status =  TX_SUCCESS;
 800d62c:	f8c0 5084 	str.w	r5, [r0, #132]	; 0x84
        _tx_thread_preempt_disable++;
 800d630:	600b      	str	r3, [r1, #0]
 800d632:	f382 8810 	msr	PRIMASK, r2
        _tx_thread_system_resume(thread_ptr);
 800d636:	f7ff f8cf 	bl	800c7d8 <_tx_thread_system_resume>
        if (semaphore_put_notify != TX_NULL)
 800d63a:	2e00      	cmp	r6, #0
 800d63c:	d0e5      	beq.n	800d60a <_tx_semaphore_put+0x1e>
            (semaphore_put_notify)(semaphore_ptr);
 800d63e:	4620      	mov	r0, r4
 800d640:	47b0      	blx	r6
}
 800d642:	2000      	movs	r0, #0
 800d644:	bd70      	pop	{r4, r5, r6, pc}
            semaphore_ptr -> tx_semaphore_suspension_list =  TX_NULL;
 800d646:	60e3      	str	r3, [r4, #12]
 800d648:	e7e9      	b.n	800d61e <_tx_semaphore_put+0x32>
 800d64a:	bf00      	nop
 800d64c:	20000f28 	.word	0x20000f28

0800d650 <_tx_thread_create>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_create(TX_THREAD *thread_ptr, CHAR *name_ptr, VOID (*entry_function)(ULONG id), ULONG entry_input,
                            VOID *stack_start, ULONG stack_size, UINT priority, UINT preempt_threshold,
                            ULONG time_slice, UINT auto_start)
{
 800d650:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d654:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 800d656:	4604      	mov	r4, r0
 800d658:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 800d65a:	468b      	mov	fp, r1
 800d65c:	4692      	mov	sl, r2
#ifndef TX_DISABLE_STACK_FILLING

    /* Set the thread stack to a pattern prior to creating the initial
       stack frame.  This pattern is used by the stack checking routines
       to see how much has been used.  */
    TX_MEMSET(stack_start, ((UCHAR) TX_STACK_FILL), stack_size);
 800d65e:	4630      	mov	r0, r6
 800d660:	462a      	mov	r2, r5
 800d662:	21ef      	movs	r1, #239	; 0xef
{
 800d664:	4698      	mov	r8, r3
 800d666:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    TX_MEMSET(stack_start, ((UCHAR) TX_STACK_FILL), stack_size);
 800d66a:	f000 fb38 	bl	800dcde <memset>

    /* Prepare the thread control block prior to placing it on the created
       list.  */

    /* Initialize thread control block to all zeros.  */
    TX_MEMSET(thread_ptr, 0, (sizeof(TX_THREAD)));
 800d66e:	4620      	mov	r0, r4
 800d670:	22c8      	movs	r2, #200	; 0xc8
 800d672:	2100      	movs	r1, #0
 800d674:	f000 fb33 	bl	800dcde <memset>
    thread_ptr -> tx_thread_entry_parameter =   entry_input;
    thread_ptr -> tx_thread_stack_start =       stack_start;
    thread_ptr -> tx_thread_stack_size =        stack_size;
    thread_ptr -> tx_thread_priority =          priority;
    thread_ptr -> tx_thread_user_priority =     priority;
    thread_ptr -> tx_thread_time_slice =        time_slice;
 800d678:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    thread_ptr -> tx_thread_new_time_slice =    time_slice;
    thread_ptr -> tx_thread_inherit_priority =  ((UINT) TX_MAX_PRIORITIES);

    /* Calculate the end of the thread's stack area.  */
    temp_ptr =  TX_VOID_TO_UCHAR_POINTER_CONVERT(stack_start);
    temp_ptr =  (TX_UCHAR_POINTER_ADD(temp_ptr, (stack_size - ((ULONG) 1))));
 800d67a:	1e6a      	subs	r2, r5, #1
    thread_ptr -> tx_thread_inherit_priority =  ((UINT) TX_MAX_PRIORITIES);
 800d67c:	f04f 0c20 	mov.w	ip, #32
        thread_ptr -> tx_thread_user_preempt_threshold =  priority;
    }
#endif

    /* Now fill in the values that are required for thread initialization.  */
    thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 800d680:	2103      	movs	r1, #3

    /* Setup the necessary fields in the thread timer block.  */
    TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
 800d682:	4f36      	ldr	r7, [pc, #216]	; (800d75c <_tx_thread_create+0x10c>)
    temp_ptr =  (TX_UCHAR_POINTER_ADD(temp_ptr, (stack_size - ((ULONG) 1))));
 800d684:	4432      	add	r2, r6
    thread_ptr -> tx_thread_name =              name_ptr;
 800d686:	f8c4 b028 	str.w	fp, [r4, #40]	; 0x28
    thread_ptr -> tx_thread_state =  TX_SUSPENDED;
 800d68a:	6321      	str	r1, [r4, #48]	; 0x30
    TX_THREAD_CREATE_INTERNAL_EXTENSION(thread_ptr)

    /* Call the target specific stack frame building routine to build the 
       thread's initial stack and to setup the actual stack pointer in the
       control block.  */
    _tx_thread_stack_build(thread_ptr, _tx_thread_shell_entry);
 800d68c:	4620      	mov	r0, r4
    thread_ptr -> tx_thread_stack_start =       stack_start;
 800d68e:	60e6      	str	r6, [r4, #12]
    thread_ptr -> tx_thread_priority =          priority;
 800d690:	f8c4 902c 	str.w	r9, [r4, #44]	; 0x2c
    thread_ptr -> tx_thread_user_priority =     priority;
 800d694:	f8c4 9094 	str.w	r9, [r4, #148]	; 0x94
    TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
 800d698:	65a4      	str	r4, [r4, #88]	; 0x58
    thread_ptr -> tx_thread_inherit_priority =  ((UINT) TX_MAX_PRIORITIES);
 800d69a:	f8c4 c09c 	str.w	ip, [r4, #156]	; 0x9c
    TX_THREAD_CREATE_TIMEOUT_SETUP(thread_ptr)
 800d69e:	6567      	str	r7, [r4, #84]	; 0x54
    _tx_thread_stack_build(thread_ptr, _tx_thread_shell_entry);
 800d6a0:	492f      	ldr	r1, [pc, #188]	; (800d760 <_tx_thread_create+0x110>)
    thread_ptr -> tx_thread_new_time_slice =    time_slice;
 800d6a2:	e9c4 3306 	strd	r3, r3, [r4, #24]
    thread_ptr -> tx_thread_preempt_threshold =       preempt_threshold;
 800d6a6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    thread_ptr -> tx_thread_entry_parameter =   entry_input;
 800d6a8:	e9c4 a811 	strd	sl, r8, [r4, #68]	; 0x44
    thread_ptr -> tx_thread_stack_end =         TX_UCHAR_TO_VOID_POINTER_CONVERT(temp_ptr);
 800d6ac:	e9c4 2504 	strd	r2, r5, [r4, #16]
    thread_ptr -> tx_thread_preempt_threshold =       preempt_threshold;
 800d6b0:	63e3      	str	r3, [r4, #60]	; 0x3c
    thread_ptr -> tx_thread_user_preempt_threshold =  preempt_threshold;
 800d6b2:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
    _tx_thread_stack_build(thread_ptr, _tx_thread_shell_entry);
 800d6b6:	f7f2 fed3 	bl	8000460 <_tx_thread_stack_build>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d6ba:	f3ef 8510 	mrs	r5, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d6be:	b672      	cpsid	i
    /* Load the thread ID field in the thread control block.  */
    thread_ptr -> tx_thread_id =  TX_THREAD_ID;

    /* Place the thread on the list of created threads.  First,
       check for an empty list.  */
    if (_tx_thread_created_count == TX_EMPTY)
 800d6c0:	4828      	ldr	r0, [pc, #160]	; (800d764 <_tx_thread_create+0x114>)
    thread_ptr -> tx_thread_id =  TX_THREAD_ID;
 800d6c2:	4a29      	ldr	r2, [pc, #164]	; (800d768 <_tx_thread_create+0x118>)
    if (_tx_thread_created_count == TX_EMPTY)
 800d6c4:	6803      	ldr	r3, [r0, #0]
    thread_ptr -> tx_thread_id =  TX_THREAD_ID;
 800d6c6:	6022      	str	r2, [r4, #0]
    {

        /* The created thread list is empty.  Add thread to empty list.  */
        _tx_thread_created_ptr =                    thread_ptr;
 800d6c8:	4a28      	ldr	r2, [pc, #160]	; (800d76c <_tx_thread_create+0x11c>)
    if (_tx_thread_created_count == TX_EMPTY)
 800d6ca:	b9db      	cbnz	r3, 800d704 <_tx_thread_create+0xb4>
        _tx_thread_created_ptr =                    thread_ptr;
 800d6cc:	6014      	str	r4, [r2, #0]
        thread_ptr -> tx_thread_created_next =      thread_ptr;
        thread_ptr -> tx_thread_created_previous =  thread_ptr;
 800d6ce:	e9c4 4422 	strd	r4, r4, [r4, #136]	; 0x88
    TX_EL_THREAD_CREATE_INSERT

#ifndef TX_NOT_INTERRUPTABLE

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800d6d2:	4927      	ldr	r1, [pc, #156]	; (800d770 <_tx_thread_create+0x120>)
    _tx_thread_created_count++;
 800d6d4:	3301      	adds	r3, #1
    _tx_thread_preempt_disable++;
 800d6d6:	680a      	ldr	r2, [r1, #0]
    _tx_thread_created_count++;
 800d6d8:	6003      	str	r3, [r0, #0]
#endif

    /* Determine if an automatic start was requested.  If so, call the resume
       thread function and then check for a preemption condition.  */
    if (auto_start == TX_AUTO_START)
 800d6da:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    _tx_thread_preempt_disable++;
 800d6dc:	3201      	adds	r2, #1
    if (auto_start == TX_AUTO_START)
 800d6de:	2b01      	cmp	r3, #1
    _tx_thread_preempt_disable++;
 800d6e0:	600a      	str	r2, [r1, #0]
    if (auto_start == TX_AUTO_START)
 800d6e2:	d12a      	bne.n	800d73a <_tx_thread_create+0xea>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d6e4:	f3ef 8205 	mrs	r2, IPSR
    {

        /* Determine if the create call is being called from initialization.  */
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
 800d6e8:	4b22      	ldr	r3, [pc, #136]	; (800d774 <_tx_thread_create+0x124>)
 800d6ea:	681b      	ldr	r3, [r3, #0]
 800d6ec:	4313      	orrs	r3, r2
 800d6ee:	f1b3 3ff0 	cmp.w	r3, #4042322160	; 0xf0f0f0f0
 800d6f2:	d211      	bcs.n	800d718 <_tx_thread_create+0xc8>
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d6f4:	f385 8810 	msr	PRIMASK, r5

        /* Perform any additional activities for tool or user purpose.  */
        TX_THREAD_CREATE_EXTENSION(thread_ptr)

        /* Call the resume thread function to make this thread ready.  */
        _tx_thread_system_resume(thread_ptr);
 800d6f8:	4620      	mov	r0, r4
 800d6fa:	f7ff f86d 	bl	800c7d8 <_tx_thread_system_resume>
#endif
    }

    /* Always return a success.  */
    return(TX_SUCCESS);
}
 800d6fe:	2000      	movs	r0, #0
 800d700:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        next_thread =  _tx_thread_created_ptr;
 800d704:	6812      	ldr	r2, [r2, #0]
        previous_thread =  next_thread -> tx_thread_created_previous;
 800d706:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
        next_thread -> tx_thread_created_previous =  thread_ptr;
 800d70a:	f8c2 408c 	str.w	r4, [r2, #140]	; 0x8c
        previous_thread -> tx_thread_created_next =  thread_ptr;
 800d70e:	f8c1 4088 	str.w	r4, [r1, #136]	; 0x88
        thread_ptr -> tx_thread_created_next =      next_thread;
 800d712:	e9c4 2122 	strd	r2, r1, [r4, #136]	; 0x88
 800d716:	e7dc      	b.n	800d6d2 <_tx_thread_create+0x82>
            saved_thread_ptr =  _tx_thread_execute_ptr;
 800d718:	4b17      	ldr	r3, [pc, #92]	; (800d778 <_tx_thread_create+0x128>)
 800d71a:	681e      	ldr	r6, [r3, #0]
            if (saved_thread_ptr != TX_NULL)
 800d71c:	b1e6      	cbz	r6, 800d758 <_tx_thread_create+0x108>
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 800d71e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
 800d720:	6bf7      	ldr	r7, [r6, #60]	; 0x3c
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 800d722:	63f3      	str	r3, [r6, #60]	; 0x3c
 800d724:	f385 8810 	msr	PRIMASK, r5
        _tx_thread_system_resume(thread_ptr);
 800d728:	4620      	mov	r0, r4
 800d72a:	f7ff f855 	bl	800c7d8 <_tx_thread_system_resume>
        if (saved_thread_ptr != TX_NULL)
 800d72e:	2e00      	cmp	r6, #0
 800d730:	d0e5      	beq.n	800d6fe <_tx_thread_create+0xae>
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
 800d732:	63f7      	str	r7, [r6, #60]	; 0x3c
}
 800d734:	2000      	movs	r0, #0
 800d736:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d73a:	f385 8810 	msr	PRIMASK, r5
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d73e:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d742:	b672      	cpsid	i
        _tx_thread_preempt_disable--;
 800d744:	680b      	ldr	r3, [r1, #0]
 800d746:	3b01      	subs	r3, #1
 800d748:	600b      	str	r3, [r1, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d74a:	f382 8810 	msr	PRIMASK, r2
        _tx_thread_system_preempt_check();
 800d74e:	f7ff f825 	bl	800c79c <_tx_thread_system_preempt_check>
}
 800d752:	2000      	movs	r0, #0
 800d754:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
UINT                    saved_threshold =  ((UINT) 0);
 800d758:	4637      	mov	r7, r6
 800d75a:	e7e3      	b.n	800d724 <_tx_thread_create+0xd4>
 800d75c:	0800dba1 	.word	0x0800dba1
 800d760:	0800da05 	.word	0x0800da05
 800d764:	20000f20 	.word	0x20000f20
 800d768:	54485244 	.word	0x54485244
 800d76c:	20000f18 	.word	0x20000f18
 800d770:	20000f28 	.word	0x20000f28
 800d774:	20000164 	.word	0x20000164
 800d778:	20000f30 	.word	0x20000f30

0800d77c <_tx_thread_delete>:
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d77c:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d780:	b672      	cpsid	i
    /* Check for proper status of this thread to delete.  */
    if (thread_ptr -> tx_thread_state != TX_COMPLETED)
    {

        /* Now check for terminated state.  */
        if (thread_ptr -> tx_thread_state != TX_TERMINATED)
 800d782:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800d784:	3b01      	subs	r3, #1
 800d786:	2b01      	cmp	r3, #1
 800d788:	d81e      	bhi.n	800d7c8 <_tx_thread_delete+0x4c>

        /* Clear the thread ID to make it invalid.  */
        thread_ptr -> tx_thread_id =  TX_CLEAR_ID;

        /* Decrement the number of created threads.  */
        _tx_thread_created_count--;
 800d78a:	4a11      	ldr	r2, [pc, #68]	; (800d7d0 <_tx_thread_delete+0x54>)
 800d78c:	6813      	ldr	r3, [r2, #0]
{
 800d78e:	b430      	push	{r4, r5}
        _tx_thread_created_count--;
 800d790:	3b01      	subs	r3, #1
        thread_ptr -> tx_thread_id =  TX_CLEAR_ID;
 800d792:	2400      	movs	r4, #0
 800d794:	6004      	str	r4, [r0, #0]
        _tx_thread_created_count--;
 800d796:	6013      	str	r3, [r2, #0]
        
        /* See if the thread is the only one on the list.  */
        if (_tx_thread_created_count == TX_EMPTY)
 800d798:	b17b      	cbz	r3, 800d7ba <_tx_thread_delete+0x3e>
            previous_thread =                            thread_ptr -> tx_thread_created_previous;
            next_thread -> tx_thread_created_previous =  previous_thread;
            previous_thread -> tx_thread_created_next =  next_thread;

            /* See if we have to update the created list head pointer.  */
            if (_tx_thread_created_ptr == thread_ptr)
 800d79a:	4c0e      	ldr	r4, [pc, #56]	; (800d7d4 <_tx_thread_delete+0x58>)
 800d79c:	6825      	ldr	r5, [r4, #0]
            previous_thread =                            thread_ptr -> tx_thread_created_previous;
 800d79e:	e9d0 3222 	ldrd	r3, r2, [r0, #136]	; 0x88
            if (_tx_thread_created_ptr == thread_ptr)
 800d7a2:	4285      	cmp	r5, r0
            next_thread -> tx_thread_created_previous =  previous_thread;
 800d7a4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
            {
                        
                /* Yes, move the head pointer to the next link. */
                _tx_thread_created_ptr =  next_thread;
 800d7a8:	bf08      	it	eq
 800d7aa:	6023      	streq	r3, [r4, #0]
            previous_thread -> tx_thread_created_next =  next_thread;
 800d7ac:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d7b0:	f381 8810 	msr	PRIMASK, r1
 800d7b4:	2000      	movs	r0, #0
        TX_RESTORE
    }

    /* Return completion status.  */
    return(status);
}
 800d7b6:	bc30      	pop	{r4, r5}
 800d7b8:	4770      	bx	lr
            _tx_thread_created_ptr =  TX_NULL;
 800d7ba:	4a06      	ldr	r2, [pc, #24]	; (800d7d4 <_tx_thread_delete+0x58>)
 800d7bc:	6013      	str	r3, [r2, #0]
 800d7be:	f381 8810 	msr	PRIMASK, r1
 800d7c2:	2000      	movs	r0, #0
}
 800d7c4:	bc30      	pop	{r4, r5}
 800d7c6:	4770      	bx	lr
 800d7c8:	f381 8810 	msr	PRIMASK, r1
            status =  TX_DELETE_ERROR;
 800d7cc:	2011      	movs	r0, #17
}
 800d7ce:	4770      	bx	lr
 800d7d0:	20000f20 	.word	0x20000f20
 800d7d4:	20000f18 	.word	0x20000f18

0800d7d8 <_tx_thread_info_get>:
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_info_get(TX_THREAD *thread_ptr, CHAR **name, UINT *state, ULONG *run_count, 
                UINT *priority, UINT *preemption_threshold, ULONG *time_slice, 
                TX_THREAD **next_thread, TX_THREAD **next_suspended_thread)
{
 800d7d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d7dc:	469c      	mov	ip, r3
 800d7de:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800d7e0:	e9dd 8706 	ldrd	r8, r7, [sp, #24]
 800d7e4:	e9dd 6508 	ldrd	r6, r5, [sp, #32]
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d7e8:	f3ef 8e10 	mrs	lr, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d7ec:	b672      	cpsid	i

    /* Retrieve all the pertinent information and return it in the supplied
       destinations.  */

    /* Retrieve the name of the thread.  */
    if (name != TX_NULL)
 800d7ee:	b109      	cbz	r1, 800d7f4 <_tx_thread_info_get+0x1c>
    {
    
        *name =  thread_ptr -> tx_thread_name;
 800d7f0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800d7f2:	600b      	str	r3, [r1, #0]
    }
    
    /* Pickup the thread's current state.  */
    if (state != TX_NULL)
 800d7f4:	b10a      	cbz	r2, 800d7fa <_tx_thread_info_get+0x22>
    {
    
        *state =  thread_ptr -> tx_thread_state;
 800d7f6:	6b01      	ldr	r1, [r0, #48]	; 0x30
 800d7f8:	6011      	str	r1, [r2, #0]
    }
    
    /* Pickup the number of times the thread has been scheduled.  */
    if (run_count != TX_NULL)
 800d7fa:	f1bc 0f00 	cmp.w	ip, #0
 800d7fe:	d002      	beq.n	800d806 <_tx_thread_info_get+0x2e>
    {
    
        *run_count =  thread_ptr -> tx_thread_run_count;
 800d800:	6842      	ldr	r2, [r0, #4]
 800d802:	f8cc 2000 	str.w	r2, [ip]
    }
    
    /* Pickup the thread's priority.  */
    if (priority != TX_NULL)
 800d806:	f1b8 0f00 	cmp.w	r8, #0
 800d80a:	d003      	beq.n	800d814 <_tx_thread_info_get+0x3c>
    {
    
        *priority =  thread_ptr -> tx_thread_user_priority;
 800d80c:	f8d0 2094 	ldr.w	r2, [r0, #148]	; 0x94
 800d810:	f8c8 2000 	str.w	r2, [r8]
    }
    
    /* Pickup the thread's preemption-threshold.  */
    if (preemption_threshold != TX_NULL)
 800d814:	b117      	cbz	r7, 800d81c <_tx_thread_info_get+0x44>
    {
    
        *preemption_threshold =  thread_ptr -> tx_thread_user_preempt_threshold;
 800d816:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
 800d81a:	603b      	str	r3, [r7, #0]
    }
    
    /* Pickup the thread's current time-slice.  */
    if (time_slice != TX_NULL)
 800d81c:	b10e      	cbz	r6, 800d822 <_tx_thread_info_get+0x4a>
    {
    
        *time_slice =  thread_ptr -> tx_thread_time_slice;
 800d81e:	6983      	ldr	r3, [r0, #24]
 800d820:	6033      	str	r3, [r6, #0]
    }
    
    /* Pickup the next created thread.  */
    if (next_thread != TX_NULL)
 800d822:	b115      	cbz	r5, 800d82a <_tx_thread_info_get+0x52>
    {
    
        *next_thread =  thread_ptr -> tx_thread_created_next;
 800d824:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 800d828:	602b      	str	r3, [r5, #0]
    }
    
    /* Pickup the next thread suspended.  */
    if (next_suspended_thread != TX_NULL)
 800d82a:	b10c      	cbz	r4, 800d830 <_tx_thread_info_get+0x58>
    {
    
        *next_suspended_thread =  thread_ptr -> tx_thread_suspended_next;
 800d82c:	6f03      	ldr	r3, [r0, #112]	; 0x70
 800d82e:	6023      	str	r3, [r4, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d830:	f38e 8810 	msr	PRIMASK, lr
    /* Restore interrupts.  */
    TX_RESTORE

    /* Return completion status.  */
    return(TX_SUCCESS);
}
 800d834:	2000      	movs	r0, #0
 800d836:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d83a:	bf00      	nop

0800d83c <_tx_thread_priority_change>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_priority_change(TX_THREAD *thread_ptr, UINT new_priority, UINT *old_priority)
{
 800d83c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800d840:	4604      	mov	r4, r0
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d842:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d846:	b672      	cpsid	i

    /* Lockout interrupts while the thread is being suspended.  */
    TX_DISABLE

    /* Save the previous priority.  */
    *old_priority =  thread_ptr -> tx_thread_user_priority;
 800d848:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
 800d84c:	6013      	str	r3, [r2, #0]

    /* Log this kernel call.  */
    TX_EL_THREAD_PRIORITY_CHANGE_INSERT

    /* Determine if this thread is currently ready.  */
    if (thread_ptr -> tx_thread_state != TX_READY)
 800d84e:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800d850:	b17a      	cbz	r2, 800d872 <_tx_thread_priority_change+0x36>
 800d852:	f8d0 209c 	ldr.w	r2, [r0, #156]	; 0x9c
    {

        /* Setup the user priority and threshold in the thread's control
           block.  */
        thread_ptr -> tx_thread_user_priority =               new_priority;
 800d856:	f8c0 1094 	str.w	r1, [r0, #148]	; 0x94
 800d85a:	428a      	cmp	r2, r1
        thread_ptr -> tx_thread_user_preempt_threshold =      new_priority;
 800d85c:	f8c0 1098 	str.w	r1, [r0, #152]	; 0x98
 800d860:	bf28      	it	cs
 800d862:	460a      	movcs	r2, r1
 800d864:	63c2      	str	r2, [r0, #60]	; 0x3c
 800d866:	62c2      	str	r2, [r0, #44]	; 0x2c
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d868:	f386 8810 	msr	PRIMASK, r6
        _tx_thread_system_preempt_check();
    }

    /* Return success if we get here!  */
    return(TX_SUCCESS);
}
 800d86c:	2000      	movs	r0, #0
 800d86e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 3);
 800d872:	4f22      	ldr	r7, [pc, #136]	; (800d8fc <_tx_thread_priority_change+0xc0>)
        thread_ptr -> tx_thread_state =    TX_SUSPENDED;
 800d874:	f04f 0c03 	mov.w	ip, #3
 800d878:	460d      	mov	r5, r1
        execute_ptr =  _tx_thread_execute_ptr;
 800d87a:	f8df a088 	ldr.w	sl, [pc, #136]	; 800d904 <_tx_thread_priority_change+0xc8>
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 3);
 800d87e:	683b      	ldr	r3, [r7, #0]
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800d880:	2101      	movs	r1, #1
        thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800d882:	64c2      	str	r2, [r0, #76]	; 0x4c
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 3);
 800d884:	4463      	add	r3, ip
        thread_ptr -> tx_thread_state =    TX_SUSPENDED;
 800d886:	f8c0 c030 	str.w	ip, [r0, #48]	; 0x30
        thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800d88a:	6381      	str	r1, [r0, #56]	; 0x38
        _tx_thread_preempt_disable =  _tx_thread_preempt_disable + ((UINT) 3);
 800d88c:	603b      	str	r3, [r7, #0]
        execute_ptr =  _tx_thread_execute_ptr;
 800d88e:	f8da 8000 	ldr.w	r8, [sl]
        original_priority =  thread_ptr -> tx_thread_priority;
 800d892:	f8d0 902c 	ldr.w	r9, [r0, #44]	; 0x2c
 800d896:	f386 8810 	msr	PRIMASK, r6
        _tx_thread_system_suspend(thread_ptr);
 800d89a:	f7ff f823 	bl	800c8e4 <_tx_thread_system_suspend>
 800d89e:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
        thread_ptr -> tx_thread_user_priority =           new_priority;
 800d8a2:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
        _tx_thread_system_resume(thread_ptr);
 800d8a6:	4620      	mov	r0, r4
 800d8a8:	42ab      	cmp	r3, r5
        thread_ptr -> tx_thread_user_preempt_threshold =  new_priority;
 800d8aa:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
 800d8ae:	bf28      	it	cs
 800d8b0:	462b      	movcs	r3, r5
 800d8b2:	63e3      	str	r3, [r4, #60]	; 0x3c
 800d8b4:	62e3      	str	r3, [r4, #44]	; 0x2c
        _tx_thread_system_resume(thread_ptr);
 800d8b6:	f7fe ff8f 	bl	800c7d8 <_tx_thread_system_resume>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d8ba:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d8be:	b672      	cpsid	i
        _tx_thread_preempt_disable--;
 800d8c0:	683b      	ldr	r3, [r7, #0]
        next_execute_ptr =  _tx_thread_execute_ptr;
 800d8c2:	f8da 2000 	ldr.w	r2, [sl]
        _tx_thread_preempt_disable--;
 800d8c6:	3b01      	subs	r3, #1
        if (thread_ptr != next_execute_ptr)
 800d8c8:	4294      	cmp	r4, r2
        _tx_thread_preempt_disable--;
 800d8ca:	603b      	str	r3, [r7, #0]
        if (thread_ptr != next_execute_ptr)
 800d8cc:	d007      	beq.n	800d8de <_tx_thread_priority_change+0xa2>
            if (thread_ptr -> tx_thread_state == TX_READY)
 800d8ce:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800d8d0:	b92b      	cbnz	r3, 800d8de <_tx_thread_priority_change+0xa2>
                if (thread_ptr -> tx_thread_priority <= next_execute_ptr -> tx_thread_priority)
 800d8d2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800d8d4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
                    if (thread_ptr == execute_ptr)
 800d8d6:	4293      	cmp	r3, r2
 800d8d8:	d801      	bhi.n	800d8de <_tx_thread_priority_change+0xa2>
 800d8da:	4544      	cmp	r4, r8
 800d8dc:	d006      	beq.n	800d8ec <_tx_thread_priority_change+0xb0>
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d8de:	f381 8810 	msr	PRIMASK, r1
        _tx_thread_system_preempt_check();
 800d8e2:	f7fe ff5b 	bl	800c79c <_tx_thread_system_preempt_check>
}
 800d8e6:	2000      	movs	r0, #0
 800d8e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                        if (original_priority < new_priority)
 800d8ec:	45a9      	cmp	r9, r5
                        _tx_thread_execute_ptr =  thread_ptr;
 800d8ee:	f8ca 4000 	str.w	r4, [sl]
                        if (original_priority < new_priority)
 800d8f2:	d2f4      	bcs.n	800d8de <_tx_thread_priority_change+0xa2>
                            _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr;
 800d8f4:	4a02      	ldr	r2, [pc, #8]	; (800d900 <_tx_thread_priority_change+0xc4>)
 800d8f6:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
 800d8fa:	e7f0      	b.n	800d8de <_tx_thread_priority_change+0xa2>
 800d8fc:	20000f28 	.word	0x20000f28
 800d900:	20000e90 	.word	0x20000e90
 800d904:	20000f30 	.word	0x20000f30

0800d908 <_tx_thread_relinquish>:
UINT            priority;
TX_THREAD       *thread_ptr;


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800d908:	4b17      	ldr	r3, [pc, #92]	; (800d968 <_tx_thread_relinquish+0x60>)
{
 800d90a:	b430      	push	{r4, r5}
    TX_THREAD_GET_CURRENT(thread_ptr)
 800d90c:	681b      	ldr	r3, [r3, #0]
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d90e:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d912:	b672      	cpsid	i

    /* Pickup the thread's priority.  */
    priority =  thread_ptr -> tx_thread_priority;

    /* Determine if there is another thread at the same priority.  */
    if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 800d914:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
    _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800d918:	4914      	ldr	r1, [pc, #80]	; (800d96c <_tx_thread_relinquish+0x64>)
    if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 800d91a:	429a      	cmp	r2, r3
    _tx_timer_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800d91c:	6008      	str	r0, [r1, #0]
    priority =  thread_ptr -> tx_thread_priority;
 800d91e:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 800d920:	d01f      	beq.n	800d962 <_tx_thread_relinquish+0x5a>
    {

        /* Yes, there is another thread at this priority, make it the highest at
           this priority level.  */
        _tx_thread_priority_list[priority] =  thread_ptr -> tx_thread_ready_next;
 800d922:	4d13      	ldr	r5, [pc, #76]	; (800d970 <_tx_thread_relinquish+0x68>)
    
        /* Mark the new thread as the one to execute.  */
        _tx_thread_execute_ptr = thread_ptr -> tx_thread_ready_next;
 800d924:	4913      	ldr	r1, [pc, #76]	; (800d974 <_tx_thread_relinquish+0x6c>)
        _tx_thread_priority_list[priority] =  thread_ptr -> tx_thread_ready_next;
 800d926:	f845 2020 	str.w	r2, [r5, r0, lsl #2]
        _tx_thread_execute_ptr = thread_ptr -> tx_thread_ready_next;
 800d92a:	600a      	str	r2, [r1, #0]
    }

    /* Determine if there is a higher-priority thread ready.  */
    if (_tx_thread_highest_priority < priority)
 800d92c:	4a12      	ldr	r2, [pc, #72]	; (800d978 <_tx_thread_relinquish+0x70>)
 800d92e:	6812      	ldr	r2, [r2, #0]
 800d930:	4282      	cmp	r2, r0
 800d932:	d203      	bcs.n	800d93c <_tx_thread_relinquish+0x34>
    {

        /* Yes, there is a higher priority thread ready to execute.  Make
           it visible to the thread scheduler.  */
        _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800d934:	480e      	ldr	r0, [pc, #56]	; (800d970 <_tx_thread_relinquish+0x68>)
 800d936:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 800d93a:	600a      	str	r2, [r1, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d93c:	f384 8810 	msr	PRIMASK, r4

    /* Restore previous interrupt posture.  */
    TX_RESTORE

    /* Determine if this thread needs to return to the system.  */
    if (_tx_thread_execute_ptr != thread_ptr)
 800d940:	680a      	ldr	r2, [r1, #0]
 800d942:	429a      	cmp	r2, r3
 800d944:	d00b      	beq.n	800d95e <_tx_thread_relinquish+0x56>
    *((ULONG *) 0xE000ED04) = ((ULONG) 0x10000000);
 800d946:	4b0d      	ldr	r3, [pc, #52]	; (800d97c <_tx_thread_relinquish+0x74>)
 800d948:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800d94c:	601a      	str	r2, [r3, #0]
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d94e:	f3ef 8305 	mrs	r3, IPSR
    if (__get_ipsr_value() == 0)
 800d952:	b923      	cbnz	r3, 800d95e <_tx_thread_relinquish+0x56>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d954:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSIE  i": : : "memory" );
 800d958:	b662      	cpsie	i
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d95a:	f383 8810 	msr	PRIMASK, r3

        /* Transfer control to the system so the scheduler can execute
           the next thread.  */
        _tx_thread_system_return();
    }
}
 800d95e:	bc30      	pop	{r4, r5}
 800d960:	4770      	bx	lr
 800d962:	4904      	ldr	r1, [pc, #16]	; (800d974 <_tx_thread_relinquish+0x6c>)
 800d964:	e7e2      	b.n	800d92c <_tx_thread_relinquish+0x24>
 800d966:	bf00      	nop
 800d968:	20000f2c 	.word	0x20000f2c
 800d96c:	20000fc8 	.word	0x20000fc8
 800d970:	20000e90 	.word	0x20000e90
 800d974:	20000f30 	.word	0x20000f30
 800d978:	20000f34 	.word	0x20000f34
 800d97c:	e000ed04 	.word	0xe000ed04

0800d980 <_tx_thread_resume>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_resume(TX_THREAD *thread_ptr)
{
 800d980:	b538      	push	{r3, r4, r5, lr}
 800d982:	4603      	mov	r3, r0
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800d984:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800d988:	b672      	cpsid	i
    /* Log this kernel call.  */
    TX_EL_THREAD_RESUME_INSERT

    /* Determine if the thread is suspended or in the process of suspending.
       If so, call the thread resume processing.  */
    if (thread_ptr -> tx_thread_state == TX_SUSPENDED)
 800d98a:	6b01      	ldr	r1, [r0, #48]	; 0x30
 800d98c:	2903      	cmp	r1, #3
 800d98e:	d00a      	beq.n	800d9a6 <_tx_thread_resume+0x26>
        
        /* Setup successful return status.  */
        status =  TX_SUCCESS;
#endif
    }
    else if (thread_ptr -> tx_thread_delayed_suspend == TX_TRUE)
 800d990:	6b41      	ldr	r1, [r0, #52]	; 0x34
 800d992:	2901      	cmp	r1, #1
 800d994:	d003      	beq.n	800d99e <_tx_thread_resume+0x1e>
    }
    else
    {

        /* Setup invalid resume return status.  */
        status =  TX_RESUME_ERROR;
 800d996:	2012      	movs	r0, #18
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d998:	f382 8810 	msr	PRIMASK, r2
    }
#endif

    /* Return completion status. */
    return(status);
}
 800d99c:	bd38      	pop	{r3, r4, r5, pc}
        thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 800d99e:	2100      	movs	r1, #0
        status =  TX_SUSPEND_LIFTED;
 800d9a0:	2019      	movs	r0, #25
        thread_ptr -> tx_thread_delayed_suspend =  TX_FALSE;
 800d9a2:	6359      	str	r1, [r3, #52]	; 0x34
 800d9a4:	e7f8      	b.n	800d998 <_tx_thread_resume+0x18>
    __asm__ volatile (" MRS  %0,IPSR ": "=r" (ipsr_value) );
 800d9a6:	f3ef 8405 	mrs	r4, IPSR
        if (TX_THREAD_GET_SYSTEM_STATE() >= TX_INITIALIZE_IN_PROGRESS)
 800d9aa:	4913      	ldr	r1, [pc, #76]	; (800d9f8 <_tx_thread_resume+0x78>)
 800d9ac:	6809      	ldr	r1, [r1, #0]
 800d9ae:	4321      	orrs	r1, r4
 800d9b0:	f1b1 3ff0 	cmp.w	r1, #4042322160	; 0xf0f0f0f0
 800d9b4:	d312      	bcc.n	800d9dc <_tx_thread_resume+0x5c>
            saved_thread_ptr =  _tx_thread_execute_ptr;
 800d9b6:	4911      	ldr	r1, [pc, #68]	; (800d9fc <_tx_thread_resume+0x7c>)
 800d9b8:	680c      	ldr	r4, [r1, #0]
            if (saved_thread_ptr != TX_NULL)
 800d9ba:	b1cc      	cbz	r4, 800d9f0 <_tx_thread_resume+0x70>
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 800d9bc:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
                saved_threshold =  saved_thread_ptr -> tx_thread_preempt_threshold;
 800d9be:	6be5      	ldr	r5, [r4, #60]	; 0x3c
                saved_thread_ptr -> tx_thread_preempt_threshold =  saved_thread_ptr -> tx_thread_priority;
 800d9c0:	63e1      	str	r1, [r4, #60]	; 0x3c
        _tx_thread_preempt_disable++;
 800d9c2:	480f      	ldr	r0, [pc, #60]	; (800da00 <_tx_thread_resume+0x80>)
 800d9c4:	6801      	ldr	r1, [r0, #0]
 800d9c6:	3101      	adds	r1, #1
 800d9c8:	6001      	str	r1, [r0, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800d9ca:	f382 8810 	msr	PRIMASK, r2
        _tx_thread_system_resume(thread_ptr);
 800d9ce:	4618      	mov	r0, r3
 800d9d0:	f7fe ff02 	bl	800c7d8 <_tx_thread_system_resume>
        if (saved_thread_ptr != TX_NULL)
 800d9d4:	b174      	cbz	r4, 800d9f4 <_tx_thread_resume+0x74>
            saved_thread_ptr -> tx_thread_preempt_threshold =  saved_threshold;
 800d9d6:	63e5      	str	r5, [r4, #60]	; 0x3c
        return(TX_SUCCESS);
 800d9d8:	2000      	movs	r0, #0
}
 800d9da:	bd38      	pop	{r3, r4, r5, pc}
        _tx_thread_preempt_disable++;
 800d9dc:	4908      	ldr	r1, [pc, #32]	; (800da00 <_tx_thread_resume+0x80>)
 800d9de:	680b      	ldr	r3, [r1, #0]
 800d9e0:	3301      	adds	r3, #1
 800d9e2:	600b      	str	r3, [r1, #0]
 800d9e4:	f382 8810 	msr	PRIMASK, r2
        _tx_thread_system_resume(thread_ptr);
 800d9e8:	f7fe fef6 	bl	800c7d8 <_tx_thread_system_resume>
        return(TX_SUCCESS);
 800d9ec:	2000      	movs	r0, #0
}
 800d9ee:	bd38      	pop	{r3, r4, r5, pc}
UINT        saved_threshold =  ((UINT) 0);
 800d9f0:	4625      	mov	r5, r4
 800d9f2:	e7e6      	b.n	800d9c2 <_tx_thread_resume+0x42>
        return(TX_SUCCESS);
 800d9f4:	4620      	mov	r0, r4
}
 800d9f6:	bd38      	pop	{r3, r4, r5, pc}
 800d9f8:	20000164 	.word	0x20000164
 800d9fc:	20000f30 	.word	0x20000f30
 800da00:	20000f28 	.word	0x20000f28

0800da04 <_tx_thread_shell_entry>:
VOID            (*entry_exit_notify)(TX_THREAD *notify_thread_ptr, UINT type);
#endif


    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800da04:	4b16      	ldr	r3, [pc, #88]	; (800da60 <_tx_thread_shell_entry+0x5c>)
{
 800da06:	b570      	push	{r4, r5, r6, lr}
    TX_THREAD_GET_CURRENT(thread_ptr)
 800da08:	681c      	ldr	r4, [r3, #0]
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800da0a:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800da0e:	b672      	cpsid	i

    /* Disable interrupts.  */
    TX_DISABLE

    /* Pickup the entry/exit application callback routine.  */
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
 800da10:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800da14:	f382 8810 	msr	PRIMASK, r2

    /* Restore interrupts.  */
    TX_RESTORE

    /* Determine if an application callback routine is specified.  */
    if (entry_exit_notify != TX_NULL)
 800da18:	b113      	cbz	r3, 800da20 <_tx_thread_shell_entry+0x1c>
    {

        /* Yes, notify application that this thread has been entered!  */
        (entry_exit_notify)(thread_ptr, TX_THREAD_ENTRY);
 800da1a:	2100      	movs	r1, #0
 800da1c:	4620      	mov	r0, r4
 800da1e:	4798      	blx	r3
    }
#endif

    /* Call current thread's entry function.  */
    (thread_ptr -> tx_thread_entry) (thread_ptr -> tx_thread_entry_parameter);
 800da20:	e9d4 3011 	ldrd	r3, r0, [r4, #68]	; 0x44
 800da24:	4798      	blx	r3

    /* Suspend thread with a "completed" state.  */

    /* Determine if the application is using mutexes.  */
    if (_tx_thread_mutex_release != TX_NULL)
 800da26:	4b0f      	ldr	r3, [pc, #60]	; (800da64 <_tx_thread_shell_entry+0x60>)
 800da28:	681b      	ldr	r3, [r3, #0]
 800da2a:	b10b      	cbz	r3, 800da30 <_tx_thread_shell_entry+0x2c>
    {

        /* Yes, call the mutex release function via a function pointer that 
           is setup during mutex initialization.  */
        (_tx_thread_mutex_release)(thread_ptr);
 800da2c:	4620      	mov	r0, r4
 800da2e:	4798      	blx	r3
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800da30:	f3ef 8010 	mrs	r0, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800da34:	b672      	cpsid	i

    /* Setup for no timeout period.  */
    thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);

    /* Temporarily disable preemption.  */
    _tx_thread_preempt_disable++;
 800da36:	4a0c      	ldr	r2, [pc, #48]	; (800da68 <_tx_thread_shell_entry+0x64>)
    thread_ptr -> tx_thread_state =  TX_COMPLETED;
 800da38:	2101      	movs	r1, #1
    thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800da3a:	2600      	movs	r6, #0
    entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
 800da3c:	f8d4 50ac 	ldr.w	r5, [r4, #172]	; 0xac
    _tx_thread_preempt_disable++;
 800da40:	6813      	ldr	r3, [r2, #0]
    thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800da42:	64e6      	str	r6, [r4, #76]	; 0x4c
    _tx_thread_preempt_disable++;
 800da44:	440b      	add	r3, r1
    thread_ptr -> tx_thread_state =  TX_COMPLETED;
 800da46:	6321      	str	r1, [r4, #48]	; 0x30
    thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800da48:	63a1      	str	r1, [r4, #56]	; 0x38
    _tx_thread_preempt_disable++;
 800da4a:	6013      	str	r3, [r2, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800da4c:	f380 8810 	msr	PRIMASK, r0
    TX_THREAD_COMPLETED_EXTENSION(thread_ptr)

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

    /* Determine if an application callback routine is specified.  */
    if (entry_exit_notify != TX_NULL)
 800da50:	b10d      	cbz	r5, 800da56 <_tx_thread_shell_entry+0x52>
    {

        /* Yes, notify application that this thread has exited!  */
        (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
 800da52:	4620      	mov	r0, r4
 800da54:	47a8      	blx	r5
    }
#endif

    /* Call actual thread suspension routine.  */
    _tx_thread_system_suspend(thread_ptr);
 800da56:	4620      	mov	r0, r4
#ifdef TX_SAFETY_CRITICAL

    /* If we ever get here, raise safety critical exception.  */
    TX_SAFETY_CRITICAL_EXCEPTION(__FILE__, __LINE__, 0);
#endif
}
 800da58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    _tx_thread_system_suspend(thread_ptr);
 800da5c:	f7fe bf42 	b.w	800c8e4 <_tx_thread_system_suspend>
 800da60:	20000f2c 	.word	0x20000f2c
 800da64:	20000f10 	.word	0x20000f10
 800da68:	20000f28 	.word	0x20000f28

0800da6c <_tx_thread_terminate>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
UINT  _tx_thread_terminate(TX_THREAD *thread_ptr)
{
 800da6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800da6e:	4604      	mov	r4, r0
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800da70:	f3ef 8610 	mrs	r6, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800da74:	b672      	cpsid	i

    /* Lockout interrupts while the thread is being terminated.  */
    TX_DISABLE

    /* Deactivate thread timer, if active.  */
    _tx_timer_system_deactivate(&thread_ptr -> tx_thread_timer);
 800da76:	304c      	adds	r0, #76	; 0x4c
 800da78:	f7ff f8d6 	bl	800cc28 <_tx_timer_system_deactivate>

    /* Log this kernel call.  */
    TX_EL_THREAD_TERMINATE_INSERT

    /* Is the thread already terminated?  */
    if (thread_ptr -> tx_thread_state == TX_TERMINATED)
 800da7c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800da7e:	2b02      	cmp	r3, #2
 800da80:	d02e      	beq.n	800dae0 <_tx_thread_terminate+0x74>
        /* Return success since thread is already terminated.  */
        status =  TX_SUCCESS;
    }

    /* Check the specified thread's current status.  */
    else if (thread_ptr -> tx_thread_state != TX_COMPLETED)
 800da82:	2b01      	cmp	r3, #1
 800da84:	d02c      	beq.n	800dae0 <_tx_thread_terminate+0x74>
    {

        /* Disable preemption.  */
        _tx_thread_preempt_disable++;
 800da86:	4d27      	ldr	r5, [pc, #156]	; (800db24 <_tx_thread_terminate+0xb8>)

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

        /* Pickup the entry/exit application callback routine.  */
        entry_exit_notify =  thread_ptr -> tx_thread_entry_exit_notify;
 800da88:	f8d4 70ac 	ldr.w	r7, [r4, #172]	; 0xac
        _tx_thread_preempt_disable++;
 800da8c:	682a      	ldr	r2, [r5, #0]
 800da8e:	3201      	adds	r2, #1
 800da90:	602a      	str	r2, [r5, #0]
#endif

        /* Check to see if the thread is currently ready.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
 800da92:	bb5b      	cbnz	r3, 800daec <_tx_thread_terminate+0x80>

            /* Setup for no timeout period.  */
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);

            /* Disable preemption.  */
            _tx_thread_preempt_disable++;
 800da94:	682a      	ldr	r2, [r5, #0]
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800da96:	2101      	movs	r1, #1
            thread_ptr -> tx_thread_state =  TX_TERMINATED;
 800da98:	2002      	movs	r0, #2
            thread_ptr -> tx_thread_timer.tx_timer_internal_remaining_ticks =  ((ULONG) 0);
 800da9a:	64e3      	str	r3, [r4, #76]	; 0x4c
            _tx_thread_preempt_disable++;
 800da9c:	440a      	add	r2, r1
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800da9e:	63a1      	str	r1, [r4, #56]	; 0x38
            thread_ptr -> tx_thread_state =  TX_TERMINATED;
 800daa0:	6320      	str	r0, [r4, #48]	; 0x30
            _tx_thread_preempt_disable++;
 800daa2:	602a      	str	r2, [r5, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800daa4:	f386 8810 	msr	PRIMASK, r6
            TX_THREAD_TERMINATED_EXTENSION(thread_ptr)

#ifndef TX_DISABLE_NOTIFY_CALLBACKS

            /* Determine if an application callback routine is specified.  */
            if (entry_exit_notify != TX_NULL)
 800daa8:	b10f      	cbz	r7, 800daae <_tx_thread_terminate+0x42>
            {

                /* Yes, notify application that this thread has exited!  */
                (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
 800daaa:	4620      	mov	r0, r4
 800daac:	47b8      	blx	r7
            }
#endif

            /* Call actual thread suspension routine.  */
            _tx_thread_system_suspend(thread_ptr);
 800daae:	4620      	mov	r0, r4
 800dab0:	f7fe ff18 	bl	800c8e4 <_tx_thread_system_suspend>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800dab4:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800dab8:	b672      	cpsid	i
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800daba:	f383 8810 	msr	PRIMASK, r3
        /* Restore interrupts.  */
        TX_RESTORE
#endif

        /* Determine if the application is using mutexes.  */
        if (_tx_thread_mutex_release != TX_NULL)
 800dabe:	4b1a      	ldr	r3, [pc, #104]	; (800db28 <_tx_thread_terminate+0xbc>)
 800dac0:	681b      	ldr	r3, [r3, #0]
 800dac2:	b10b      	cbz	r3, 800dac8 <_tx_thread_terminate+0x5c>
        {

            /* Yes, call the mutex release function via a function pointer that 
               is setup during initialization.  */
            (_tx_thread_mutex_release)(thread_ptr);
 800dac4:	4620      	mov	r0, r4
 800dac6:	4798      	blx	r3
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800dac8:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800dacc:	b672      	cpsid	i
        /* Disable interrupts.  */
        TX_DISABLE
#endif

        /* Enable preemption.  */
        _tx_thread_preempt_disable--;
 800dace:	682b      	ldr	r3, [r5, #0]
 800dad0:	3b01      	subs	r3, #1
 800dad2:	602b      	str	r3, [r5, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800dad4:	f382 8810 	msr	PRIMASK, r2
        /* Restore interrupts.  */
        TX_RESTORE
    }

    /* Check for preemption.  */
    _tx_thread_system_preempt_check();
 800dad8:	f7fe fe60 	bl	800c79c <_tx_thread_system_preempt_check>

    /* Return completion status.  */
    return(status);
}
 800dadc:	2000      	movs	r0, #0
 800dade:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800dae0:	f386 8810 	msr	PRIMASK, r6
    _tx_thread_system_preempt_check();
 800dae4:	f7fe fe5a 	bl	800c79c <_tx_thread_system_preempt_check>
}
 800dae8:	2000      	movs	r0, #0
 800daea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            thread_ptr -> tx_thread_state =    TX_TERMINATED;
 800daec:	2102      	movs	r1, #2
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800daee:	2201      	movs	r2, #1
            suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
 800daf0:	6ea3      	ldr	r3, [r4, #104]	; 0x68
            thread_ptr -> tx_thread_state =    TX_TERMINATED;
 800daf2:	6321      	str	r1, [r4, #48]	; 0x30
            thread_ptr -> tx_thread_suspending =  TX_TRUE;
 800daf4:	63a2      	str	r2, [r4, #56]	; 0x38
            suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
 800daf6:	f8d4 10c0 	ldr.w	r1, [r4, #192]	; 0xc0
 800dafa:	f386 8810 	msr	PRIMASK, r6
            if (suspend_cleanup != TX_NULL)
 800dafe:	b10b      	cbz	r3, 800db04 <_tx_thread_terminate+0x98>
                (suspend_cleanup)(thread_ptr, suspension_sequence);
 800db00:	4620      	mov	r0, r4
 800db02:	4798      	blx	r3
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800db04:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800db08:	b672      	cpsid	i
            thread_ptr -> tx_thread_suspending =  TX_FALSE;
 800db0a:	2200      	movs	r2, #0
 800db0c:	63a2      	str	r2, [r4, #56]	; 0x38
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800db0e:	f383 8810 	msr	PRIMASK, r3
            if (entry_exit_notify != TX_NULL)
 800db12:	b117      	cbz	r7, 800db1a <_tx_thread_terminate+0xae>
                (entry_exit_notify)(thread_ptr, TX_THREAD_EXIT);
 800db14:	2101      	movs	r1, #1
 800db16:	4620      	mov	r0, r4
 800db18:	47b8      	blx	r7
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800db1a:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800db1e:	b672      	cpsid	i
 800db20:	e7cb      	b.n	800daba <_tx_thread_terminate+0x4e>
 800db22:	bf00      	nop
 800db24:	20000f28 	.word	0x20000f28
 800db28:	20000f10 	.word	0x20000f10

0800db2c <_tx_thread_time_slice>:
ULONG           system_state;
UINT            preempt_disable;
#endif

    /* Pickup thread pointer.  */
    TX_THREAD_GET_CURRENT(thread_ptr)
 800db2c:	4b16      	ldr	r3, [pc, #88]	; (800db88 <_tx_thread_time_slice+0x5c>)
 800db2e:	681b      	ldr	r3, [r3, #0]
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800db30:	f3ef 8210 	mrs	r2, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800db34:	b672      	cpsid	i

    /* Lockout interrupts while the time-slice is evaluated.  */
    TX_DISABLE

    /* Clear the expired time-slice flag.  */
    _tx_timer_expired_time_slice =  TX_FALSE;
 800db36:	4915      	ldr	r1, [pc, #84]	; (800db8c <_tx_thread_time_slice+0x60>)
 800db38:	2000      	movs	r0, #0
 800db3a:	6008      	str	r0, [r1, #0]

    /* Make sure the thread pointer is valid.  */
    if (thread_ptr != TX_NULL)
 800db3c:	b193      	cbz	r3, 800db64 <_tx_thread_time_slice+0x38>
    {

        /* Make sure the thread is still active, i.e. not suspended.  */
        if (thread_ptr -> tx_thread_state == TX_READY)
 800db3e:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800db40:	b981      	cbnz	r1, 800db64 <_tx_thread_time_slice+0x38>
            /* Reset the actual time-slice variable.  */
            _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;

            /* Determine if there is another thread at the same priority and preemption-threshold
               is not set.  Preemption-threshold overrides time-slicing.  */
            if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 800db42:	6a18      	ldr	r0, [r3, #32]
            thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800db44:	69d9      	ldr	r1, [r3, #28]
            if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 800db46:	4298      	cmp	r0, r3
{
 800db48:	b410      	push	{r4}
            _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
 800db4a:	4c11      	ldr	r4, [pc, #68]	; (800db90 <_tx_thread_time_slice+0x64>)
            thread_ptr -> tx_thread_time_slice =  thread_ptr -> tx_thread_new_time_slice;
 800db4c:	6199      	str	r1, [r3, #24]
            _tx_timer_time_slice =  thread_ptr -> tx_thread_time_slice;
 800db4e:	6021      	str	r1, [r4, #0]
            if (thread_ptr -> tx_thread_ready_next != thread_ptr)
 800db50:	d003      	beq.n	800db5a <_tx_thread_time_slice+0x2e>
            {

                /* Check to see if preemption-threshold is not being used.  */
                if (thread_ptr -> tx_thread_priority == thread_ptr -> tx_thread_preempt_threshold)
 800db52:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 800db54:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800db56:	4299      	cmp	r1, r3
 800db58:	d007      	beq.n	800db6a <_tx_thread_time_slice+0x3e>
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800db5a:	f382 8810 	msr	PRIMASK, r2

        /* Yes, check this thread's stack.  */
        TX_THREAD_STACK_CHECK(next_thread_ptr)
    }
#endif
}
 800db5e:	f85d 4b04 	ldr.w	r4, [sp], #4
 800db62:	4770      	bx	lr
 800db64:	f382 8810 	msr	PRIMASK, r2
 800db68:	4770      	bx	lr
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800db6a:	4c0a      	ldr	r4, [pc, #40]	; (800db94 <_tx_thread_time_slice+0x68>)
                    _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
 800db6c:	4b0a      	ldr	r3, [pc, #40]	; (800db98 <_tx_thread_time_slice+0x6c>)
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800db6e:	6824      	ldr	r4, [r4, #0]
                    _tx_thread_priority_list[thread_ptr -> tx_thread_priority] =  thread_ptr -> tx_thread_ready_next;
 800db70:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
                    _tx_thread_execute_ptr =  _tx_thread_priority_list[_tx_thread_highest_priority];
 800db74:	4909      	ldr	r1, [pc, #36]	; (800db9c <_tx_thread_time_slice+0x70>)
 800db76:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 800db7a:	600b      	str	r3, [r1, #0]
 800db7c:	f382 8810 	msr	PRIMASK, r2
}
 800db80:	f85d 4b04 	ldr.w	r4, [sp], #4
 800db84:	4770      	bx	lr
 800db86:	bf00      	nop
 800db88:	20000f2c 	.word	0x20000f2c
 800db8c:	200014b8 	.word	0x200014b8
 800db90:	20000fc8 	.word	0x20000fc8
 800db94:	20000f34 	.word	0x20000f34
 800db98:	20000e90 	.word	0x20000e90
 800db9c:	20000f30 	.word	0x20000f30

0800dba0 <_tx_thread_timeout>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _tx_thread_timeout(ULONG timeout_input)
{
 800dba0:	b410      	push	{r4}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800dba2:	f3ef 8410 	mrs	r4, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800dba6:	b672      	cpsid	i

    /* Disable interrupts.  */
    TX_DISABLE

    /* Determine how the thread is currently suspended.  */
    if (thread_ptr -> tx_thread_state == TX_SLEEP)
 800dba8:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800dbaa:	2a04      	cmp	r2, #4
 800dbac:	d008      	beq.n	800dbc0 <_tx_thread_timeout+0x20>
        /* Increment the number of timeouts for this thread.  */
        thread_ptr -> tx_thread_performance_timeout_count++;
#endif
    
        /* Pickup the cleanup routine address.  */
        suspend_cleanup =  thread_ptr -> tx_thread_suspend_cleanup;
 800dbae:	6e82      	ldr	r2, [r0, #104]	; 0x68

#ifndef TX_NOT_INTERRUPTABLE

        /* Pickup the suspension sequence number that is used later to verify that the
           cleanup is still necessary.  */
        suspension_sequence =  thread_ptr -> tx_thread_suspension_sequence;
 800dbb0:	f8d0 10c0 	ldr.w	r1, [r0, #192]	; 0xc0
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800dbb4:	f384 8810 	msr	PRIMASK, r4
        /* Restore interrupts.  */
        TX_RESTORE
#endif

        /* Call any cleanup routines.  */
        if (suspend_cleanup != TX_NULL)
 800dbb8:	b162      	cbz	r2, 800dbd4 <_tx_thread_timeout+0x34>

        /* Restore interrupts.  */
        TX_RESTORE
#endif
    }
}
 800dbba:	f85d 4b04 	ldr.w	r4, [sp], #4
            (suspend_cleanup)(thread_ptr, suspension_sequence);
 800dbbe:	4710      	bx	r2
        _tx_thread_preempt_disable++;
 800dbc0:	4a06      	ldr	r2, [pc, #24]	; (800dbdc <_tx_thread_timeout+0x3c>)
 800dbc2:	6813      	ldr	r3, [r2, #0]
 800dbc4:	3301      	adds	r3, #1
 800dbc6:	6013      	str	r3, [r2, #0]
 800dbc8:	f384 8810 	msr	PRIMASK, r4
}
 800dbcc:	f85d 4b04 	ldr.w	r4, [sp], #4
        _tx_thread_system_resume(thread_ptr);
 800dbd0:	f7fe be02 	b.w	800c7d8 <_tx_thread_system_resume>
}
 800dbd4:	f85d 4b04 	ldr.w	r4, [sp], #4
 800dbd8:	4770      	bx	lr
 800dbda:	bf00      	nop
 800dbdc:	20000f28 	.word	0x20000f28

0800dbe0 <_tx_timer_expiration_process>:
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800dbe0:	f3ef 8110 	mrs	r1, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800dbe4:	b672      	cpsid	i
    /* Restore interrupts.  */
    TX_RESTORE
#else

    /* Increment the preempt disable flag.  */
    _tx_thread_preempt_disable++;
 800dbe6:	4a04      	ldr	r2, [pc, #16]	; (800dbf8 <_tx_timer_expiration_process+0x18>)
 800dbe8:	6813      	ldr	r3, [r2, #0]
 800dbea:	3301      	adds	r3, #1
 800dbec:	6013      	str	r3, [r2, #0]
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800dbee:	f381 8810 	msr	PRIMASK, r1

    /* Restore interrupts.  */
    TX_RESTORE

    /* Call the system resume function to activate the timer thread.  */
    _tx_thread_system_resume(&_tx_timer_thread);
 800dbf2:	4802      	ldr	r0, [pc, #8]	; (800dbfc <_tx_timer_expiration_process+0x1c>)
 800dbf4:	f7fe bdf0 	b.w	800c7d8 <_tx_thread_system_resume>
 800dbf8:	20000f28 	.word	0x20000f28
 800dbfc:	20000fd8 	.word	0x20000fd8

0800dc00 <_tx_semaphore_cleanup>:
/*                                                                        */
/*  05-19-2020     William E. Lamie         Initial Version 6.0           */
/*                                                                        */
/**************************************************************************/
VOID  _tx_semaphore_cleanup(TX_THREAD *thread_ptr, ULONG suspension_sequence)
{
 800dc00:	b538      	push	{r3, r4, r5, lr}
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800dc02:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800dc06:	b672      	cpsid	i

    /* Disable interrupts to remove the suspended thread from the semaphore.  */
    TX_DISABLE

    /* Determine if the cleanup is still required.  */
    if (thread_ptr -> tx_thread_suspend_cleanup == &(_tx_semaphore_cleanup))
 800dc08:	4a1a      	ldr	r2, [pc, #104]	; (800dc74 <_tx_semaphore_cleanup+0x74>)
 800dc0a:	6e84      	ldr	r4, [r0, #104]	; 0x68
 800dc0c:	4294      	cmp	r4, r2
 800dc0e:	d002      	beq.n	800dc16 <_tx_semaphore_cleanup+0x16>
    __asm__ volatile (" MSR  PRIMASK,%0": : "r" (primask_value): "memory" );
 800dc10:	f383 8810 	msr	PRIMASK, r3
    }

    /* Restore interrupts.  */
    TX_RESTORE
#endif
}
 800dc14:	bd38      	pop	{r3, r4, r5, pc}
        if (suspension_sequence == thread_ptr -> tx_thread_suspension_sequence)
 800dc16:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
 800dc1a:	428a      	cmp	r2, r1
 800dc1c:	d1f8      	bne.n	800dc10 <_tx_semaphore_cleanup+0x10>
            semaphore_ptr =  TX_VOID_TO_SEMAPHORE_POINTER_CONVERT(thread_ptr -> tx_thread_suspend_control_block);
 800dc1e:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
            if (semaphore_ptr != TX_NULL)
 800dc20:	2a00      	cmp	r2, #0
 800dc22:	d0f5      	beq.n	800dc10 <_tx_semaphore_cleanup+0x10>
                if (semaphore_ptr -> tx_semaphore_id == TX_SEMAPHORE_ID)
 800dc24:	4914      	ldr	r1, [pc, #80]	; (800dc78 <_tx_semaphore_cleanup+0x78>)
 800dc26:	6814      	ldr	r4, [r2, #0]
 800dc28:	428c      	cmp	r4, r1
 800dc2a:	d1f1      	bne.n	800dc10 <_tx_semaphore_cleanup+0x10>
                    if (semaphore_ptr -> tx_semaphore_suspended_count != TX_NO_SUSPENSIONS)
 800dc2c:	6911      	ldr	r1, [r2, #16]
 800dc2e:	2900      	cmp	r1, #0
 800dc30:	d0ee      	beq.n	800dc10 <_tx_semaphore_cleanup+0x10>
                        semaphore_ptr -> tx_semaphore_suspended_count--;
 800dc32:	3901      	subs	r1, #1
                        thread_ptr -> tx_thread_suspend_cleanup =  TX_NULL;
 800dc34:	2400      	movs	r4, #0
 800dc36:	6684      	str	r4, [r0, #104]	; 0x68
                        semaphore_ptr -> tx_semaphore_suspended_count--;
 800dc38:	6111      	str	r1, [r2, #16]
                        if (suspended_count == TX_NO_SUSPENSIONS)
 800dc3a:	b1c1      	cbz	r1, 800dc6e <_tx_semaphore_cleanup+0x6e>
                            if (semaphore_ptr -> tx_semaphore_suspension_list == thread_ptr)
 800dc3c:	68d5      	ldr	r5, [r2, #12]
                            previous_thread =                               thread_ptr -> tx_thread_suspended_previous;
 800dc3e:	e9d0 141c 	ldrd	r1, r4, [r0, #112]	; 0x70
                            if (semaphore_ptr -> tx_semaphore_suspension_list == thread_ptr)
 800dc42:	4285      	cmp	r5, r0
                            next_thread -> tx_thread_suspended_previous =   previous_thread;
 800dc44:	674c      	str	r4, [r1, #116]	; 0x74
                            previous_thread -> tx_thread_suspended_next =   next_thread;
 800dc46:	6721      	str	r1, [r4, #112]	; 0x70
                            if (semaphore_ptr -> tx_semaphore_suspension_list == thread_ptr)
 800dc48:	d011      	beq.n	800dc6e <_tx_semaphore_cleanup+0x6e>
                        if (thread_ptr -> tx_thread_state == TX_SEMAPHORE_SUSP)
 800dc4a:	6b02      	ldr	r2, [r0, #48]	; 0x30
 800dc4c:	2a06      	cmp	r2, #6
 800dc4e:	d1df      	bne.n	800dc10 <_tx_semaphore_cleanup+0x10>
                            _tx_thread_preempt_disable++;
 800dc50:	490a      	ldr	r1, [pc, #40]	; (800dc7c <_tx_semaphore_cleanup+0x7c>)
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_INSTANCE;
 800dc52:	240d      	movs	r4, #13
                            _tx_thread_preempt_disable++;
 800dc54:	680a      	ldr	r2, [r1, #0]
                            thread_ptr -> tx_thread_suspend_status =  TX_NO_INSTANCE;
 800dc56:	f8c0 4084 	str.w	r4, [r0, #132]	; 0x84
                            _tx_thread_preempt_disable++;
 800dc5a:	3201      	adds	r2, #1
 800dc5c:	600a      	str	r2, [r1, #0]
 800dc5e:	f383 8810 	msr	PRIMASK, r3
                            _tx_thread_system_resume(thread_ptr);
 800dc62:	f7fe fdb9 	bl	800c7d8 <_tx_thread_system_resume>
    __asm__ volatile (" MRS  %0,PRIMASK ": "=r" (primask_value) );
 800dc66:	f3ef 8310 	mrs	r3, PRIMASK
    __asm__ volatile (" CPSID i" : : : "memory" );
 800dc6a:	b672      	cpsid	i
 800dc6c:	e7d0      	b.n	800dc10 <_tx_semaphore_cleanup+0x10>
                                semaphore_ptr -> tx_semaphore_suspension_list =   next_thread;
 800dc6e:	60d1      	str	r1, [r2, #12]
 800dc70:	e7eb      	b.n	800dc4a <_tx_semaphore_cleanup+0x4a>
 800dc72:	bf00      	nop
 800dc74:	0800dc01 	.word	0x0800dc01
 800dc78:	53454d41 	.word	0x53454d41
 800dc7c:	20000f28 	.word	0x20000f28

0800dc80 <__libc_init_array>:
 800dc80:	b570      	push	{r4, r5, r6, lr}
 800dc82:	4e0d      	ldr	r6, [pc, #52]	; (800dcb8 <__libc_init_array+0x38>)
 800dc84:	4c0d      	ldr	r4, [pc, #52]	; (800dcbc <__libc_init_array+0x3c>)
 800dc86:	1ba4      	subs	r4, r4, r6
 800dc88:	10a4      	asrs	r4, r4, #2
 800dc8a:	2500      	movs	r5, #0
 800dc8c:	42a5      	cmp	r5, r4
 800dc8e:	d109      	bne.n	800dca4 <__libc_init_array+0x24>
 800dc90:	4e0b      	ldr	r6, [pc, #44]	; (800dcc0 <__libc_init_array+0x40>)
 800dc92:	4c0c      	ldr	r4, [pc, #48]	; (800dcc4 <__libc_init_array+0x44>)
 800dc94:	f000 f82c 	bl	800dcf0 <_init>
 800dc98:	1ba4      	subs	r4, r4, r6
 800dc9a:	10a4      	asrs	r4, r4, #2
 800dc9c:	2500      	movs	r5, #0
 800dc9e:	42a5      	cmp	r5, r4
 800dca0:	d105      	bne.n	800dcae <__libc_init_array+0x2e>
 800dca2:	bd70      	pop	{r4, r5, r6, pc}
 800dca4:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800dca8:	4798      	blx	r3
 800dcaa:	3501      	adds	r5, #1
 800dcac:	e7ee      	b.n	800dc8c <__libc_init_array+0xc>
 800dcae:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800dcb2:	4798      	blx	r3
 800dcb4:	3501      	adds	r5, #1
 800dcb6:	e7f2      	b.n	800dc9e <__libc_init_array+0x1e>
 800dcb8:	0800ded8 	.word	0x0800ded8
 800dcbc:	0800ded8 	.word	0x0800ded8
 800dcc0:	0800ded8 	.word	0x0800ded8
 800dcc4:	0800dedc 	.word	0x0800dedc

0800dcc8 <memcpy>:
 800dcc8:	b510      	push	{r4, lr}
 800dcca:	1e43      	subs	r3, r0, #1
 800dccc:	440a      	add	r2, r1
 800dcce:	4291      	cmp	r1, r2
 800dcd0:	d100      	bne.n	800dcd4 <memcpy+0xc>
 800dcd2:	bd10      	pop	{r4, pc}
 800dcd4:	f811 4b01 	ldrb.w	r4, [r1], #1
 800dcd8:	f803 4f01 	strb.w	r4, [r3, #1]!
 800dcdc:	e7f7      	b.n	800dcce <memcpy+0x6>

0800dcde <memset>:
 800dcde:	4402      	add	r2, r0
 800dce0:	4603      	mov	r3, r0
 800dce2:	4293      	cmp	r3, r2
 800dce4:	d100      	bne.n	800dce8 <memset+0xa>
 800dce6:	4770      	bx	lr
 800dce8:	f803 1b01 	strb.w	r1, [r3], #1
 800dcec:	e7f9      	b.n	800dce2 <memset+0x4>
	...

0800dcf0 <_init>:
 800dcf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800dcf2:	bf00      	nop
 800dcf4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800dcf6:	bc08      	pop	{r3}
 800dcf8:	469e      	mov	lr, r3
 800dcfa:	4770      	bx	lr

0800dcfc <_fini>:
 800dcfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800dcfe:	bf00      	nop
 800dd00:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800dd02:	bc08      	pop	{r3}
 800dd04:	469e      	mov	lr, r3
 800dd06:	4770      	bx	lr
